{"meta":{"title":"Javascript-React-Apollo-GraphQL-Ramda-Prisma","subtitle":"All In One","description":"base on javascript","author":"React-Apollo","url":"https://React-Apollo.github.io"},"pages":[{"title":"Chapter 5  GPU acceleration with WebGL","date":"2019-01-28T09:45:00.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"ch05 GPU  Acceleration with WebGL.html","permalink":"https://React-Apollo.github.io/ch05 GPU  Acceleration with WebGL.html","excerpt":"","text":"Deeplearning in Broswer Translation Demo JavaScript代码是在中央处理器(CPU)里执行的.CPU单元速度很快,可以执行复杂的任务,但是处理任务总是以序列方式执行,这会导致一个很大的瓶颈.我们可以使用 WebWorkers来利用所有的 CPU内核,但是现代计算机很少有使用超过16核的CPU.而且,JavaScript 任然是一种解释性语言,没有和编译性语言例如C或者 C++那样性能优越. 对于深度学习计算支持最好的是 GPU.现代GPU,即使在移动设备上都有成百个处理器单元.这些单元可以同时并行工作.幸运的是,深度学习计算也可以重度依赖并行操作,因为神经元层的每个单元和同层的其他神经元都是独立的. WebGL 深度学习实现对于处理实时的视频流是必须的. 神经网络必须要处理视频的每一帧图像,其中每帧图像都有很多像素,代表着高维度空间的一个输入向量.这个需求对于 GPU提出了特别的要求. 而且,把一个(html5)元素转变为 WebGL构造很容易,也很有效,这个构造可以存储在 GPU 内存中. WebGL 是对 OpenGL ES的 JavaScript 的绑定.到目前为止,这是唯一可以在浏览器端底层使用 GPU硬件和并行计算加速深度学习的方法.不管是由 WebGL,还是直接使用 OpenGl 的原生应用(例如 C语言),发送到 GPU的指令是相同的. 在本章,我们首先来学习一下WebGL 是如何工作的,看看如何借助它以颜色梯度形式来画出两个三角形组成的正方形. By adding a few lines of graphic code this simple color gradient is metamorphsosed into a beautiful colored Mandelbrot fractal. 接着会了解 WebGL 的威力,以及最多计算执行的位置.将会改进代码,构建第一个 GPU模拟,这是一个生命游戏 of Conway. 使用温度散射展示从离散到连续的模拟,处理精确度和优化问题. 这两个简单的问题将会帮助你理解 WebGL程序的效率,同时也会介绍 WebGL 编程模型和语言的内容. 在本章第二部分,我们会返回到深度学习,并解释实现用于常规矩阵操作的 特殊shader. 这些快速矩阵操作(例如卷积(convolution),池化(pooling),激活(activation)等等)是所有深度学习框架的基础. 我们要构建自己的GPU 线性代数库,命名为 WGLMatrix.会使用这个库来训练一个神经网络用于识别 MNIST 数据集的手写体数字,这也是图像分类里的 Hello World 程序.最后我们会优化学习脚本,使之速度比 Python/NumPy 的 CPU 版本快5倍. WebGL 深度学习的速度用于处理事实视频流是足够快了. 这张图是借助用户的摄像头实现的 太阳镜 VR试戴系统. 卷积网络识别到面部,方位,旋转甚至是光线强弱. 然后使用这些信息画出一个眼镜的3D模型. WebGL不是一个3D库.尽管有很多的工具可以实现3D渲染算法,整个投影处理过程需要使用单纯的矩阵操作来开发位移和摄影矩阵操作. WebGL是一个rasterization库:它会把向量对象转变为离散向量值.在上图左:一个向量化的猫.每个点都是向量,编码从初始点开始的位置.类似的图可以被无限的放大,但是不能直接显示在屏幕上.右图:由像素形成的图像. 正如我们在简介中学到的,WebGL通过更多的渲染通道让你可以运行繁重的并行操作. 然而和 CUDA或者 OpenGL 不同,WebGL 不是运行并行代码的通用计算 通道.因此要从并行 GPU构架中获益,我们需要把所有的深度学习相关操作变换为WebGL渲染通道. 这里的解释应该让你有了足够的动机来学习本部分内容,尤其要理解渲染通道的基本原理,shader和 GLSL. WebGL由 Khronos集团标准化,类似 OpenGL.它的规范在https://www.khronos.org/registry/webgl/specs.. WebGL 的输出是在 $$ 元素中渲染的.所以,使用 WebGL的第一步就是在web 页面的 HTML代码中插入 $$ 元素: 123&lt;body&gt;&lt;canvas id='myWebGLCanvas' height='512' width='512'&gt; &lt;/canvas&gt;&lt;/body&gt; 页面加载以后,使用 JavaScript代码获取到 canvas 元素,创建 WebGL 上下文 GL.在这个节点要检测用户的配置是否和WebGL兼容: 1234567var myCanvas=document.getElementById('myWebGLCanvas'); var GL; //获取canvas元素try &#123;GL=myCanvas.getContext( 'webgl',&#123;antialias: false, depth: false&#125; );&#125; catch(e) &#123;alert('Cannot init a WebGL context. So sad...:(');&#125; 我们已经关闭了智能感应和深层的缓存,因为我们要用 WebGL 来进行计算,而不是来执行渲染操作. 在这个操作之后, $$ 元素 已经完全可以用于 WebGL 操作了. 不要用于 canvas2D渲染或者没有绑定 WebGL 上下文的操作.在接下来的实例中, GL 变量就是 WebGL API 的接入点:所有的 WebGL 函数和属性都是 这个上下文的方法和属性. 从 WebGL的视点触发,用于画图的区域叫做视口. 它的坐标系总是从中心出发,所以 X 轴是从-1(左)到1(右), Y轴从-1(底部)到1(顶部). WebGL 的工作流程 WebGL 工作流划分为: 主机代码,运行在 GPU,使用JavaScript语言编写.负责把几何,矩阵操作绑定到 GPU 内存,并处理用户的交互操作. 图形代码,运行在 GPU,包装成称为shaders 的小段程序. 使用 GLSL,类 C 风格的语言编写(Graphic Library Shading Language). JavaScript 不能解析原生的 GLSL代码,所以 GLSL 源代码和变量名总是被声明为字符串,然后传递给 WebGL 上下文. 初看,这是一个很大的缺陷,然而当变量名和 TypeScript(译注:JavaScript的超语言类型,最大特点是强类型) 同时工作时,TS使用的模板字符串会极大的改进 GLSL shaders代码的可读性. 然而在本书,我们还是坚持使用原生 JavaScript. WebGL可以提供两种 shaders的访问权力: vertex shader 接收几何数据作为输入,并进行变换. 操作的是 vertex 数据(几何向量点),可以存储在 Vertex 缓存对象中(VBOs). 这个shader是在 rasterization处理之前执行的. fragement shader 在智能感应关闭之后,每画一个像素,只能调用一次. 在resterization之后执行,会为每个输入像素插值 vertex几何向量. 对于每个像素,只渲染一次,决定这个像素的输出颜色. 例如,如果用 WebGL 来话一个 3D 立方体: 立方体的每个角分别执行一次 vertex shader操作,该操作把3D位置投影到视口. fragment shader负责为立方体的每个像素应用颜色. 一组每个类型的 shader集合就称为 shader 程序. shader program 完整的定义了一个特定的渲染方法(例如, 用于3D渲染的材质).两种 shader都有相同的结构: 1234567//声明 I/O 变量//定制函数//主循环void main(void)&#123;//主要代码在这里ouput_variable=value;&#125; vertex shader 的输出变量总是 gl_position. 它是一个四维的向量$[x,y,z,w]$ .in clipping坐标系中.在视口中,2D点的坐标是 $[x/w,y/w]$ . $z/w$ 缓存值的深度,在3D渲染中用于处理堆叠的深度. $w$ 是3D坐标到4D坐标同一转换的扩展,4D坐标实现仿射变换(旋转,缩放和转位操作). 可以使用单个的矩阵乘法操作执行同一坐标的仿射变换. fragment shader的输出变量根据 GLSL 的版本不同,可以是 gl_FragColor 或者是 gl_FragData . 它是像素的 RGBA 值,RGBA 中的 A 代表alpha通道,所以是用来管理透明度(transparency)的. 对于标准的颜色渲染,每个颜色通道被钳位在0到1之间(例如[1,1,1,1]是不透明的白色,[0.5,0,0,1]是50%透明度的深红色,[1,0,0,1]是不透明的黑色). 上图是 WebGL的简化工作流程图(我们有意的去掉了 GLSL I/O类型,因为它们不可能用于 GPGPU).在左侧是数据: 用于 VBPs的 每个 vertex 数据,用于构造或者 JavaScript 数字的 类型数组. 中间是 GLSL I/O变量:他们是 GLSL和JavaScript之间的桥梁.这些变量是 JavaScript的某种指针(pointer),可以直接用在shader中.左侧是 GPU的代码. shaders之间的rasterization 有图形驱动自动执行. Fragment shader 渲染我们在fragment shader中使用主要的计算. 使用两个三角形填充视口,在 fragment shader中执行所有的渲染操作. 使用 WebGL shaders 用于计算,这是最普通的练习.使用这两个三角形可以确保我们可以对每个像素执行一次fragment shader. 如果三角形没有覆盖整个视口, fragment shaders只会在三角形覆盖的部分执行. WebGL工作流密不可分,我们不能单独使用shader. 所以,我们也必须要使用vertex shader,但是只用来渲染两个三角形.之后,三角形每个像素的颜色由fragment shader来完成. 之后我们会用计算代替渲染.参考本书代码的第一个仓库:chapter3/O_webglFirstRendering. VERTEX BUFFER OBJECTS声明一个 JS 类型数组包含视口四个角的2D坐标. 1234var quadVertices = new Float32Array([­1, ­1, //bottom left corner ­&gt; index 0 ­1, 1, //top left corner ­&gt; index 11, 1, //top right corner ­&gt; index 21, ­1 //bottom right corner­&gt; index 3 ]); 然后,使用 vertices 的索引把这四个点分成两组,构建出两个互相不重叠的三角形: 123var quadIndices = new Uint16Array([0,1,2, //first triangle if made with points of indices 0,1,2 0,2,3 //second triangle]); 这张图上,画出了填充视口的两个三角形.顶部靠左的为蓝色,顶点是 0,1,2.右下角红色的是 0,2,3. 数据存储在 JS 数组中.通过创建 Vertex Buffer Objects(VBO),发送给 GPU内存.VBO就是存储在 GPU内存中的的简单数组形式. 1234//send vertices to the GPU:var quadVerticesVBO = GL.createBuffer(); GL.bindBuffer(GL.ARRAY_BUFFER, quadVerticesVBO); GL.bufferData(GL.ARRAY_BUFFER, quadVerticesVBO, GL.STATIC_DRAW);//send indices to the GPU:var quadIndicesVBO = GL.createBuffer(); GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER,quadIndicesVBO); GL.bufferData(GL.ELEMENT_ARRAY_BUFFER,quadIndicesVBO,GL.STATIC_DRAW); SHADER ＰＲＯＧＲＡＭvertex shader接收 四维的 vertices作为输入,在视口的四个角输出.这里是 GLSL中的的vertex shader源代码 1234attribute vac2 position;void main(void)&#123; gl_postion=vec4(position,0.,1.); position in clip coords&#125; 如上代码所示,我们只需要 Vertices 的 x和 y坐标.因此设定深度为 z=0和w=1. 接着写一个 fragment shader, 用于输出红色通道,绿色通道中每个像素的2D位置. 从现在开始,我们会经常使用这个技巧来编码输出像素的颜色通道. 12345precision highp float;uniform vec2 resolution; //resolution in pixelsvoid main(void)&#123;//gl_FragCoord is a built­in input variable. //It is the current pixel position, in pixels: vec2 pixelPosition=gl_FragCoord.xy/resolution; gl_FragColor=vec4(pixelPosition, 0.,1.);&#125; 把两个 shader都声明为 JS的字符串,单独编译他们: 123456789101112131415161718//declare shader sources as stringvar shaderVertexSource=\"attribute vec2 position;\\n\" +\"void main(void)&#123;\\n\" +\"gl_Position=vec4(position, 0., 1.);\\n\"+\"&#125;\";var shaderFragmentSource=\"precision highp float;\\n\"+\"uniform vec2 resolution;\\n\"+\"void main(void)&#123;\\n\"+\"vec2 pixelPosition=gl_FragCoord.xy/resolution;\\n\" +\"gl_FragColor=vec4(pixelPosition, 0.,1.);\\n\"+\"&#125;\";//function to compile a shaderfunction compile_shader(source, type, typeString) &#123; var shader = GL.createShader(type); GL.shaderSource(shader, source); GL.compileShader(shader);if (!GL.getShaderParameter(shader, GL.COMPILE_STATUS)) &#123; alert(\"ERROR IN \"+typeString+ \" SHADER: \"+ GL.getShaderInfoLog(shader)); return false;&#125;return shader; &#125;;//compile both shaders separatelyvar shaderVertex = compile_shader(shaderVertexSource, GL.VERTEX_SHADER, \"VERTEX\");var shaderFragment = compile_shader(shaderFragmentSource, GL.FRAGMENT_SHADER, \"FRAGMENT\"); 我们创建了 shader program, 包含了用于特定渲染的所有图形代码: 12var shaderProgram=GL.createProgram(); GL.attachShader(shaderProgram, shaderVertex);GL.attachShader(shaderProgram, shaderFragment); 最后,用 JS 类指针变量关联 GLSL I/O变量,这个操作目的是之后可以从 JS 中更新 GLSL 的值. GLSL变量命名总是设定为字符串,因为 JS理解不了 GLSL: 1234567//start the linking stage:GL.linkProgram(shaderProgram);//link attributes:var posAttribPointer = GL.getAttribLocation(shaderProgram,\"position\"); GL.enableVertexAttribArray(posAttribPointer);//link uniforms:varresUniform = GL.getUniformLocation(shaderProgram, \"resolution\"); 渲染时间唯一在 GPGPU中使用的的 VBP 是一个四核, 所以我们可以直接绑定一次,一劳永逸: 12GL.bindBuffer(GL.ARRAY_BUFFER, quadVerticesVBO); GL.vertexAttribPointer(posAttribPointer, 2, GL.FLOAT, false, 8,0);GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, quadIndicesVBO); GL.vertexAttribPointer drawcall 细节是关于如何从 VBO数据中解析 shader program属性. 它意味着,posAttribPointer 属性(之前关联到 GLSL “position”变量) 有两个元素,类型是 GL.FLOAT.false 禁止对到来的 vertex 执行归一化操作,8 是1个vertice的字节大小(8个字节=两个元素*4字节,因为一个GL.FLOAT元素用4字节存储). 来触发渲染吧: 1234 GL.useProgram(shaderProgram);//update GLSL \"resolution\" value in the fragment shader: GL.viewport(0,0,myCanvas.width, myCanvas.height);//update GLSL \"resolution\" value in the fragment shader: GL.uniform2f(resUniform, myCanvas.width, myCanvas.height); //trigger the rendering:GL.drawElements(GL.TRIANGLES, 6, GL.UNSIGNED_SHORT, 0); GL.flush(); 了解 GPU的威力每个像素的颜色都是由fragment shader 声明 gl_FragColor=vec4(pixelPosition,0.,1.) 并行赋值的. 每个像素只知道由 内置变量gl_FragCoord 给出的相对位置. 这就是WebGL并行操作的威力.经过渲染的像素数组纹理和 CUDA 核的渲染类似. 用下面代码替换fragment shader中的 main 函数. 123456789101112void main(void)&#123;vec2 pixPos=gl_FragCoord.xy/resolution;//translate and scale:vec2 pixPosCentered=1.3*(pixPos*2.­vec2(1.55,1.));vec2 z = pixPosCentered, newZ; float j = 0.;for(int i=0; i&lt;=200; i+=1) &#123;newZ = pixPosCentered+vec2(z.x*z.x­z.y*z.y,2.*z.y*z.x); if(length(newZ) &gt; 2.) break;z=newZ; j+=1.;&#125;//generate RGB color from j:vec3 color=step(j, 199.)*vec3(j/20., j*j/4000., 0.);gl_FragColor = vec4(color,1.); &#125; 这个漂亮的分形图渲染速度很快,因此可以在每秒60帧的的渲染循环里平滑运行.可以在github仓库 ,chapter3/1_mandelBrot 看到.关于这个分形的介绍可以看 http://nuclear.mutantstargoat.com网站的介绍. 仅仅使用fragment shader 就可以获得很多有趣的渲染结果,包括使用 raymarching 算法的 实时 raytracing实现. 详细内容可以参见 http://shadertoy.com 使用 WebGL 的通用计算不再画漂亮的颜色梯度或者分形图, 我们来开始来处理计算. 在这一部分,要解释使用 WebGL(GPGPU) 的通用计算原理. 我们可以用使用 WebGL在两个不同的位置执行并行操作: 以fragment shader或者是 vertex shader. 在vertex shader中处理主工作负载非常不便,因为他的输出 gl_Position不能像 gl_FragColor一样直接读取或者保存在texture或者另一个对象中. gl_Position控制着位置,所以如果某些计算结果在视口中得到相同的位置,它们就会重叠在一起.如果滑出视口,就变为不可读. 此外,通常处理的 vertices比输出的像素要少,因此在fragment shader中的的并行计算会更有效. 再者,我们仍然会以fragment shader的输出来结束读取或者保存结果.说到 GPGPU,我们总是使用vertex shader 来简化填充视口的操作,在fragment shader中执行整个计算部分. 不再使用渲染 canvas 元素到屏幕的方法,取而代之的是渲染到所谓的 framebuffer,framebuffer 位于 GPU 的内存中,在接下来的drawcall中,使用这个framebuffer 作为texture,并从fragment shader 中读取它的值.尽管 一个texture通常被作为一个图片储存在 VRAM 中,apprehend it as a 2D array with four channels per value (which are the RGBA color channels). 它保存了计算结果,4通道可以根据任意规范来赋值. 这是一种过时的 GPGPU,因为还有非常特别的GPU计算库或者 APIS,例如 OpenGL或者 CUDA. 浏览器端热门的 JS深度学习库(例如 TensorFlow.js) 把整个深度学习模型映射到GPU的 VRAM 中,每层的输出被写入到texture,前馈至正在等待 fragment shader的下一层神经元. 我们想避免从 JS 的主线程中读取 GPU内存,而是把整个深度学习模型的执行图作为一个巨大的渲染路径. WebGL排错WebGL很难排错,因为可以在不同的支持条件下执行,图形硬件之间有一些非常大的差别. 某些浏览器扩展例如 WebGL inspector或者 WebGL Insight 可以检测显卡内存是否能够链接到特定 WebGL上下文.浏览器检查texture,VBOs,或者列出drawcalls也是有可能的. 与硬件有关的错误如果你遇到了硬件相关的错误,你可以: 打开 chrome://gpu 收集有关Chrome WebGL的支持情况 访问 webglreport.com 收集 WebGL1 和 WebGL2的支持,扩展和图形硬件限制情况. 如果 WebGL在特定规范下,怎么也不工作,可能是显卡的驱动被浏览器列入了黑名单,之所以这样是因为发现了安全漏洞. 更新驱动应该就能解决问题. GLSL 句法错误当shaders 在编译的时候,会会探测可能的 GLSL 句法错误. 这些错误是显式的,有行号(以 GLSL代码的形式)声明,所以比较容易修复. 在使用 shader时, 这个错误是非常常见的. WEBGL 运行时错误大多数此类错误会在标准 JS 终端中以警告的形式出现.如果一个定制的 framebuffer没有被绑定到 texture,或者 texture初始化定义的类型长度不够. 错误信息是显式的,但是 drawcall触发错误 JS 行号没有申明. 可以在 JS终端中设置断点并做分析.我建议在断点之前添加 GL.finish() 声明,目的是确保已经执行了所有暂停的 drawcall. 算法错误这种错误很难分析,因为在 shaders中设置断点是不可能的. 要实现特殊的渲染方法以标准framebuffer的颜色通道形式显示模拟变量,借此可以高亮问题位置. 渲染到 texture我们开发了 Conway的生命游戏,展示用于计算的 渲染到texture的概念.WebGL和 JavaScript 实现的游戏代码可以在本书的代码仓库中看到.运行在低级显示硬件的WebGL程序比在高端 CPU上的运行速度快4000倍.这是一个很好的例子在相对简单的代码上就可以显示并行运算的效果. 源代码在 github仓库, chapter3/x_renderToTexture 首先声明模拟的全局参数: 1234var SETTINGS=&#123;simuSize: 256, //simulation is done in a 256*256 cells //squarenIterations: 2000 //number of computing iterations&#125;; 创建默认的framebuffer对象(FBO),在 WebGL上下文实例化时绑定到上下文上.渲染发生在控制显示的framebuffer上.为了渲染到texture(RTT),我们需要创建定制的framebuffer对象.然后绑定到上下文: 1var rttFbo=GL.createFramebuffer(); GL.bindFramebuffer(GL.FRAMEBUFFER, rttFbo); 这个函数JS类型数组创建了texture: 12345678910111213function create_rttTexture(width, height, data)&#123; var texture=GL.createTexture(); GL.bindTexture(GL.TEXTURE_2D, texture); //texture filtering://pick the nearest pixel from the texture UV coordinates //(do not linearly interpolate texel values): GL.texParameteri(GL.TEXTURE_2D,GL.TEXTURE_MAG_FILTER, GL.NEAREST); GL.texParameteri(GL.TEXTURE_2D,GL.TEXTURE_MIN_FILTER, GL.NEAREST);//do not repeat texture along both axis:GL.texParameteri(GL.TEXTURE_2D,GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE );GL.texParameteri(GL.TEXTURE_2D,GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE);//set size and send data to the texture:GL.texImage2D(GL.TEXTURE_2D,0, GL.RGBA, width, height, 0, GL.RGBA,return texture; &#125; 不可能同时读取texture和渲染它. 所以我们需要创建两个texture.两个 texture 都存储了单个红色通道的 细胞声明(如果细胞是活的,红色通道的值就是1.0,如果死了,就等于0.0): 12var dataTextures=[ create_rttTexture(SETTINGS.simuSize,SETTINGS.simuSize,data0), create_rttTexture(SETTINGS.simuSize,SETTINGS.simuSize,data0)]; data0是随机初始化的UnitArray,储存了texture的 RGBA值.在第一次模拟遍历期间,使用dataTexture[0]渲染到dataTexture[1],接着交换两个texture,然后重新遍历. 我们需要两个shader程序: 计算shader 程序接受细胞状态 texture作为输入,并返回更新的细胞状态. 在模拟的末尾,渲染的shader程序使用一次,用于在画布上显示结果 两个shader 程序需要同样的vertex shader,仍然画出两个三角形填充视口.所有的逻辑执行都通过fragment shader执行. 这里是计算fragment shader的主函数. 实现了Conway 的生命游戏: 12345678910111213void main(void)&#123;//current position of the rendered pixel:vec2 uv=gl_FragCoord.xy/resolution;vec2 duv=1./resolution; //distance between 2 texels //cellState values: 1­&gt;alive, 0­&gt;dead:float cellState=texture2D(samplerTexture, uv).r; //number of alive neighbors (Moore neighborhood): float nNeighborsAlive=texture2D(samplerTexture, uv+duv*vec2(1.,1.)).r+ texture2D(samplerTexture, uv+duv*vec2(0.,1.)).r+ texture2D(samplerTexture, uv+duv*vec2(­1.,1.)).r + texture2D(samplerTexture, uv+duv*vec2(­1.,0.)).r + texture2D(samplerTexture, uv+duv*vec2(­1.,­1.)).r + texture2D(samplerTexture, uv+duv*vec2(0.,­1.)).r + texture2D(samplerTexture, uv+duv*vec2(1.,­1.)).r + texture2D(samplerTexture, uv+duv*vec2(1.,0.)).r;if (nNeighborsAlive==3.0)&#123; cellState=1.0; //born&#125; else if (nNeighborsAlive&lt;=1.0 || nNeighborsAlive&gt;=4.0)&#123; cellState=0.0; //die&#125;;gl_FragColor=vec4(cellState, 0., 0.,1.);&#125; texture2D 声明从texture(也称为一个texel)获取一个像素.它的参数是texture 赝本和texel 坐标. 根据GPU的能力强弱,在 一个fragment shader中大概可以同时使用16个texture. 确切的数字可以通过声明获得. GL.getParameter(GL.MAX_TEXTURE_IMAGE_UNITS). 当然你可以实例化更多的texture,但是不能都同时使用. 样本在 shader中有类型 uniform sampler2D 但是赋值有点想 JS 的整数: 12345678//At the linking stepvar _samplerTextureRenderingUniform=GL.getUniformLocation( shaderProgramRendering,'samplerTexture');//...//We affect the sampler value to channel 7, like an integer GL.useProgram(myShaderProgram); GL.uniform1i(_samplerTextureRenderingUniform, 7);//...//Just before the rendering://we activate the texture channel 7: GL.activeTexture(GL.TEXTURE7);//we bind myTexture to the activated channel: GL.bindTexture(GL.TEXTURE_2D, myTexture); GLSL的第二个参数声明 texture2d是 textures坐标,也称为UV坐标.它是 vec2的实例,标记获取的texel的位置.它的两个元素都在 0.0-1.0之间. 来准备一下模拟步骤: 12GL.useProgram(shaderProgramComputing);GL.viewport(0,0,SETTINGS.simuSize,SETTINGS.simuSize); 接着加载模拟循环: 12345for (var i=0; i&lt;SETTINGS.nIterations; ++i)&#123;//dataTextures[0] is the state (read): GL.bindTexture(GL.TEXTURE_2D, dataTextures[0]); //dataTextures[1] is the updated state (written): GL.framebufferTexture2D(GL.FRAMEBUFFER,GL.COLOR_ATTACHMENT0,GL.TEXTURE_2D, dataTextures[1], 0); GL.drawElements(GL.TRIANGLES, 6, GL.UNSIGNED_SHORT, 0);dataTextures.reverse(); &#125;&#125; GL.framebufferTexture2D(...)意味着在当前framebuffer 范围之内(就是rttFbo)画出的每个内容也要滑入到texture dataTextures[1]. 以渲染步骤结束: 1234//come back to the default FBO (displayed on the canvas):GL.bindFramebuffer(GL.FRAMEBUFFER, null); GL.useProgram(shaderProgramRendering); GL.viewport(0,0,myCanvas.width, myCanvas.height); //[...]//trigger the rendering:GL.drawElements(GL.TRIANGLES, 6, GL.UNSIGNED_SHORT, 0); GL.flush(); 上图是 Conway 生命游戏的模拟结果.在仓库代码中,我们已经修改了初始值,从模拟中心(左边图)开始的活细胞呈现方形.经过2000轮迭代之后,复杂图形出现了(右图). 精确度的重要性在 Conway游戏中,我们只使用离散值:细胞要么是活要么是死.但是如果你需要使用连续值,你就有可能被 WebGL默认的八位精确度限制住.事实上,,每个gl_FragColor的元素都是用八位编码,并且被钳位在0~1之间.每个元素的值只有 $2^8=256$ 中可能性. 这对于颜色编码就足够了,因为人眼不能分辨一个比特的颜色差异. 但是在深度学习模型中我们需要更高的精确度,因为经常需要处理浮点值.16比特的浮点值(GL.HALF_FLOAT)可能就够了.但是某些配置只有32比特精确度(GL.FLOAT)才能使用.需要以下能力: FLOAT或者HALF_FLOAT texture的 实例化 渲染 texture 到 FLOAT或者HALF_FLOAT texture 如果你使用 $WebGL_1$,就需要 OES_TEXTURE_FLOAT或者OES_TEXTURE_HALF_FLOAT 扩展(并不总是能实现).接着仍然需要测试 渲染到 FLOAT或HALF_FLOAT texture 如果使用 $WebGL_2$ 这些需求已经满足了,因为 FLOAT或HALF_FLOAT 已经包含在规范中. 但是只有渲染到texture,到HALF_FLOAT texture 是规范声明的. $WebGL_2$可以向后兼容$WebGL_1$,通过使用: 1var GL=myCanvas.getContext('webgl2', ...); 在上下文初始化里,应该要执行: 如果使用 $WebGL_2$ ,就是用 具有HALF_FLOAT精确度的 $WebGL_2$ 如果使用 $WebGL_2$: – 得到 OES_TEXTURE_HALF_FLOAT 扩展 – 使用 FLOAT textures 测试 RTT. 如果OES_TEXTURE_FLOAT 扩展不可用或者 如果 RTT不工作: – 获取 OES_TEXTURE_HALF_FLOAT 扩展 – 测试 RTT 在某些 GPU 配置中,我们需要得到 &lt;WEBGL|EXT|OES&gt;_color_buffer_float 扩展.否则就不能把framebuffer 对象绑定到 FLOAT或者HALF_FLOAT texture. 在着色中使用的精确度要在第一行确定: 1precision highp float 它接收三个值: lowp : 计算由八位精确度完成. 速度足够快,但是对于浮点数计算不够精确. 仍然适合于渲染颜色值. medium:highp,lowp或者位于两者之间的精确度,但这要看 GPU 的配置.在使用这个水平的精确度之前,需要使用GL.getShaderPrecisionFormat(GL.MEDIUM_FLOAT) 检测真实的精确度,因为随着显卡的不同,精确度会发生变化. highp : 浮点值使用 16或者32比特 来处理.16比特用于深度学习计算就够了(但是并不总是能用于物理模拟…). 这个水平的真实精确度可以通过运行 GL.getShaderPrecisionFormat(GL.HIGH_FLOAT).检测 GL.getShaderPrecisionFormat(&lt;level&gt;) 的返回值包含有 precision 属性的对象,属性值是 编码着色时浮点数小数部分的位数.例如,32位浮点数就是23,16位的浮点数就是10. 从Conway开始,开发一个热图模拟.包含 浮点 textures.可以在 Github 仓库 ,chapter3/3_RTTfloat. 我们模拟了一个2D的方形铁块,边长是2.56米,温度是100 $o^oC$ .周围由 0 $o^oC$ 的铁块包围,热量随时间散失. 在这幅图中, 左侧:模拟了初始状态,右侧:模拟了2000秒之后的情况. 颜色由 IDL_Rainbow color 图实现,使用fragment 着色,从0~100 $o^oC$ 平衡 优化 使用 WebGL 来实现深度学习网络不太容易.导入了一些复杂的内容,原因是 特定的工作流和依照不同图形硬件而实现的不同执行路径引起. 仅有的目标是提高执行效率,这可能称为一些效率低下代码的遮羞布. 再者说, 速度的确对很多用例很重要. 计算机视觉问题,例如图像分类,分隔或者物体识别,总是针对连续视频流工作,在视频流中要维持 每秒30帧(FPS)的速度.因此,应该要遵循一些基础着色原则. GLSL 开发 和你想的的一样, GLSL开发是整个书的主题(最流行的部分,覆盖率超过1.000页!). 我们会处理一些常见的开发错误. 如果你想更进一步的学习 WebGL 和 GLSL ,你可以尝试 http://webgl.academy 的免费交互课程. 在有可能的情况下,要避免在着色时使用条件声明语句,例如:if...then...else. 思考一下这段计算指数线性单元(ELU) 激活函数: 1234 float ELU(float x)&#123; if (x&gt;=0.0)&#123;return x; &#125; else &#123;return exp(x)­1.0; &#125;&#125; 使用的是 if 声明. 这样做,这段代码会更有效: 123456789101112131415161718192021222324252627282930float ELU(float x)&#123;return mix(exp(x)­1.0, x, step(x, 0.));&#125;``` GLSL内置函数`mix()`,定义为: $mix(x,y,a)=x*(1-a)+y*a$ 使用几个较小的着色器代替单个大的着色器. 如果着色器太长,GPU 的执行缓存会在执行期间发生更新,这就会有拖累.### 注意浮点的特殊性在高精度的着色器上,浮点数根据 GPU不同,使用16比特或者32比特存储.第一位决定符号,之后的位置,对于32位编码,8比特编码指数,23比特编码分数.因为有这个存储方式,32位编码的浮点数最大是 `3.4e38`,最小是`-3.4e38`. 对于16位编码,这个范围要更窄一点.![](https://ws2.sinaimg.cn/large/006tNbRwgy1fx8rnjzng5j30gu0400sq.jpg)本图是32位二进制编码形式.来源:Wikipedia如果计算结果超过了上面的最大值,会被特殊的浮点数替换,`+Infinite`. 怎么处理特殊浮点数例如 `+Infinite`,`-Infinite`,`NaN`,不同硬件策略不同. 接着值计算结果在计算流程中继续传递.特殊的浮点数被存储在`FLOAT`和`HALF_FLOAT` 纹理中.所以如果我们要把结果渲染到纹理,这些特殊值要经过如下的计算.特殊浮点即使在计算步骤是隐式条件下也会出现.考虑一下计算 ELU激活函数的 GLSL 函数:```javascriptfloat ELU(float x)&#123;return mix(exp(x)­1.0, x, step(x, 0.));&#125; 如果 x=100, 这是有可能的结果(x 可以是输入神经元权重的总和),我们得到 ELU(100)=100. 但是 GPU 必须要计算 ELU(100)=mix(exp(100)-1,100,1)=(exp(100)-1)*0+100. 但是 exp(100)= $2.7.10^43$ 超过了浮点最大值. 所以用特殊浮点值 +Infinity 代替. exp(100)-1=+Infinity-1=+Infinity . GPU 计算的 ELU(100)=+Infinity*0+100.但是 +Infinity*0是未定义的,但是它生成了另一个特殊浮点数,NaN. NaN总是会沿着操作流程传递,因为任何包含有 NaN的操作都会输出NaN(相反,Infinite会消失,因为 1/Infinity=0) .GPU输出 ELU(100)=NaN+100=NaN.接着所有下一层连接的神经元收到 NaN值,然后也输出NaN,等等一直继续. 有一些解决办法可以避免出现特殊浮点值: 避免在函数中包含指数(例如, softmax)或者对数.有时候可以用多项式代替. 如果 mix() 或者其他的 GLSL插值函数被调用,确保两个参数都足够小. 这样实现 ELU 更安全: 12345678910111213141516171819202122232425262728293031323334353637383940float ELU(float x)&#123;return mix(exp(­abs(x))­1.0, x, step(x, 0.));&#125;``` - Majorate or minorate.- 使用深度学习技术把权重和偏置保持在较低的值,例如 L1或 L2 正交化.关于因伟达GPU特殊浮点数的规范都可以在官网上看大.### 重视 纹理缓存GPU 有类似 CPU 的多层缓存系统.当纹理素材是通过 `texture2D()`函数声明在片元着色器中获得,GPU 首先会搜索较小但是速度快的缓存. 如果没找到,它会触发一个缓存缺位,接着再第二级稍大,但是速度慢的缓存中查找,直到在最高级的纹理缓存中获取素材信息为止.接着纹理素材被拷贝进底层的高速缓存,在接下来的查找时,速度会加快.如果临近的像素使用的是同样的纹理素材渲染 ,缓存的缺失率很低,着色会加快.但是如果临近像素使用不同的纹理素材, 缓存确实会增加,着色执行效率会显著下降.在一些实例中,有很多方法可以在纹理中安排数据. One of the alternatives is often better optimized for this aspect.![](https://ws3.sinaimg.cn/large/006tNbRwgy1fx8xyfb81bj308e08gq3e.jpg)上图看到的是图形内存, 纹理素材不整齐,但是是以莫顿顺序排列的. 这个处理被称为纹理swizzling. 获取纹理之后,纹理素材的整个线条(显示为红色) 被压入到 GPU 缓存中. 所以 2D的近邻纹理素材获取速度会更快,因为可以在底层的缓存找到.尽管有一些书籍谈到了 纹理缓存(纹理缓存, Michael Dogget ,Lund University) ,缓存实现机制还是因硬件不同而有区别.仍然需要使用不同的硬件测试 WebGL程序,保证它可以在任何地方都可以运行,而且保持足够快的速度.### 颜色通道角色渲染到纹理定义了四个颜色通道和四个颜色通道帧缓存. 他们以不同的方式使用:- 只有一个通道被使用,像 Conway 游戏模拟一样. 但是他不能被优化,因为 GPU无论什么时候都会同时处理四个向量和矩阵.所以我们要为相同的操作执行四次计算.- 每32比特的值可以分包进四个 RGBA 8比特元素中.之后这些元素可能根本不会用于浮点纹理. 主要的缺陷是 每个片元着色器应该从纹理解压缩出的 RGBA 值应该是32比特的值,然后压缩为`gl_Fragcolor`的 8比特 RGBA通道.- 四个神经元网络可以并行运行在四个 RGBA 通道上. 四个神经元学习的是不同的初始参数,输出稍有不同.输出结果是四个神经元网络的平均值. 并行的四个通道有助于减少输出的噪音.### 防止抖动WebGL 状态可以通过使用`GL.enable()`或者`GL.disable()` 指令来修改. 他们的状态会被保留.所以 WebGL上下文的状态需要改变一次. 在片元着色器用于计算时,抖动要关掉,因为它有可能会改变输出值. It consists in applying some noise to the fragment shader output to avoid color quantization visual artifacts.```javascriptGL.disable(GL.DITHER); 在这张图上,可以看到如果分辨率比计算的颜色精度低,抖动就会在framebuffer中改变颜色像素值.在左边:图像是32比特 RGBA 颜色.中间:2比特 RGBA 颜色.颜色精度降低,猫的每个像素由调色板中最类似的颜色代替. 右边图也是2比特的颜色,但是打开了抖动. 像素颜色不在是调色板中最近似的颜色:为了避免出现边界,引入了一些噪声. 避免帧缓存交换使用GL.framebufferTexture2D,实例化一个帧缓存,每次需要渲染到特定的纹理时,在其上动态绑定的做法比使用GL.bindFramebuffer有效率的多,使用GL.bindFramebuffer时,每次渲染一个纹理,都重新实例化一个新的framebuffer. 的确,GL.bindFramebuffer执行的计算开销非常大. 一个三角形比两个更好相比在视口上画出两个三角形,我们更愿意画出单个更大的三角形(定点是:[-1,1],[3,-1],[-1,3]).单个大三角形的速度稍快一点. 片元着色器仍然是针对每个像素执行一次,感谢 WebGL 整合进图形流水线的 $scissor$ 测试,使之成为默认的的选项. 从CPU到GPU,再从 GPU到 CPU在一开始,数据不管是图片,视频还是数组都由Javascript处理,所以它们注册,并存储在 CPU的内存汇总,首先由 CPU 处理. 接着被发送到 GPU,使用 GPU 的着色器处理.最后可能在 CPU端再次使用到经过着色的数据.所以我们需要把数据从 CPU发送到 GPU,接着数据原路返回. 浮点纹理初始化浮点纹理从 JavaScript数据初始化而来.例如,如果突出权重被存储在纹理中,我们 会使用从之前训练或者匹配特定随机分布获取的 JavaScript 数组值来填充纹理. 如果纹理储存了 GL_FLOAT 元素(每个浮点数使用32比特),初始化是简洁明了的: 1234//small variation between WebGL1 and 2:var internalPixelFormat=(ISWEBGL2)?GL.RGBA32F:GL.RGBA; GL.texImage2D(GL.TEXTURE_2D, 0, internalPixelFormat,&lt;width&gt;, &lt;height&gt;,0, GL.RGBA, GL.FLOAT, &lt;instance_of_Float32Array&gt;); 但是如果纹理存储的是GL.HALF_FLOAT类型,从数组的初始化就很难了,因为 JavaScript 没有 Float16Array类型. 在 JavaScript 端,我们必须要使用每值16比特的形式编码浮点数(1比特符号,5比特指数,10比特分数). 接着要把编码数据存入 JavaScript Unit16Array中. 在本书的仓库中有 JS函数编码 Float32Array-Unit16Array的方法(参见 RTTfloat 热图模拟). 接着使用Unit16Array 来初始化纹理: 123456//see \"continuous simulation\" example to see the code//of the \"convert_arrayToUInt16Array\" function:var u16a = convert_arrayToUInt16Array(&lt;instance_of_Float32Array&gt;); var internalPixelFormat=(ISWEBGL2)?GL.RGBA16F:GL.RGBA;GL.texImage2D(GL.TEXTURE_2D, 0, internalPixelFormat, &lt;width&gt;, &lt;height&gt;,0, GL.RGBA, GL.HALF_FLOAT, u16a); 在 CPU 获得返回的计算结果除非我们的工作流是100%的 GPU流程,否则在有些情况下,我们需要把计算结果返回到JavaScript中.这个操作很慢,能不操作就不操作. 必须要渲染到默认的framebuffer(显示在元素中),然后使用GL.readPixels指令读取像素值.它使用一个正方形区域的的交错像素 RGBA 值来来填充 JavaScript 的 Unit8Array. 速度慢的根源是 CPU 和 GPU之间要强制同步. 在使用之前我们应该要使用选项 preserveDrawoingBuffer:true 来创建 WebGL 上下文. 读取8bit的编码值是很直接的: 片元着色器把纹理值拷贝到gl_FragColor,然后进行渲染.接着 framebuffer的值通过GL.readPixels 读取. 但是对于浮点值纹理,过程更加复杂. 需要开发特殊的片元着色器把每个浮点值打包成几个8比特的值,然后使用栅格视口来处理几个渲染过程, 使用 GL.readPixels drawcall 读取渲染数据,最后使用 JavaScript 的 Unit8Array 重构浮点数组. 在本书代码仓库中有着色器把浮点数打包成8比特颜色值的代码,同时还有读取浮点纹理的示例代码. 用于矩阵计算的纹理和着色器经过一段在 WebGL和 GPGPU 的奇妙旅行,我们要返回到深度学习中,构建一个最小的 WebGL 线性代数库WGLMatrix. 接着我们会使用这个库来实现一个简单的神经网络(非卷积网络),学习识别MNIST数据集的手写体数字. 第一版本的线性代数库包含在仓库 chapter3/4_WGLMatrix. 标准矩阵加法在 GLSL中内置的矩阵类型最大只支持4个维度. 这对于深度学习是远远不够的. 所以矩阵要 用纹理来存储,我们需要开发特殊的纹理用于常见的矩阵操作. 每个 texel 都是一个矩阵条目,纹理的分辨率和矩阵的维度是一样的. 在创建矩阵时,如果 JavaScript 提供了初始化数组,RGBA 通道就用这些数组填充.否则,如果只提供了一个数组,它的值就会被复制四次用于填充颜色通道. 每个普通的矩阵操作在 RGBA 颜色通道中都是独立执行的.也就是我们可以对一个数组使用四个不同矩阵并行处理四次. 加法片元着色器不会和其他元素类操作符一样依赖于矩阵的大小.这是 GLSL 的代码: 1234void main(void)&#123;vec2 uv=gl_FragCoord.xy/resolution;vec4 matAValue=texture2D(samplerTexture0, uv); vec4 matBValue=texture2D(samplerTexture1, uv); gl_FragColor=matAValue+matBValue;&#125; 标准矩阵乘法和加法着色器不同,乘法着色器包含了for 循环用于遍历第一个矩阵的行和第二个矩阵的列.使用 $WebGL_1$ 不能在for 条件语句中使用 非常量值.这限制了GLSL的归一化值或者之前计算结果的使用.所以我们需要为每个矩阵乘法维度编译一个着色器程序. 例如,这段代码用于 (n,10)矩阵和(10,n)矩阵的所有乘法: 1234567891011//vector between 2 consecutive texels of first factor:const vec2 DU=vec2(1./10., 0.);//vector between 2 consecutive texels of second factor: const vec2 DV=vec2(0., 1./10.);void main(void)&#123;vec2 uv=gl_FragCoord.xy/resolution; vec2 uvu=uv*vec2(1.,0.);vec2 uvv=uv*vec2(0.,1.);vec4 result=vec4(0.,0.,0.,0.);for (float i=0.0; i&lt;10.0; i+=1.0)&#123;result+=texture2D(samplerTexture0, uvv+(i+0.5)*DU) *texture2D(samplerTexture1, uvu+(i+0.5)*DV);&#125;gl_FragColor=result; &#125; 增加了 0.5 到 i 用于提取像素中间值,否则可能会在特定的矩阵维度上出现舍入错误. 在 $WebGL_2$ 中, 实现了for循环中的非常量操作,但是商业应用对于 $WebGL_2$ 的支持仍然是不可接受的(2018年3月的支持率是41%,webglstats.com数据).所以我们要构建一个 $WebGL_1$ 着色器,也可以用于 $WebGL_2$ 操作. 我们经常会同时进行矩阵乘法和加法. 例如,把一个神经元层的输入 $x$ 和权重矩阵 $W$ 相乘,然后加上偏置 $B$,可以计算出总的输出 $Z:Z=Wx+B$ .应该要编译一个特殊点着色器用于执行这个操作,称为 FMA(Fused Multiply-Accumulate,熔合乘法累积).它会节省一些渲染到纹理的时间. 我们的矩阵库,WGLMatrix, 管理者一个乘法和 FMA程序的字典.如果我们需要处理两个矩阵,这是字典中包含的普通维度操作,我们只使用字典中的着色程序就可以了.否则会编译出具有新维度的着色器程序,并添加到字典中. 激活函数的应用着色器就是专门用于激活函数的应用. 我们应该要小心特殊浮点数,尤其是包含指数或者对数的激活函数. 下面的着色器使用 sigmoid 激活函数: 12345const vec4 ONE=vec4(1.,1.,1.,1.); void main(void) &#123;vec2 uv=gl_FragCoord.xy/resolution; vec4 x=texture2D(samplerTexture0, uv); vec4 y;y=1./(ONE+exp(­x));gl_FragColor=y;&#125; 因为很多的特殊激活函数都可以应用于矩阵,我们设置了公用的方法从外部库编译定制的着色器. 精通 WGLMatrix矩阵在使用之前需要初始化, 矩阵 m,v,n从扁平值开始初始化: 123456// encoding 3*3 matrix | 0 1 2 |:// |345|// |678|var M=new WGLMatrix.Matrix(3,3,[0,1,2, //V is a column matrix, which is a vector: var V=new WGLMatrix.Matrix(3,1,[1,2,3]);3,4,5, 6,7,8]);var W=new WGLMatrix.MatrixZero(3,1); 从数学角度说, 向量和矩阵没有区别,向量就是宽度为1的矩阵.经过初始化,我们就可以对矩阵进行操作. 为了对矩阵A 执行操作 OPERATION,运行: 1A.OPERATION(arguments..., R) R是用于结果储存的矩阵.我们不能把结果存储在任何用于操作的矩阵中,因为不可能同时读取纹理和渲染纹理. 操作总是返回结果矩阵 R. 例如,处理操作 $W=M*V$ ,运行代码: 1M.multiply(V,W); 结果返回一个矩阵 $W$.我们可以声明一个定制元素的操作: 1WGL.addFunction('y=cos(x)','cos'); GLSL函数代码中,使用预定义的 vec4 x*vec4 y. 第二个参数是用户定义的函数标识符. 然后应用于矩阵 M的元素,执行操作 M.apply(&#39;COS&#39;,R) 这里的R 是矩阵收到的结果. 应用于手写体识别我们已经在 WGLMatrix 中添加了一些实现训练和运行神经网络的矩阵操作方法.也添加了一些验证矩阵维度的方法,防止无效的操作发生. 数据编码GPU加载的数据集作为输入向量,编码了数字图像,等待输出结果.数据集使用了显卡内存的绝大多数.这些数据不需要16或者32位精度:8位就足够了,因为输入图像使用8位编码每个通道的.输出是二元值. 我们已经在 WGLMatrix库中添加了8位精度的支持. 数据加载使用mnist_loader_js 脚本. 在代码第50行,添加了新的[X,Y]对,根据索引存储训练或者是测试数据集: 123targetData.push([new WGLMatrix.Matrix(784, 1, learningInputVector), //X new WGLMatrix.Matrix(10, 1, learningOutputVector) //Y&#125; 这一步之后,整个数据集作为纹理被加载到显卡内存中 内存优化能够预测需要的显卡内存就很重要了,如果我们要分配比可用内存多的内存,WebGL上下文进程会被杀掉,应用会崩溃.在我们的实例中,我们加载了 60000幅手写数字图片,所有有 $60002828=47e6$的纹理素材. 每个texel存储在4个 RGBA通道,每个颜色通道使用8比特来编码(1字节). 我们需要 47e6*4*1=188e6字节用于输入向量,所以大概是200MB,对于输出向量,我们需要 60000*10*4*1=2.4e6字节,大概是2.4MB. 但是 GPU不支持以原生像素形式存储纹理. 每个像素根据2D坐标上的近邻来编码,所有有很强的边缘效应.在我们的实例中,没有使用大约400MB的显卡内存,整个数据集需要4G 的显卡内存. 上图中,你看到的是 英伟达的 GPU,这里,英伟达的设置面板对于检测 GPU内存和占用率很方便.完成整个 MNIST 数据集加载之后,你可以看到使用93%的显卡内存. 如果把输入像向量的外观从(784,1)变为(28,28), 他们的内存大小是一样的,因为他们支持的问题有相同到的纹理像素(7841=2828).但是这时,整个 MNIST 的数据集占用的显存大概只有280MB,所以少了10倍.的确,一个像素宽的纹理像素例如(784,1)的输入向量存储效率不高,因为纹理像素都没有2D的邻居. 正方形的纹理像素仍然高于理论值,因为内存是分页的(或者分成单个的块),并且有边缘效应,因为这些纹理后很小. 为了优化 GPU 纹理的压缩,我们需要: 使用的纹理要尽可能的是方阵 纹理相乘获得一些大的纹理,称为纹理地图集 如果我们分配了一些大的正方纹理,边际效应减小,部分内存块的空余会减小.实际占用的内存值会更接近于理论值. 为了保持实现简单一点,我们不考虑这些改进措施.总是使用和分辨率和编码矩阵维度相同的纹理. 前置这是在network.js中声明的sigmoid函数: 1WGLMatrix.addFunction('y=1./(ONE+exp(­x));', 'ACTIVATION'); 这是 network.js中的前置部分: 123456789self.feedforward=function(a)&#123;//Return the output of the network if ``a`` is input. for (var i=0, inp=a; i&lt;self._nConnections; ++i)&#123;//from input to output layer,// compute WI+B and store the result in _z: self.weights[i].fma(inp, self.biases[i], self._z[i]);//apply actFunc to _z and store result to _yself._z[i].apply('ACTIVATION', self._y[i]);//set input for the next iterationinp=self._y[i]; &#125;return inp; &#125; 第一次尝试我们已经把使用 Python/Numpy写的 MNIST分类器转码为 JavaScript/WGLMatrix. 代码可以在 chapter3/5_MNIST 查看. 这段代码来自于 Micheal Nielsen的在线书籍 &lt;神经网络和深度学习&gt;第一章. 地址是http://neuralnetworksanddeeplearning.com/chap1.html 分类器的神经网络是非常浅显的. 它只有三层神经元: 输入神经元有784个单元(接收28x28像素的数字图像) 隐藏层有 30个神经元 输出层有10个神经元(每个数字一个) 属于致密连接,激活函数是 sigmoid.网络训练超过30个epochs,每个小批次有8个样本,学习率是3.0(每个小批次). 训练集有50 000个样本,测试集有10 000个样本.最佳效果是27个epochs的95.42% 这是基准值: Python/Numpy 实现(Python=2.7.12,CPU=Intel Core i7-4720HQ):318秒 JavaScript/WebGL实现(Chrome=65,GPU=Nvidia GTX960M):942秒 注释: 通过 Numpy执行的矩阵操作是使用底层的线性代数库,例如 BLAS或者 LAPACK实现,它们有类似 SIMD 的指令,使得使用 CPU 的执行也很有效.如果使用原生的 Python 函数,会更快. 这个基准中,我们的实现不太好,但是我们可以通过一些改进超越Numpy 的实现 改进执行效率可以看 改进的版本 在 chapter3/6_MNISTimporved 在之前的实现中,我们完全没有使用 RGBA 通道. 操作毫无用处的在四个通道中被复制了.这里要单独使用四个通道,从而可以并行处理四个输入向量.这是可行的,因为最小批次是4的倍数(之前的例子中是8).对于测试数据,为了多路复用RGBA通道,我们把每4个输入/输出向量包装成一个输入/输出向量.同样的执行,现在的实现时间从942秒下降到282秒. 现在比 Python/Numpy更好了. 但是 GPU 的利用率只有30%,因为纹理编码矩阵太小.的确,如果我们渲染的纹理的尺寸小于 GPU 计算单元数量时就会出现瓶颈:没有足够的工作可以做,一些计算单元处于休眠状态. 所以,我们需要渲染更大的纹理.有几个方案可以解决这个问题: 把几个小的批次样本分组成一个纹理.和我们在 RGBA通道对于小批量样本的复用一样,分组的纹理包含纹理的空间复用. 这个方案加速了学习,但是没有改善网络的利用效率. 可以增加每层神经元的数量. 核心的概念是使神经网络的构架适应硬件构架.我们选择这个方案. 考虑一下另一种学习 MNIST数据集的网络构架: 输入层有784个单元(接收28X28像素的数字图像) 两个隐藏层,分别有256和64个神经元 输出层有10个神经元(每个数字一个) 每批次8个样本,学习率1.0. 超过20个epoch. 现在 GPU的占有率平均在64% .我们的方案执行时间是344秒,Python/Numpy的执行时间为1635秒,几乎快乐5倍(最佳成功率在epoch18,96.45%). 通过增加隐藏层神经元规模,还可以增加 GPU的使用强度到100% 我们的方案和 Python方案的执行比值会攀升的更高.但是在测试数据上不会得到更好的结果,因为过拟合问题(应该要实现正交化或者丢弃算法来解决过拟合问题,后者实现卷积连接). 使用低端 GPU(笔记本电脑的低端 Intel HD4600 GPU),同样的学习花费587秒.仍然比 CPU的实现快了3倍. 总结本章我们从 WebGL的简单实现开始,画出两个三角形填充视口. 在开始 WebGL 的学习曲线很陡,这是最难的部分. WebGL似乎很繁琐,我们需要写很多代码,渲染 之前要创建不同的对象.但是实践的越多,它展现的逻辑越多,便利性也越大.经过首次渲染后,学习变成增量式的了. 接着,我们使用 WebGL来计算并行像素颜色,形成了漂亮的分形. 尽管每个像素都要经过重度的计算,但是渲染速度很快.之后,我们利用这个能力来加速计算. 实现渲染到纹理,得到结果用于下一步使用,代替了直接的显示. 实现类第一个 WebGL模拟: Conway 生命游戏. 我们处理了浮点计算问题. WebGL 设计时就考虑的是低精度计算,因为 RGB 颜色值每个元素不需要使用超过8比特的编码.所以我们要根据显示硬件版本和 WebGL 版本来考虑几个不同的执行路径. 运用新的知识,把之前的模拟转化为温度散失模拟,用物理连续变量代替了离散变量. 构建了自己的线性代数库,可以操作所有标准的矩阵操作.用它测试了 MNIST 数据集的手写体识别模型. 最后,我们优化了模型的实现,使之比 Python/Numpy的版本更快. 这一章对于改进已有的 WebGL 实现或者构建定制的 WebGL 实现都特别有用.无论我们如何在 WebGL上叠加任何的软件,如果不理解底层的机制,正确优化或者有效添加功能都是不可能的.这也是一个起点,开启了实际应用硬件加速的无限可能. 在下一章,我们将会看看如何从浏览器提取数据,例如从 URLs 加载图片,从摄像头解析帧图像,或者解析话筒拾取的音频."},{"title":"about","date":"2019-04-28T05:52:57.900Z","updated":"2019-04-28T05:52:57.900Z","comments":false,"path":"about/index.html","permalink":"https://React-Apollo.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2016-07-05T11:39:04.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"categories/index.html","permalink":"https://React-Apollo.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-06-04T03:30:57.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"tags/index.html","permalink":"https://React-Apollo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"翻译|Where and When to Fetch Data With Redux","slug":"翻译|Where and When to Fetch Data With Redux","date":"2019-04-28T12:07:00.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2019/04/28/翻译|Where and When to Fetch Data With Redux/","link":"","permalink":"https://React-Apollo.github.io/2019/04/28/翻译|Where and When to Fetch Data With Redux/","excerpt":"","text":"原文:Where and When to Fetch Data With Redux 如果固件为了渲染需要一些数据,你想使用Redux获取数据,并保存在Redux Store中,那么什么时间点是调用API的最好时机? 在componentdidMount生命周期函数中启动Action 在Redux中调用API假设你要显示一个产品列表. 后台API是:’GET/products’,可以这么创建Redux action productAction.js123456789101112131415161718192021export function fetchProducts() &#123; return dispatch =&gt; &#123; dispatch(fetchProductsBegin()); return fetch(\"/products\") .then(handleErrors) .then(res =&gt; res.json()) .then(json =&gt; &#123; dispatch(fetchProductsSuccess(json.products)); return json.products; &#125;) .catch(error =&gt; dispatch(fetchProductsFailure(error))); &#125;;&#125;// Handle HTTP errors since fetch won't.function handleErrors(response) &#123; if (!response.ok) &#123; throw Error(response.statusText); &#125; return response;&#125; 注释:fetch()不会抛出HTTP error,例如404错误. 这一点让人有点困惑,如果你之前使用的是其他的方法,例如axios. 看这里,有关于fetch和错误处理的内容. 在Redux中,使用redux-thunk获取数据通常,actions必须是一个简单对象.返回一个函数,例如实例中的fetchProducts,超出了范围,Redux不允许这么做.至少在没有协助的情况下不行.所以redux-thunk就出现了.redux-thunk是一个中间件可以告诉Redux如何处理新类型的action(如果很好奇,可以看看thunk到底是什么东东?) 等等.神马情况?redux-thunk,Reducers有些意义. redux-thunk是完全捏造出来的吧? 如果你处在对Redux似懂非懂的边缘,要大胆大往前尝试,尽管可能不太明白到底是怎么一回事.我会把这件事说明白. 即使你已经搞清楚了,或许理解的很透彻. 回顾一下也是值得的. 使用npm install redux-thunk安装redux-thunk.接着需要添加几行代码扩展Redux store,以便使用新的中间件 1234567import &#123; createStore, applyMiddleware &#125; from \"redux\";import thunk from \"redux-thunk\";const store = createStore( rootReducer, applyMiddleware(thunk)); 重要的一件事要注意,在传递给Redux之前,必须要用applyMiddleware包装中间件. 这里还出现了rootReducer,之后我们会看看它的出处. 这段代码可以卸载index.js中,或者写在自己的文件中(store.js是个很好的名字).Redux不关心文件放在那里.如果你愿意,放在一起也可以.只要能够获取到store,并通过Provider提供给app就设置完成了. 如何命名 Redux ActionsRedux action获取数据通常是三部曲:BEGIN,SUCCESS,FAULURE,这不是必须的,只是约定俗成. 在起始API调用之前,dispatch BEGIN actionapi调用成功之后, dispatch SUCCESS和数据.如果api调用失败,dispatch FAILURE和error. 有时候, 最后一次的调用用ERROR代替.不太理想,只是为了统一. BEGIN/SUCCESS/FAILURE 模式很好,因为他给出了一个挂钩用于追踪具体发生的事-例如,设置 “loading”标志为true标识BEGIN action, SUCCESS或者FAILURE时设定为false.下面是action的样子: productActions.js1234567891011121314151617export const FETCH_PRODUCTS_BEGIN = 'FETCH_PRODUCTS_BEGIN';export const FETCH_PRODUCTS_SUCCESS = 'FETCH_PRODUCTS_SUCCESS';export const FETCH_PRODUCTS_FAILURE = 'FETCH_PRODUCTS_FAILURE';export const fetchProductsBegin = () =&gt; (&#123; type: FETCH_PRODUCTS_BEGIN&#125;);export const fetchProductsSuccess = products =&gt; (&#123; type: FETCH_PRODUCTS_SUCCESS, payload: &#123; products &#125;&#125;);export const fetchProductsFailure = error =&gt; (&#123; type: FETCH_PRODUCTS_FAILURE, payload: &#123; error &#125;&#125;); 之后,在收到FETCH_PRODUCTS_SUCCESS action时用reducer保存products至Redux store. 也同样在获取数据开始时,设置loading标志为true,完成或失败时设置为false. productReducer.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import &#123; FETCH_PRODUCTS_BEGIN, FETCH_PRODUCTS_SUCCESS, FETCH_PRODUCTS_FAILURE&#125; from './productActions';const initialState = &#123; items: [], loading: false, error: null&#125;;export default function productReducer(state = initialState, action) &#123; switch(action.type) &#123; case FETCH_PRODUCTS_BEGIN: // Mark the state as \"loading\" so we can show a spinner or something // Also, reset any errors. We're starting fresh. return &#123; ...state, loading: true, error: null &#125;; case FETCH_PRODUCTS_SUCCESS: // All done: set loading \"false\". // Also, replace the items with the ones from the server return &#123; ...state, loading: false, items: action.payload.products &#125;; case FETCH_PRODUCTS_FAILURE: // The request failed. It's done. So set loading to \"false\". // Save the error, so we can display it somewhere. // Since it failed, we don't have items to display anymore, so set `items` empty. // // This is all up to you and your app though: // maybe you want to keep the items around! // Do whatever seems right for your use case. return &#123; ...state, loading: false, error: action.payload.error, items: [] &#125;; default: // ALWAYS have a default case in a reducer return state; &#125;&#125; 最后只需要把products传递给ProductList组件,这个组件最终显示列表,同时也负责启动数据获取工作. ProductList.js12345678910111213141516171819202122232425262728293031323334353637import React from \"react\";import &#123; connect &#125; from \"react-redux\";import &#123; fetchProducts &#125; from \"/productActions\";class ProductList extends React.Component &#123; componentDidMount() &#123; this.props.dispatch(fetchProducts()); &#125; render() &#123; const &#123; error, loading, products &#125; = this.props; if (error) &#123; return &lt;div&gt;Error! &#123;error.message&#125;&lt;/div&gt;; &#125; if (loading) &#123; return &lt;div&gt;Loading...&lt;/div&gt;; &#125; return ( &lt;ul&gt; &#123;products.map(product =&gt; &lt;li key=&#123;product.id&#125;&gt;&#123;product.name&#125;&lt;/li&gt; )&#125; &lt;/ul&gt; ); &#125;&#125;const mapStateToProps = state =&gt; (&#123; products: state.products.items, loading: state.products.loading, error: state.products.error&#125;);export default connect(mapStateToProps)(ProductList); 这里引用数据用了state.products.&lt;somedata&gt;,没有用state.&lt;somedata&gt;, 因为我假设你可有有不止一个reducer,每个reducer处理自己的一块state. 为了让多个reducer一同工作,我们需要rootReducer.js文件, 它会把所有的小块reducer组合在一起: rootReducer.js123456import &#123; combineReducers &#125; from \"redux\";import products from \"./productReducer\";export default combineReducers(&#123; products&#125;); 截止,在创建store时, 可以传递这个”root” reducer: index.js12345import rootReducer from './rootReducer';// ...const store = createStore(rootReducer); Redux中的错误处理这里的错误处理内容很少,但是基础的结构和执行api调用的action是一样的. 总体的思路是: 在调用失败时dispatch FAILURE 在reducer中通过设置标识或保存出错信息来处理 FAILURE action. 向组件传递错误标识或者信息,根据需要条件性渲染错误信息 但是它将会渲染两次这是一个常见的担忧.的确是会渲染超过不止一次.在state为空的时候渲染一次, 根据loading state会重新渲染,在显示数据时还要渲染. 恐怖! 三次渲染!(如果直接跳过loading 会减微微两次). 你之所以担心不必要的渲染是因为性能的考虑,但是不要担心,单个渲染速度很快. 如果明显很慢,那就需要找到导致变慢的原因. 这样考虑:app需要在没有内容时显示一些东西,可以是加载提示,或者错误提示. 你也不愿意在在数据到来之前显示空白页面.这些提示为了我们增强用户体验的机会. 但是组件不应该自己去获取数据从构架的观点看,如果一个父”东东”(组件,函数,或路由)在他加载组件之前自动获取数据就更好了. 组件自己觉察不到无意义的调用. 他们可以幸福的等待数据. 有一些方法可以修复这个问题,但是凡事都有得有失. 魔术加载是魔术,它们需要更多的代码. 解决数据获取的不同方法有很多方式可以重构这段代码.没有最好的方法,因为每个方法都有适用范围, 因为对一个实例是最好的对于其他的实例未必如此. 在componentDidMount中获取数据不是最好的一个,但是是最简单的完成工作的方法. 如果你不喜欢这么作,还要其他一些方法可以尝试: 把API调用从Redux Action中转移到api模块中, 在action中调用(分离关注点). 组件直接调用API模块,然后在数据返回时从内部组件dispatch action. 类似 Dan Abramov的演示 使用类似redux-dataloader或者redu-async-loader.或者Mark Eriksons的数据获取库方法之一. 使用一个包装组件用于执行fetch操作- 在上面的例子中可以称为ProductListPage.之后”Page”关注fetching,”List”仅仅接受数据并渲染他们 使用recompose库把componentDidMount周期函数放入到高阶包装函数内-这个库是可以工作,但是可能作者要停止了[^译注,这个库的作者就是React的核心成员,recompose算是react hooks的前身] 很快你就可以使用React内置的suspense特性来获取数据了. 代码 CodeSandbox完整代码 可用的api 完成!","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"}]},{"title":"翻译|How to Use the useReducer Hook","slug":"翻译|How to Use the useReducer Hook","date":"2019-04-28T09:20:00.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2019/04/28/翻译|How to Use the useReducer Hook/","link":"","permalink":"https://React-Apollo.github.io/2019/04/28/翻译|How to Use the useReducer Hook/","excerpt":"","text":"原文:How to Use the useReducer Hook 在所有的新React Hooks,或许仅仅是因为名字,就可能成为使用最多的一个.“reducer”这个单词会让很多人联想起Redux-但是读本文,你不必事先理解Redux. 我们这里要谈的”reducer”实际问题是,如何利用useReducer的优点来管理组件中的复杂状态(state),新的hook对于Redux意味着什么?Redux需要hook吗?(对不起,有点跑题). [^译注:结合Redux和useReducer来阐述问题,可能是一个很好的出发点, Redux的reducer和useReducer核心都是根据组件dispatch的Action的type,payload来对State对象进行更新.概念是完全一样的,如果对Redux不是太了解, 可以借助useReducer来理解这个过程. 留给你大脑的转变过程是,如果两者之间的这种相同点存在,可以迁移吗?] 在本文中,我们会探讨一下useReducer.在组件中管理复杂state,要比useState的方式厉害的多. 什么是Reducer?如果你熟悉Redux,或者数组的reduce方法,你就应该知道reducer 是什么?.如果你不熟悉,”reducer”是一个奇特的单词,代表一个函数接收两个值,返回一个值. 如果有一个数组, 你想把其中的元素组合成单个值,”函数式编程”的做法是使用数组的reduce函数. 例如,如果你有一个数组,元素是数字,你想得到数字的综合, 可以编写一个reducer函数,传递给数组的reduce方法,例如: 1234let numbers = [1, 2, 3];let sum = numbers.reduce((total, number) =&gt; &#123; return total + number;&#125;, 0); 如果之前没看过这样的用法,可能有点晕. 这里所做的是针对数组的每个元素调用函数,传递的参数是前一个total和当前的number.函数返回值成为新的total,第二个传递给reduce的参数(在这里是0)就是total的初始值. 在这个例子中,输入的函数将会调用三次: 用个(0,1)调用,返回1 用个(1,2)调用,返回3 用个(3,3)调用,返回1 reduce返回6,结果存储在sum中. 但是,这和useReducer有什么关系?我花了半页的篇幅俩解释数组的reduce的原因是因为,useReducer接受相同的参数,基础的工作是相同的.你传递一个reducer函数和初始值(initial state). reducer接收当前的state和一个action,返回一个新的state.我们可以写一个类似的合计reducer:123useReducer((state,action)=&gt;&#123; Return state+action;&#125;,0) 那么如何触发这个操作? action是如何输入函数的. 想到这个问题就对了. [^译注:这里的这个问题绝对是学习Redux时,令人最困惑的地方] useReducer返回有两个元素的数组,类似useState hook. 第一个元素是当前的state,第二个参数是dispatch函数. 实际的代码如下: 123const [sum, dispatch] = useReducer((state, action) =&gt; &#123; return state + action;&#125;, 0); 注意”state”可以是任何值,不一定非要是一个对象. 可以是数字,数组,任何东西. 接着来看一个使用reducer的完整组件实例: 123456789101112131415161718import React, &#123; useReducer &#125; from 'react';function Counter() &#123; // 首次渲染会创建一个state,后续的渲染会保存结果. const [sum, dispatch] = useReducer((state, action) =&gt; &#123; return state + action; &#125;, 0); return ( &lt;&gt; &#123;sum&#125; &lt;button onClick=&#123;() =&gt; dispatch(1)&#125;&gt; Add 1 &lt;/button&gt; &lt;/&gt; );&#125; 可以在CodeSandbox 试试 可以看到,点击按钮,dispatch一个action,参数是1, 这个值会被加到当前的state上, 之后组件会用新的state(更大的值)来渲染组件. 我可以的把”action”写成这样.没有使用{type:&quot;INCREMENT_BY&quot;,value:1}的形式或者其他类似Redux的形式,因为reducer不一定必须要准守Redux的type模式.Hooks的世界是一个全新的世界:这一点很值得考虑,是否能发现旧有模式的价值,并保持它们,还是使用新的模式. 稍微复杂一点的例子现在来看一个和典型Redux reducer 非常接近的实例.我们要创建一个组件管理购物车列表,同时也会使用另一个hook:useRef 首先导入两个hook: 1import React,&#123;useReducer,useRef&#125; from 'react' 接着创建组件,设置ref和reducer.ref保留对表单输入的引用,便于我们获取表单的值(也可以通过组件内部state,传递value,onChange props来获取值,但是用useRef可以很好的展现它的用法) 1234567891011121314151617181920212223function ShoppingList() &#123; const inputRef = useRef(); const [items, dispatch] = useReducer((state, action) =&gt; &#123; switch (action.type) &#123; // do something with the action &#125; &#125;, []); return ( &lt;&gt; &lt;form onSubmit=&#123;handleSubmit&#125;&gt; &lt;input ref=&#123;inputRef&#125; /&gt; &lt;/form&gt; &lt;ul&gt; &#123;items.map((item, index) =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &#123;item.name&#125; &lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/&gt; );&#125; 注意,本例中的”state”是一个数组.我们使用一个空数组来初始化它,(传递给useReducer的第二个参数),后续会从reducer函数返回一个数组. useRef Hook题外话解释一下useRef的用法,之后在返回reducer话题. useRefhook 可以让我们创建一个DOM元素的持久化引用. 调用useRef会创建一个空的引用(可以传递参数进行初始化).返回的对象有一个current属性,所以在实例中,我们可以通过inputRef.current来访问DOM元素的输入值. 如果你对React.createRef()很熟悉,这里的工作原理是相同的. 从useRef返回的对象不仅仅可以承载一个DOM元素的引用,它可以承载做组件内的任何特定值,并且在渲染中保持固定.耳熟! 必须的. useRef也可用于创建泛型实例化变量,和React 类组件中的this.whatever=value做法一样. 唯一的区别是要写成”side effect”的形式,所以就不能在组件渲染过程中改变它了-只能在useEffect内部执行. 官方Hook问答 有实例讲解. 回到useReducer的例子用from包装input,在按下Enter键时触发提交函数. 现在需要编写handleSubmit函数,认为是把一个项目添加到列表上,还要在reducer中处理action 123456789101112131415161718192021222324252627282930function ShoppingList() &#123; const inputRef = useRef(); const [items, dispatch] = useReducer((state, action) =&gt; &#123; switch (action.type) &#123; case 'add': return [ ...state, &#123; id: state.length, name: action.name &#125; ]; default: return state; &#125; &#125;, []); function handleSubmit(e) &#123; e.preventDefault(); dispatch(&#123; type: 'add', name: inputRef.current.value &#125;); inputRef.current.value = ''; &#125; return ( // ... same ... );&#125; reducer函数有两个分支: 一个是action:type===&#39;add&#39;,默认分支:其他的任务. 当reduce获取到”add” action 以后, 它会返回一个新的数组包含了旧的元素,在末尾添加新的一条项目. 我们使用数组的长度作为自增ID.在这个实例中用自增ID是可以的,但是在实际的app中,不太理想,因为有可能导致重复的ID和bugs(最好是使用类似uuid的软件包,或者由服务器生成一个唯一的ID!) 在用户点击Enter键时,会调用handleSubmit函数,所以需要调用preventDefault来避免正页面的重载. 之后调用dispatch,参数是action.在app中,我们想让action更像Redux形式-拥有type属性,附带一些数据. 此外还有清除输入. 这个阶段的代码CodeSandBox 移除一项现在添加从列表中移除项目的能力 挨着项目添加 删除按钮,点击时会dispatch一个action,参数是type===&quot;remove&quot;,需要删除项目的索引 接着需要在Reducer中处理action,通过过滤数组来移除项目 123456789101112131415161718192021222324252627282930313233343536function ShoppingList() &#123; const inputRef = useRef(); const [items, dispatch] = useReducer((state, action) =&gt; &#123; switch (action.type) &#123; case 'add': // ... same as before ... case 'remove': // keep every item except the one we want to remove return state.filter((_, index) =&gt; index != action.index); default: return state; &#125; &#125;, []); function handleSubmit(e) &#123; /*...*/ &#125; return ( &lt;&gt; &lt;form onSubmit=&#123;handleSubmit&#125;&gt; &lt;input ref=&#123;inputRef&#125; /&gt; &lt;/form&gt; &lt;ul&gt; &#123;items.map((item, index) =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &#123;item.name&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'remove', index &#125;)&#125; &gt; X &lt;/button&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/&gt; );&#125; 这个阶段的代码CodeSandBox 练习:清除列表在额外添加一个内容,清空列表的按钮,作为练习. 在&lt;ul&gt;之上添加一个按钮, 添加onClick属性,可以dispatch,type为”clear”的action.之后在reducer中添加分支处理”clear”action. 那么… Redux就此终结篇章了吗?很多人初次看到useReducer就想,React现在内置reducer了,还有Context可以在全局范围传递数据,所以Redux已死! 我想给出我的一些想法,因为我猜你也很想知道到Redux的命运将会如何? [^译注: 我个人观点, useReducer的引入不仅不会让Redux很难堪,反而会让程序员借助useReducer对Redux有更深的认识,Redux的构架学习可能会有很多的回报,此刻如果舍弃React-Native,投入flutter的怀抱, flutter-Redux的就不再是一个负担了.] 我不认为useReducer会杀死Redux,Context也不会. 我认为这两个方法只是扩展了React state管理的方法范围而已,所以真正的情况是他们会减少使用Redux的用例. Redux仍然比Context+useReducer所做的工作多得多- Redux有Redux DevTools用于拍错,可以定制化的组件,还有全生态系统的助手软件包.你可以大胆的说,Redux在很多情况下都有点杀鸡用牛刀.但是我认为它仍然是非常强有力的. Redux提供的全局store可以让你集中控制app的data.useReducer是特定组件私有的.使用useReducer,useContext构建一个迷你版的Redux也是完全可行的. 如果你想做,它们完全可以满足需求(Twitter上有很多人已经做了,有截图).我个人仍然想念DevTools. 总之-Redux活蹦乱跳的.Hooks不会让Redux过时. 自己尝试一下一下是几个小的应用,可以用useReducerhook来完成 建一所房子,有一盏灯,按按钮可以调光-关,低亮度,中等亮度,最高亮度 做一个键盘锁,有6个按钮, 正确的顺序会解锁. 真确的按键顺序事先记录在state中, 顺序不正确会充值.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"React-Hooks","slug":"React-Hooks","permalink":"https://React-Apollo.github.io/tags/React-Hooks/"}]},{"title":"翻译|React & Redux Tutorial — Build a Hacker News Clone","slug":"翻译|React & Redux Tutorial — Build a Hacker News Clone","date":"2019-04-28T05:52:57.900Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2019/04/28/翻译|React & Redux Tutorial — Build a Hacker News Clone/","link":"","permalink":"https://React-Apollo.github.io/2019/04/28/翻译|React & Redux Tutorial — Build a Hacker News Clone/","excerpt":"","text":"翻译|React &amp; Redux Tutorial — Build a Hacker News Clone– Build a production React project using Redux and Styled Components. Deploy the app using GitHub pages.原文参见 本文是 gitconnected Hacktobrefest项目的逐步解决方法. 在本教程中,我将会构建一个产品级别的的 Hacker News 克隆. 我们会逐步实现应用的初始化,添加用于状态管理的 Redux,用 React 构建 UI并且部署到 GitHub 主页上.样式将会采用`styled-components,API方面使用axios库调用 Hacker News API. 源代码在这里查看. 下载 Chrome应用 如果你愿意看视频,可以看看 youtube 上的教程. http://www.youtube.com/watch?v=oGB_VPrld0U&amp;index=2&amp;list=PLTTC1K14KAxHj6AftnRUD28SQaoVauvl3 初始化项目使用create-react-app来初始化项目.用这个包初始化项目,就不用担心配置问题了.首先要确定已经安装了create-react-app. 1npm -i -g create-react-app 运行下面的命令来启动项目. create-react-app 安装了所有构建 React 应用的必备依赖包,还有默认的脚本用于管理开发和实际应用的打包. 12345create-react-app hn-clone# wait for everything to finish...cd hn-clone 现在可以安装应用所需的核心软件包了.目前我使用的是yarn来管理依赖包,如果你使用的是npm,只需要用npm install替换掉yarn add就可以了. 1yarn add redux styled-components react-redux redux-logger redux-thunk axios create-react-app使用NODE_PATH 环境变量(environment variable)来创建绝对路径. 我们可以在.env文件中声明环境变量. create-react-app会识别它,通过doten库 来应用绝对路径. 12345#使用touch 命令创建.env文件touch .env# 在.env文件里添加#NODE_PATH=src 如果你对这个模式不太熟悉, 当我们开始构建应用的时候,对你来说更为有意义.设定环境变量可以让我们直接导入文件而不用考虑文件的路径. 类似这样 ../../components/List 变为components/List- 使用上方便多了. 文件组织结构在src文件夹里面, 从应用要适应更为大规模和重用性更强上考虑,做一些更新. components: 这个文件夹包含所有的 React 组件(container和 presentational 组件都包含). services: Services可以连接到API(例如,使用axios调用 HN API)或者为应用提供扩展的功能(例如,添加markdown)支持. store: store 包含了所有的Redux和state 管理的逻辑 styles: 在styles文件夹内,我们声明变量,模板和可以在组件间共享的样式模式 utils: 整个应用中可以重用的助手函数 这里的文件夹结构有两个地方值得注意: 应用中只有一个路由,位于根./下.如果我们有多个路由,我可能会使用react-router包,同时创建pages文件夹用于保存页面级别的组件. 我没有使用单独的container文件夹用于连接应用组件到Redux.我发现增加container文件夹反而添加了不必要的复杂性,让一些新手感到很困惑,因为开发者总是要从没有关联的位置中导入文件(container想要连接组件,反之亦然). 在我的使用经验汇总,从当个来源导入文件工作的更好一点. 因为我们在使用styled-components,所以可以删除掉index.css和app.css文件. 现在我们要在src/styles文件件中添加一些基础模板样式,创建文件global.js和palette.js文件 Palette包含了应用UI中使用的成组的颜色配置. 在src/styles/palette.js中添加 global.js用于生成应用中共享的基础样式. styled-components的injectGlobal方法应该要小心使用,但是用于应用级别的样式时时非常有用的. 注意: 在styled-components v4中injectGlobal已经被createGlobalStyle替代了. 在components文件夹中创建App文件夹,把所有的 CRA默认生成的文件都移动到这个文件中,把App.js文件重命名为index.js文件. 这样就可以导入components/App 现在代开src/index.js文件(项目的根文件),使用更新的文件结构更新文件. 注意,因为之前我们定义了NODE_PATH,现在使用components/App导入App文件,styles/globals来导入setGlobalStyles文件. 执行setGlobalStyles()函数可以在应用中导入全局的样式. 现在我们已经准备好了启动应用开发环境的核心配置. 运行下面命令启动应用,会在http://localhost:3000看到应用. 现在看上去还不是太好,但是应用已经跑起来了 :) 12yarn start# npm 安装用 npm start 在 React 应用添加Redux在src/store文件中,创建index.js,reducer.js和middleware.js文件. 让我们来初始化一个app专项(feature)来管理应用的state. 以我的经验,在生产级别的应用中,如果按照特性而不是按照功能进行分组,Redux会更具有管理性,类似于鸭子方法(Ducks approach). “按照功能分组(grouping by functionality)” 方法中所有的actions,reducers,等等都位于独立的文件夹中, 当应用规模增加时,在不同文件中切换难度就增大了. 如果按照特性分组,你需要的文件总是在一个位置. 在index.js文件中,创建configureStore函数,用于初始化应有的 Redux. 使用createStore构建初始化store. 从根reducer文件导入reducer,同时从middleware配置文件中导入 middleware(中间件). initialState 应该在程序运行时提供,并传递给我们的函数. 在生产中,要能够管理复杂的功能例如 SSR(服务端渲染),或者在初始化时从服务器获取传递的数据. 在这里初始state,可以让我们更优雅的和抽象出store的创建过程. 在reducer.js文件中,使用combineReducers函数创建根reducer.此函数把所有的reducer函数组合起来生成单个的state树. 接下来在middleware.js中创建中间件. 中间件是每一次dispatch action 时都必须要执行的函数. 中间在扩展Redux应用时非常有用. 在文件中添加如下代码 也要构建第一个Reducer.在 src/store/app文件加中创建 reducer.js和action.js文件. 需要添加日间/夜间的切换模式功能,所以让我们创建一个action来管理这个特性.在src/store/app/action.js 添加下面代码 我们创建了一个actionTypes对象放置actio-type常量. 类似的常量在reducer中用于匹配改变state的类型. 也要创建actions对象,包含了可以从应用中dispatch 用于改变state的 action函数.每一个action都包括了一个type和一个payload(译注: type告诉store要干什么,payload 是执行action时携带的条件). 最后,创建我们的reducer 当我们dispatch一个SET_THEME action时, 将会使用payload的内容更新 state中theme的属性值. payload是一个对象,形式是{theme:&#39;value&#39;}.使用es6的展开操作...,state中对应payload键的值会被替换掉. 如果需要详细理解 Redux的基础 ,看看Dan Abramov的视频 现在返回src/index.js文件,做一些更新,需要把我们的应用连接到 Redux. 为Provider添加一个导入,更新渲染方法 现在应该已经做完了 Redux的整个工作.返回到localhost:3000,在Chrome的console中可以看到下面的内容 使用 React和Styld Components 构建 UI现在 Redux 已经初始化完毕, 开始完成 UI 的工作. 首先声明一些会在应用中使用的样式常量. 在本应用中,我们要创建mediaQueries(媒体查询) 文件包含构建响应式应用的常量. 创建src/styles/mediaQueries.js文件,添加下面的代码 返回到src/components/App文件夹, 在index.js文件中,更新文件内容 其中使用了styled-components的ThemeProvider组件.这个组件尅让我们把”theme”作为prop传递给创建的styled components. 这里初始化theme为 colorDark对象. App中包含的组件,现在还没有创建,所以现在来创建.首先构建styld-components 组件. 在App文件夹里创建styles.js文件, 添加代码 创建的用于页面的div称为Wrapper. 用于页面标题的h1创建为Title组件. styled-components语法使用styled对象定义 HTML 元素. 可以用字符串定义组件的 CSS 属性. 注意代码20行, 我们使用了theme prop. 包含props参数的函数由styled-components 注入到样式字符串中,这么,我们就可提起属性或者添加用于动态构建样式的逻辑,从组件中抽象出构建样式的逻辑. 接下来, 创建包含 Hacker Nees故事的 List 组件. 创建src/components/List文件夹并添加index.js,styles.js文件. 在index.js文件中,添加代码 在styles.js文件中创建ListWrapper.使用从ThemeProvider组件得到的theme props 的background-color属性. 最后创建ListItem组件用于显示单个的故事. 创建src/components/ListItem文件夹和index.js,styles.js文件. 我们想让 UI模仿 Hacker News. 目前会在ListItem中使用fake 数据里模拟. 在index.js文件中添加代码 每个故事都有标题,作者,评分,发帖时间,URL地址,评论数. 初始化这几个值,以便于查看 UI 的样子. 基于安全原因, 添加rel=&quot;nofollow noreferrer noopener&quot;. 在styles.js文件中添加下面代码 这些应该就是我们需要的基础 UI 组件了. 返回到浏览器,应该看到使用fake数据的单个条目 使用 Redux 和 Axios 构建 API 调用是时候在应用添加实际数据了.我们通过axios库来调用 Hacker News的 API.调用 API 的过程会在应用中引入 “side effect(副作用)”,意思是调用 API 会从外部资源影响本地环境的state. API 调用之所以被称为 side effect,原因是在应用的state中引入了外部的数据. 其他的side effect的例子包括和浏览器的localStorage的交互操作, 追踪用户分析,连接到web socket,等等. 在 Redux 应用中可以使用很多库来管理 side effect. 从简单的redux-thunk 到更为复杂的redux-saga. 然而他们的目的是相同的,就是让 Redux与外界交互. redux-thunk是最简单的库, 可以在action 对象中再次 dispatch JavaScript 函数.这个功能就是我们在使用axios时需要的功能,在 API调用管理返回的promise对象. 在src/services文件夹中,创建Api.js和hackerNewsApi.js文件. axios库有着难以置信的强大功能和扩展性. Api.js包含的配置使得执行axios请求更容易. 这里没有拷贝完整代码,你可以在源代码中看到信息内容,其中包含了更为精细的配置. 在src/services/hackerNewsApi.js文件中, 我们要定义请求 Hacker News API 的函数. 在Hacker New API 文档 可以找到,如果要获取 IDs 的列表, 要使用/v0/topstories 入口. 获取每个 id的独立故事要使用/v0/items/&lt;id&gt; 入口. v0/topstories 入口返回列表中 IDs的 400-500条故事. 因为我们要获取单个故事的数据,如果立刻获取500个故事的数据会严重影响性能. 为了解决这个问题,我们一次只获取20个故事的数据. 使用.slice()函数基于页面的故事 ID进行分割. 因为我们使用/v0/item/&lt;id&gt; 调用每个故事的数据, 因此使用Promise.all把所有的请求返回的promise对象压缩的一个数组中,然后用一个then(),resolve返回获取数据,并且保存 IDs 的顺序标记. 为了在应用管理我们的故事state,我们来创建一个story reducer. 创建src/store/story文件夹, 添加reducer.js和action.js文件. 在action.js文件中添加代码 为 IDs请求和stor用的API 调用都创建了 request,success,failure的 actionTypes. 我们的actions 对象中包含了 用于请求管理的thunk 函数. 通过dispatch 函数而不是dispatch action 对象. 我们就可以在请求周期的不同点 dispatch 不同的acitons了. 函数getTopStoryIds会执行 API 调用,获取整个故事的列表. 在getTopStoryIds函数中success(成功)的回调函数执行时,我们会dispatch fetchStories action,用于获取第一页故事的结果. 当 API 调用成功返回时,就可以dispatch success Action,这样就可以使用新获取的数据来更新 Redux的 store了. thunk软件包的基础实现只是用了几行代码. 要充分理解它,需要对 Redux的中间件有了解,但是从代码中,我们可以看到,如果我们使用一个函数来代替一个对象,就可以执行一个函数,并且把dispatch作为函数的参数传递. 现在我们需要创建reducer用于 Redux store中的数据存储. 在src/store/story/reudcer.js中添加代码 对于 FETCH_STORY_IDS_SUCCESS action type,我们展开当前 state和 payload. 在 payload 中唯一的键/值是storyIds,展开操作将会用新的值来更新 state. 对于FETCH_STORIES_SUCCESS action type. 在之前的故事列表中按顺序添加故事,以便于获取更多的页面. 此外,增加page 数, 设置isFetching state 为false. 现在,State已经由 Redux管理了, 我们就可以在组件中显示数据了. 把React APP 连接到 Redux Store通过使用react-redux绑定,我们可以把组件连接到 Redux的store, 以props的形式接收Redux的 State.之后,只要 store 有更新,props就会引起组件的重新渲染,由此就更新了 UI. 在需要dispatch action 的组件中,以 props 的形式传递函数. 之后在组件内部调用这些函数,就可以触发 Redux store 中的state变化. 来看看如何在应用中管理这个变化. 返回到src/components/App文件夹,创建一个 App.js文件, 从src/components/App/index.js拷贝内容进来. 在index.js文件里面,我们将会把App组件连接到 Redux. 在index.js文件中添加代码 mapStateToProps函数接受 Redux store作为参数,返回一些属性到连接的组件中.对于App,我们需要 stories 数组, 当前页 page,storyIds数组还有isFetching指示器. mapDispatchToProps函数接受dispatch函数作为参数,把返回的函数对象作为props传递给我们的组件. 创建的函数fetchStoriesFirstPage,执行时会dispatch action 来获取story IDs(然后获取第一页故事的内容). 我们在App.js中使用这两个props,首先添加componentDidMount,当组件在 DOM 中渲染完就可以立刻获取数据. 为List组件传递stories props. 在src/components/List/index.js中,遍历stories 数组, 创建 ListItem组件的数组. 设置列表的key为story ID,并且展开story对象: ...story.展开操作会把对象的属性值作为单个的props传递给组件. key prop 是 React中组件作为数组加载时的一个策略,可以让列表形式的渲染更新速度更快. 如果现在观察屏幕,应该看到到的是硬编码的20行列表数据 我们需要使用从stories 获取的数据对ListItem进行更新.同时在 Hacker News中, 也会显示上次故事更新的时间和来源的地址. 需要安装timeago.js 和URl 软件包帮助计算没有通过 API 直接获取的数据, 使用下面命令执行安装 1yarn add timeago.js url 需要编写助手函数来构建这些值. 从源码的src/utils文件夹中拷贝文件 现在更新 src/components/ListItem/index.js文件 通过这一步, 现在就可以在应用显示前20个故事了- cool! 使用无限滚动来对请求分页现在,我们想实现的是当用于页面滚动到底部, 获取新的一页.回忆一下,每次成功获取故事之后,我们都增加了store中page的数字. 所以在第一页到达之后,Redux store 现在应该是page:1.我们需要在滚动到底部时dispatch fetchStories action. 为了实现无限滚动,我们会使用react-infinite-scroll-component组件. 我们也想实现一个方法来决定管是否要加载更多的页面,这一点我们使用reselect 在selector中实现. 1yarn add react-infinite-scroll-component reselect 首先构建selector来计算是否有更多的故事存在. 创建 src/store/story/selecor.js文件. 为了判断是否有更多故事存在, 我们 Redux store中的storyIds 数组的长度是否和stories的长度相同, 如果stories的长度短一点,意思就是有更多的页面存在 在src/components/App/index.js container中,导入hasMoreStoriesSelector 在mapStateToProps中添加 键hasMoreStories.同时在mapDispatchProps中添加fetchStories action,便于滚动时 dispatch action. 我们想在等待 API请求时使用动画显示. 创建src/components/Loader文件夹,index.js和styles.js文件. 需要的动画是闪动的三个圆点. 在styles.js文件中添加下面代码 @keyframe 是定义动画的 CSS 技术. 上面代码显示了在 Styled Components中的代码抽象. 有三个圆点,透明度从0.2开始增加到1, 然后返回到0.2, 给第二个和第三个点添加延迟,表现出弹跳式的偏移. 我们的Loader组件就是有三个独立span元素的动画styled components动画组件. 现在,准备为列表添加功能,在App组件中导入无限加载模块和Loader组件.也要创建fetchStories回调函数,将会调用fetchStories prop dispatch 下一页的action. 只有在isFetching为 false 时dispatch fetchStories action. 如果为 true.我们就多次获取统一页面. 你的src/components/App/App.js文件应该如下 当我们滚动到页面底部, 只要hasMoreStories为真,InfiniteScroll组件将会调用this.fetchStroies. 当fetchStories API 请求返回时,新的故事会添加到stories数组的尾部,渲染到页面中. 最后的挑战在教程刚开始, 我们初始化了一个theme property.现在,留给你实现一个toggle功能. 在一些组件中添加点击事件,dispatch setTheme action.切换 light和dark的状态. 在ThemeProvider组件中需要一个三元条件判断如果 state.app.theme===&#39;dark&#39;就传递colorDark,否则就传递colorsLight. 如果你卡住了,可以看看源码的实现.加入Slack 寻求帮助. 试试我们的办法. 部署到GitHub 主页对于应用的最后一步都是投入生产. 因为我们的功能是在客户端,可以免费部署在 GitHub 主页的静态网站. 提交你的代码并推送到Github. 我命名仓库为hn-clone.如果你在创建仓库和上传代码是遇到问题可以参照一下这个指导 现在使用如下的步骤发送过的 GitHub 主页: 在package.json文件中添加 &quot;homepage&quot;:&quot;http://&lt;username&gt;.github.io/&lt;repo-name&gt;&quot; 使用你的实际值替换&lt;username&gt;和&lt;repo-name&gt;. 我的值是 treyhuffine和hn-clone. 安装gh-pages作为开发依赖项 1yarn add -D gh-pages 在package.json文件中添加两个脚本 1\"predeploy\": \"npm run build\",\"deploy\": \"gh-pages -d build\" 最后运行yarn deploy 并访问在homepage中定义的URL. 现在你的 Hacker News 投入生产了. 结论本文覆盖了构建 Hacker News clone所必须的所有的功能. 源码还有一些额外的特性,持续更新中, 查看一下是否有灵感出现可以继续添加功能,学习更多的 React 知识. 不要忘了下载Chrome 扩展, 并访问 gitconnectec.com网站,加入开发者社区. 原文发表在 gitconnected.com-开发者社区","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"}]},{"title":"翻译|18 Tips for Training your own Tensorflow.js Models in the Browser","slug":"翻译| 18 Tips for Training your own Tensorflow.js Models in the Browser","date":"2019-04-28T05:52:57.900Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2019/04/28/翻译| 18 Tips for Training your own Tensorflow.js Models in the Browser/","link":"","permalink":"https://React-Apollo.github.io/2019/04/28/翻译| 18 Tips for Training your own Tensorflow.js Models in the Browser/","excerpt":"","text":"参见原文 在导入已有的用于物体检测,面部检测,面部识别模型之后,what not to tensorflow.js之后.我发现有些模型性能不太好了,但是有些模型在浏览器端性能很好. 如果你认真思考了浏览器端的机器学习模型的潜能,以及所有可以使用库,你可能会觉得很神奇. 然而, 直接在浏览器端运行深度模型,我们也面临着存在模型的一些局限,这些模型设计之初并不是用于客户端的,移动浏览器就更不要想了. 就拿物体检测作为实例:通常都需要大量的计算资源确保模型的流畅运行,保持实时的速度. 此外,在浏览器端加载100MB+ 的权重参数也不太可行. 为 web 环境训练有效的深度学习模型但是,希望最终会实现. 我要告诉你,如果考虑一些基本的原则,我们也能够训练处相当地道的模型,专门用于web环境.信不信由你:我们可以训练出真正的图片分类,甚至是物体检测模型,最终大小之后几兆,甚至是几十kb.","categories":[{"name":"Medium","slug":"Medium","permalink":"https://React-Apollo.github.io/categories/Medium/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://React-Apollo.github.io/tags/JavaScript/"},{"name":"TensorFlow.js","slug":"TensorFlow-js","permalink":"https://React-Apollo.github.io/tags/TensorFlow-js/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://React-Apollo.github.io/tags/Machine-Learning/"}]},{"title":"React,Reselect and Redux","slug":"React,Redux,Reselect","date":"2019-04-28T05:52:57.896Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2019/04/28/React,Redux,Reselect/","link":"","permalink":"https://React-Apollo.github.io/2019/04/28/React,Redux,Reselect/","excerpt":"","text":"原文在这里 作者 : Dan Parker (译注: 主要思想实际和Node.js的中间件类似,在 UI 组件从Redux的 State 中获取对象分枝时,不要在UI组件中对数据进行复杂处理,在 UI 组件之前再加一个 Reselect的selector(同样可以把单个的selector组合起来,形成更为复杂的数据结构),在selector中进行数据的复杂处理,或者是缓存处理, UI组件要完全成为无状态的. 提起出数据选取,处理和缓存组件.) React很棒, Redux很棒,Reselect 也很棒.但是要让三个部分一起工作还是要有点技巧的. 我会试着解释讲解一下三者如何一起配合工作. npm install --save reselect 如果你还没有React,Redux以及 Redux-connect(Redux连接组件)的知识,就暂时不要往下继续了,等学完了上面三个知识以后再返回来继续学习. Reselect创建了有记忆能力的选择器(selector),并且把选择器组合起来(译注:因为没有恰当的译文,所以下面仍然直接使用英文单词,并注意单复数变化,单数指从 Redux 的 state 对象中选出的单个对象分支,复数值得是单个对象分支的组合)是滴,这就是需要技巧的地方. Selector 的 Selectors. Selector 的意义. 可以直接到本文最后查看源代码. 第一步:创建selector…可以在connect 文件中创建.但是现在我们创建单独的文件 selector.js 1const getBar=(state)=&gt;state.foo.bar 这样,一个简单的selector就完成了,但是这和 Reselect没有什么关系. 在 Redux 的 connect 方法中都是这么做的,不同点只是这是单独创建了一个文件. 只要getBar()函数获得state对象,总是返回 state.foo.bar(译注:这是函数式编程的概念,同样的输入,总是有同样的输出). 现在Reselect可以出场了.Reselect是记忆性的reselector函数,组合selectors,之后返回组件需要的属性(React Props). 1234567891011import &#123;createSelector&#125; from 'reselect';//selectorconst getBar=state=&gt;state.foo.bar;//reselect functionexport const getBarState=createSelector( [getBar], (bar)=&gt;bar) 我知道这段代码初看起来有点滑稽.但是这里发生了很多事.createSelector是一个函数.第一个参数是一个selectors. 第二个参数的参数就是 reselectors.所以,上面 (bar)=&gt;bar是一个函数.这个函数只有一个参数(这里我命名为bar,但是你可以用任何函数名),就是selectors,也就是第一个参数声明的 createSelector函数. 仍然有点令人费解…我明白. 坚持往下面看,你会明白的. 当这个文件和mapStateToProps放到一起的时候,就有意义了. React 组件123456789101112131415import React from 'react';import &#123;connect&#125; from 'react-redux';import &#123;getBarState&#125; from '../selectors'const mapStateToProps=(state)=&gt;&#123; return &#123; bar:getBarState(state) &#125;&#125;class Thing extends React.component &#123; ...&#125;export default connect(mapStateToProps)(Thing) 看到了吗? 很标准的 Redux配置,唯一不同点是我们用了selector函数,而没有直接用state.foo.bar对象分支. 我们把state传递进getBarState函数 getBar函数调用 getBar函数,state作为参数. getBar函数获取 state对象,返回 bar. 我们在 Reselect函数中使用了返回的值. Reselect处理了数据的记忆(或者缓存). 注意:在使用 Redux 时,无论应用中分发任何action,所有的mount和connect 组件都会调用他们的 mapStateToProps函数. 这就是 Reselect非常酷的地方.如果没有发生变化,它只返回记忆的结果(译注:注意 React的组件props更新的问题). 高级使用方法在实际使用中,可能不同的组件需要的是相同的state部分.所以也想把同样的 props 传递给selector. 为了实现这个步骤,需要创建可以同时在多个组件中使用的selector函数…所有的内容都会被记忆. 为了让有相应记忆的selectorFunction 函数可以重用.就不能用单个组件的方法来写了. mapStateToProps也必须要修改. 如果多个组件需要使用同一个记忆reselector,需要在每次使用时都创建实例. 把selectorFunction修改为匿名函数(anonymouse function), 返回 一个selectorFunction. 123456789101112131415161718192021222324import &#123;createSelector&#125; from 'reselect'//我以一个通用的selector,我不需要特殊待遇//我现在有了 props,所以我可以扎到特定的 bar 分支了const getBar=(state,props)=&gt;&#123; const id=props.id const barById=state.foo.bar.find((item,i)=&gt;item.id===id) return barByID&#125;//如果在多个组件中需要这个分支,就不能工作了//export const getBarState=createSelector( //[getBar], //(bar)=&gt;bar//)//如果要在多个组件中使用这个属性,这是正确的用法export const makeGetBarStaet=()=&gt;createSelector( [getBar], (bar)=&gt;bar) 现在,当我们调用makeGetBarState,就可以得到一个createSelector函数. 在组件中使用时也必须要做一些改动 123456789101112131415161718192021import React from 'react'import &#123; connect &#125; from 'react-redux'import &#123; makeGetBarState &#125; from '../selectors'// remember, mapStateToProps can have the component's// props as the second argument// but now we need to modify this method to allow for a new// instance of our makeGetBarState function, which returns a // memoized selector const makeMapStateToProps = () =&gt; &#123; const getBarState = makeGetBarState() const mapStateToProps = (state, props) =&gt; &#123; return &#123; bar: getBarState(state, props) &#125; &#125; return mapStateToProps&#125;class Thing extends React.Component &#123; ...&#125;export default connect(makeMapStateToProps)(Thing) 我们需要把 mapStateToProps改为匿名函数,它返回一个 mapStateToProps函数…因此命名为makeMapStateToProps, 在makeMapStateToProps中, 我使用const getBarState=makeGetBarState()创建了一个selector函数的实例. 现在getBarState就是一个 selector函数了, 和其他的selector没有相互关联(independent). 可以在多个组件中使用. (译注:如果要了解底层,这里就是JavaScript的高阶函数, 高阶函数的底层就是 JavaScript的闭包,创建函数实例时,为每个组件都出创建了单独的变量空间,这就是 independent的含义). 清理一下大家都喜欢简短和甜蜜… 对吧. 为了简洁,可以重构一下代码. selector.js 123456import &#123; createSelector &#125; from 'reselect'const getBar = (state, props) =&gt; state.foo.bar.find( b =&gt; b.id === props.id )export const makeGetBarState = () =&gt; createSelector( getBar, (bar) =&gt; (&#123; bar &#125;)) component 1234567891011import React from 'react'import &#123; connect &#125; from 'react-redux'import &#123; makeGetBarState &#125; from '../selectors'const makeMapStateToProps = () =&gt; &#123; const getBarState = makeGetBarState() return (state, props) =&gt; getBarState(state, props)&#125;class Thing extends React.Component &#123; ...&#125;export default connect(makeMapStateToProps)(Thing) 代码在这里","categories":[{"name":"Medium","slug":"Medium","permalink":"https://React-Apollo.github.io/categories/Medium/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"Reselect","slug":"Reselect","permalink":"https://React-Apollo.github.io/tags/Reselect/"}]},{"title":"Selector Pattern:painless Redux Store Destructiong","slug":"Selector Pattern","date":"2019-04-28T05:52:57.896Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2019/04/28/Selector Pattern/","link":"","permalink":"https://React-Apollo.github.io/2019/04/28/Selector Pattern/","excerpt":"","text":"原文请见 作者 : Dean Slama Jr Redux非常好,因为它显式定义了所有可能的 state变化(通过actions),以及如何改变state(通过reducer)–但是组件如何查询store的方法没有. 解决这个问题的方法之一是使用 Selector Pattern. 在同一个地方集中处理 与state访问有关的问题,减少代码的复杂度. Selector 模式 在React组件中的实现 提取出 Selector的实现部分 执行优化:缓存 Selector模式Redux 把应用的 state 集中为全局的state(例如,组件间可以共享 state). 这一点对于减少应用的复杂度非常好. seletor模式解决的问题就是如何从集中的全局 state 获取所需要的值的问题. 对于这个问题,常见的解决办法是通过state的引用来访问state. 1const thePieceOfStateMyAppNeeds = store.someStateDomain.someProperty[someKey] (译注:这里就是问题的关键点, 每次要从很庞大的单个state中筛选出我们需要的部分. 如果把需要的一部分 state,拷贝出来单独存储,如果下次访问时没有改变,就直接从副本中获取数据.) 问题是,这个方法,需要应用代码知道store的确切结构-如果 store 发生了改变,不得更新所有需要state的部分. selector pattern 是一个抽象方法使得应用store的查询逻辑标准化. 很简单:对于应用需要访问的每一部分,都定义函数,接收整个store,返回需要的部分(或者衍生出来的部分). 直接跳过 selector模式,让组件自己掌握store情况,尤其是在简单引用下.wrong1.js123//这段代码在本文是不提倡的const thePieceOfStateMyAppNeeds=store.someArrayOfValues 我会建议对于应用的所有store查询操作都使用selector模式,不要考虑查询是否复杂. 如果store的实现要考虑重构, 通过使用selector模式,需要更新的对象引用关联更新会讲到最低程度. 在 React组件中的实现1234567891011121314151617181920212223242526272829303132333435363738394041import React from 'react'import &#123; connect &#125; from 'react-redux'import &#123; isLoadingFriends, getFriends &#125; from '../redux/reducer'import Friend from './Friend'/** * Component */export class FriendsList extends React.Component &#123; renderLoading () &#123; return ( &lt;div&gt;Loading...&lt;/div&gt; ) &#125; renderFriendsList () &#123; return ( &lt;div&gt; &#123; this.props.friends.map(friend =&gt; (&lt;Friend friend=&#123;friend&#125; /&gt;)) &#125; &lt;/div&gt; ) &#125; render () &#123; if (this.props.isLoading) &#123; return this.renderLoading() &#125; else &#123; return this.renderFriendsList() &#125; &#125;&#125;/** * 把 Redux store 映射到组件props */function mapStateToProps (store) &#123; return &#123; isLoading: isLoadingFriends(store), friends: getFriends(store) &#125;&#125; 在mapStateToProps函数中,我们只是简单的把store传递给对应的selector.这个组件不需要知道selector的具体实现细节,仅仅是返回组件需要的部分或者衍生出的数据. selectors从根reducer模块中导入 123456789101112131415161718192021222324252627282930313233343536import &#123; combineReducers &#125; from 'redux'import userReducer, * as FromUser from './user'import friendsReducer, * as FromFriends from './friends'const USER = 'USER'const FRIENDS = 'FRIENDS'// -----------------------------------------------------------------------------// REDUCERexport default const rootReducer = combineReducers(&#123; [USER]: userReducer, [FRIENDS]: friendsReducer&#125;);// -----------------------------------------------------------------------------// PUBLIC SELECTORS// userexport function isLoadingUser(store) &#123; return FromUser.isLoading(store[USER]);&#125;export function getUsername(store) &#123; return FromUser.getUsername(store[USER]);&#125;// friendsexport function isLoadingFriends(store) &#123; return FromFriends.isLoading(store[FRIENDS]);&#125;export function getFriends(store) &#123; return FromFriends.getFriends(store[FRIENDS]);&#125; 在根 reducer模块中包含 selectors是有意义的,因为 selectors需要知道 应用的整个store的结构.这个模块就是就包含了store的所有情况. 重要的是,如果 store的整体结构发生变化,极有可能只需要修改这一个文件. selectors共享相同的接口: 都把整个store作为函数的第一个参数. 为了获取需要的值, 这些selectors函数都由一个或者多个私有selector组合而成.公共的 selector 需要整个store作为参数, 每个私有的 selector需要store的一个分支部分. 每个私有的selector和整个 Store 的一个分支相关,方法和reducer从store获取对应的片段是同样的. 更重的是,私有的selectors 和reducers配置可以简单优雅的放在同一个文件中: 12345678910111213141516171819202122const defaultStore = &#123; isLoading: false, friends: [] &#125;// -----------------------------------------------------------------------------// REDUCERexport default const reducer = () =&gt; Object.assign(&#123;&#125;, defaultStore)// -----------------------------------------------------------------------------// 私有SELECTORSexport function isLoadingFriends (store) &#123; return store.isLoading&#125;export function getFriends (store) &#123; return store.friends&#125; 这样的共有/私有selectors模式可以执行: 针对 reducer 变化的配置不需要让共有selector发生改变 两个或者更多的公共selectors可以共享私有的 selector,更容易维护(这里的公有指的是几个组件都需要的 state 部分). 衍生selector的实现","categories":[{"name":"Medium","slug":"Medium","permalink":"https://React-Apollo.github.io/categories/Medium/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"}]},{"title":"Promise的例子","slug":"Promise对象的例子","date":"2019-04-28T05:52:57.892Z","updated":"2019-04-28T05:52:57.892Z","comments":true,"path":"2019/04/28/Promise对象的例子/","link":"","permalink":"https://React-Apollo.github.io/2019/04/28/Promise对象的例子/","excerpt":"","text":"Promise的使用 根据阮一峰的博客内容 Promise对象的使用在事件循环中有优先级如果异步事件在第一轮就可以resovle,就在第一轮中返回 输出为 3，2，1第一个setTimeout函数中的回调函数会在第二轮事件循环中执行，第三个函数会在本轮事件循环中立刻执行第二个函数比较微妙， promise对象的回调函数没有延迟，并不会等到第二轮事件循环中执行， 在第一轮循环的最后就会执行。 如果修改一下， promise对象中的函数有延迟，如下 添加的第三个函数有延迟，在第一轮循环中还不能完成，会进入到第二轮循环。解析完成后会在第二轮或者后续的时间循环中返回。","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://React-Apollo.github.io/tags/Javascript/"},{"name":"Async","slug":"Async","permalink":"https://React-Apollo.github.io/tags/Async/"}]},{"title":"","slug":"Awesome List for FrontEnd Programmer","date":"2019-04-28T05:52:57.888Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2019/04/28/Awesome List for FrontEnd Programmer/","link":"","permalink":"https://React-Apollo.github.io/2019/04/28/Awesome List for FrontEnd Programmer/","excerpt":"","text":"Awesome List for FrontEnd Programmer","categories":[],"tags":[]},{"title":"翻译|Thinking Statefully","slug":"翻译|Thinking Statefully","date":"2019-04-27T12:48:00.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2019/04/27/翻译|Thinking Statefully/","link":"","permalink":"https://React-Apollo.github.io/2019/04/27/翻译|Thinking Statefully/","excerpt":"","text":"‌原文:Thinking Statefully 熟练掌握React的过程包含了如何解决特定问题的方法转变.这提醒我,这个学习过程有点像在路上不同的方向开车.第一次感受这一点是,我真正访问土耳其和卡斯柯岛,他们的车都靠左行驶.在美国我们是靠右行驶,所以要花很大的力气重编程. 一出机场就差点完蛋了. 有意思的是,即使我已经可以在正常的直道上行驶,但是在不同情况发生时,大脑仍然把他转换成了旧的习惯. 转进停车场?习惯接管了,我开进了错误的车道.在停车标志车左转?还是同样的问题.向右转?你认为我已经了解了一切,但是对于我的大脑,完全没这回事. 我讲这个故事是因为在学习React的时候,我的经历是类似的.我想其他人也有这样的经历. 传递props到组件(最好把组件看成是函数),大脑也已习惯了. 看起来和HTML的工作差不多. 在简单实例中,往下传递数据,向上传递事件也很好理解.这就是回掉模式,在其他的地方也很常见.向按钮组件传递一个onClick handler是相当普通. 但是如果需要Modal对话框.或者是提示Badge,要怎么操作?亦或者根据事件响应来对一个Icon进行动画操作?可以看到,这些都是命令式的,”事件驱动”的内容在声明式和状态时的React世界显得很不自然. 怎么开发”状态式”或者是”声明式”的思考如果你有jQuery,Angular的经验或者其他框架的以经验,需要调用函数执行任务(“过程式编程”),在React的领域里为了更为有效的工作就需要调整思维模型.从实践中可以很快的完成这个转变-只需要给大脑一些新的实例或者”模式”. 这里是一些实例 打开/关闭一个Accordion组件(手风琴组件) 旧有办法: 点击toggle按钮调用toggle函数,从而打开或者关闭accordion.Accordion组件知道该怎么关闭或打开.state方法: Accordion要么是”open”状态,要么是”close”状态. 这个信息我们作为一个标记(flag)存储在Accordion组件的父组件state上(不在Accordion上存储).以名为isOpen的prop形式传递state信息,Accordion依据prop来进行渲染. 当isOpen是true时,渲染为打开,反之就关闭. 123&lt;Accordion isOpen=&#123;true&#125;/&gt;// or&lt;Accordion isOpen=&#123;false&#125;/&gt; 这个实例相对简单.希望不要有什么认知负担. 最大的挑战是以声明式的React方法处理,打开/关闭的state是存储在Accordion组件之外,并以prop的形式传递的. 打开,关闭一个Dialog‌旧有办法: 点击按钮打开modal,点击按钮关闭.state方法: Modal是开还是闭是一个状态,”open”,”state”两者居其一.所以state是”open”,我们就渲染组件.如果是”close”,就不做渲染.此外,可以给Modal传递onClose回调函数-通过这种方法,Modal组件的父组件决定了用户点击按钮时应该干什么 1&#123;this.state.isModalOpen &amp;&amp; &lt;Modal onClose=&#123;this.handleClose&#125;/&gt;&#125; 详细内容请看Modal Dialogs in React 提醒组件‌旧有办法: 当一个事件发生时(例如一个错误),调用提示库的组件来显示popup,例如toast.error(&quot;Oh,no!&quot;) state方法: 把提示作为一个state.有0个或者1个,或多个提示,保存在消息数组中. 在根组件处安置提醒组件. 传递state用于显示.你可以用不同的方式来管理消息数组: 如果使用Redux,保存在store中,Dispatch actions来添加消息 如果不使用Redux,可以保存在根组件的state中,或者是一个单例对象(整个应用中只实例化一次的对象)中.然后就可以传递向组件传递addNotificationprop,或者导入可以添加到全局单例对象的函数. 在应用中,你可以使用软件包来完成任务,例如react-redux-toastr.但是概念很简单,所以可以根据你的需求自己编写. 用动画显示改变假设你有一个有数字的badge用于显示登录的用户,组件从prop获取这个数字.但是如果你想在组件数字变化时有点动效,怎么处理? ‌老办法: 可以使用jQuery来toggle(切换)一个执行动画的类([^译注:CSS的类]),或者直接用jQuery操控要执行动画的元素.state方法: 你可以在props改变时通过componentWillReceiveProps声明周期函数比较新旧值来响应变化.如果改变了,可以把”animating” state设置为true.接着执行render,当”animating”为trur时,添加一个执行动画的CSS类.为false时,不添加类.这里是代码: 1234567891011121314151617181920 componentWillReceiveProps(nextProps) &#123; if(this.props.counter !== nextProps.counter) &#123; // Set animating to true right now. When that state change finishes, // set a timer to set animating false 200ms later. this.setState(&#123; animating: true &#125;, () =&gt; &#123; setTimeout(() =&gt; &#123; this.setState(&#123; animating: false &#125;); &#125;, 200); &#125;); &#125;&#125;render() &#123; const animatingClass = this.state.animating ? 'animating' : ''; return ( &lt;div className=&#123;`badge $&#123;animatingClass&#125;`&#125;&gt; &#123;this.props.counter&#125; &lt;/div&gt; );&#125; 完成","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"}]},{"title":"翻译|A Visual Guide to State in React","slug":"翻译|A Visual Guide to State in React","date":"2019-04-27T09:48:00.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2019/04/27/翻译|A Visual Guide to State in React/","link":"","permalink":"https://React-Apollo.github.io/2019/04/27/翻译|A Visual Guide to State in React/","excerpt":"","text":"原文在此:A Visual Guide to State in React React的”state”概念是比较难学的内容,不仅仅是因为React中放置了state,而是实际上,React是因此而生存. Redux也和React的state直接相关.我希望在本文中能把一些困惑的内容讲清楚 你一直在使用的这个词…实际上,这个词”state”有点模棱两可.某种意义上,”state”意思是当前屏幕上的数据表现. 它可以是”loading” 状态,或者是一个”error” 状态. 这里的解释和React里的state解释还不太一样. 从React的角度上,”state”是一个代表了应用中可以变化的部分.每个组件都在this.state中保存了自己的state 简而言之,如果需要应用可以做任何事-如果想添加交互,添加和删除内容,输入输出日志-都要包含在state中. React的state是什么样子假设你有这样一个应用,在特定的时间,如下图: 看这张图,挑出所有可以改变的部分(基本上包含了所有的东西) 现在我们可以给这些内容定义名字(时间,电池用量,室内温度,室外温度),用JavaScript对象描述如下: 12345678910111213141516171819&#123; currentTime: \"2016-10-12T22:25:42.564Z\", power: &#123; min: 0, current: 37, max: 100 &#125;, indoorTemperature: &#123; min: 0.0, current: 72.0, max: 100.0 &#125;, outdoorTemperature: &#123; min: -10.0, current: 84.0, max: 120.0 &#125;, tempUnits: \"F\"&#125; 这个对象描述了应用的整个state,也就是React state的用途. 注意一点,字段没有和UI完全契合. 没关系,日期很容易格式化,可以用最大值这最小值画出图形的尺度,等等. 这一点保持不变:改变了state对象就会改变app的表现. 读者 foobarwtf指出 min和max不会改变,因为他们从不改变,为什么还要在state中出现? 常见的做法是从服务器获取响应输入到state.如果你远程获取当前温度数据,数据就包含了min,max.最好和state中其他数据一起保存. 因为看起好像数据是固定不变的.但是如何服务器改变了标准怎么处理? 如果用户使用了一个200A的电力系统?等等问题. 所以:state通常保存这个可以变化的东西,也可以放一些从服务器获得的易改变的信息. 如何对State进行修改如果state中任何一项发生变化,例如温度飙升到75°,应用应该刷新反映出变化.这就是React根据state所做的工作:重新渲染整个app 这里是state可能发生变化的原因: 用户点击按钮 从服务器获得了数据-websocket的信息,或者是之前请求返回的响应数据 定时器终止-或许是每5秒更新屏幕上的当前时间 那么,React是如何知道state发生改变的? 持续轮训变化?像Angular一样观察事件?不是,一点也不神奇. React知晓State的变化是因为你在组件内部通过this.setState显式的告诉组件应该怎么更新.换句话说,没有什么魔法,React只是按照你设定的去做更新. 计数器中的State变换上面的家庭检测应用是一个state实战的绝好实例,但是我们会返回简单的”counter”应用,看看state是如何变化的. 这里是counter的工作方式: 数字显示从0开始 你点击按钮(会调用设定的handleClick函数) 计数器增加1(调用setState完成这个任务) React 根据state的变化重新渲染app 代码展示快速浏览: React以对象的形式保存state 你可以通过调用setState来改变对象 每次调用setState时,React会重新渲染这里有两个地方要注意: 不能直接用this.state,一定要用this.setState state的变化时异步的,所以如果你想从this.state中立即获取this.setState的变化,可能还没有反应出来. 用Debugger把代码可视化 细节,细节在本文中,我说过state是一个描述整个app的单一对象-但是在实际中,它需要分成更小的片段. 最好的方法是把它们保存在”container”组件中,和”presentational”组件隔离. 如果你正在使用Redux,你实际就有一个描述整个app的大 state对象. Redux的基本做法就是保持一个大的代表整个应用的state, 接着reducer和mapStateToProps把它切分成每个组件需要的块. 我希望本文能让你理解state的内容.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"}]},{"title":"翻译|How to Export a Connected Component","slug":"翻译|How to Export a Connected Component","date":"2019-04-27T09:13:00.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2019/04/27/翻译|How to Export a Connected Component/","link":"","permalink":"https://React-Apollo.github.io/2019/04/27/翻译|How to Export a Connected Component/","excerpt":"","text":"原文在这里:How to Export a Connected Component 根据你在export的不同,可以获得一个完美的函数式React-Redux connected组件,或者是一个完全忽略Redux的组件 换句话说这里两个完全不同的世界: 123class Thing extends Component &#123; ... &#125;export default connect(mapStateToProps)(Thing); 还有这个: 123export class Thing extends Component &#123; ... &#125;connect(mapStateToProps, mapDispatchToProps)(Thing); 如果设定为第二个实例,可以注意到所有的React有关的东西,但是Redux的函数,mapStateToProps和mapDispatchToProps没有返回 connect不会对组件作出改变在你用connect包装一个组件的时候, 例如connect(...)(Thing),重要的一点要理解,虽然返回的是一个connected的组件,但是它根本没有动过原始的Thing组件任何东西. 换句话说,运行connect(...)(Thing),没有”connect”到Thing组件,缺失没有. 所做的是翻译一个经过连接的新组件. 导出Connected组件所以,在导出组件的时候,一定要定义到底连接的是哪一个组件.确保export关键字出现在 connect调用的前面,像这样: 1export default connect(...)(Thing); 为什么不同时导出原始组件和经过连接的组件?同时导出连接组件和未连接组件非常有效.对于测试大有好处-例如想测试没有没有连接到模拟Redux store的组件. 下面是同时导出未连接组件和连接组件的代码: 12345678910export class Thing extends React.Component &#123; render() &#123; return \"whatever\"; &#125;&#125;const mapState = state =&gt; (&#123; someValue &#125;);const mapDispatch = &#123; action1, action2 &#125;;export default connect(mapState, mapDispatch)(Thing); 注意这里有两个导入,其中之一是名字,另一个是default,这里的定义很重要,因为会影响到后面的导入(import). Import 连接组件总的原则是,如果某个代码是用exprot default,在导入的时候不用{},;例如: 12345// Thing.jsexport default connect(...)(Thing);// UserOfThing.jsimport Thing from './Thing'; 如果导出的是名字,需要使用{}: 12345// Thing.jsexport function Thing() &#123; ... &#125;// UserOfThing.jsimport &#123; Thing &#125; from './Thing';","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"}]},{"title":"翻译|Redux-Starter-Kit 使用指南","slug":"翻译|Redux-Starter-Kit 使用指南","date":"2019-04-25T14:55:00.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2019/04/25/翻译|Redux-Starter-Kit 使用指南/","link":"","permalink":"https://React-Apollo.github.io/2019/04/25/翻译|Redux-Starter-Kit 使用指南/","excerpt":"","text":"‌原文在这里,这是Redux官方的充电包工具集,可以使Redux的用法简单一点. 本文是文档中的用户指南的翻译版本[^译注:这里的包装只是简化了操作,概念性问题的难度并没有降低,因此在没有理解Redux核心概念之前,Redux的文档任然是学习的敲门砖] 前言Redux核心库刻意安排为没有任何偏向性.因此可以让使用者自己来处理每个问题,例如包含了state的State的配置,以及怎么构建reducers.在某些使用案例中,是很好的,因为这么样做给了你很大的灵活性,但是用户并不总是需要灵活性.有时候,我们需要的只是尽肯能简单的开始工作,只需要有开箱即用的默认配置就可以.又或者是,你正在编写一个大型的应用,发现自己写了太多类似的代码,你非常希望能山减掉大量的手写代码. 正如在快速入门中讲到的一样,Redux Starter Kit的目标是协助简化Redux的常见使用用例.它并没有像你想象的那样成为一个完整的解决方案,而是使得一些Redux相关代码的编写变简单(或者在某些情况下,彻彻底底的减少手写代码的量). Redux Starter Kit 导出了几个可供使用的独立函数,在其他的包中添加依赖就可以和Redux一起工作.这可以让你决定,到底是在全新的项目还是已经进行的项目中使用Kit. 接下来看看一些Redux Starter Kit的用法,这些用法可以让你的Redux代码更漂亮. Store的配置每个Redux App需要配置并创建一个Store,通常情况下包含以下几个步骤: 导入或者创建顶层reducer函数(root reducer function) 配置中间件(middleware),例如包含至少一个有关异步操作逻辑的中间件 配置Redux DevTools 扩展 尽你所能的配置一些专门用于开发环境或者产品环境的切换逻辑 Store的手工配置下面的代码是 Redux文档 ‌配置Store中的典型代码 1234567891011121314151617181920212223 import &#123; applyMiddleware, compose, createStore &#125; from 'redux'import &#123; composeWithDevTools &#125; from 'redux-devtools-extension'import thunkMiddleware from 'redux-thunk'import monitorReducersEnhancer from './enhancers/monitorReducers'import loggerMiddleware from './middleware/logger'import rootReducer from './reducers'export default function configureStore(preloadedState) &#123; const middlewares = [loggerMiddleware, thunkMiddleware] const middlewareEnhancer = applyMiddleware(...middlewares) const enhancers = [middlewareEnhancer, monitorReducersEnhancer] const composedEnhancers = composeWithDevTools(...enhancers) const store = createStore(rootReducer, preloadedState, composedEnhancers) if (process.env.NODE_ENV !== 'production' &amp;&amp; module.hot) &#123; module.hot.accept('./reducers', () =&gt; store.replaceReducer(rootReducer)) &#125; return store&#125; 实例代码的可读性还可以,但是流程不太直接明了: 基础的Redux createStore函数接收几个固定位置的参数:(rootReducer,preloadedState,enhancer).有时候很容易忘记其中的参数. 中间件(middleware)和增强件(enhancer)的设定过程令人感到困惑,尤其是你准备添加多个配置的时候. Redux DevTools 扩展文旦初始建议你使用一些手写文档检查全局作用域中可用的扩展.很多用户只是简单的拷贝粘贴这些代码块,这使得配置代码很难理解. 使用configureStore函数简化Store的配置 configureStore在一下几个方面对我们有帮助: 有一个”name”参数的可选对象,很容易读懂. 允许你提供中间件和增强件的数组,用于在store中添加这些组件,并自动调用applyMiddleware和compose函数. 自动开启Redux DevTools扩展 此外,confitureStore默认添加了一些有特定用途的中间件: redux-thunk 是在组件外执行同步和异步逻辑的常用中间件 在开发环境,用于检查常见state mutate操作或者使用非序列化错误的中间件. 这么做意味着,store的配置代码本身更短,更容易阅读. 最简答的用法是只要把顶层reducer函数作为reducer 形参传递就可以了. 12345678import &#123; configureStore &#125; from 'redux-starter-kit'import rootReducer from './reducers'const store = configureStore(&#123; reducer: rootReducer&#125;)export default store 也可以传递分片(slice)的reducer,configureStore会自动调用combineReducers: 123456789import usersReducer from './usersReducer'import postsReducer from './postsReducer'const store = configureStore(&#123; reducer: &#123; users: usersReducer, posts: postsReducer &#125;&#125;) 注意,这个用法只对第一级的reducer有用.如果你想嵌套reducer,需要自己调用combineReducers来完成更低一级的嵌套. 如果你想定制store的配置,可以传递额外的选项.这里是热加载的实例: 1234567891011121314151617181920import &#123; configureStore, getDefaultMiddleware &#125; from 'redux-starter-kit'import monitorReducersEnhancer from './enhancers/monitorReducers'import loggerMiddleware from './middleware/logger'import rootReducer from './reducers'export default function configureAppStore(preloadedState) &#123; const store = configureStore(&#123; reducer: rootReducer, middleware: [loggerMiddleware, ...getDefaultMiddleware()], preloadedState, enhancers: [monitorReducersEnhancer] &#125;) if (process.env.NODE_ENV !== 'production' &amp;&amp; module.hot) &#123; module.hot.accept('./reducers', () =&gt; store.replaceReducer(rootReducer)) &#125; return store&#125; 如果你提供了middleware参数, confitureStore就只使用你提供的中间件. 如果你想在默认中间件基础上添加定制的中间件,可以调用getDefaultMiddleware,把你自己的中间件数组包含进去. 编写ReducersReducers是Redux中最重要的概念,一个典型的reducer函数需要具备的功能是: 查找action对象的type 字段,来决定如何响应action 通过拷贝state中需要修改的部分,只修改这些部分,从而不可突变的更新Redux的state. 当你在reducer中使用需要的条件逻辑是,最常见的方法是switch声明,因为针对单个字段执行最直接的操作.然而很多人不喜欢switch声明.Redux文档展示了基于action type类型的映射的用法,但是需要你自己配置. 另一个常见的痛点是编写reducers时,不要有不可突变的更新state.Javascript是可突变的语言.手动更新嵌套的数据非常棘手,很容易出错. 使用createReducer函数简化Reducer的操作因为”查表”(映射)方法很流行,Redux Starter Kit 包含了一个类似Redux 文档中createReducer的函数.然而我们的createReducer工具有一些魔法,是的Reducer的操作更好,在内部它使用‘Immer’库,Immer库可以让你编写假的”突变”代码,实际上进行了不可突变更新.这么做有效的避免了偶然的突变操作. 总体上,任何使用switch声明的Reducx Reducer都可以直接转化使用createReducer. switch中每个case都变成传递给createReducer对象的一个键. 不可突变更新逻辑,例如对象展开操作,拷贝数组都可以直接转换为”可突变”操作 . 保持原来的不可突变操作也可以, 只需返回更新的拷贝就行. 这里有一些可以使用createReducer的实例. 我们从经典的”todo list” reducer开始,使用的是switch声明和不可突变更新 12345678910111213141516171819202122function todosReducer(state = [], action) &#123; switch(action.type) &#123; case \"ADD_TODO\": &#123; return state.concat(action.payload); &#125; case \"TOGGLE_TODO\": &#123; const &#123;index&#125; = action.payload; return state.map( (todo, i) =&gt; &#123; if(i !== index) return todo; return &#123; ...todo, completed : !todo.completed &#125;; &#125;); &#125; , \"REMOVE_TODO\" : (state, action) =&gt; &#123; return state.filter( (todo, i) =&gt; i !== action.payload.index) &#125; default : return state; &#125;&#125; 注意:我们声明调用了state.concat(),返回包含todo新条目的经过拷贝的数组,state.map() 返回toggle分支的拷贝数组,这里使用对象展开操作符对要更新的todo项进行了复制. 通过使用createReducer,我们可以考虑简化实例: 123456789101112131415const todosReducer = createReducer([], &#123; \"ADD_TODO\" : (state, action) =&gt; &#123; // \"mutate\" the array by calling push() state.push(action.payload); &#125;, \"TOGGLE_TODO\" : (state, action) =&gt; &#123; const todo = state[action.payload.index]; // \"mutate\" the object by overwriting a field todo.completed = !todo.completed; &#125;, \"REMOVE_TODO\" : (state, action) =&gt; &#123; // Can still return an immutably-updated value if we want to return state.filter( (todo, i) =&gt; i !== action.payload.index) &#125;&#125;) “突变”state的能力在试图更新深度嵌套的state时特别有用.复杂而令人痛苦的代码如下: 1234567891011121314case \"UPDATE_VALUE\": return &#123; ...state, first: &#123; ...state.first, second: &#123; ...state.first.second, [action.someId]: &#123; ...state.first.second[action.someId], fourth: action.someValue &#125; &#125; &#125; &#125; 可以简化为下面的代码: 1234updateValue(state, action) &#123; const &#123;someId, someValue&#125; = action.payload; state.first.second[someId] = someValue;&#125; 看上去好多了[^译注:这里看上去是可突变操作,实际底层使用的Immer在操作之前已经进行了拷贝操作,不会在原始内存地址做修改]. 以对象的形式定义函数在现代Javascript中,有几个固定好的方法可以在对象中定义键和函数(并不是特定针对Redux),所以你可以混合匹配不同的键定义和函数定义. 例如下面对象中所有的函数定义方法都是合规的. 12345678910111213141516const keyName = \"ADD_TODO4\";const reducerObject = &#123; // Explicit quotes for the key name, arrow function for the reducer \"ADD_TODO1\" : (state, action) =&gt; &#123; &#125; // Bare key with no quotes, function keyword ADD_TODO2 : function(state, action)&#123; &#125; // Object literal function shorthand //对象字面量函数简写方式 ADD_TODO3(state, action) &#123; &#125; // Computed property [keyName] : (state, action) =&gt; &#123; &#125;&#125; 使用对象字面量函数简写方式 可能是最简短的代码,但是你可以使用以上任何一种方式. 使用createReducer要考虑的因素 Redux Starter Kit的createReducer函数可以发挥很大的作用,但是也要留心: “突变”的代码只能在createReducer函数内使用 Immer不允许混合突变(译注:这里指的是真正的JS突变操作)操作,又返回新的state. 查看createReducer API 参考 ,了解具体的详情. 编写 Action CreatorsRedux鼓励使用者编写action creator 函数,action creator函数封装了创建Action 对象的流程. 但是标准的Redux用法中不是必须的. 绝大多数的action creator都非常简单.它们接受一些参数,返回一个拥有特定type字段和传入参数的 action对象.这些参数通常放在payload字段下, action队形是‌Flux标准action的传统定义,目的是组织action对象的内容. 一个典型action creator的结构如下: 123456 function addTodo(text) &#123; return &#123; type: 'ADD_TODO', payload: &#123; text &#125; &#125;&#125; 使用createAction函数定义Action Creators 手动编写action creators很乏味.Redux Starter Kit提供了一个函数 createAction,用于简化给定了action type的action对象的创建过程,传入的参数安置在payload字段中: 123 const addTodo = createAction('ADD_TODO')addTodo(&#123; text: 'Buy milk' &#125;)// &#123;type : \"ADD_TODO\", payload : &#123;text : \"Buy milk\"&#125;&#125;) 目前,creatAction不允许你定制payload字段. 必须要把payload作为整个参数来传递.payload 可以是单个的值,或者一个有大量数据的对象(我们最终会为‌createAction添加一个用于定制payload的回调函数,或者是可以添加其他类似meta一样的字段). 把Action Creatros 作为Action TypeRedux的reducers函数需要查找特定的action types来决定该如何更新state.通常情况下, 定义action type 字符串和定义action creator函数式分开的. Redux Starter Kit的createAction函数使用了一套技巧让两个定义更容易了. 首先,createAction 在它生成的action creators上 重写了toString()方法. 意思是,action creators自身也可以作为”action type”来引用,例如可以作为creareReducer的键. 第二点,action type也可以定义为action creator的一个type 字段. 123456789101112131415const actionCreator = createAction(\"SOME_ACTION_TYPE\");console.log(actionCreator.toString())// \"SOME_ACTION_TYPE\"console.log(actionCreator.type);// \"SOME_ACTION_TYPE\"const reducer = createReducer(&#123;&#125;, &#123; // actionCreator.toString() will automatically be called here [actionCreator] : (state, action) =&gt; &#123;&#125; // Or, you can reference the .type field: [actionCreator.type] : (state, action) =&gt; &#123; &#125;&#125;); 这意味着,你不需要编写或使用独立的action type变量,或或者重复action type的名字和值,例如const SOME_ACTION_TYPE = &quot;SOME_ACTION_TYPE&quot; 就不需要了. 不幸的是,隐式转换为字符串对于switch声明不起作用.如果你在一个switch 声明中使用了这些action creator,需要你自己调用actionCreator.toString() 123456789101112131415161718const actionCreator = createAction('SOME_ACTION_TYPE')const reducer = (state = &#123;&#125;, action) =&gt; &#123; switch (action.type) &#123; // ERROR: 这里会出错, 在switch中,actionCreator不会自动获取字符串 case actionCreator: &#123; break &#125; // CORRECT: this will work as expected case actionCreator.toString(): &#123; break &#125; // CORRECT: this will also work right case actionCreator.type: &#123; break &#125; &#125;&#125; 如果你同时使用了Redux Starter Kit和TypeScript,要留心, 在action creator 用于对象的键时,TypeScript编译器不会接受 toString()的隐式转换.这种情况下,你需要手动转换(actionCreator as string),或者使用.type字段作为键. 创建 分片的State,Redux 的state通常都以”切片”的形式组织,由reducers定义的切片 state传递给combineReducers. 12345678import &#123; combineReducers &#125; from 'redux'import usersReducer from './usersReducer'import postsReducer from './postsReducer'const rootReducer = combineReducers(&#123; users: usersReducer, posts: postsReducer&#125;) 在这个例子中,users和posts都被认为是”切片(slices)”.也都是reducers: “拥有”state中的一块, 包括初始值 定义了state更新的方法 定义了会引起state更新的特定Action 常规的方法是在自己独立的文件中定义切片reducer函数,action creators在第二个文件中.因为两个文件都需要引用同样的action types, 又会在第三个文件中定义,并在前两个文件中导入: 1234567891011121314151617181920212223242526272829 // postsConstants.jsconst CREATE_POST = 'CREATE_POST'const UPDATE_POST = 'UPDATE_POST'const DELETE_POST = 'DELETE_POST'// postsActions.jsimport &#123; CREATE_POST, UPDATE_POST, DELETE_POST &#125; from './postConstants'export function addPost(id, title) &#123; return &#123; type: CREATE_POST, payload: &#123; id, title &#125; &#125;&#125;// postsReducer.jsimport &#123; CREATE_POST, UPDATE_POST, DELETE_POST &#125; from './postConstants'const initialState = []export default function postsReducer(state = initialState, action) &#123; switch (action.type) &#123; case CREATE_POST: &#123; // omit implementation &#125; default: return state &#125;&#125; 这唯一必不可少的部分只有reducer自己,想想其他部分: 我们可以在两个地方编写action type 作为行内字符串. action creators很好,但是对于使用Redux不是必须的,一个组件可以直接跳过由connect提供的mapDispatch参数,转而直接使用this.porps.dispatch({type:&#39;CREATE_POST&#39;,payload:{id:123,title:&quot;Hello World&quot;}}) 唯一要这么写的原因是因为这是常规的做法. &quot;‌鸭式&quot;文件结构 建议把所有的Redux相关逻辑放到一个单一文件中,像这样: 123456789101112131415161718192021222324 // postsDuck.jsconst CREATE_POST = 'CREATE_POST'const UPDATE_POST = 'UPDATE_POST'const DELETE_POST = 'DELETE_POST'export function addPost(id, title) &#123; return &#123; type: CREATE_POST, payload: &#123; id, title &#125; &#125;&#125;const initialState = []export default function postsReducer(state = initialState, action) &#123; switch (action.type) &#123; case CREATE_POST: &#123; // Omit actual code break &#125; default: return state &#125;&#125; 这样做简化了很多事,因为我们不需要多个文件,所以可以移除掉冗余的action type 常量的导入.但是,我们仍然要手动编写action types和action creators. 使用createSlice简化Slices(切片)的创建为了简化这个过程,Redux Starter Kit 包含了一个createSlice函数, 可以根据你提供的reducer函数的名字自动生成action type和action creators. 这里是pops的实例代码: 12345678910111213141516171819202122232425const postsSlice = createSlice(&#123; initialState: [], reducers: &#123; createPost(state, action) &#123;&#125;, updatePost(state, action) &#123;&#125;, deletePost(state, action) &#123;&#125; &#125;&#125;)console.log(postsSlice)/*&#123; actions : &#123; createPost, updatePost, deletePost, &#125;, reducer&#125;*/const &#123; createPost &#125; = postsSlice.actionsconsole.log(createPost(&#123; id: 123, title: 'Hello World' &#125;))// &#123;type : \"createPost\", payload : &#123;id : 123, title : \"Hello World\"&#125;&#125; createSlice查找所有在reducers字段中定义的函数,以及每一个”case reducer”函数,用reducer的名字生成同名的action creator和action type.所以, createPost reducer 将会返回 一个createPost类型,和createPost() action creator. 也可以选择性定义一个slice参数用于action type的前缀: 1234567891011121314const postsSlice = createSlice(&#123; slice: 'posts', initialState: [], reducers: &#123; createPost(state, action) &#123;&#125;, updatePost(state, action) &#123;&#125;, deletePost(state, action) &#123;&#125; &#125;&#125;)const &#123; createPost &#125; = postsSlice.actionsconsole.log(createPost(&#123; id: 123, title: 'Hello World' &#125;))// &#123;type : \"posts/createPost\", payload : &#123;id : 123, title : \"Hello World\"&#125;&#125; 导出并使用Slices大多数情况下,需要定义一个slice,导出action creators和reducer. 推荐的方法是使用ES6的解构和导出方法: 12345678910111213141516const postsSlice = createSlice(&#123; slice: 'posts', initialState: [], reducers: &#123; createPost(state, action) &#123;&#125;, updatePost(state, action) &#123;&#125;, deletePost(state, action) &#123;&#125; &#125;&#125;)// Extract the action creators object and the reducerconst &#123; actions, reducer &#125; = postsSlice// Extract and export each action creator by nameexport const &#123; createPost, updatePost, deletePost &#125; = actions// Export the reducer, either as a default or named exportexport default reducer 也可以导出需要的slice部分. 通过这种方式定义的Slice和 &quot;Redux Ducks pattern&quot;的概念非常类似. 然而,他们也要一些潜在的问题,在导入和导出slices时需要注意. 首先,Redux action types并不是说专门只对应一个slice.从概念上说,每个slice reducer “拥有”他们自己的一块state,例如,但是reducer应该能鉴监听任何action type并更新对应的state.例如, 很多不同的slice可能都会响应”user logger out” action, 包括清除数据,重置state为初始值等等.在设计state和创建slices是要特别当心. 第二点,JS模块在两个模块互相引用是会有”循环引用”问题. 这会导致导入变为未定义, 由此可能会中断需要导入的代码, 特别是在”ducks”或者”slices”中,如果连个slice定义在不同的问题件中,要响应定义在另一个文件中断额action是可能会出问题. 如果你碰到这个问题, 可以需要重构代码避免循环引用. 完","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"}]},{"title":"翻译|Immutability in React and Redux/ The Complete Guide News Clone","slug":"翻译|Immutability in React and Redux: The Complete Guide","date":"2019-04-23T11:50:00.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2019/04/23/翻译|Immutability in React and Redux: The Complete Guide/","link":"","permalink":"https://React-Apollo.github.io/2019/04/23/翻译|Immutability in React and Redux: The Complete Guide/","excerpt":"","text":"原文在这里:Immutability in React and Redux: The Complete Guide Immutability(不可突变性,一下直接使用英文)是一个令人困惑的话题,总体上在React,Redux和Javascript出现的地方都会有他的身影浮现. 在React组件没有自动渲染的时候,你可能碰到了一个bug,即使是你知道已经修改了props,并且有人会提醒你,应该要做immutable state更新.或许你或者同事之一经常写出mutate(与immutable对应,为可突变,一下沿用英文单词)state的 Redux Reducer.你不得不经常纠正他们(reducers,或者同事). 这一点有点诡异,也十分的微妙,尤其是你不确定要到底要注意什么.坦率讲,如果你没有认识到Immutable的重要性,就很难关注它. 这个教程会解释什么是immutability以及如何在应用中编写immutable代码.一下是涵盖的内容: 什么是Immtablity?首先 immutable是mutable的反义词-mutable的意思是:变化,修改,能被搞得一团糟. 所以如果某个东西是immutable,那么他就是不能有变化的. 极端的例子是,不能使用传统意义的变量, 你要不断的创建新值来代替旧的值. JavaScript没有这么极端, 但是有些语言根本不允许mutate任何东西(Elixir, Erlang还有ML). Javas不是纯粹的函数式语言,它可以在某种程度上伪装成函数式语言.JS中有些数组操作时immutable(意思是:不修改原始值,而是返回一个新的数组).字符串操作总是immutable的(JS使用改变的字符串创建新的字符串). 同时,你也可以编写自己的immutable函数.需要注意的是要遵守一些规则. 用于Mutation的实例代码现在来看看mutality是如何工作的. 从整个person对象开始: 123456789let person = &#123; firstName: \"Bob\", lastName: \"Loblaw\", address: &#123; street: \"123 Fake St\", city: \"Emberton\", state: \"NJ\" &#125;&#125; 接着假设写一个函数赋予person超凡的力量: 1234function giveAwesomePowers(person) &#123; person.specialPower = \"invisibility\"; return person;&#125; 好了,每个人都获得了超集能力. 隐身(invisibility)是很腻害的技术 现在让我们给Mr.Loblaw其他一些特别的能力 123456789101112// Initially, Bob has no powers :(console.log(person);// Then we call our function...let samePerson = giveAwesomePowers(person);// Now Bob has powers!console.log(person);console.log(samePerson);// He's the same person in every other respect, though.console.log('Are they the same?', person === samePerson); // true 这个函数giveAwesomePowers mutate 了传递进入的person对象. 运行这个代码,你会看到第一次打印出的person,Bob没有specialPower属性.但是接下来,第二次,他突然就有了specialPower能力. 问题在于,因为这个函数修改了传递进入的person,我们再也不知道之前的对象是什么样子.这个对象永远被改变了. 从giveAwesomePowers函数返回的对象和我们传递进的对象是同一个对象,但是在对象的内部已经乱套了.属性已经发生改变. 因此对象被mutate了(突变了). 我想要再次重申一下,因为这一点很重要:对象的内在 已经发生改变,但是对象的引用没有变[^译注:在内存中的地址空间没变].从对象外部看是同一个对象(全等于检查例如person===samePerson为true,就是这个原因.) 如果我们想让giveAesomePowers函数不对person对象作出修改,必须要作出一些改变.首先要让函数变 pure(变纯),因为纯函数和immutability紧密相关. Immutability的原则为了让函数变纯,必须要遵守以下规则: 相同的输入总是有相同的返回值. 纯函数不能有副作用(side effect) [^译注:总是觉得这个副作用不太明了,用附带作用是不是更好理解一点?] 那么什么是”Side Effect(副作用)”?“Side effects”是一个宽泛的术语,但是本质上,意味着此刻调用的函数还修改了作用域之外的内容.看看一些side effect的例子… 突变/修饰了输入的参数,像giveAwesomePowers函数所做的 修改任何函数以外的其他state,例如修改了全局变量,或者document.(anything)或者window.(anything) 执行API调用 console.log() Math.random() API调用可能让你觉得很迷糊.毕竟调用API,例如fetch(&#39;/users&#39;) 好像完全没有改变UI中的任何东西. 但是在深究一下:如果你调用fetch(&#39;/users&#39;),能改变其他的东西吗?甚至是在UI之外? 非常明确.API调用会产生一条浏览器的网络日志.也会创建(有可能最终会关闭)一个指向服务器的网络连接. 一旦调用命中服务器,一切都有可能发生. 服务器可以做任何想做的事,包括继续调用其他的服务,作出更多的mutation操作. 最终,API调用会在某个地方生成一个日志文件(生成日志文件是正正整整的mutation操作). 所以想我说的一样,”side effect”的确是涵盖宽泛的术语. 下面是一个没有side effect的函数: 123function add(a, b) &#123; return a + b;&#125; 你调用一次和调用一百万次一个样, 世界上其他地方的东西不会发生任何改变. 我意思是,从技术角度,严谨一点,在你调用这个函数时,世界上其他的东西会改变的. 时间会流逝…强大帝国会衰落…但是调用这个函数不会直接的导致外接其他事物发生变化.这一点满足规则2-没有side effect 再者, 没有调用这个函数,例如 add(1,2),你总是会得到相同的返回结果.不管你调用多少次. 这一点满足规则1-同一输入==同一响应 JS 数组方法会导致Mutate几个特定的方法会在使用的时候导致数组发生mutate, push(在一个数组末尾添加一个元素) pop(从数组的末尾移除一个元素) shift(从数组的开始处移除一个元素) unshift(在数组的开始处添加一个元素) sort reverse splice 注意,JS 数组的sort操作是mutable的,它会在原内存地址空间上进行排序操作(in place,或者叫原位操作).要改为immutable操作([^译注:这一点,似乎原作者没有明确表达?]).可以拷贝一份,然后针对拷贝进行操作.可以使用一下的几个方法进行操作: 1234 let a = [1, 2, 3];let copy1 = [...a];let copy2 = a.slice();let copy3 = a.concat(); 所以,如果你想对一个数组进行immutable的排序操作, 可以这么操作 123456789101112131415161718192021222324let sortedArray = [...originalArray].sort(compareFunction);``` 关于`sort`方法有个小知识点(过去困扰过我), 传递给`sort`的`compareFunction`需要返回0,1或者-1.不能是布尔值.下次编写比较函数时要留意这一点.## 纯函数只能调用其他的纯函数一个可能出问题的地方就是在纯函数中调用了不纯的函数.纯度是可以变化的.要么有要么就没了.你可以写一个完美的纯函数,但是如果你最后点用了一个其他的函数,这些函数又调用了`setState`,`dispatch`,亦或者其他的side effect操作, 纯函数就不存在了.现在有一些几个特例的side effect是可以\"接受的\".使用`console.log`输出日志是可以接受的. 是的,从技术角度上讲, 这是一个side effect,但是它不会影响任何其他内容.## 纯函数版的 `giveAwesomePowers`现在谨记纯函数的原则,重写这个函数```javascriptfunction giveAwesomePowers(person) &#123; let newPerson = Object.assign(&#123;&#125;, person, &#123; specialPower: 'invisibility' &#125;) return newPerson;&#125; 现在稍微有点不同,并没有修改person对象,我们创建了一个 new person对象. 如果之前你没见过Object.assign,它的用法是把一个对象的属性复制到另一个对象中. 你可以传递多个对象,Ojecct.assign会把多个对象按照从左到右的方向合并成一个单一对象,因此会覆盖重复的属性.(说到从左至右,我意思是执行Object.assign(result,a,b,c),)会把a拷贝进result,接着是b,接着是c) 但是Object.assign()不会执行深度融合操作-只有每个参数对象的的直接子代属性才能够被移动.也就是时候, 非常重要的一点,这个操作不会拷贝或者克隆参数对象的属性. 它会按照原来的样子分配, 引用不会动. 所用上面的代码所做的是创建了一个空对象,接着把所有的person的属性复制到空对象,接着把specialPower属性也复制的空对象中.另一种可以执行相同操作的方法是对象在展开操作(spread operator): 12345678function giveAwesomePowers(person) &#123; let newPerson = &#123; ...person, specialPower: 'invisibility' &#125; return newPerson;&#125; 对象展开操作可以这么理解:”创建一个新对象,之后从person插入属性person,接着插入另一个属性specialPower“.上面的写法里的对象展开语法是JavaScript规范ES2018的正式组成部分. 返回全新对象的纯函数现在我们可以使用新的纯函数版的giveAwesomePowers来重新运行之前的实例代码. 12345678910111213// Initially, Bob has no powers :(//打印原始对象console.log(person);// 执行纯函数版的对象修改操作var newPerson = giveAwesomePowers(person);// Now Bob&apos;s clone has powers!console.log(person);console.log(newPerson);// newPerson 是一个全新的对象了console.log(&apos;Are they the same?&apos;, person === newPerson); // false 最大的不同点是,person对象没有被修改. Bob没有改变. 函数用同样的属性创建一个Bob的克隆版本,此外还具有了隐身的属性. 这就是函数式编程很另类的地方. 对象不断的被创建和销毁. 我们不能修改Bob;只能创建克隆,修改克隆,然后用克隆版本替代Bob.真的有点残酷.如果你看过电影 致命魔术(The Prestige),有点类似(如果没看多,就当我没说). React优先考虑Immutability在React的用例中, 绝对不要mutate state或者props是很重要的.不管是函数式组件或者类组件都要遵循这一原则. 如果你准编写类似这样的代码this.state.something=...或者this.props.something=...,不要这么做了吧, 试试看更好的方法. 要修改state,唯一的方法就是使用this.setState.如果你很好奇为什么要这么做,可以看看这篇文章why not to modify state directly. 至于props,是单向流动的.Props输入进组件.Props不是双向通道,至少不能通过mutate操作把props设定为新的值. 如果你必须要发送一些值返回到父组件中,或者要触发父组件中的某些操作, 可以以props的形式传递函数来实现,之后在需要的时候通过在子组件内调用函数来和父组件通讯. 下面是就是回调prop的实例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//子组件function Child(props) &#123; // 如果,点击按钮 // 会调用从父组件通过props传递的函数. return ( &lt;button onClick=&#123;props.printMessage&#125;&gt; Click Me &lt;/button&gt; );&#125;//父组件function Parent() &#123; //①父组件中定义一个函数 function printMessage() &#123; console.log('you clicked the button'); &#125; // ②父组件通过props向子组件传递一个函数 // 注意!!!: 传递的是函数名,不是调用结果 // 是printMessage, 不是 printMessage() return ( &lt;Child onClick=&#123;printMessage&#125; /&gt; );&#125;``` [^译注:这个示例代码如果不太明白,要反复的看,这是Redux最核心思想之一].## Immutability 对于PureComponents至关重要.默认情况下,React组件(函数式组件或者通过继承React.component的类组件)在他们的父组件重新渲染时也会重新渲染,或者在组件内部通过`setState`修改内部state时也会重新渲染.从性能角度考虑,优化React组件最简单的办法是声明一个类,继承`React.PureComponent`,不要继承`React.Component`.这样做,只有在组件的props或者state改变时才会重新渲染. 再也不会在父组件重新渲染时,没头没脑的跟着重新渲染了.只有在自己的props发生变化时才执行重渲染.这里是React依赖immutability的原因:如果你要向`PureComponent`传递props,必须要确保这些props是通过immutability的方式更新的.意思是说.如果props是对象或者数组,一定要用新的(修改过的)对象或者数组来替换整个props值.像之前对Bob做的一样-把他杀掉,然后用克隆顶替.如果你通过修改属性,或者添加新的项目来修改对象或者数组的内部元素,甚至是修改数组元素内部的结构- 修改之后的对象或者数组会引用全等于旧的自身,`PureComponent`就不会注意到props的变化,不会重新渲染. 怪异的渲染问题就会接踵而来.还记得第一个实例中的Bob和`giveAwesomePowers`函数吗? 还记得由函数返回的对象如何与`person`相同吗?用的是三个等号,`===`. 原因是两个对象的引用地址都指向同一个对象. 内部发生改变了,但是地址没有变.## JavaScript中引用全等于是如何工作的?什么是\"引用等于\"(referentially equal)?好吧,有点离题,但是理解这个概念非常重要.JavaScript的对象和数组都存储在内存中(现在,你应该立刻点头,否则就很难解释下去了).我们假设内存像一个盒子,变量名\"指向\"这个盒子, 盒子里放的是实际的值.![](https://ws3.sinaimg.cn/large/006tNc79gy1g2bjdjd7o2j310k0u0myy.jpg)在JavaScript中,这些盒子(实际就是内存地址)是没有名字,或者不为人所知的. 你不会知道一个变量指向的内存地址(在某些语言中,例如C语言,你可以实际查看一个变量的内存地址,看看他们的生存情况.)如果你声明一个变量,它会指向新的内存地址.![](https://ws1.sinaimg.cn/large/006tNc79gy1g2bjeri62jj30u012q42s.jpg)如果你mutate了变量的内部结构, 它仍然指向同一个地址.![](https://ws3.sinaimg.cn/large/006tNc79gy1g2bjh616p8j30uk0u0n0a.jpg)有点类似于扒掉了房子中的一切东西,重新修了墙,厨房,起居室,游泳池等等--- 房子的地址没有改变. **‌关键点:** 当我们用`===`比较两个对象或者数组时,JavaScript实际比较的是他们指向的内存地址-也就是引用(references).JS甚至根本都不看对象.它只比较引用. 这就是\"引用等于\"(referential equality)的意思.所以,如果你接收一个对象,修改它时,修改的是内容,但是不会改变它的引用.另一点是,在你把一个对象赋值给另一个对象(或者作为函数参数传递,这么做更高效),其他的对象仅仅是指向第一个对象的地址.有点想巫毒娃娃.你在第二个对象上做的事会直接影响到第一个对象.下面的代码让你更清楚的认识到这个问题.```javascript// 创建变量 `crayon`,指向一个盒子 (无名),// 盒子承载了对象 `&#123; color: 'red' &#125;`let crayon = &#123; color: 'red' &#125;;// 改变 `crayon` 的属性 不会改变他的指向 crayon.color = 'blue';// 把对象或数组赋值给一个新的变量// 新变量不会改变旧变量指向的盒子let crayon2 = crayon;console.log(crayon2 === crayon); // true.两者指向同一个盒子// 任何针对 `crayon2`变量的修改 也会影响到变量 `crayon1`crayon2.color = 'green';console.log(crayon.color); //变为绿色!console.log(crayon2.color); //也是绿色了!// 因为这两个变量指向同一个内存地址console.log(crayon2 === crayon); 为什么不做深等于检查?在声明两个对象之前检查两个对象的内部,看起来更合乎情理.这是事实,但是这样做速度很慢. 到底有多慢? 这要看你需要比较的对象.比较有10,000个子属性和孙子属性的对象肯定比2个属性的对象慢.时间无法预测. 引用等于的的时间,计算机科学家成为”时间常数”(constant time).时间常数也成为 O(1),意思是操作的花费时间总是相同,不用考虑输入值有多大. 深度等检查,成为线性时间(linear time), O(n).意思是花费的时间和对象中的键成比例. 通常来说, 线性时间总是比时间常数慢. 这样来思考:假设JS每次比较两个值例如a===b要花费0.5秒时间.现在你是愿意进行引用检查还是深入两个对象比较每对属性?听起来几很慢. 在实际计算中,等检查比时间要远远低于1秒,但是尽肯能的少做工作在这里也是适用的.其他条件相同,有限考虑性能. 在试图找到应用的瓶颈时,这会节省大量时间.如果你留心一一点,刚开始就不会慢. const会阻止改变吗? 简短的回答是:不能阻止. let,const,var都不会阻止你改变对象的内部结构.所有这三种声明方式都允许你mutate对象或数组的内部结构. “但是它不是叫做const吗”? 难道意思不是 constant(恒定)? 好吧! const 只会阻止你重新赋值引用,但是不会阻止你改变对象内部结构. 实例如下: 1234567const order = &#123; type: \"coffee\" &#125;// const will allow changing the order type...order.type = \"tea\"; // this is fine// const will prevent reassigning `order`order = &#123; type: \"tea\" &#125; // this is an Error 下次遇到const要留点心. 我喜欢使用const提醒我自己一个对象或者数组不应该被mutate(大多数情况下),如果我在编写代码时,我确定要修改某个对象或者数组,我会用let声明. 这像是一个传统(像其他传统一样,如果你时不时的打破约定,就不太好了). 怎么更新 Redux的StateRedux需要保证它的reducer是纯函数. 意味着你不能直接修改state-必须基于旧的对象创建一个新的state,正如我们上面对Bob做的那样(如果你不太确定,可以看看这篇文章 what a reducer is,介绍了reducer名字的来历) 编写代码对state作出immutable更新有点棘手. 下面你会看大一下常见的模式 不管是在浏览器终端,还是实际的应用中亲自尝试一下. 尤其要注意嵌套对象的更新,实践中也是如此. 我发现嵌套对象是最麻烦的. 所有这些模式对于React state同样也是适用的.所以在这个教程中学到的东西可以用于Redux,没有Redux的应用也可以用. 在最后部分,会看到使用Immer库让操作更简单. 但是不要直接跳到最后一部分.理解普通的编写方式对于明白具体的工作原理大有好处. ... 展开操作符这些事例大量使用了展开操作符针对数字和对象进行操作. 下面是具体的工作方式 ...放在对象或者数组之前,它解开内部的子元素,插入到右边的变量中 12345678910111213141516171819202122232425// For arrays:let nums = [1, 2, 3];let newNums = [...nums]; // =&gt; [1, 2, 3]nums === newNums // =&gt; false! 新的数组对象// For objects:let person = &#123; name: \"Liz\", age: 32&#125;let newPerson = &#123;...person&#125;;person === newPerson // =&gt; false! 新的对象// 内部属性不动 :let company = &#123; name: \"Foo Corp\", people: [ &#123;name: \"Joe\"&#125;, &#123;name: \"Alice\"&#125; ]&#125;let newCompany = &#123;...company&#125;;newCompany === company // =&gt; false! 不是同一个对象 objectnewCompany.people === company.people // =&gt; true! 内部属性相同 像上面一样使用, 展开操作符使得创建包含相同内容的数组和对象变得更容易.在创建一个对象/数组的拷贝是非常有用,接着我们可以重写需要改变的部分: 1234567891011121314151617let liz = &#123; name: \"Liz\", age: 32, location: &#123; city: \"Portland\", state: \"Oregon\" &#125;, pets: [ &#123;type: \"cat\", name: \"Redux\"&#125; ]&#125;//使Liz年龄增加一岁,其他的都不动let olderLiz = &#123; ...liz, age: 33&#125; 展开操作符是ES2018标准的一部分. 更新State的方法这些例子的编写出发点是从Redux reducer中返回state. 我会展示输入的state是什么样子, 返回的Sate是什么样的. 为了保持实例代码简洁. 我会完全忽略”action”参数. 假定更新可以有任何action触发. 当然在你自己的reducer中, 你可能会私用switch和case来针对每个action执行操作,但是我认为这会增加本部分理解的噪音. 在React中更新State为了在简单的React State中使用这些事例, 需要稍作一些调整. 因为React会 浅融合传递进this.setState()的对象.不需要像Redux一样展开已有的state. 在Redux reducer中,要这么写: 1234return &#123; ...state, (updates here)&#125; 对于简单 React,可以这么写, 不需要展开操作符: 123456789101112131415161718192021222324252627this.setState(&#123; updates here&#125;)``` 要记住一点,尽管`setState`不会执行浅融合,在更新state内嵌套的属性时也必须要使用展开操作符(任何比第一层更深的部分).## Redux:更新一个对象当你想更新Redux state的顶层属性时,用`...state`拷贝存在的state,之后列出要更新的属性和对应的修改值```javascriptfunction reducer(state, action) &#123; /* State 类似这样: state = &#123; clicks: 0, count: 0 &#125; */ return &#123; ...state, clicks: state.clicks + 1, count: state.count - 1 &#125;&#125; Redux:更新对象内的对象(这一部分并不是专门针对Redux的-对用简单的React state通用适用 看这里,如何使用). 当你想更新的对象在Redux内部一层,或更底层,需要拷贝每一层,直至包含了需要更新的对象部分.这里是第一层实施: 1234567891011121314151617181920function reducer(state, action) &#123; /* State像这样: state = &#123; house: &#123; name: \"Ravenclaw\", points: 17 &#125; &#125; */ // Ravenclaw加2分 return &#123; ...state, // 拷贝(level 0) house: &#123; ...state.house, // 拷贝嵌套的 (level 1) points: state.house.points + 2 &#125; &#125; 另一个例子, 有两层深度: 1234567891011121314151617181920212223242526function reducer(state, action) &#123; /* State looks like: state = &#123; school: &#123; name: \"Hogwarts\", house: &#123; name: \"Ravenclaw\", points: 17 &#125; &#125; &#125; */ // Two points for Ravenclaw return &#123; ...state, // 拷贝 (level 0) school: &#123; ...state.school, // 拷贝 level 1 house: &#123; // 替换 state.school.house... ...state.school.house, // 拷贝存在属性 points: state.school.house.points + 2 // 改变属性值 &#125; &#125; &#125; 在更新深度嵌套的对象时,这个代码很难阅读. Redux:通过对象的键来更新对象1234567891011121314151617181920212223242526272829303132333435function reducer(state, action) &#123; /* State looks like: const state = &#123; houses: &#123; gryffindor: &#123; points: 15 &#125;, ravenclaw: &#123; points: 18 &#125;, hufflepuff: &#123; points: 7 &#125;, slytherin: &#123; points: 5 &#125; &#125; &#125; */ // Add 3 points to Ravenclaw, // 变量存储键名 const key = \"ravenclaw\"; return &#123; ...state, // copy state houses: &#123; ...state.houses, // copy houses [key]: &#123; //利用计算属性修改键值 ...state.houses[key], // copy that specific house's properties points: state.houses[key].points + 3 // update its `points` property &#125; &#125; &#125; Redux: 在数组前添加元素mutable的方法是使用数组的.unshift函数在数组之前添加元素. Array.prototype.unshift mutate数组, 不是我们想要的结果. 这里是如何用immutable的方法在数组前添加一个元素的方法,适用于Redux: 123456789101112function reducer(state, action) &#123; /* State looks like: state = [1, 2, 3]; */ const newItem = 0; return [ // 新的数组 newItem, // 添加的第一个元素 ...state // 在最后展开数组 ]; Redux:给一个数组添加项目 mutable的方法是使用数组的.push函数,在数组的末尾添加一个项目.但是这会mutate数组. immutably的方法: 123456789101112function reducer(state, action) &#123; /* State looks like: state = [1, 2, 3]; */ const newItem = 0; return [ // a new array ...state, // explode the old state first newItem // then add the new item at the end ]; 也可以使用.slice方法拷贝数组,之后mutate拷贝: 123456function reducer(state, action) &#123; const newItem = 0; const newState = state.slice(); newState.push(newItem); return newState; 使用map方法更新数组的项目数组的.map 函数调用你提供的函数,传递的参数是数组的每个项目,返回一个新的数组,使用每个新项目的返回值作为新数组的项目. 换句话说,如果你的数组有N个项目,需要返回的数组也是N条,就要使用.map函数.可以在一次传递替换更新一个或者多个项目. 如果数组N条,结束时比N少,可以使用.filter. 参见Remove an item form an array. 123456789101112131415161718function reducer(state, action) &#123; /* State looks like: state = [1, 2, \"X\", 4]; */ return state.map((item, index) =&gt; &#123; // Replace \"X\" with 3 // alternatively: you could look for a specific index if(item === \"X\") &#123; return 3; &#125; // Leave every other item unchanged return item; &#125;);&#125; Redux:更新数组中的一个对象这个和上面的工作原理相同, 唯一的区别是,你需要构建一个新的对象,并返回一个想要改变的对象. 数组的.map 函数通过对数组每个条目调用函数返回一个新的数组,用函数返回值作为新数组的元素. 换句话说,如果你的数组有N条项目, 新的数组也需要N条项目, 就用.map. 可以更新一条或者多条项目. 在这个实例中,我们有一个数组包含了用户email地址的数组. 其中一个人改变了email地址,所以我们需要更新它. 这里演示的是如何用action的用户ID和新的email执行更新,你也可以使用其他的途径来执行更新. 12345678910111213141516171819202122232425262728293031323334353637383940function reducer(state, action) &#123; /* State looks like: state = [ &#123; id: 1, email: 'jen@reynholmindustries.com' &#125;, &#123; id: 2, email: 'peter@initech.com' &#125; ] Action contains the new info: action = &#123; type: \"UPDATE_EMAIL\" payload: &#123; userId: 2, // Peter's ID newEmail: 'peter@construction.co' &#125; &#125; */ return state.map((item, index) =&gt; &#123; // Find the item with the matching id if(item.id === action.payload.userId) &#123; // Return a new object return &#123; ...item, // copy the existing item email: action.payload.newEmail // replace the email addr &#125; &#125; // Leave every other item unchanged return item; &#125;);&#125; Redux:在一个数组中间插入一个条目数组的.splice函数会在数组中插入一个项目,但是它会mutate一个数组. 因为我们并不想mutate原始的数组, 所以可以先做一下拷贝(.slice),之后使用.splice插入项目 其他的方法比包括拷贝新元素之前的所有元素,接着插入新的,然后拷贝之后的元素. 但是这么做很容易出错. 提示:要做单元测试. 这里非常容易出错. 123456789101112131415161718192021222324252627function reducer(state, action) &#123; /* State looks like: state = [1, 2, 3, 5, 6]; */ const newItem = 4; // make a copy const newState = state.slice(); // insert the new item at index 3 newState.splice(3, 0, newItem) return newState; /* // You can also do it this way: return [ // make a new array ...state.slice(0, 3), // copy the first 3 items unchanged newItem, // insert the new item ...state.slice(3) // copy the rest, starting at index 3 ]; */&#125; 根据数组元素的index来更新数组我们可以使用.map方法返回一个特定索引(index)的新值,保持其他的值不变. 1234567891011121314151617function reducer(state, action) &#123; /* State looks like: state = [1, 2, \"X\", 4]; */ return state.map((item, index) =&gt; &#123; // Replace the item at index 2 if(index === 2) &#123; return 3; &#125; // Leave every other item unchanged return item; &#125;);&#125; 使用filter从数组中删除项目数组的.filter函数调用你提供的函数,逐个传递进每个项目,返回的新数组的元素是条目输入时,函数返回值为true的条目.如果函数返回值为false,就从数组中删除. 如果你的数组有N条, 你需要返回的条目等于或者少于N,就可以使用.filter函数 123456789101112131415161718function reducer(state, action) &#123; /* State looks like: state = [1, 2, \"X\", 4]; */ return state.filter((item, index) =&gt; &#123; // Remove item \"X\" // alternatively: you could look for a specific index if(item === \"X\") &#123; return false; &#125; // Every other item stays return true; &#125;);&#125; 查看Redux 文档Immutable Update Patterns. 有更多的技巧. 用Immer 使更新更为简单如果你看看上面的immutable state更新代码,想退缩.我不会责怪你. 深度嵌套对象的更新很难阅读, 很难书写,也很难得到正确的结构. 单元测试是命令式的,但是即使这样也不会让代码更容易阅读和编写. 谢天谢地, 有一个库能帮上忙, 使用由 Michael Weststrate编写的Immer,可以让你编写你知道并喜欢的[].push,[].pop还有=编写mutable代码-Immer会接受这些代码,生成完美的immutable代码,像魔法一样. 赞! 来看开具体的工作 首先安装Immer(3.9kb gzipped,) 1Yarn add immer 之后,导入produce函数,只要这一个函数, 就完成一切工作了.简单,明了 1Import produce from 'immer'; 顺便讲一句,叫做”produce”是因为它产出一个新的值, 名字某种意义上和reduce相反, 这里是对名字的讨论issue on Immer&#39;s Github. 从现在起,你可以使用produce函数构建一个极佳的mutable练习场所,你所有的mutations都会被具有魔法的JS 代理对象(Proxies)处理. 这里的前后对比实例使用了纯JS版本的reducer和Immer 版本,对比一下更新嵌套对象的过程. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* State looks like: state = &#123; houses: &#123; gryffindor: &#123; points: 15 &#125;, ravenclaw: &#123; points: 18 &#125;, hufflepuff: &#123; points: 7 &#125;, slytherin: &#123; points: 5 &#125; &#125; &#125;*/function plainJsReducer(state, action) &#123; // Add 3 points to Ravenclaw, // when the name is stored in a variable const key = \"ravenclaw\"; return &#123; ...state, // copy state houses: &#123; ...state.houses, // copy houses [key]: &#123; // update one specific house (using Computed Property syntax) ...state.houses[key], // copy that specific house's properties points: state.houses[key].points + 3 // update its `points` property &#125; &#125; &#125;&#125;function immerifiedReducer(state, action) &#123; const key = \"ravenclaw\"; // produce takes the existing state, and a function // It'll call the function with a \"draft\" version of the state return produce(state, draft =&gt; &#123; // Modify the draft however you want draft.houses[key].points += 3; // The modified draft will be // returned automatically. // No need to return anything. &#125;);&#125; 在React State上使用ImmerImmer也可以针对setState形式的对象更新形式. 你可能已经知道了React的setState有函数式的形式,接收一个函数,并传递当前值, 函数返回新的值: 12345678910111213onIncrementClick = () =&gt; &#123; // The normal form: this.setState(&#123; count: this.state.count + 1 &#125;); // The functional form: this.setState(state =&gt; &#123; return &#123; count: state.count + 1 &#125; &#125;);&#125; Immer的produce函数可以被插入到state更新函数中.你会注意到,调用produce的调用方式只传递了单个参数-也就是更新函数-并不是两个参数(state,draft=&gt;{}) 123456onIncrementClick = () =&gt; &#123; // The Immer way: this.setState(produce(draft =&gt; &#123; draft.count += 1 &#125;);&#125; 这是因为Immer的produce函数设置返回的是一个柯里化函数,只有一个参数. 在这个例子中返回的函数已经准备接受state作为参数,使用draft调用你的更新函数 渐进采用ImmerImmer的一个很好的特性是,因为他很小,目标聚焦(仅仅返回新state的函数), 很容在已有代码中添加. Immer向后兼容已经有的Redux reducers,如果你在Immer的produce函数中包装已经存在的switch/case代码,所有的reducer测试仍然可以通过. 之前,我演示过, 传递给produce的更新函数可以隐式返回undefined,并且会自动挑选出针对draftstate的变化.我没有提到的是,更新函数可以一个全新的对象,只要它没有对draft作出任何改变. 这意味着,已经编写好的返回全新state 的Redux reducer,也可以用Immer的produce函数包装,他们应该保持完全相同. 在这一点上,你可以轻松一块,一块地替换掉很难阅读的immutable 代码.看看官方实例从producers返回不同数据的各种方法 完!","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"}]},{"title":"React的状态管理","slug":"React的状态管理","date":"2019-04-22T15:10:00.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2019/04/22/React的状态管理/","link":"","permalink":"https://React-Apollo.github.io/2019/04/22/React的状态管理/","excerpt":"","text":"主要内容,看看State的状态管理方式,包括最基本的方式和React-Hooks方式以及Redux方式和ReSub方式 我们从基本的方式开始 React和数据的基本交互方式 在MVC程序构架中,React经常被称为View层,但实际上并不完全是这样, React实际对MVC模式做了新的构想. 本质上React只是借助JSX语法实现的UI界面库,但是UI都需要数据来填充,所以问题就是如何获取数据,如何灵活的展现数据. MVC的思想 MVC架构的基本思想: 模型层(Model)就是数据层. 视图层(View)负责整个应用程序的展示. 控制层(Controller)在应用程序中扶着提供数据处理的逻辑操作. React处理数据和MVC有微妙的区别. 在由多个子组件组合而成的视图(父组件)里, 子组件可以管理自己的数据处理方式,而且也可以从父组件获取数据,只需要在父组件中提供一个控制器就可以了. React的思想在React的组件中有两种不同的数据类型: props ,在创建组件的时候,props会作为参数传递给组件,这个就作为组件顶级的配置项,一旦定义好,组件就不能自行修改了. 在React定的父组件-&gt;子组件的信息传递中,只能使用这一种方式.没有其他的方法. Props是React组件库的精华, 我们可以定义不同的Props来控制组件的表现形式. state,state是组件内部的数据.React的精华实际就在state上,我们可以在父组件中定义一个state,然后以Props的形式传递给子组件, state只是一个JS对象,我们可以定义任何形式的属性. state的定义多样性,决定了你的应用的多样性. 通过定义组件的state,可以实现基本的状态管理,也可以实现类Redux管理方式, 还可以实现React-Hooks的管理方式. 如果深入一点,你需要知道,Redux其实就是一个只有State逻辑处理而没有UI的React组件. 进行State修改的方法就只有一个 this.setState({}).在Redux这个特殊的React组件中,也是通过这个方法来修改App的State,只不过我们看不到实现细节. 后续我会通过一个表单来看看看里面具体的实现. 以上内容整理自F8-App的介绍,原来有中文的,但是打不开了,英文的需要科学上网. 基本实现State设计是React应用最重要的部分.这个设计,我认为也是React思想建立的关键. 核心是如何思考State的提升, 也就是不断的把State提升到更高一级的组件中. 但是这个提升也要适可而止, 应该总是以具体的处理流程作为分割线. 同一个流程的State,最终可以提升为一个总的State,例如和登录,注册,登出,找回密码和修改密码的流程,就可以提升为一个大的State. 不相关流程的State,就不要混合在一起.不管你是使用基础的State管理,Redux管理,Hooks管理,包括ReSub,这一点都是一样的. React文档中的基本处理方法单个字段的‌表单 123456789101112131415161718192021222324252627282930class SingleFieldForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;value: ''&#125;; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125; handleSubmit(event) &#123; alert('A name was submitted: ' + this.state.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input type=\"text\" value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;/form&gt; ); &#125;&#125; 这是一个简单的表单组件,要实现这个表单,不仅要使用state,还有props,同时还要有展示内容的UI组件 在表单组件中定义了state: 12//只是一个JS对象,属性名为valuethis.state = &#123;value: ''&#125;; 定义了处理state的方法: 12345678handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125; handleSubmit(event) &#123; alert('A name was submitted: ' + this.state.value); event.preventDefault(); &#125; 在创建一个表单组件的时候,需要反馈给输入用户到底自己输入的是什么,还有如何进行表单提交的方法.上面两段代码就定义这两个内容. 那么表单组件内部的子组件直接获取输入的内容和提交方法就可以了.从父组件向子组件传递数据时,我们就需要用到props.就是下面的代码 1234567&lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input type=\"text\" value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;/form&gt; 这里的form,input[type=&quot;text&quot;],input[type=&quot;submit&quot;] 都是props的用法. 这里只要牢记一点, 在return中出现的所有参数都是props, render之外的是state, 1234render()&#123;return( ...code) 在JS中,我们是传引用赋值的,所以在子组件就可以通过引用的方法名来操作父组件定义的State, 那么这里就有一个问题, 如果我们继续把父组件中定义的State和State处理方法提升的爷爷组件,在继续提升的太爷爷组件上,应该是一样的吧? 我可以确切的说, React的代码编写就是这个原则. 只不过state的设计需要稍稍复杂一点. 如果是多个字段的表单,我们应该如何编写代码? 如果按照常规是这样的‌多字段表单常规写法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class ThreeFieldsForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;name: '' age: null, email:'' &#125;; this.handleNameChange = this.handleNameChange.bind(this); this.handleAgeChange = this.handleAgeChange.bind(this); this.handleEmailChange = this.handleEmailChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleNameChange(event) &#123; this.setState(&#123;name: event.target.value&#125;); &#125; handleAgeChange(event) &#123; this.setState(&#123;age: event.target.value&#125;); &#125; handleEmailChange(event) &#123; this.setState(&#123;email: event.target.value&#125;); &#125; handleSubmit(event) &#123; alert('A name was submitted: ' + this.state.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input type=\"text\" value=&#123;this.state.name&#125; onChange=&#123;(event)=&gt;this.handleNameChange(event.target.value)&#125; /&gt; &lt;/label&gt; &lt;label&gt; Age: &lt;input type=\"text\" value=&#123;this.state.age&#125; onChange=&#123;this.handleAgeChange&#125; /&gt; &lt;/label&gt;&lt;label&gt; Email: &lt;input type=\"text\" value=&#123;this.state.email&#125; onChange=&#123;this.handleEmailChange&#125; /&gt; &lt;/label&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;/form&gt; ); &#125;&#125; 这里是三个字段的表单, 如果是十个字段, 那么state和处理方法代码就太多了, 并且你发现这些代码只有一个地方是不同,或许我们可以在state处理方法上想想办法? ‌把handleChange方法抽象出来 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class ThreeFieldsForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;name: '' age: null, email:'' &#125;; &#125; //这里用了ES6的箭头函数就不需要再绑定啦 setValue = (type, text) =&gt; &#123; switch (type) &#123; case \"setName\": this.setState(&#123; name: text &#125;); break; case \"setAge\": this.setState(&#123; age: text &#125;); break; case \"setEmail\": this.setState(&#123; email: text &#125;); break; &#125; &#125;; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input type=\"text\" type=\"setName\" onChange=&#123;(event)=&gt;this.setValue(event.target.value,\"setName\")&#125; value=&#123;this.state.name&#125; /&gt; &lt;/label&gt; &lt;label&gt; Age: &lt;input type=\"text\" type=\"setAge\" onChange=&#123;(event)=&gt;this.setValue(event.target.value,\"setAge\")&#125; value=&#123;this.state.age&#125; /&gt; &lt;/label&gt;&lt;label&gt; Email: &lt;input type=\"text\" type=\"setEmail\" onChange=&#123;(event)=&gt;this.setValue(event.target.value,\"setEmail\")&#125; value=&#123;this.state.age&#125; /&gt; &lt;/label&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;/form&gt; ); &#125;&#125; 这里有两个词,如果你看了Redux和React-Hooks,可能会觉得很眼熟, 一个是type,另一个是setValue, 没错这个地方也是我写这篇文章的着眼点,上周我想到这个地方的的时候,就觉得常规的State处理,Redux和React-hooks对于State的处理其实并没有明确的界限. 如何使用就是React程序员需要考虑的问题. 如果这个表单用React-Hooks处理是这个样子的 1234567891011121314151617181920212223242526272829303132333435import &#123;useState&#125; from 'React'; const ThreeFieldForm=(props)=&gt;&#123; const [name,setName]=useState(\"\"); const [age,setAge]=useState(null); const [email,setEmail]=useState(\"\") return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input type=\"text\" type=\"setName\" onChange=&#123;(event)=&gt;setName(event.target.value)&#125; value=&#123;this.state.name&#125; /&gt; &lt;/label&gt; &lt;label&gt; Age: &lt;input type=\"text\" type=\"setAge\" onChange=&#123;(event)=&gt;setAge(event.target.value)&#125; value=&#123;this.state.age&#125; /&gt; &lt;/label&gt;&lt;label&gt; Email: &lt;input type=\"text\" type=\"setEmail\" onChange=&#123;(event)=&gt;this.setEmail(event.target.value)&#125; value=&#123;this.state.age&#125; /&gt; &lt;/label&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;/form&gt; );&#125; 如果我们在处理的方法中加了type那就可以用useReducer啦! useReducer可以看下面这段代码. useReducer 123456789101112131415161718192021222324const initialState = &#123; count: 0 &#125;;function reducer(state, action) &#123; switch (action.type) &#123; case \"reset\": return initialState; case \"increment\": return &#123; count: state.count + 1 &#125;; case \"decrement\": return &#123; count: state.count - 1 &#125;; &#125;&#125;function Demo() &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: \"reset\" &#125;)&#125;&gt;Reset&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: \"increment\" &#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: \"decrement\" &#125;)&#125;&gt;-&lt;/button&gt; &lt;/&gt; );&#125; 这里的这段代码,我们先不作解释,如果对Redux比较理解了, useReducer的方法也是比较好理解的. 还是之前提到的那一句话, state的管理方法不是绝对的, 看看如何思考具体的是用. 经过之前的提升操作, 如果更进一步,把所有的state都提升到一个顶级的组件中, Redux模式就完成了. 这一点我在后面会继续讲到, 其实在很多讲解Redux的图示中,都会提到数据单向流动, 没错一旦所有的State都提升到顶级的组件中, 数据就只能通过props的形式传递给子组件. 最大的子组件就是Redux的包装下的那个App组件. 如果你看过Redux的模型图,例如下面这一张: 或者我自己画的 数据是单向流动的,从React-Redux组件流向应用的组件.但是在第一张图的右侧的Actions似乎有流了回去, 这算是单向流动吗?这个问题时间用dispatch并不好理解, 用ReSub的触发似乎要好一点.后边我会结合一个自己想的现实生活中的实例来解释这个问题. 下面我要声明我自己的一个学习体会, React经过几年的高速发展, 构架不断的向函数式编程方向发展, 函数式组件内部的JSX代码结合传入的数据,我们想要的应用就实现了.所以归结为两点一个是函数式组件,另外一个就是数据. 在React中流动的数据仅仅只是JS对象,如果我们给这些对象添加了定义好了Type类型,那么数据就可以井然有序的呗管理和组织,就是这么简洁,注意是简洁并不是简单, 要想设计好State也不是一件容易的事情.下面我们要进入本文的主题了, 通俗的学习Redux. React的状态管理的权威-Redux这里我不想很正式的讲解Redux,Redux文档写的非常好,可能一开始看觉得很难,但是看过十几遍之后,你会觉得甘之如饴. 没有看十遍以上的,是苦的.所以我想换个方法, 用通俗的方法来解释一下,这个问题.作为看文档的补充.很多时候看问题要换个角度,或者换个容易理解的模型就比较容易理解了. Redux的通俗理解我们就从 这张图的Store开始 这一段时间我都在思考Redux Store的通俗理解方法. 结果发现本身这个单词就是最好的诠释. 这里的Store我想用两个模型解释,一个是沃尔玛的Super Store,一个是电商的Store,就拿JD商城做例子吧. 从Store开始.沃尔玛的Store如果你没去过沃尔玛,把沃尔玛换成全家便利店也可以, 规模不同,结构和组织完全相同.但是如果类比Redux的Store,大型超市的多人管理更类似些 在Store里,首先你会看大很多的货架,一个Store在刚开始初始化的时候是这个样子的 开张的时候是这个样子的: 基本大型超市会分成不同的楼层,然后分成不同的区域,不同的货架 处理具体货架的人是不同的,所以尽管很大,但是由于进行了分区,分层处理,管理是井井有条的.每个区域,每个分类,每个货架都有不同的标签来标识. 每种货物的具体补货,出货,换货等方法都相应的不同, 但是只要找到具体每个区的负责员工就可以实现了. 看这个每天超市庞大的货物吞吐量, 其实进入到超市之后,就想看不见的洋流一样其实是在各自区域中独立的流动. 与之对照, 在Redux中所有的应用State,初看起来也是非常庞大,但是具体到实现,都由JS对象的键类区分和管理,各自也包含了自己的State处理方法. 每个小部分的对象和处理方法就统称为reducer,每个小分区的State又通过 CombineReducer组合成最大的Reducer,我们可以从整个Reducer里获取到应用的完整State. 我们去超市,抽象的是和超市打交道,具体的是和每个终端在员工和货架在打交道. 所以尽管超市很大,但是处理问题的方式却很简单. 京东的Store京东的Store,和我们React里的Store就非常接近了. 之所以拿电商来做实际的例子,要解决三个问题,一是如何理解Redux的 dispatch方法,另一个是如何理解connect. 这里我先做一个通俗的解释,然后讲解一张我认为对这个模式解释最好的图片.还有就是数据的不可突变性 dispatch dispatch时,到底有没有数据从用户流向Store? 这个单词翻译为中文叫分派,似乎还不太准确,准确的翻译应该叫触发. ReSub这个库就用了trigger这个词. 最好的处理就是把state和处理state的方法统一放大一个地方. 由于JS是传引用赋值的,我们可以把修改State的方法通过props的形式传递给子组件, 子组件只需要触发对应的操作就可以了.所以这里用触发的解释比较好. 面对一个庞大的电商Store,也没有什么担心的,只要定义好了不会引发歧义的type就可以了. 我们触发一个操作,就是执行一个Store定义的方法,根据触发的type对Redux的State做出修改. 我们在京东购物时,点击购买,提交的就是商品品名,数量,此外我们还要提供自己的地址,相当于为自己的地址绑定了这次购物,等物品从JD的Store出来之后,后按照你的地址进行派送. 整个流程几乎是完全相同的. connect 从JD Store出来的货物是针对全部买家的,不是每件商品都是你需要的. 所以当Store的货物返回到社会以后,需要根据买家的地址来进行筛选和分类,然后由快递员按你提供的地址进行派送. 这个过程是自动, 你不需要自己动手, 因为之前已经进行了订阅. 用Redux的方法就是使用mapStateToProps把某个组件需要的数据筛选出来.由于需要dispatch的Store方法也是从外部传递的,所有就有了mapDispatchToProps方法, 传递Store对应的方法名. 在重复一下, 组件外部的数据只能通过props传递. 好了时候借用别人的杀手锏了.下面这张图嘛,你可以想象是你有几个朋友,分别在不同的城市,你用他们的地址进行了订阅,然后你在JD上提交了订单,触发了JD Store的一次操作,然后JD根据你的订阅地址把货物发送到几个朋友手中. 图片出处 when-do-i-know-im-ready-for-redux 你现在可以进入这张图中,你的家就在最右边的这个球中,你触发了一个订购操作,比如在2019年4月22号20点20分20秒195毫秒时订购了三只中华铅笔,HB的.然后JD的的文具分部接受根据你触发的动作的类型做了相应的处理,通知Store出货,然后铅笔库存减掉3, 这时如果还有其他人想买中华的HB铅笔,就会显示无货. 你的这次订阅和小米的旗舰店没有任何的关联, 尽管从外面看JD的铅笔和小米的手机是从同一个地方出来的,但是在Store内部是由不同的分支来处理的. 上面我专门添加了一个时间,是为了要解决数据的不可变性这个问题,就是在Redux文档中提到的时间旅行的问题. 数据的不可突变性对于JavaScript是一个问题,但是对于某些语言就不是问题. JS中的这个问题是由于JS对于数据存储的方法引起的. 例如我们要在JS中定义一个蜡笔的颜色为红色: 然后我们把对象变为蓝色的对象, JS会为这个对象重新分配内存地址 但是如果我们只修改对象的属性,问题就来了,JS会在原位置对对象作出修改 由于Redux Store中的state是嵌套对象, 如果对某一部分属性进行修改, 内存地址不会发生改变, Store可能认为你没有做什么修改工作,因为在Store中使用’===’来决定state是否发生改变的.===符号在JS中就是比较对象的内存地址的.所以在Redux中需要手动把要修改的State复制到新的内存地址中,然后在做修改,从而让Store可以觉察到State的变化. 以上解释来自[Immutability in React and Redux: The Complete Guide](https://daveceddia.com/react-redux-immutability-guide/). 如果理解有偏差,敬请指出 但是这样做每次修改都要开辟新的内存地址, 是比较浪费内存的.所以FaceBook提出了 Immutable.js 的方法. 这就是我上面用到的那个时间段的意思. 还是在JD的Store, 我们要出货,管理库存,当用户订购了三只中华铅笔,库存要减掉, 我们可以把所有的库存账本重新抄一遍,然后把中华铅笔的库存减掉3.但是实际的库存管理不是这样做的, 我们有一个总的库存目录, 然后单独在一个地方记载某个时间某个商品的库存发生了什么变化, 没有变化的部分,就不管了. 这就是Immutable的处理方法. 记载变化的位置,共享不变的位置. 如果我们不为修改打上时间戳就没有办法知道历史记录了,因为历史数据被新的数据给替换掉了. 所以实际的账目中不仅要记录账目发生变化的品名还要记录时间. Redux的时间旅行就是这个意思. 上面的那篇文章对于JS的Immutability操作解释的非常好, 我也准备翻译. 尤其是后面的Immer库很方便. 未完成,还有一些内容 微软的Resub下面我们来看看微软的Resub库. 这个库是配合微软的ReactXP项目的附属.我没看过mobx的文档,我猜想应该和Mobx是很像的. 主要内容就是使用StoreBase定义数据和数据处理方法, 12345678910111213141516171819import &#123; StoreBase, AutoSubscribeStore, autoSubscribe &#125; from 'resub';@AutoSubscribeStoreclass TodosStore extends StoreBase &#123; private _todos: string[] = []; addTodo(todo: string) &#123; // Don't use .push here, we need a new array since the old _todos array was passed to the component by reference value this._todos = this._todos.concat(todo); this.trigger(); &#125; @autoSubscribe getTodos() &#123; return this._todos; &#125;&#125;export = new TodosStore(); 在组件中使用数据和方法 1234567891011121314151617181920212223242526import * as React from 'react';import &#123; ComponentBase &#125; from 'resub';import TodosStore = require('./TodosStore');interface TodoListState &#123; todos?: string[];&#125;class TodoList extends ComponentBase&lt;&#123;&#125;, TodoListState&gt; &#123; protected _buildState(props: &#123;&#125;, initialBuild: boolean): TodoListState &#123; return &#123; todos: TodosStore.getTodos() &#125; &#125; render() &#123; return ( &lt;ul className=\"todos\"&gt; &#123; this.state.todos.map(todo =&gt; &lt;li&gt;&#123; todo &#125;&lt;/li&gt; ) &#125; &lt;/ul&gt; ); &#125;&#125;export = TodoList; 应该也算是非常简洁的.而且有TS的类型约束, 出错的机会要少很多. Redux的TS方法,我后面也会提到.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"Javascript","slug":"Javascript","permalink":"https://React-Apollo.github.io/tags/Javascript/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"React-Hooks","slug":"React-Hooks","permalink":"https://React-Apollo.github.io/tags/React-Hooks/"}]},{"title":"代码|Migrating from Component State to Hooks for a Fetch Request","slug":"代码|Migrating from Component State to Hooks for a Fetch Request","date":"2019-04-19T21:39:00.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2019/04/19/代码|Migrating from Component State to Hooks for a Fetch Request/","link":"","permalink":"https://React-Apollo.github.io/2019/04/19/代码|Migrating from Component State to Hooks for a Fetch Request/","excerpt":"","text":"Migrating from Component State to Hooks for a Fetch Request React-Hooks的用法, 包装Hooks,然后返回一组接口, 这是React-Hooks提倡的用法 原始代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import React from 'react';import &#123; StyleSheet, Text, View, FlatList, SafeAreaView, ActivityIndicator, Button,&#125; from 'react-native';const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: '#fff', alignItems: 'center', justifyContent: 'center', &#125;,&#125;);export default class App extends React.Component &#123; state = &#123; people: [], loading: true, page: 1, &#125;; componentDidMount() &#123; this.getPeople(); &#125; getPeople = () =&gt; &#123; this.setState(&#123; loading: true &#125;); fetch(`https://swapi.co/api/people?page=$&#123;this.state.page&#125;`) .then(res =&gt; res.json()) .then(res =&gt; &#123; this.setState(state =&gt; (&#123; people: [...state.people, ...res.results], loading: false, &#125;)); &#125;); &#125;; render() &#123; return ( &lt;SafeAreaView style=&#123;&#123; flex: 1 &#125;&#125;&gt; &lt;FlatList data=&#123;this.state.people&#125; keyExtractor=&#123;item =&gt; item.url&#125; renderItem=&#123;(&#123; item &#125;) =&gt; ( &lt;View&gt; &lt;Text&gt;&#123;item.name&#125;&lt;/Text&gt; &lt;/View&gt; )&#125; ListFooterComponent=&#123; this.state.loading ? ( &lt;ActivityIndicator /&gt; ) : ( &lt;Button title=\"Load More\" onPress=&#123;() =&gt; &#123; this.setState( state =&gt; (&#123; page: state.page + 1 &#125;), this.getPeople ); &#125;&#125; /&gt; ) &#125; /&gt; &lt;/SafeAreaView&gt; ); &#125;&#125; React-Hooks包装的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const useSwapiPeople = () =&gt; &#123; const [people, setPeople] = useState([]); const [loading, setLoading] = useState(false); const [page, setPage] = useState(1); useEffect( () =&gt; &#123; setLoading(true); fetch(`https://swapi.co/api/people?page=$&#123;page&#125;`) .then(res =&gt; res.json()) .then(res =&gt; &#123; setPeople([...people, ...res.results]); setLoading(false); &#125;); &#125;, [page] ); const loadMore = () =&gt; &#123; setPage(page + 1); &#125;; return &#123; people, loading, loadMore, &#125;;&#125;;export default () =&gt; &#123; const &#123; people, loading, loadMore &#125; = useSwapiPeople(); return ( &lt;SafeAreaView style=&#123;&#123; flex: 1 &#125;&#125;&gt; &lt;FlatList data=&#123;people&#125; keyExtractor=&#123;item =&gt; item.url&#125; renderItem=&#123;(&#123; item &#125;) =&gt; ( &lt;View&gt; &lt;Text&gt;&#123;item.name&#125;&lt;/Text&gt; &lt;/View&gt; )&#125; ListFooterComponent=&#123; loading ? ( &lt;ActivityIndicator /&gt; ) : ( &lt;Button title=\"Load More\" onPress=&#123;loadMore&#125; /&gt; ) &#125; /&gt; &lt;/SafeAreaView&gt; );&#125;; ‌核心部分 组件需要三个state,1️⃣是从API返回的数据,2️⃣是远程异步操作的提示状态,3️⃣是分页状态. 作者这里的代码进行了重构, 返回了数据和加载提示, 分页标识外部不可见,只暴露了函数. 12345678910111213141516171819202122232425262728const useSwapiPeople = () =&gt; &#123; const [people, setPeople] = useState([]); const [loading, setLoading] = useState(false); const [page, setPage] = useState(1); useEffect( () =&gt; &#123; setLoading(true); fetch(`https://swapi.co/api/people?page=$&#123;page&#125;`) .then(res =&gt; res.json()) .then(res =&gt; &#123; setPeople([...people, ...res.results]); setLoading(false); &#125;); &#125;, [page] ); const loadMore = () =&gt; &#123; setPage(page + 1); &#125;; return &#123; people, loading, loadMore, &#125;;&#125;;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"https://React-Apollo.github.io/tags/React-Native/"},{"name":"React-Hooks","slug":"React-Hooks","permalink":"https://React-Apollo.github.io/tags/React-Hooks/"},{"name":"Fetch","slug":"Fetch","permalink":"https://React-Apollo.github.io/tags/Fetch/"},{"name":"StarWar","slug":"StarWar","permalink":"https://React-Apollo.github.io/tags/StarWar/"}]},{"title":"TypeScript的通俗解释","slug":"TypeScript的通俗解释","date":"2019-04-18T22:10:00.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2019/04/18/TypeScript的通俗解释/","link":"","permalink":"https://React-Apollo.github.io/2019/04/18/TypeScript的通俗解释/","excerpt":"","text":"如果下一次有人问我TypeScript是怎么工作的. 我会告诉他. TS就是事先规定好了,这个锁只能用某种匙形的钥匙来开, 你拿一把匙形不对的钥匙来,TS就像是一个老师傅, 你还没动手开,他就告诉你,你拿错钥匙了,不要再往下试啦, 赶快换钥匙吧! 要是没有这个老师傅, 你试了半天, 打不开锁, 你就开始怀疑是锁的问题,还是钥匙的问题. TS总体上说通过约定(接口和类型)减少了你试错的机会,加快了你开锁的机会. 当然速度有多快,与你定义的匙形有很大的关系,如果定义的非常好, 速度就会很快.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://React-Apollo.github.io/tags/Javascript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://React-Apollo.github.io/tags/TypeScript/"}]},{"title":"GitPoint代码结构","slug":"GitPoint代码结构","date":"2019-02-14T09:39:00.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2019/02/14/GitPoint代码结构/","link":"","permalink":"https://React-Apollo.github.io/2019/02/14/GitPoint代码结构/","excerpt":"","text":"简介React的16.8.1的版本已经发布，在稍后的React-Native的0.59版本会支持React-Hooks这个特性。 经过之间一段时间的学习，对React的函数式编程方式有了一定的了解。刚好遇到React-Hooks发布。 学习了一些Hook上的使用方法。由衷的感慨，React向函数式组件的进化让编程变得非常有意思。 之前看过了GitPoint代码，由于代码结构比较复杂，所以似懂非懂的。又翻出来看，发现GitPoint的技术栈和我之前学习积累的方法已经很接近了。 理想的RN技术栈包括如下的技术： React,React-hooks 数据管理 Functional Components APP组织 Apollo 异步操作 GraphQL client Styled-Components 函数式CSS, Typescript 类型检查 React-Navigation 用于导航 GitPoint目前的技术栈： React,Redux 数据管理 Class Components APP组织 GraphQL, 异步操作 Client Styled-Components 函数式样式 Flow 类型检查 React-Navigation 导航 目的就是想看看从目前的技术栈迁移到理想的技术栈的可行性。对于这个APP,对远程数据的需要比本地的交互操作内容要多得的，Redux结构就稍显复杂，但是React-Hooks的useState ,useEffects和useReducer原理和Redux是完全一样的，之前需要把所有的Reducer合并(combineReducer)一起，现在就不用了， 单个的功能组件管理自己的reducer, 如果是全局的state，可以使用useContext方法， 还要两个论坛包装的方法，也可以在全局使用。 原则就是：‌数据的Immutable,数据的单向流动。 遵循的原则 数据的Immutable现在可以借助新的 Immer 使得 Immutable的操作简单化 数据单相流动， 对于函数式组件，完全不是问题，因为 函数式组件的数据天然是通过函数的参数传入。 项目结构基本结构 🔘 app.js :入口文件 🔘 routes.js: 路由总文件 🔘 root.store.js: redux的store文件 🔘 root-reducer.js： redux的reducer的combine文件 🔘 .flowconfig: flow类型检查的配置文件 🔘 ./src ：程序文件夹 入口文件 app.jsx‌静态方法获取当前位置 因为GitPoint App支持多种语言的本地化，在这里获取地理位置之后，后面的界面可以加载不同的文字 123456static async initLocale() &#123; //获取当前位置 const locale = await getCurrentLocale(); //配置当前位置，根据当前位置来设置App本地化信息 configureLocale(locale); &#125; constructor 使用redux-persist 保存Redux state至本地。在程序启动时需要判读state读取是否完成，或者是第一个使用，state为null. 12345678constructor() &#123; super(); this.state = &#123; rehydrated: false, &#125;; this.statusBarHandler = this.statusBarHandler.bind(this); &#125; componentWillMount() 在组件挂在周期函数中获取state加密方法，从本地获取state,设置rehydrated:true ,标识state加载完毕 12345678910111213141516171819componentWillMount() &#123; const encryptor = createEncryptor(&#123; secretKey: md5(DeviceInfo.getUniqueID()), &#125;); persistStore( configureStore, &#123; storage: AsyncStorage, transforms: [encryptor], whitelist: ['auth'], &#125;, () =&gt; &#123; this.setState(&#123; rehydrated: true &#125;); &#125; ); this.constructor.initLocale(); &#125; render（） render方法要根据rehydrated的状态加载不同的组件如果为false 加载splash界面 如果为true，跳转到React-Navigation的主路由 1234567891011121314151617render() &#123; if (!this.state.rehydrated) &#123; return ( &lt;Container&gt; &lt;Logo source=&#123;require('./src/assets/logo-black.png')&#125; /&gt; &lt;/Container&gt; ); &#125; //如果已经登录、就返回Redux store包装的主程序界面 //gitpoint主程序有React-Navigation来执行路由导航任务 return ( &lt;Provider store=&#123;configureStore&#125;&gt; &lt;GitPoint onNavigationStateChange=&#123;this.statusBarHandler&#125;&gt; &lt;StatusBar /&gt; &lt;/GitPoint&gt; &lt;/Provider&gt; ); routes.js总路由文件 Splash 页面 启动页 Login 页面 加载了github的第三方登录web页面和一个 Welcome 页面 Main 实际应用的路由 这四个路由使用堆栈来存放，实际的处理就是按顺序执行， 如果Longin没有完成，无法进入到Welcome的界面和Main的界面 Main路由的组织Main路由是登录以后的实际路由，分为两大块， 根据BottomTab组织的Tab路由分为： Home Notification ‌Search User 路由的安排和Redux中的Reducer的组织是一样方式，就是按照这个Tab的结构来安排， Tab就是APP的具体内容. 每个Tab中的页面是使用StackNavigator来组织的 还有一些可以共用的页面单独存放，压入到单个的Tab中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105const MyProfileStackNavigator = StackNavigator( &#123; MyProfile: &#123; screen: AuthProfileScreen, navigationOptions: &#123; header: null, &#125;, &#125;, ...sharedRoutes, &#125;, &#123; headerMode: 'screen', &#125;);const MainTabNavigator = TabNavigator( &#123; Home: &#123; screen: HomeStackNavigator, navigationOptions: &#123; tabBarIcon: (&#123; tintColor &#125;) =&gt; ( &lt;Icon containerStyle=&#123;&#123; justifyContent: 'center', alignItems: 'center' &#125;&#125; color=&#123;tintColor&#125; name=\"home\" size=&#123;33&#125; /&gt; ), &#125;, &#125;, Notifications: &#123; screen: NotificationsStackNavigator, navigationOptions: &#123; tabBarIcon: (&#123; tintColor &#125;) =&gt; ( &lt;NotificationIcon iconColor=&#123;tintColor&#125; /&gt; ), &#125;, &#125;, Search: &#123; screen: SearchStackNavigator, navigationOptions: &#123; tabBarIcon: (&#123; tintColor &#125;) =&gt; ( &lt;Icon containerStyle=&#123;&#123; justifyContent: 'center', alignItems: 'center' &#125;&#125; color=&#123;tintColor&#125; name=\"search\" size=&#123;33&#125; /&gt; ), &#125;, &#125;, MyProfile: &#123; screen: MyProfileStackNavigator, navigationOptions: &#123; tabBarIcon: (&#123; tintColor &#125;) =&gt; ( &lt;Icon containerStyle=&#123;&#123; justifyContent: 'center', alignItems: 'center' &#125;&#125; color=&#123;tintColor&#125; name=\"person\" size=&#123;33&#125; /&gt; ), &#125;, &#125;, &#125;, &#123; lazy: true, tabBarPosition: 'bottom', tabBarOptions: &#123; showLabel: false, activeTintColor: colors.primaryDark, inactiveTintColor: colors.grey, style: &#123; backgroundColor: colors.alabaster, &#125;, &#125;, tabBarComponent: (&#123; jumpToIndex, ...props &#125;) =&gt; ( &lt;TabBarBottom &#123;...props&#125; jumpToIndex=&#123;index =&gt; &#123; const &#123; dispatch, state &#125; = props.navigation; if (state.index === index &amp;&amp; state.routes[index].routes.length &gt; 1) &#123; const stackRouteName = [ 'Events', 'Notifications', 'Search', 'MyProfile', ][index]; dispatch( NavigationActions.reset(&#123; index: 0, actions: [ NavigationActions.navigate(&#123; routeName: stackRouteName &#125;), ], &#125;) ); &#125; else &#123; jumpToIndex(index); &#125; &#125;&#125; /&gt; ), &#125; 在最新版本的 React-Navigtion中，TabBarBottom的配置非常简单。需要做更新。 实际应用代码 Splash页面判断用户是否登录，如果登录跳转的Main路由，如果没有登录过，跳转到登录页面.Splash页面不属于应用的流程， 只是从store获取登录状态， 123456789101112131415161718192021222324252627//通过react-redux mapStateToProps方法从store获取认证信息const mapStateToProps = state =&gt; (&#123; isAuthenticated: state.auth.isAuthenticated,&#125;);//render方法加载 Logorender() &#123; return ( &lt;LogoContainer&gt; &lt;Logo source=&#123;require('../../assets/logo-black.png')&#125; /&gt; &lt;/LogoContainer&gt; ); &#125;// cdm方法根据isAuthenicated状态决定跳转到那个页面componentDidMount() &#123; const &#123; isAuthenticated, navigation &#125; = this.props; //如果登录直接跳转到主界面 if (isAuthenticated) &#123; resetNavigationTo('Main', navigation); &#125; else &#123; resetNavigationTo('Login', navigation); &#125; &#125; 登录流程Login.screen.js12345678910111213141516从state获取的信息const mapStateToProps = state =&gt; (&#123; locale: state.auth.locale, isLoggingIn: state.auth.isLoggingIn, isAuthenticated: state.auth.isAuthenticated, hasInitialUser: state.auth.hasInitialUser,&#125;);//dispactch的方法，const mapDispatchToProps = dispatch =&gt; bindActionCreators( &#123; auth, getUser, &#125;, dispatch ); 在gitPoint中，文件的组织是按照Tab来分类的，每个Tab是一个独立的应用流程。 在独立的流程文件夹中保存了Redux的结构， 容器组件和展示组件没有分开， .action.js ，.reducer.js ，.selector.js , .type.js 文件 位于同一个流程中， 管理起来非常方便。 在Redux内部，每个应用的流程是独立的。一开始学习是感到困惑的CombineReducer，其实只是简单的把reducer合并起来。只要不违反 Redux的三个原则， 文件组织结构可以是很灵活的。 GitPoint的组织结构迁移到React-Hooks模式，将会非常方便。 未登录时，跳转到github登录页面，如果登录成功，会返回状态和代码,state,code。根据这两个返回结构来执行下面的操作 12345678910111213141516171819202122232425262728//login.screen.jshandleOpenURL = (&#123; url &#125;) =&gt; &#123; if (url &amp;&amp; url.substring(0, 11) === 'gitpoint://') &#123; const [, queryStringFromUrl] = url.match(/\\?(.*)/); const &#123; state, code &#125; = queryString.parse(queryStringFromUrl); const &#123; auth, getUser, navigation, locale &#125; = this.props; if (stateRandom === state) &#123; this.setState(&#123; code, showLoader: true, loaderText: t('Preparing GitPoint...', locale), &#125;); stateRandom = Math.random().toString(); CookieManager.clearAll().then(() =&gt; &#123; auth(code, state).then(() =&gt;&#123;//redux action getUser().then(() =&gt; &#123; resetNavigationTo('Main', navigation); &#125;); &#125;); &#125;); &#125; &#125; &#125;; 在auth.action.js中执行的auth方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//auth.action.js//首先获取用户的Tokenexport const auth = (code, state) =&gt; &#123; return dispatch =&gt; &#123; dispatch(&#123; type: LOGIN.PENDING &#125;); return delay(fetchAccessToken(code, state), 2000) .then(data =&gt; &#123; dispatch(&#123; type: LOGIN.SUCCESS, payload: data.access_token, &#125;); &#125;) .catch(error =&gt; &#123; dispatch(&#123; type: LOGIN.ERROR, payload: error, &#125;); &#125;); &#125;;&#125;;//根据Token获取用户信息export const getUser = () =&gt; &#123; return (dispatch, getState) =&gt; &#123; const accessToken = getState().auth.accessToken; dispatch(&#123; type: GET_AUTH_USER.PENDING &#125;); return fetchAuthUser(accessToken) .then(data =&gt; &#123; dispatch(&#123; type: GET_AUTH_USER.SUCCESS, payload: data, &#125;); &#125;) .catch(error =&gt; &#123; dispatch(&#123; type: GET_AUTH_USER.ERROR, payload: error, &#125;); &#125;); &#125;;&#125;; 与用户相关的流程都放在这里， 其他的信息是通过GraphQL来获取的。 action.type.js在执行异步操作的action时，需要标识状态， GitPoint使用了 action-helper.js中的createActionSet来生成多个方法 1234567891011export const createActionSet = actionName =&gt; (&#123; PENDING: `$&#123;actionName&#125;_PENDING`, SUCCESS: `$&#123;actionName&#125;_SUCCESS`, ERROR: `$&#123;actionName&#125;_ERROR`, actionName,&#125;);export const createPaginationActionSet = actionName =&gt; (&#123; ...createActionSet(actionName), RESET: `$&#123;actionName&#125;_RESET`,&#125;); 12345678910//auth.type.jsimport &#123; createActionSet &#125; from 'utils';export const CHANGE_LOCALE = createActionSet('CHANGE_LOCALE');export const GET_AUTH_ORGS = createActionSet('GET_AUTH_ORGS');export const GET_AUTH_STAR_COUNT = createActionSet('GET_AUTH_STAR_COUNT');export const GET_AUTH_USER = createActionSet('GET_AUTH_USER');export const LOGIN = createActionSet('LOGIN');export const LOGOUT = createActionSet('LOGOUT'); 由于异步操作开销比较大，所以对于已经执行过的流程，可以缓存起来，GitPoint使用了reselect库来执行这个操作 12345678import &#123; createSelector &#125; from 'reselect';export const getAuthFromStore = state =&gt; state.auth;//缓存了用户的认证信息和当前的地理位置export const getAuthLocale = createSelector( getAuthFromStore, auth =&gt; auth.locale); 具体执行state修改的是reducer文件.首先从auth.type.js中加载 actionType,目的是要和组件dispacth的 actionType做匹配，决定要执行那个修改state的操作 初始State 12345678910111213141516export const initialState = &#123; isLoggingIn: false, isSigningOut: false, isAuthenticated: false, accessToken: null, user: &#123;&#125;, hasInitialUser: false, orgs: [], events: [], // TODO: there should not be a dependency here that can't be constructor injected. locale: getLocale(), isPendingUser: false, isPendingOrgs: false, isPendingEvents: false, error: '',&#125;; 根据actionType对state做出操作(Immutable) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//auth.reducer.jsexport const authReducer = (state = initialState, action = &#123;&#125;) =&gt; &#123; switch (action.type) &#123; case LOGIN.PENDING: return &#123; ...state, isLoggingIn: true, isAuthenticated: false, &#125;; case LOGIN.SUCCESS: return &#123; ...state, isLoggingIn: false, isAuthenticated: true, accessToken: action.payload, &#125;; case LOGIN.ERROR: return &#123; ...state, isLoggingIn: false, isAuthenticated: false, error: action.payload, &#125;; case LOGOUT.PENDING: return &#123; ...state, isSigningOut: true, &#125;; case LOGOUT.SUCCESS: return &#123; ...initialState, hasInitialUser: false, &#125;; case LOGOUT.ERROR: return &#123; ...state, isSigningOut: false, error: action.payload, &#125;; case GET_AUTH_USER.PENDING: return &#123; ...state, isPendingUser: true, &#125;; case GET_AUTH_USER.SUCCESS: return &#123; ...state, isPendingUser: false, hasInitialUser: true, user: action.payload, &#125;; case GET_AUTH_USER.ERROR: return &#123; ...state, isPendingUser: false, error: action.payload, &#125;; case GET_AUTH_STAR_COUNT.PENDING: return &#123; ...state, isPendingStarCount: true, &#125;; case GET_AUTH_STAR_COUNT.SUCCESS: return &#123; ...state, isPendingStarCount: false, starCount: action.payload, &#125;; case GET_AUTH_STAR_COUNT.ERROR: return &#123; ...state, isPendingStarCount: false, error: action.payload, &#125;; case GET_AUTH_ORGS.PENDING: return &#123; ...state, isPendingOrgs: true, &#125;; case GET_AUTH_ORGS.SUCCESS: return &#123; ...state, isPendingOrgs: false, orgs: action.payload, &#125;; case GET_AUTH_ORGS.ERROR: return &#123; ...state, isPendingOrgs: false, error: action.payload, &#125;; case CHANGE_LOCALE.SUCCESS: return &#123; ...state, locale: action.payload, &#125;; default: return state; &#125;&#125;;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"https://React-Apollo.github.io/tags/React-Native/"},{"name":"Redux，styled-compoents","slug":"Redux，styled-compoents","permalink":"https://React-Apollo.github.io/tags/Redux，styled-compoents/"}]},{"title":"摘要|Restaruant Review GraphQL Schema","slug":"摘要|Restaruant Review GraphQL Schema","date":"2019-02-09T07:56:00.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2019/02/09/摘要|Restaruant Review GraphQL Schema/","link":"","permalink":"https://React-Apollo.github.io/2019/02/09/摘要|Restaruant Review GraphQL Schema/","excerpt":"","text":"主要流程 🔘 设计APP需要的数据类型 🔘 返回“分页”处理的列表数据 🔘 考虑APP应该具有的合理需求，然后设计操作 🔘 为GraphQL查询编写输入类型 🔘 从安全角度考虑认证的需求 初始数据类型 🔘 拥有者， 可以添加restaurant 到数据库 🔘 认证用户 可以给restaurant写评价 🔘 认证用户 可以给为 restaurant添加favorite标记 🔘 认证用户 可以查看喜欢restaurant的列表 🔘 没有认证用户 可以搜索restaruant,查看评分 🔘 认证用户 可以看到某个restaurant的具体评论 添加标记的需要在执行流程前执行授权检测 有三个基本类型 User Location, restaurant的位置 Review 基础的GraphQL Schema12345678910111213141516171819202122232425262728 type User &#123; id: ID! name: String! email: String locations: [Location] reviews: [Review] favorites: [Location]&#125;type Location &#123; id: ID! owner: User! name: String! longitude: Float latitude: Float address: String averageRating: Float favoritesCount: Int reviews: [Review]&#125;type Review &#123; id: ID! owner: User! location: Location! content: String! rating: Number!&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"}]},{"title":"使用配置对象消除多分支结构","slug":"使用配置对象消除多分支结构","date":"2019-02-07T13:20:00.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2019/02/07/使用配置对象消除多分支结构/","link":"","permalink":"https://React-Apollo.github.io/2019/02/07/使用配置对象消除多分支结构/","excerpt":"","text":"使用配置对象消除多分支结构 在Javascript设计模式中已经有这个原理了，使用分支关键词和对象的键做匹配，把多分支结构的判断或者切换消除掉实现BootStrap颜色配置 1234567891011121314151617181920212223const Color=&#123;primary:\"palevoletred\",success:'blue',info:'green',danger:'yellow',normal:'white'&#125;const Button = styled.button` /* Adapt the colors based on primary prop */ background: $&#123;props =&gt; props.color ? Color[props.color] : Color.normal&#125;; color: $&#123;props =&gt; props.color ? Color.normal : Color[props.color]&#125;; font-size: 1em; margin: 1em; padding: 0.25em 1em; border: 2px solid palevioletred; border-radius: 3px;`;render( &lt;div&gt; &lt;Button&gt;Normal&lt;/Button&gt; &lt;Button color=\"success\"&gt;Primary&lt;/Button&gt; &lt;Button color=\"info\"&gt;Info&lt;/Button&gt; &lt;Button color=\"danger\"&gt;Danger&lt;/Button&gt; &lt;/div&gt;);","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"}]},{"title":"MicroLink使用","slug":"microlink","date":"2019-02-07T10:24:00.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2019/02/07/microlink/","link":"","permalink":"https://React-Apollo.github.io/2019/02/07/microlink/","excerpt":"","text":"MicroLink使用安装1$ npm install @microlink/react styled-components --save 使用方法12345678import MicrolinkCard from '@microlink/react'// Just provide a URL to create a card&lt;MicrolinkCard url='https://www.theverge.com/tldr/2018/2/7/16984284/tesla-space-falcon-heavy-launch-elon-musk'/&gt;//size:'large' Styling microlink_card: 是根 div micro_card_media: 可以是video或者image mircolink_card_media_image : div用于包装link的preview的background-image microlink_card_media_video_wrapper: video link 的preview包装器 microlink_card_media_video :link video preview 的video元素 micro_card_content: link content 的 div micro_card_content: link content microlink_card_content_title: card title p元素 microlink_card_content_description: card description microlink_card_content_url: link url span元素 使用styled-components进行修饰12345678import MicrolinkCard from '@microlink/react'import styled from 'styled-components'const myCustomCard = styled(MicrolinkCard)` font-family: 'Nitti, \"Microsoft YaHei\", 微软雅黑, monospace'; max-width: 100%; border-radius: .42857em;` 设想是通过爬虫抓取url,然后生成pocket形式的网页","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"Styled-Component","slug":"Styled-Component","permalink":"https://React-Apollo.github.io/tags/Styled-Component/"}]},{"title":"CSS Grid MediaQuery","slug":"Css grid media query","date":"2019-02-05T22:22:00.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2019/02/05/Css grid media query/","link":"","permalink":"https://React-Apollo.github.io/2019/02/05/Css grid media query/","excerpt":"","text":"Css grid media query 通过template来改变不同尺寸下的布局 大屏幕 中屏幕 小屏幕","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://React-Apollo.github.io/tags/HTML/"},{"name":"Responsive","slug":"Responsive","permalink":"https://React-Apollo.github.io/tags/Responsive/"}]},{"title":"摘要|Next.js + Styled Components The Really Simple Guide","slug":"Next.js + Styled Components The Really Simple Guide ","date":"2019-01-30T21:59:00.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2019/01/30/Next.js + Styled Components The Really Simple Guide /","link":"","permalink":"https://React-Apollo.github.io/2019/01/30/Next.js + Styled Components The Really Simple Guide /","excerpt":"","text":"原文参见Next.js自带了styled-jsx的css方法。在Next的实例中有with-styled-components的实例，但是我们需要理解是怎么构建出实例的。 具体构建过程1. 创建项目目录，安装依赖包1mkdir my-next-app &amp;&amp;cd my-next-app &amp;&amp;yarn add next react ract-dom Next.js 现在支持React 16版本 2. 在package.json文件中添加脚本123456789101112&#123; \"scripts\": &#123; \"dev\": \"next\", \"build\": \"next build\", \"start\": \"next start\" &#125;, \"dependencies\": &#123; \"next\": \"^...\", \"react\": \"^...\", \"react-dom\": \"^...\" &#125;&#125; 完成这一步之后，文件系统就是主要的API 入口。 每个.js文件都成为自动处理和渲染的路由。 3. 创建一个/pages 文件夹，建立第一个页面1mkdir pages&amp;&amp; touch pages/index.js 编写./pages/index.js文件 12345Export default ()=&gt;&#123; &lt;div&gt; &lt;h1&gt; My First Next.js Page &lt;/h1&gt; &lt;/div&gt;&#125; 然后在终端中运行命令 yarn dev,浏览器打开http://localhost:3000 截止目前，我们建立了： 自动编译和绑定(借助webpack和babel) 代码热加载 服务端渲染和./pages的索引文件 4. 添加styled-components组件包1yarn add styled-components 现在编辑./pages/index.js文件 1234567891011Import styled from 'styled-components';Export default ()=&gt;&#123; &lt;div&gt; &lt;Title&gt; My First Next.js Pages&lt;/Title&gt; &lt;/div&gt;&#125;;const Title=styled.h1` color: red;` 如果加载文件，会报错，因为配置不正确。接下来完成这一步 5. 添加 babel 插件，定制 .bablerc文件首先安装styled components bable插件 1yarn add -D babel-plugin-styled-components 在项目的根目录下创建 .babelrc文件 1touch .babelrc 添加 babel/preset 添加styled-components插件，设置ssr 标记为 true,displayName为 true,preprocess 为false. 最后得到的.babelrc文件如下 123456789101112131415&#123; &quot;presets&quot;: [ &quot;next/babel&quot; ], &quot;plugins&quot;: [ [ &quot;styled-components&quot;, &#123; &quot;ssr&quot;: true, &quot;displayName&quot;: true, &quot;preprocess&quot;: false &#125; ] ]&#125; 6.创建定制的 _document.js文件如果你之前使用过create-react-app,你就知道主文件在哪里，但是next.js不会暴露出这个文件，但是你可通过添加 _document.js文件来覆盖默认的Document。 1Touch pages/_document.js 我们要扩充 &lt;Document&gt;,并把服务端渲染的样式注入到&lt;head&gt;中。 如果只渲染page，不做其他工作，_document.js文件如下： 12345678910111213141516171819202122import Document, &#123; Head, Main, NextScript &#125; from 'next/document'export default class MyDocument extends Document &#123; static getInitialProps (&#123; renderPage &#125;) &#123; // Returns an object like: &#123; html, head, errorHtml, chunks, styles &#125; return renderPage(); &#125; render () &#123; return ( &lt;html&gt; &lt;Head&gt; &lt;title&gt;My page&lt;/title&gt; &lt;/Head&gt; &lt;body&gt; &lt;Main /&gt; &lt;NextScript /&gt; &lt;/body&gt; &lt;/html&gt; ) &#125;&#125; 添加进styled-components的代码如下： 12345678910111213141516171819202122232425262728293031323334353637import Document, &#123; Head, Main, NextScript &#125; from 'next/document';// Import styled components ServerStyleSheetimport &#123; ServerStyleSheet &#125; from 'styled-components';export default class MyDocument extends Document &#123; static getInitialProps(&#123; renderPage &#125;) &#123; // Step 1: Create an instance of ServerStyleSheet const sheet = new ServerStyleSheet(); // Step 2: Retrieve styles from components in the page const page = renderPage((App) =&gt; (props) =&gt; sheet.collectStyles(&lt;App &#123;...props&#125; /&gt;), ); // Step 3: Extract the styles as &lt;style&gt; tags const styleTags = sheet.getStyleElement(); // Step 4: Pass styleTags as a prop return &#123; ...page, styleTags &#125;; &#125; render() &#123; return ( &lt;html&gt; &lt;Head&gt; &lt;title&gt;My page&lt;/title&gt; &#123;/* Step 5: Output the styles in the head */&#125; &#123;this.props.styleTags&#125; &lt;/Head&gt; &lt;body&gt; &lt;Main /&gt; &lt;NextScript /&gt; &lt;/body&gt; &lt;/html&gt; ); &#125;&#125; 添加完成之后，重启服务器，之前的错误就没有了，&lt;h1&gt;标签应该是红色的。 SSR 的styled-components工作正常了 回顾一下步骤 创建项目，安装依赖包 添加脚本 创建page文件夹和第一个页面文件 添加styled-components 天剑babel插件，并定制.babelrc文件 创建定制的 _document.js文件 如果你已经有了next项目， 需要实现4-6步。这也是在next.js中使用.css文件的方法。","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"Next.js","slug":"Next-js","permalink":"https://React-Apollo.github.io/tags/Next-js/"}]},{"title":"useHooks的函数抽象","slug":"userHooks的抽象方法","date":"2019-01-29T21:39:00.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2019/01/29/userHooks的抽象方法/","link":"","permalink":"https://React-Apollo.github.io/2019/01/29/userHooks的抽象方法/","excerpt":"","text":"useHooks的函数抽象React Hooks的引入 作为实例，表单的输入方法，和setState的方法都是完全一样的，所以可以可以使用useState进一步的做抽象 123456789101112const useFormInput=(intialValue)=&gt;&#123; const [value,setValue]=useState(intialValue); const handleChange=(e)=&gt;&#123; setValue(e.target.value); &#125; return &#123; vaule, onChange:handleChange &#125;;&#125; 在函数式组件中使用时引入不同的初始值 123456789101112const Component=()=&gt;&#123; const name=useFomrInput(\"Mary\"); const surname=useFormInput(\"Poppins\"); return ( &lt;section&gt; &lt;input &#123;...name&#125;/&gt; &lt;input &#123;...surname&#125;/&gt; &lt;/section&gt; )&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"React-Hooks","slug":"React-Hooks","permalink":"https://React-Apollo.github.io/tags/React-Hooks/"}]},{"title":"Chapter 5  GPU acceleration with WebGL","slug":"ch05 GPU  Acceleration with WebGL","date":"2019-01-28T09:45:00.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2019/01/28/ch05 GPU  Acceleration with WebGL/","link":"","permalink":"https://React-Apollo.github.io/2019/01/28/ch05 GPU  Acceleration with WebGL/","excerpt":"","text":"Deeplearning in Broswer Translation Demo JavaScript代码是在中央处理器(CPU)里执行的.CPU单元速度很快,可以执行复杂的任务,但是处理任务总是以序列方式执行,这会导致一个很大的瓶颈.我们可以使用 WebWorkers来利用所有的 CPU内核,但是现代计算机很少有使用超过16核的CPU.而且,JavaScript 任然是一种解释性语言,没有和编译性语言例如C或者 C++那样性能优越. 对于深度学习计算支持最好的是 GPU.现代GPU,即使在移动设备上都有成百个处理器单元.这些单元可以同时并行工作.幸运的是,深度学习计算也可以重度依赖并行操作,因为神经元层的每个单元和同层的其他神经元都是独立的. WebGL 深度学习实现对于处理实时的视频流是必须的. 神经网络必须要处理视频的每一帧图像,其中每帧图像都有很多像素,代表着高维度空间的一个输入向量.这个需求对于 GPU提出了特别的要求. 而且,把一个(html5)元素转变为 WebGL构造很容易,也很有效,这个构造可以存储在 GPU 内存中. WebGL 是对 OpenGL ES的 JavaScript 的绑定.到目前为止,这是唯一可以在浏览器端底层使用 GPU硬件和并行计算加速深度学习的方法.不管是由 WebGL,还是直接使用 OpenGl 的原生应用(例如 C语言),发送到 GPU的指令是相同的. 在本章,我们首先来学习一下WebGL 是如何工作的,看看如何借助它以颜色梯度形式来画出两个三角形组成的正方形. By adding a few lines of graphic code this simple color gradient is metamorphsosed into a beautiful colored Mandelbrot fractal. 接着会了解 WebGL 的威力,以及最多计算执行的位置.将会改进代码,构建第一个 GPU模拟,这是一个生命游戏 of Conway. 使用温度散射展示从离散到连续的模拟,处理精确度和优化问题. 这两个简单的问题将会帮助你理解 WebGL程序的效率,同时也会介绍 WebGL 编程模型和语言的内容. 在本章第二部分,我们会返回到深度学习,并解释实现用于常规矩阵操作的 特殊shader. 这些快速矩阵操作(例如卷积(convolution),池化(pooling),激活(activation)等等)是所有深度学习框架的基础. 我们要构建自己的GPU 线性代数库,命名为 WGLMatrix.会使用这个库来训练一个神经网络用于识别 MNIST 数据集的手写体数字,这也是图像分类里的 Hello World 程序.最后我们会优化学习脚本,使之速度比 Python/NumPy 的 CPU 版本快5倍. WebGL 深度学习的速度用于处理事实视频流是足够快了. 这张图是借助用户的摄像头实现的 太阳镜 VR试戴系统. 卷积网络识别到面部,方位,旋转甚至是光线强弱. 然后使用这些信息画出一个眼镜的3D模型. WebGL不是一个3D库.尽管有很多的工具可以实现3D渲染算法,整个投影处理过程需要使用单纯的矩阵操作来开发位移和摄影矩阵操作. WebGL是一个rasterization库:它会把向量对象转变为离散向量值.在上图左:一个向量化的猫.每个点都是向量,编码从初始点开始的位置.类似的图可以被无限的放大,但是不能直接显示在屏幕上.右图:由像素形成的图像. 正如我们在简介中学到的,WebGL通过更多的渲染通道让你可以运行繁重的并行操作. 然而和 CUDA或者 OpenGL 不同,WebGL 不是运行并行代码的通用计算 通道.因此要从并行 GPU构架中获益,我们需要把所有的深度学习相关操作变换为WebGL渲染通道. 这里的解释应该让你有了足够的动机来学习本部分内容,尤其要理解渲染通道的基本原理,shader和 GLSL. WebGL由 Khronos集团标准化,类似 OpenGL.它的规范在https://www.khronos.org/registry/webgl/specs.. WebGL 的输出是在 $$ 元素中渲染的.所以,使用 WebGL的第一步就是在web 页面的 HTML代码中插入 $$ 元素: 123&lt;body&gt;&lt;canvas id='myWebGLCanvas' height='512' width='512'&gt; &lt;/canvas&gt;&lt;/body&gt; 页面加载以后,使用 JavaScript代码获取到 canvas 元素,创建 WebGL 上下文 GL.在这个节点要检测用户的配置是否和WebGL兼容: 1234567var myCanvas=document.getElementById('myWebGLCanvas'); var GL; //获取canvas元素try &#123;GL=myCanvas.getContext( 'webgl',&#123;antialias: false, depth: false&#125; );&#125; catch(e) &#123;alert('Cannot init a WebGL context. So sad...:(');&#125; 我们已经关闭了智能感应和深层的缓存,因为我们要用 WebGL 来进行计算,而不是来执行渲染操作. 在这个操作之后, $$ 元素 已经完全可以用于 WebGL 操作了. 不要用于 canvas2D渲染或者没有绑定 WebGL 上下文的操作.在接下来的实例中, GL 变量就是 WebGL API 的接入点:所有的 WebGL 函数和属性都是 这个上下文的方法和属性. 从 WebGL的视点触发,用于画图的区域叫做视口. 它的坐标系总是从中心出发,所以 X 轴是从-1(左)到1(右), Y轴从-1(底部)到1(顶部). WebGL 的工作流程 WebGL 工作流划分为: 主机代码,运行在 GPU,使用JavaScript语言编写.负责把几何,矩阵操作绑定到 GPU 内存,并处理用户的交互操作. 图形代码,运行在 GPU,包装成称为shaders 的小段程序. 使用 GLSL,类 C 风格的语言编写(Graphic Library Shading Language). JavaScript 不能解析原生的 GLSL代码,所以 GLSL 源代码和变量名总是被声明为字符串,然后传递给 WebGL 上下文. 初看,这是一个很大的缺陷,然而当变量名和 TypeScript(译注:JavaScript的超语言类型,最大特点是强类型) 同时工作时,TS使用的模板字符串会极大的改进 GLSL shaders代码的可读性. 然而在本书,我们还是坚持使用原生 JavaScript. WebGL可以提供两种 shaders的访问权力: vertex shader 接收几何数据作为输入,并进行变换. 操作的是 vertex 数据(几何向量点),可以存储在 Vertex 缓存对象中(VBOs). 这个shader是在 rasterization处理之前执行的. fragement shader 在智能感应关闭之后,每画一个像素,只能调用一次. 在resterization之后执行,会为每个输入像素插值 vertex几何向量. 对于每个像素,只渲染一次,决定这个像素的输出颜色. 例如,如果用 WebGL 来话一个 3D 立方体: 立方体的每个角分别执行一次 vertex shader操作,该操作把3D位置投影到视口. fragment shader负责为立方体的每个像素应用颜色. 一组每个类型的 shader集合就称为 shader 程序. shader program 完整的定义了一个特定的渲染方法(例如, 用于3D渲染的材质).两种 shader都有相同的结构: 1234567//声明 I/O 变量//定制函数//主循环void main(void)&#123;//主要代码在这里ouput_variable=value;&#125; vertex shader 的输出变量总是 gl_position. 它是一个四维的向量$[x,y,z,w]$ .in clipping坐标系中.在视口中,2D点的坐标是 $[x/w,y/w]$ . $z/w$ 缓存值的深度,在3D渲染中用于处理堆叠的深度. $w$ 是3D坐标到4D坐标同一转换的扩展,4D坐标实现仿射变换(旋转,缩放和转位操作). 可以使用单个的矩阵乘法操作执行同一坐标的仿射变换. fragment shader的输出变量根据 GLSL 的版本不同,可以是 gl_FragColor 或者是 gl_FragData . 它是像素的 RGBA 值,RGBA 中的 A 代表alpha通道,所以是用来管理透明度(transparency)的. 对于标准的颜色渲染,每个颜色通道被钳位在0到1之间(例如[1,1,1,1]是不透明的白色,[0.5,0,0,1]是50%透明度的深红色,[1,0,0,1]是不透明的黑色). 上图是 WebGL的简化工作流程图(我们有意的去掉了 GLSL I/O类型,因为它们不可能用于 GPGPU).在左侧是数据: 用于 VBPs的 每个 vertex 数据,用于构造或者 JavaScript 数字的 类型数组. 中间是 GLSL I/O变量:他们是 GLSL和JavaScript之间的桥梁.这些变量是 JavaScript的某种指针(pointer),可以直接用在shader中.左侧是 GPU的代码. shaders之间的rasterization 有图形驱动自动执行. Fragment shader 渲染我们在fragment shader中使用主要的计算. 使用两个三角形填充视口,在 fragment shader中执行所有的渲染操作. 使用 WebGL shaders 用于计算,这是最普通的练习.使用这两个三角形可以确保我们可以对每个像素执行一次fragment shader. 如果三角形没有覆盖整个视口, fragment shaders只会在三角形覆盖的部分执行. WebGL工作流密不可分,我们不能单独使用shader. 所以,我们也必须要使用vertex shader,但是只用来渲染两个三角形.之后,三角形每个像素的颜色由fragment shader来完成. 之后我们会用计算代替渲染.参考本书代码的第一个仓库:chapter3/O_webglFirstRendering. VERTEX BUFFER OBJECTS声明一个 JS 类型数组包含视口四个角的2D坐标. 1234var quadVertices = new Float32Array([­1, ­1, //bottom left corner ­&gt; index 0 ­1, 1, //top left corner ­&gt; index 11, 1, //top right corner ­&gt; index 21, ­1 //bottom right corner­&gt; index 3 ]); 然后,使用 vertices 的索引把这四个点分成两组,构建出两个互相不重叠的三角形: 123var quadIndices = new Uint16Array([0,1,2, //first triangle if made with points of indices 0,1,2 0,2,3 //second triangle]); 这张图上,画出了填充视口的两个三角形.顶部靠左的为蓝色,顶点是 0,1,2.右下角红色的是 0,2,3. 数据存储在 JS 数组中.通过创建 Vertex Buffer Objects(VBO),发送给 GPU内存.VBO就是存储在 GPU内存中的的简单数组形式. 1234//send vertices to the GPU:var quadVerticesVBO = GL.createBuffer(); GL.bindBuffer(GL.ARRAY_BUFFER, quadVerticesVBO); GL.bufferData(GL.ARRAY_BUFFER, quadVerticesVBO, GL.STATIC_DRAW);//send indices to the GPU:var quadIndicesVBO = GL.createBuffer(); GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER,quadIndicesVBO); GL.bufferData(GL.ELEMENT_ARRAY_BUFFER,quadIndicesVBO,GL.STATIC_DRAW); SHADER ＰＲＯＧＲＡＭvertex shader接收 四维的 vertices作为输入,在视口的四个角输出.这里是 GLSL中的的vertex shader源代码 1234attribute vac2 position;void main(void)&#123; gl_postion=vec4(position,0.,1.); position in clip coords&#125; 如上代码所示,我们只需要 Vertices 的 x和 y坐标.因此设定深度为 z=0和w=1. 接着写一个 fragment shader, 用于输出红色通道,绿色通道中每个像素的2D位置. 从现在开始,我们会经常使用这个技巧来编码输出像素的颜色通道. 12345precision highp float;uniform vec2 resolution; //resolution in pixelsvoid main(void)&#123;//gl_FragCoord is a built­in input variable. //It is the current pixel position, in pixels: vec2 pixelPosition=gl_FragCoord.xy/resolution; gl_FragColor=vec4(pixelPosition, 0.,1.);&#125; 把两个 shader都声明为 JS的字符串,单独编译他们: 123456789101112131415161718//declare shader sources as stringvar shaderVertexSource=\"attribute vec2 position;\\n\" +\"void main(void)&#123;\\n\" +\"gl_Position=vec4(position, 0., 1.);\\n\"+\"&#125;\";var shaderFragmentSource=\"precision highp float;\\n\"+\"uniform vec2 resolution;\\n\"+\"void main(void)&#123;\\n\"+\"vec2 pixelPosition=gl_FragCoord.xy/resolution;\\n\" +\"gl_FragColor=vec4(pixelPosition, 0.,1.);\\n\"+\"&#125;\";//function to compile a shaderfunction compile_shader(source, type, typeString) &#123; var shader = GL.createShader(type); GL.shaderSource(shader, source); GL.compileShader(shader);if (!GL.getShaderParameter(shader, GL.COMPILE_STATUS)) &#123; alert(\"ERROR IN \"+typeString+ \" SHADER: \"+ GL.getShaderInfoLog(shader)); return false;&#125;return shader; &#125;;//compile both shaders separatelyvar shaderVertex = compile_shader(shaderVertexSource, GL.VERTEX_SHADER, \"VERTEX\");var shaderFragment = compile_shader(shaderFragmentSource, GL.FRAGMENT_SHADER, \"FRAGMENT\"); 我们创建了 shader program, 包含了用于特定渲染的所有图形代码: 12var shaderProgram=GL.createProgram(); GL.attachShader(shaderProgram, shaderVertex);GL.attachShader(shaderProgram, shaderFragment); 最后,用 JS 类指针变量关联 GLSL I/O变量,这个操作目的是之后可以从 JS 中更新 GLSL 的值. GLSL变量命名总是设定为字符串,因为 JS理解不了 GLSL: 1234567//start the linking stage:GL.linkProgram(shaderProgram);//link attributes:var posAttribPointer = GL.getAttribLocation(shaderProgram,\"position\"); GL.enableVertexAttribArray(posAttribPointer);//link uniforms:varresUniform = GL.getUniformLocation(shaderProgram, \"resolution\"); 渲染时间唯一在 GPGPU中使用的的 VBP 是一个四核, 所以我们可以直接绑定一次,一劳永逸: 12GL.bindBuffer(GL.ARRAY_BUFFER, quadVerticesVBO); GL.vertexAttribPointer(posAttribPointer, 2, GL.FLOAT, false, 8,0);GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, quadIndicesVBO); GL.vertexAttribPointer drawcall 细节是关于如何从 VBO数据中解析 shader program属性. 它意味着,posAttribPointer 属性(之前关联到 GLSL “position”变量) 有两个元素,类型是 GL.FLOAT.false 禁止对到来的 vertex 执行归一化操作,8 是1个vertice的字节大小(8个字节=两个元素*4字节,因为一个GL.FLOAT元素用4字节存储). 来触发渲染吧: 1234 GL.useProgram(shaderProgram);//update GLSL \"resolution\" value in the fragment shader: GL.viewport(0,0,myCanvas.width, myCanvas.height);//update GLSL \"resolution\" value in the fragment shader: GL.uniform2f(resUniform, myCanvas.width, myCanvas.height); //trigger the rendering:GL.drawElements(GL.TRIANGLES, 6, GL.UNSIGNED_SHORT, 0); GL.flush(); 了解 GPU的威力每个像素的颜色都是由fragment shader 声明 gl_FragColor=vec4(pixelPosition,0.,1.) 并行赋值的. 每个像素只知道由 内置变量gl_FragCoord 给出的相对位置. 这就是WebGL并行操作的威力.经过渲染的像素数组纹理和 CUDA 核的渲染类似. 用下面代码替换fragment shader中的 main 函数. 123456789101112void main(void)&#123;vec2 pixPos=gl_FragCoord.xy/resolution;//translate and scale:vec2 pixPosCentered=1.3*(pixPos*2.­vec2(1.55,1.));vec2 z = pixPosCentered, newZ; float j = 0.;for(int i=0; i&lt;=200; i+=1) &#123;newZ = pixPosCentered+vec2(z.x*z.x­z.y*z.y,2.*z.y*z.x); if(length(newZ) &gt; 2.) break;z=newZ; j+=1.;&#125;//generate RGB color from j:vec3 color=step(j, 199.)*vec3(j/20., j*j/4000., 0.);gl_FragColor = vec4(color,1.); &#125; 这个漂亮的分形图渲染速度很快,因此可以在每秒60帧的的渲染循环里平滑运行.可以在github仓库 ,chapter3/1_mandelBrot 看到.关于这个分形的介绍可以看 http://nuclear.mutantstargoat.com网站的介绍. 仅仅使用fragment shader 就可以获得很多有趣的渲染结果,包括使用 raymarching 算法的 实时 raytracing实现. 详细内容可以参见 http://shadertoy.com 使用 WebGL 的通用计算不再画漂亮的颜色梯度或者分形图, 我们来开始来处理计算. 在这一部分,要解释使用 WebGL(GPGPU) 的通用计算原理. 我们可以用使用 WebGL在两个不同的位置执行并行操作: 以fragment shader或者是 vertex shader. 在vertex shader中处理主工作负载非常不便,因为他的输出 gl_Position不能像 gl_FragColor一样直接读取或者保存在texture或者另一个对象中. gl_Position控制着位置,所以如果某些计算结果在视口中得到相同的位置,它们就会重叠在一起.如果滑出视口,就变为不可读. 此外,通常处理的 vertices比输出的像素要少,因此在fragment shader中的的并行计算会更有效. 再者,我们仍然会以fragment shader的输出来结束读取或者保存结果.说到 GPGPU,我们总是使用vertex shader 来简化填充视口的操作,在fragment shader中执行整个计算部分. 不再使用渲染 canvas 元素到屏幕的方法,取而代之的是渲染到所谓的 framebuffer,framebuffer 位于 GPU 的内存中,在接下来的drawcall中,使用这个framebuffer 作为texture,并从fragment shader 中读取它的值.尽管 一个texture通常被作为一个图片储存在 VRAM 中,apprehend it as a 2D array with four channels per value (which are the RGBA color channels). 它保存了计算结果,4通道可以根据任意规范来赋值. 这是一种过时的 GPGPU,因为还有非常特别的GPU计算库或者 APIS,例如 OpenGL或者 CUDA. 浏览器端热门的 JS深度学习库(例如 TensorFlow.js) 把整个深度学习模型映射到GPU的 VRAM 中,每层的输出被写入到texture,前馈至正在等待 fragment shader的下一层神经元. 我们想避免从 JS 的主线程中读取 GPU内存,而是把整个深度学习模型的执行图作为一个巨大的渲染路径. WebGL排错WebGL很难排错,因为可以在不同的支持条件下执行,图形硬件之间有一些非常大的差别. 某些浏览器扩展例如 WebGL inspector或者 WebGL Insight 可以检测显卡内存是否能够链接到特定 WebGL上下文.浏览器检查texture,VBOs,或者列出drawcalls也是有可能的. 与硬件有关的错误如果你遇到了硬件相关的错误,你可以: 打开 chrome://gpu 收集有关Chrome WebGL的支持情况 访问 webglreport.com 收集 WebGL1 和 WebGL2的支持,扩展和图形硬件限制情况. 如果 WebGL在特定规范下,怎么也不工作,可能是显卡的驱动被浏览器列入了黑名单,之所以这样是因为发现了安全漏洞. 更新驱动应该就能解决问题. GLSL 句法错误当shaders 在编译的时候,会会探测可能的 GLSL 句法错误. 这些错误是显式的,有行号(以 GLSL代码的形式)声明,所以比较容易修复. 在使用 shader时, 这个错误是非常常见的. WEBGL 运行时错误大多数此类错误会在标准 JS 终端中以警告的形式出现.如果一个定制的 framebuffer没有被绑定到 texture,或者 texture初始化定义的类型长度不够. 错误信息是显式的,但是 drawcall触发错误 JS 行号没有申明. 可以在 JS终端中设置断点并做分析.我建议在断点之前添加 GL.finish() 声明,目的是确保已经执行了所有暂停的 drawcall. 算法错误这种错误很难分析,因为在 shaders中设置断点是不可能的. 要实现特殊的渲染方法以标准framebuffer的颜色通道形式显示模拟变量,借此可以高亮问题位置. 渲染到 texture我们开发了 Conway的生命游戏,展示用于计算的 渲染到texture的概念.WebGL和 JavaScript 实现的游戏代码可以在本书的代码仓库中看到.运行在低级显示硬件的WebGL程序比在高端 CPU上的运行速度快4000倍.这是一个很好的例子在相对简单的代码上就可以显示并行运算的效果. 源代码在 github仓库, chapter3/x_renderToTexture 首先声明模拟的全局参数: 1234var SETTINGS=&#123;simuSize: 256, //simulation is done in a 256*256 cells //squarenIterations: 2000 //number of computing iterations&#125;; 创建默认的framebuffer对象(FBO),在 WebGL上下文实例化时绑定到上下文上.渲染发生在控制显示的framebuffer上.为了渲染到texture(RTT),我们需要创建定制的framebuffer对象.然后绑定到上下文: 1var rttFbo=GL.createFramebuffer(); GL.bindFramebuffer(GL.FRAMEBUFFER, rttFbo); 这个函数JS类型数组创建了texture: 12345678910111213function create_rttTexture(width, height, data)&#123; var texture=GL.createTexture(); GL.bindTexture(GL.TEXTURE_2D, texture); //texture filtering://pick the nearest pixel from the texture UV coordinates //(do not linearly interpolate texel values): GL.texParameteri(GL.TEXTURE_2D,GL.TEXTURE_MAG_FILTER, GL.NEAREST); GL.texParameteri(GL.TEXTURE_2D,GL.TEXTURE_MIN_FILTER, GL.NEAREST);//do not repeat texture along both axis:GL.texParameteri(GL.TEXTURE_2D,GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE );GL.texParameteri(GL.TEXTURE_2D,GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE);//set size and send data to the texture:GL.texImage2D(GL.TEXTURE_2D,0, GL.RGBA, width, height, 0, GL.RGBA,return texture; &#125; 不可能同时读取texture和渲染它. 所以我们需要创建两个texture.两个 texture 都存储了单个红色通道的 细胞声明(如果细胞是活的,红色通道的值就是1.0,如果死了,就等于0.0): 12var dataTextures=[ create_rttTexture(SETTINGS.simuSize,SETTINGS.simuSize,data0), create_rttTexture(SETTINGS.simuSize,SETTINGS.simuSize,data0)]; data0是随机初始化的UnitArray,储存了texture的 RGBA值.在第一次模拟遍历期间,使用dataTexture[0]渲染到dataTexture[1],接着交换两个texture,然后重新遍历. 我们需要两个shader程序: 计算shader 程序接受细胞状态 texture作为输入,并返回更新的细胞状态. 在模拟的末尾,渲染的shader程序使用一次,用于在画布上显示结果 两个shader 程序需要同样的vertex shader,仍然画出两个三角形填充视口.所有的逻辑执行都通过fragment shader执行. 这里是计算fragment shader的主函数. 实现了Conway 的生命游戏: 12345678910111213void main(void)&#123;//current position of the rendered pixel:vec2 uv=gl_FragCoord.xy/resolution;vec2 duv=1./resolution; //distance between 2 texels //cellState values: 1­&gt;alive, 0­&gt;dead:float cellState=texture2D(samplerTexture, uv).r; //number of alive neighbors (Moore neighborhood): float nNeighborsAlive=texture2D(samplerTexture, uv+duv*vec2(1.,1.)).r+ texture2D(samplerTexture, uv+duv*vec2(0.,1.)).r+ texture2D(samplerTexture, uv+duv*vec2(­1.,1.)).r + texture2D(samplerTexture, uv+duv*vec2(­1.,0.)).r + texture2D(samplerTexture, uv+duv*vec2(­1.,­1.)).r + texture2D(samplerTexture, uv+duv*vec2(0.,­1.)).r + texture2D(samplerTexture, uv+duv*vec2(1.,­1.)).r + texture2D(samplerTexture, uv+duv*vec2(1.,0.)).r;if (nNeighborsAlive==3.0)&#123; cellState=1.0; //born&#125; else if (nNeighborsAlive&lt;=1.0 || nNeighborsAlive&gt;=4.0)&#123; cellState=0.0; //die&#125;;gl_FragColor=vec4(cellState, 0., 0.,1.);&#125; texture2D 声明从texture(也称为一个texel)获取一个像素.它的参数是texture 赝本和texel 坐标. 根据GPU的能力强弱,在 一个fragment shader中大概可以同时使用16个texture. 确切的数字可以通过声明获得. GL.getParameter(GL.MAX_TEXTURE_IMAGE_UNITS). 当然你可以实例化更多的texture,但是不能都同时使用. 样本在 shader中有类型 uniform sampler2D 但是赋值有点想 JS 的整数: 12345678//At the linking stepvar _samplerTextureRenderingUniform=GL.getUniformLocation( shaderProgramRendering,'samplerTexture');//...//We affect the sampler value to channel 7, like an integer GL.useProgram(myShaderProgram); GL.uniform1i(_samplerTextureRenderingUniform, 7);//...//Just before the rendering://we activate the texture channel 7: GL.activeTexture(GL.TEXTURE7);//we bind myTexture to the activated channel: GL.bindTexture(GL.TEXTURE_2D, myTexture); GLSL的第二个参数声明 texture2d是 textures坐标,也称为UV坐标.它是 vec2的实例,标记获取的texel的位置.它的两个元素都在 0.0-1.0之间. 来准备一下模拟步骤: 12GL.useProgram(shaderProgramComputing);GL.viewport(0,0,SETTINGS.simuSize,SETTINGS.simuSize); 接着加载模拟循环: 12345for (var i=0; i&lt;SETTINGS.nIterations; ++i)&#123;//dataTextures[0] is the state (read): GL.bindTexture(GL.TEXTURE_2D, dataTextures[0]); //dataTextures[1] is the updated state (written): GL.framebufferTexture2D(GL.FRAMEBUFFER,GL.COLOR_ATTACHMENT0,GL.TEXTURE_2D, dataTextures[1], 0); GL.drawElements(GL.TRIANGLES, 6, GL.UNSIGNED_SHORT, 0);dataTextures.reverse(); &#125;&#125; GL.framebufferTexture2D(...)意味着在当前framebuffer 范围之内(就是rttFbo)画出的每个内容也要滑入到texture dataTextures[1]. 以渲染步骤结束: 1234//come back to the default FBO (displayed on the canvas):GL.bindFramebuffer(GL.FRAMEBUFFER, null); GL.useProgram(shaderProgramRendering); GL.viewport(0,0,myCanvas.width, myCanvas.height); //[...]//trigger the rendering:GL.drawElements(GL.TRIANGLES, 6, GL.UNSIGNED_SHORT, 0); GL.flush(); 上图是 Conway 生命游戏的模拟结果.在仓库代码中,我们已经修改了初始值,从模拟中心(左边图)开始的活细胞呈现方形.经过2000轮迭代之后,复杂图形出现了(右图). 精确度的重要性在 Conway游戏中,我们只使用离散值:细胞要么是活要么是死.但是如果你需要使用连续值,你就有可能被 WebGL默认的八位精确度限制住.事实上,,每个gl_FragColor的元素都是用八位编码,并且被钳位在0~1之间.每个元素的值只有 $2^8=256$ 中可能性. 这对于颜色编码就足够了,因为人眼不能分辨一个比特的颜色差异. 但是在深度学习模型中我们需要更高的精确度,因为经常需要处理浮点值.16比特的浮点值(GL.HALF_FLOAT)可能就够了.但是某些配置只有32比特精确度(GL.FLOAT)才能使用.需要以下能力: FLOAT或者HALF_FLOAT texture的 实例化 渲染 texture 到 FLOAT或者HALF_FLOAT texture 如果你使用 $WebGL_1$,就需要 OES_TEXTURE_FLOAT或者OES_TEXTURE_HALF_FLOAT 扩展(并不总是能实现).接着仍然需要测试 渲染到 FLOAT或HALF_FLOAT texture 如果使用 $WebGL_2$ 这些需求已经满足了,因为 FLOAT或HALF_FLOAT 已经包含在规范中. 但是只有渲染到texture,到HALF_FLOAT texture 是规范声明的. $WebGL_2$可以向后兼容$WebGL_1$,通过使用: 1var GL=myCanvas.getContext('webgl2', ...); 在上下文初始化里,应该要执行: 如果使用 $WebGL_2$ ,就是用 具有HALF_FLOAT精确度的 $WebGL_2$ 如果使用 $WebGL_2$: – 得到 OES_TEXTURE_HALF_FLOAT 扩展 – 使用 FLOAT textures 测试 RTT. 如果OES_TEXTURE_FLOAT 扩展不可用或者 如果 RTT不工作: – 获取 OES_TEXTURE_HALF_FLOAT 扩展 – 测试 RTT 在某些 GPU 配置中,我们需要得到 &lt;WEBGL|EXT|OES&gt;_color_buffer_float 扩展.否则就不能把framebuffer 对象绑定到 FLOAT或者HALF_FLOAT texture. 在着色中使用的精确度要在第一行确定: 1precision highp float 它接收三个值: lowp : 计算由八位精确度完成. 速度足够快,但是对于浮点数计算不够精确. 仍然适合于渲染颜色值. medium:highp,lowp或者位于两者之间的精确度,但这要看 GPU 的配置.在使用这个水平的精确度之前,需要使用GL.getShaderPrecisionFormat(GL.MEDIUM_FLOAT) 检测真实的精确度,因为随着显卡的不同,精确度会发生变化. highp : 浮点值使用 16或者32比特 来处理.16比特用于深度学习计算就够了(但是并不总是能用于物理模拟…). 这个水平的真实精确度可以通过运行 GL.getShaderPrecisionFormat(GL.HIGH_FLOAT).检测 GL.getShaderPrecisionFormat(&lt;level&gt;) 的返回值包含有 precision 属性的对象,属性值是 编码着色时浮点数小数部分的位数.例如,32位浮点数就是23,16位的浮点数就是10. 从Conway开始,开发一个热图模拟.包含 浮点 textures.可以在 Github 仓库 ,chapter3/3_RTTfloat. 我们模拟了一个2D的方形铁块,边长是2.56米,温度是100 $o^oC$ .周围由 0 $o^oC$ 的铁块包围,热量随时间散失. 在这幅图中, 左侧:模拟了初始状态,右侧:模拟了2000秒之后的情况. 颜色由 IDL_Rainbow color 图实现,使用fragment 着色,从0~100 $o^oC$ 平衡 优化 使用 WebGL 来实现深度学习网络不太容易.导入了一些复杂的内容,原因是 特定的工作流和依照不同图形硬件而实现的不同执行路径引起. 仅有的目标是提高执行效率,这可能称为一些效率低下代码的遮羞布. 再者说, 速度的确对很多用例很重要. 计算机视觉问题,例如图像分类,分隔或者物体识别,总是针对连续视频流工作,在视频流中要维持 每秒30帧(FPS)的速度.因此,应该要遵循一些基础着色原则. GLSL 开发 和你想的的一样, GLSL开发是整个书的主题(最流行的部分,覆盖率超过1.000页!). 我们会处理一些常见的开发错误. 如果你想更进一步的学习 WebGL 和 GLSL ,你可以尝试 http://webgl.academy 的免费交互课程. 在有可能的情况下,要避免在着色时使用条件声明语句,例如:if...then...else. 思考一下这段计算指数线性单元(ELU) 激活函数: 1234 float ELU(float x)&#123; if (x&gt;=0.0)&#123;return x; &#125; else &#123;return exp(x)­1.0; &#125;&#125; 使用的是 if 声明. 这样做,这段代码会更有效: 123456789101112131415161718192021222324252627282930float ELU(float x)&#123;return mix(exp(x)­1.0, x, step(x, 0.));&#125;``` GLSL内置函数`mix()`,定义为: $mix(x,y,a)=x*(1-a)+y*a$ 使用几个较小的着色器代替单个大的着色器. 如果着色器太长,GPU 的执行缓存会在执行期间发生更新,这就会有拖累.### 注意浮点的特殊性在高精度的着色器上,浮点数根据 GPU不同,使用16比特或者32比特存储.第一位决定符号,之后的位置,对于32位编码,8比特编码指数,23比特编码分数.因为有这个存储方式,32位编码的浮点数最大是 `3.4e38`,最小是`-3.4e38`. 对于16位编码,这个范围要更窄一点.![](https://ws2.sinaimg.cn/large/006tNbRwgy1fx8rnjzng5j30gu0400sq.jpg)本图是32位二进制编码形式.来源:Wikipedia如果计算结果超过了上面的最大值,会被特殊的浮点数替换,`+Infinite`. 怎么处理特殊浮点数例如 `+Infinite`,`-Infinite`,`NaN`,不同硬件策略不同. 接着值计算结果在计算流程中继续传递.特殊的浮点数被存储在`FLOAT`和`HALF_FLOAT` 纹理中.所以如果我们要把结果渲染到纹理,这些特殊值要经过如下的计算.特殊浮点即使在计算步骤是隐式条件下也会出现.考虑一下计算 ELU激活函数的 GLSL 函数:```javascriptfloat ELU(float x)&#123;return mix(exp(x)­1.0, x, step(x, 0.));&#125; 如果 x=100, 这是有可能的结果(x 可以是输入神经元权重的总和),我们得到 ELU(100)=100. 但是 GPU 必须要计算 ELU(100)=mix(exp(100)-1,100,1)=(exp(100)-1)*0+100. 但是 exp(100)= $2.7.10^43$ 超过了浮点最大值. 所以用特殊浮点值 +Infinity 代替. exp(100)-1=+Infinity-1=+Infinity . GPU 计算的 ELU(100)=+Infinity*0+100.但是 +Infinity*0是未定义的,但是它生成了另一个特殊浮点数,NaN. NaN总是会沿着操作流程传递,因为任何包含有 NaN的操作都会输出NaN(相反,Infinite会消失,因为 1/Infinity=0) .GPU输出 ELU(100)=NaN+100=NaN.接着所有下一层连接的神经元收到 NaN值,然后也输出NaN,等等一直继续. 有一些解决办法可以避免出现特殊浮点值: 避免在函数中包含指数(例如, softmax)或者对数.有时候可以用多项式代替. 如果 mix() 或者其他的 GLSL插值函数被调用,确保两个参数都足够小. 这样实现 ELU 更安全: 12345678910111213141516171819202122232425262728293031323334353637383940float ELU(float x)&#123;return mix(exp(­abs(x))­1.0, x, step(x, 0.));&#125;``` - Majorate or minorate.- 使用深度学习技术把权重和偏置保持在较低的值,例如 L1或 L2 正交化.关于因伟达GPU特殊浮点数的规范都可以在官网上看大.### 重视 纹理缓存GPU 有类似 CPU 的多层缓存系统.当纹理素材是通过 `texture2D()`函数声明在片元着色器中获得,GPU 首先会搜索较小但是速度快的缓存. 如果没找到,它会触发一个缓存缺位,接着再第二级稍大,但是速度慢的缓存中查找,直到在最高级的纹理缓存中获取素材信息为止.接着纹理素材被拷贝进底层的高速缓存,在接下来的查找时,速度会加快.如果临近的像素使用的是同样的纹理素材渲染 ,缓存的缺失率很低,着色会加快.但是如果临近像素使用不同的纹理素材, 缓存确实会增加,着色执行效率会显著下降.在一些实例中,有很多方法可以在纹理中安排数据. One of the alternatives is often better optimized for this aspect.![](https://ws3.sinaimg.cn/large/006tNbRwgy1fx8xyfb81bj308e08gq3e.jpg)上图看到的是图形内存, 纹理素材不整齐,但是是以莫顿顺序排列的. 这个处理被称为纹理swizzling. 获取纹理之后,纹理素材的整个线条(显示为红色) 被压入到 GPU 缓存中. 所以 2D的近邻纹理素材获取速度会更快,因为可以在底层的缓存找到.尽管有一些书籍谈到了 纹理缓存(纹理缓存, Michael Dogget ,Lund University) ,缓存实现机制还是因硬件不同而有区别.仍然需要使用不同的硬件测试 WebGL程序,保证它可以在任何地方都可以运行,而且保持足够快的速度.### 颜色通道角色渲染到纹理定义了四个颜色通道和四个颜色通道帧缓存. 他们以不同的方式使用:- 只有一个通道被使用,像 Conway 游戏模拟一样. 但是他不能被优化,因为 GPU无论什么时候都会同时处理四个向量和矩阵.所以我们要为相同的操作执行四次计算.- 每32比特的值可以分包进四个 RGBA 8比特元素中.之后这些元素可能根本不会用于浮点纹理. 主要的缺陷是 每个片元着色器应该从纹理解压缩出的 RGBA 值应该是32比特的值,然后压缩为`gl_Fragcolor`的 8比特 RGBA通道.- 四个神经元网络可以并行运行在四个 RGBA 通道上. 四个神经元学习的是不同的初始参数,输出稍有不同.输出结果是四个神经元网络的平均值. 并行的四个通道有助于减少输出的噪音.### 防止抖动WebGL 状态可以通过使用`GL.enable()`或者`GL.disable()` 指令来修改. 他们的状态会被保留.所以 WebGL上下文的状态需要改变一次. 在片元着色器用于计算时,抖动要关掉,因为它有可能会改变输出值. It consists in applying some noise to the fragment shader output to avoid color quantization visual artifacts.```javascriptGL.disable(GL.DITHER); 在这张图上,可以看到如果分辨率比计算的颜色精度低,抖动就会在framebuffer中改变颜色像素值.在左边:图像是32比特 RGBA 颜色.中间:2比特 RGBA 颜色.颜色精度降低,猫的每个像素由调色板中最类似的颜色代替. 右边图也是2比特的颜色,但是打开了抖动. 像素颜色不在是调色板中最近似的颜色:为了避免出现边界,引入了一些噪声. 避免帧缓存交换使用GL.framebufferTexture2D,实例化一个帧缓存,每次需要渲染到特定的纹理时,在其上动态绑定的做法比使用GL.bindFramebuffer有效率的多,使用GL.bindFramebuffer时,每次渲染一个纹理,都重新实例化一个新的framebuffer. 的确,GL.bindFramebuffer执行的计算开销非常大. 一个三角形比两个更好相比在视口上画出两个三角形,我们更愿意画出单个更大的三角形(定点是:[-1,1],[3,-1],[-1,3]).单个大三角形的速度稍快一点. 片元着色器仍然是针对每个像素执行一次,感谢 WebGL 整合进图形流水线的 $scissor$ 测试,使之成为默认的的选项. 从CPU到GPU,再从 GPU到 CPU在一开始,数据不管是图片,视频还是数组都由Javascript处理,所以它们注册,并存储在 CPU的内存汇总,首先由 CPU 处理. 接着被发送到 GPU,使用 GPU 的着色器处理.最后可能在 CPU端再次使用到经过着色的数据.所以我们需要把数据从 CPU发送到 GPU,接着数据原路返回. 浮点纹理初始化浮点纹理从 JavaScript数据初始化而来.例如,如果突出权重被存储在纹理中,我们 会使用从之前训练或者匹配特定随机分布获取的 JavaScript 数组值来填充纹理. 如果纹理储存了 GL_FLOAT 元素(每个浮点数使用32比特),初始化是简洁明了的: 1234//small variation between WebGL1 and 2:var internalPixelFormat=(ISWEBGL2)?GL.RGBA32F:GL.RGBA; GL.texImage2D(GL.TEXTURE_2D, 0, internalPixelFormat,&lt;width&gt;, &lt;height&gt;,0, GL.RGBA, GL.FLOAT, &lt;instance_of_Float32Array&gt;); 但是如果纹理存储的是GL.HALF_FLOAT类型,从数组的初始化就很难了,因为 JavaScript 没有 Float16Array类型. 在 JavaScript 端,我们必须要使用每值16比特的形式编码浮点数(1比特符号,5比特指数,10比特分数). 接着要把编码数据存入 JavaScript Unit16Array中. 在本书的仓库中有 JS函数编码 Float32Array-Unit16Array的方法(参见 RTTfloat 热图模拟). 接着使用Unit16Array 来初始化纹理: 123456//see \"continuous simulation\" example to see the code//of the \"convert_arrayToUInt16Array\" function:var u16a = convert_arrayToUInt16Array(&lt;instance_of_Float32Array&gt;); var internalPixelFormat=(ISWEBGL2)?GL.RGBA16F:GL.RGBA;GL.texImage2D(GL.TEXTURE_2D, 0, internalPixelFormat, &lt;width&gt;, &lt;height&gt;,0, GL.RGBA, GL.HALF_FLOAT, u16a); 在 CPU 获得返回的计算结果除非我们的工作流是100%的 GPU流程,否则在有些情况下,我们需要把计算结果返回到JavaScript中.这个操作很慢,能不操作就不操作. 必须要渲染到默认的framebuffer(显示在元素中),然后使用GL.readPixels指令读取像素值.它使用一个正方形区域的的交错像素 RGBA 值来来填充 JavaScript 的 Unit8Array. 速度慢的根源是 CPU 和 GPU之间要强制同步. 在使用之前我们应该要使用选项 preserveDrawoingBuffer:true 来创建 WebGL 上下文. 读取8bit的编码值是很直接的: 片元着色器把纹理值拷贝到gl_FragColor,然后进行渲染.接着 framebuffer的值通过GL.readPixels 读取. 但是对于浮点值纹理,过程更加复杂. 需要开发特殊的片元着色器把每个浮点值打包成几个8比特的值,然后使用栅格视口来处理几个渲染过程, 使用 GL.readPixels drawcall 读取渲染数据,最后使用 JavaScript 的 Unit8Array 重构浮点数组. 在本书代码仓库中有着色器把浮点数打包成8比特颜色值的代码,同时还有读取浮点纹理的示例代码. 用于矩阵计算的纹理和着色器经过一段在 WebGL和 GPGPU 的奇妙旅行,我们要返回到深度学习中,构建一个最小的 WebGL 线性代数库WGLMatrix. 接着我们会使用这个库来实现一个简单的神经网络(非卷积网络),学习识别MNIST数据集的手写体数字. 第一版本的线性代数库包含在仓库 chapter3/4_WGLMatrix. 标准矩阵加法在 GLSL中内置的矩阵类型最大只支持4个维度. 这对于深度学习是远远不够的. 所以矩阵要 用纹理来存储,我们需要开发特殊的纹理用于常见的矩阵操作. 每个 texel 都是一个矩阵条目,纹理的分辨率和矩阵的维度是一样的. 在创建矩阵时,如果 JavaScript 提供了初始化数组,RGBA 通道就用这些数组填充.否则,如果只提供了一个数组,它的值就会被复制四次用于填充颜色通道. 每个普通的矩阵操作在 RGBA 颜色通道中都是独立执行的.也就是我们可以对一个数组使用四个不同矩阵并行处理四次. 加法片元着色器不会和其他元素类操作符一样依赖于矩阵的大小.这是 GLSL 的代码: 1234void main(void)&#123;vec2 uv=gl_FragCoord.xy/resolution;vec4 matAValue=texture2D(samplerTexture0, uv); vec4 matBValue=texture2D(samplerTexture1, uv); gl_FragColor=matAValue+matBValue;&#125; 标准矩阵乘法和加法着色器不同,乘法着色器包含了for 循环用于遍历第一个矩阵的行和第二个矩阵的列.使用 $WebGL_1$ 不能在for 条件语句中使用 非常量值.这限制了GLSL的归一化值或者之前计算结果的使用.所以我们需要为每个矩阵乘法维度编译一个着色器程序. 例如,这段代码用于 (n,10)矩阵和(10,n)矩阵的所有乘法: 1234567891011//vector between 2 consecutive texels of first factor:const vec2 DU=vec2(1./10., 0.);//vector between 2 consecutive texels of second factor: const vec2 DV=vec2(0., 1./10.);void main(void)&#123;vec2 uv=gl_FragCoord.xy/resolution; vec2 uvu=uv*vec2(1.,0.);vec2 uvv=uv*vec2(0.,1.);vec4 result=vec4(0.,0.,0.,0.);for (float i=0.0; i&lt;10.0; i+=1.0)&#123;result+=texture2D(samplerTexture0, uvv+(i+0.5)*DU) *texture2D(samplerTexture1, uvu+(i+0.5)*DV);&#125;gl_FragColor=result; &#125; 增加了 0.5 到 i 用于提取像素中间值,否则可能会在特定的矩阵维度上出现舍入错误. 在 $WebGL_2$ 中, 实现了for循环中的非常量操作,但是商业应用对于 $WebGL_2$ 的支持仍然是不可接受的(2018年3月的支持率是41%,webglstats.com数据).所以我们要构建一个 $WebGL_1$ 着色器,也可以用于 $WebGL_2$ 操作. 我们经常会同时进行矩阵乘法和加法. 例如,把一个神经元层的输入 $x$ 和权重矩阵 $W$ 相乘,然后加上偏置 $B$,可以计算出总的输出 $Z:Z=Wx+B$ .应该要编译一个特殊点着色器用于执行这个操作,称为 FMA(Fused Multiply-Accumulate,熔合乘法累积).它会节省一些渲染到纹理的时间. 我们的矩阵库,WGLMatrix, 管理者一个乘法和 FMA程序的字典.如果我们需要处理两个矩阵,这是字典中包含的普通维度操作,我们只使用字典中的着色程序就可以了.否则会编译出具有新维度的着色器程序,并添加到字典中. 激活函数的应用着色器就是专门用于激活函数的应用. 我们应该要小心特殊浮点数,尤其是包含指数或者对数的激活函数. 下面的着色器使用 sigmoid 激活函数: 12345const vec4 ONE=vec4(1.,1.,1.,1.); void main(void) &#123;vec2 uv=gl_FragCoord.xy/resolution; vec4 x=texture2D(samplerTexture0, uv); vec4 y;y=1./(ONE+exp(­x));gl_FragColor=y;&#125; 因为很多的特殊激活函数都可以应用于矩阵,我们设置了公用的方法从外部库编译定制的着色器. 精通 WGLMatrix矩阵在使用之前需要初始化, 矩阵 m,v,n从扁平值开始初始化: 123456// encoding 3*3 matrix | 0 1 2 |:// |345|// |678|var M=new WGLMatrix.Matrix(3,3,[0,1,2, //V is a column matrix, which is a vector: var V=new WGLMatrix.Matrix(3,1,[1,2,3]);3,4,5, 6,7,8]);var W=new WGLMatrix.MatrixZero(3,1); 从数学角度说, 向量和矩阵没有区别,向量就是宽度为1的矩阵.经过初始化,我们就可以对矩阵进行操作. 为了对矩阵A 执行操作 OPERATION,运行: 1A.OPERATION(arguments..., R) R是用于结果储存的矩阵.我们不能把结果存储在任何用于操作的矩阵中,因为不可能同时读取纹理和渲染纹理. 操作总是返回结果矩阵 R. 例如,处理操作 $W=M*V$ ,运行代码: 1M.multiply(V,W); 结果返回一个矩阵 $W$.我们可以声明一个定制元素的操作: 1WGL.addFunction('y=cos(x)','cos'); GLSL函数代码中,使用预定义的 vec4 x*vec4 y. 第二个参数是用户定义的函数标识符. 然后应用于矩阵 M的元素,执行操作 M.apply(&#39;COS&#39;,R) 这里的R 是矩阵收到的结果. 应用于手写体识别我们已经在 WGLMatrix 中添加了一些实现训练和运行神经网络的矩阵操作方法.也添加了一些验证矩阵维度的方法,防止无效的操作发生. 数据编码GPU加载的数据集作为输入向量,编码了数字图像,等待输出结果.数据集使用了显卡内存的绝大多数.这些数据不需要16或者32位精度:8位就足够了,因为输入图像使用8位编码每个通道的.输出是二元值. 我们已经在 WGLMatrix库中添加了8位精度的支持. 数据加载使用mnist_loader_js 脚本. 在代码第50行,添加了新的[X,Y]对,根据索引存储训练或者是测试数据集: 123targetData.push([new WGLMatrix.Matrix(784, 1, learningInputVector), //X new WGLMatrix.Matrix(10, 1, learningOutputVector) //Y&#125; 这一步之后,整个数据集作为纹理被加载到显卡内存中 内存优化能够预测需要的显卡内存就很重要了,如果我们要分配比可用内存多的内存,WebGL上下文进程会被杀掉,应用会崩溃.在我们的实例中,我们加载了 60000幅手写数字图片,所有有 $60002828=47e6$的纹理素材. 每个texel存储在4个 RGBA通道,每个颜色通道使用8比特来编码(1字节). 我们需要 47e6*4*1=188e6字节用于输入向量,所以大概是200MB,对于输出向量,我们需要 60000*10*4*1=2.4e6字节,大概是2.4MB. 但是 GPU不支持以原生像素形式存储纹理. 每个像素根据2D坐标上的近邻来编码,所有有很强的边缘效应.在我们的实例中,没有使用大约400MB的显卡内存,整个数据集需要4G 的显卡内存. 上图中,你看到的是 英伟达的 GPU,这里,英伟达的设置面板对于检测 GPU内存和占用率很方便.完成整个 MNIST 数据集加载之后,你可以看到使用93%的显卡内存. 如果把输入像向量的外观从(784,1)变为(28,28), 他们的内存大小是一样的,因为他们支持的问题有相同到的纹理像素(7841=2828).但是这时,整个 MNIST 的数据集占用的显存大概只有280MB,所以少了10倍.的确,一个像素宽的纹理像素例如(784,1)的输入向量存储效率不高,因为纹理像素都没有2D的邻居. 正方形的纹理像素仍然高于理论值,因为内存是分页的(或者分成单个的块),并且有边缘效应,因为这些纹理后很小. 为了优化 GPU 纹理的压缩,我们需要: 使用的纹理要尽可能的是方阵 纹理相乘获得一些大的纹理,称为纹理地图集 如果我们分配了一些大的正方纹理,边际效应减小,部分内存块的空余会减小.实际占用的内存值会更接近于理论值. 为了保持实现简单一点,我们不考虑这些改进措施.总是使用和分辨率和编码矩阵维度相同的纹理. 前置这是在network.js中声明的sigmoid函数: 1WGLMatrix.addFunction('y=1./(ONE+exp(­x));', 'ACTIVATION'); 这是 network.js中的前置部分: 123456789self.feedforward=function(a)&#123;//Return the output of the network if ``a`` is input. for (var i=0, inp=a; i&lt;self._nConnections; ++i)&#123;//from input to output layer,// compute WI+B and store the result in _z: self.weights[i].fma(inp, self.biases[i], self._z[i]);//apply actFunc to _z and store result to _yself._z[i].apply('ACTIVATION', self._y[i]);//set input for the next iterationinp=self._y[i]; &#125;return inp; &#125; 第一次尝试我们已经把使用 Python/Numpy写的 MNIST分类器转码为 JavaScript/WGLMatrix. 代码可以在 chapter3/5_MNIST 查看. 这段代码来自于 Micheal Nielsen的在线书籍 &lt;神经网络和深度学习&gt;第一章. 地址是http://neuralnetworksanddeeplearning.com/chap1.html 分类器的神经网络是非常浅显的. 它只有三层神经元: 输入神经元有784个单元(接收28x28像素的数字图像) 隐藏层有 30个神经元 输出层有10个神经元(每个数字一个) 属于致密连接,激活函数是 sigmoid.网络训练超过30个epochs,每个小批次有8个样本,学习率是3.0(每个小批次). 训练集有50 000个样本,测试集有10 000个样本.最佳效果是27个epochs的95.42% 这是基准值: Python/Numpy 实现(Python=2.7.12,CPU=Intel Core i7-4720HQ):318秒 JavaScript/WebGL实现(Chrome=65,GPU=Nvidia GTX960M):942秒 注释: 通过 Numpy执行的矩阵操作是使用底层的线性代数库,例如 BLAS或者 LAPACK实现,它们有类似 SIMD 的指令,使得使用 CPU 的执行也很有效.如果使用原生的 Python 函数,会更快. 这个基准中,我们的实现不太好,但是我们可以通过一些改进超越Numpy 的实现 改进执行效率可以看 改进的版本 在 chapter3/6_MNISTimporved 在之前的实现中,我们完全没有使用 RGBA 通道. 操作毫无用处的在四个通道中被复制了.这里要单独使用四个通道,从而可以并行处理四个输入向量.这是可行的,因为最小批次是4的倍数(之前的例子中是8).对于测试数据,为了多路复用RGBA通道,我们把每4个输入/输出向量包装成一个输入/输出向量.同样的执行,现在的实现时间从942秒下降到282秒. 现在比 Python/Numpy更好了. 但是 GPU 的利用率只有30%,因为纹理编码矩阵太小.的确,如果我们渲染的纹理的尺寸小于 GPU 计算单元数量时就会出现瓶颈:没有足够的工作可以做,一些计算单元处于休眠状态. 所以,我们需要渲染更大的纹理.有几个方案可以解决这个问题: 把几个小的批次样本分组成一个纹理.和我们在 RGBA通道对于小批量样本的复用一样,分组的纹理包含纹理的空间复用. 这个方案加速了学习,但是没有改善网络的利用效率. 可以增加每层神经元的数量. 核心的概念是使神经网络的构架适应硬件构架.我们选择这个方案. 考虑一下另一种学习 MNIST数据集的网络构架: 输入层有784个单元(接收28X28像素的数字图像) 两个隐藏层,分别有256和64个神经元 输出层有10个神经元(每个数字一个) 每批次8个样本,学习率1.0. 超过20个epoch. 现在 GPU的占有率平均在64% .我们的方案执行时间是344秒,Python/Numpy的执行时间为1635秒,几乎快乐5倍(最佳成功率在epoch18,96.45%). 通过增加隐藏层神经元规模,还可以增加 GPU的使用强度到100% 我们的方案和 Python方案的执行比值会攀升的更高.但是在测试数据上不会得到更好的结果,因为过拟合问题(应该要实现正交化或者丢弃算法来解决过拟合问题,后者实现卷积连接). 使用低端 GPU(笔记本电脑的低端 Intel HD4600 GPU),同样的学习花费587秒.仍然比 CPU的实现快了3倍. 总结本章我们从 WebGL的简单实现开始,画出两个三角形填充视口. 在开始 WebGL 的学习曲线很陡,这是最难的部分. WebGL似乎很繁琐,我们需要写很多代码,渲染 之前要创建不同的对象.但是实践的越多,它展现的逻辑越多,便利性也越大.经过首次渲染后,学习变成增量式的了. 接着,我们使用 WebGL来计算并行像素颜色,形成了漂亮的分形. 尽管每个像素都要经过重度的计算,但是渲染速度很快.之后,我们利用这个能力来加速计算. 实现渲染到纹理,得到结果用于下一步使用,代替了直接的显示. 实现类第一个 WebGL模拟: Conway 生命游戏. 我们处理了浮点计算问题. WebGL 设计时就考虑的是低精度计算,因为 RGB 颜色值每个元素不需要使用超过8比特的编码.所以我们要根据显示硬件版本和 WebGL 版本来考虑几个不同的执行路径. 运用新的知识,把之前的模拟转化为温度散失模拟,用物理连续变量代替了离散变量. 构建了自己的线性代数库,可以操作所有标准的矩阵操作.用它测试了 MNIST 数据集的手写体识别模型. 最后,我们优化了模型的实现,使之比 Python/Numpy的版本更快. 这一章对于改进已有的 WebGL 实现或者构建定制的 WebGL 实现都特别有用.无论我们如何在 WebGL上叠加任何的软件,如果不理解底层的机制,正确优化或者有效添加功能都是不可能的.这也是一个起点,开启了实际应用硬件加速的无限可能. 在下一章,我们将会看看如何从浏览器提取数据,例如从 URLs 加载图片,从摄像头解析帧图像,或者解析话筒拾取的音频.","categories":[{"name":"IT书籍翻译","slug":"IT书籍翻译","permalink":"https://React-Apollo.github.io/categories/IT书籍翻译/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://React-Apollo.github.io/tags/JavaScript/"},{"name":"TensorFlow.js","slug":"TensorFlow-js","permalink":"https://React-Apollo.github.io/tags/TensorFlow-js/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://React-Apollo.github.io/tags/Deep-Learning/"}]},{"title":"React-Spring,Hooks的用法","slug":"React-Spring,Hooks的用法","date":"2019-01-27T20:19:00.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2019/01/27/React-Spring,Hooks的用法/","link":"","permalink":"https://React-Apollo.github.io/2019/01/27/React-Spring,Hooks的用法/","excerpt":"","text":"React-Spring，Hooks的用法React-Hooks让组件的状态管理简洁了很多。下面是React-Spring的Hooks用法 123456789101112131415//Hooks.jsximport React from 'react';import &#123; useSpring, animated &#125; from 'react-spring';const HookedComponent = () =&gt; &#123; const [props] = useSpring(&#123; opacity: 1, color: 'white', from: &#123; opacity: 0 &#125;, delay: '2000' &#125;) return &lt;animated.div style=&#123;props&#125;&gt;This text Faded in Using hooks&lt;/animated.div&gt;&#125;export default HookedComponent;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"React-Hooks","slug":"React-Hooks","permalink":"https://React-Apollo.github.io/tags/React-Hooks/"}]},{"title":"React-Apollo-Hooks的用法","slug":"React-Apollo-Hooks的用法","date":"2019-01-25T07:40:00.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2019/01/25/React-Apollo-Hooks的用法/","link":"","permalink":"https://React-Apollo.github.io/2019/01/25/React-Apollo-Hooks的用法/","excerpt":"","text":"React-Apollo-Hooks的用法Introduction react-hooks的诞生彻底把React的组件函数化。 基本的思想延续了recompose的技术，对于组件的状态管理更为方便和直观了，所以立刻出现了很多的应用。 很多程序用react-hooks来写变得很直观，简洁。react-apollo-hooks的用法就在apollo查询组件的基础上更加方便使用了 初始化1npm install react-apollo-hooks ‌容器包装顶层组件 1234567891011121314151617import React from 'react';import &#123; render &#125; from 'react-dom';import &#123; ApolloProvider &#125; from 'react-apollo';import &#123; ApolloProvider as ApolloHooksProvider &#125; from 'react-apollo-hooks';const client = ... // create Apollo clientconst App = () =&gt; ( &lt;ApolloProvider client=&#123;client&#125;&gt; &lt;ApolloHooksProvider client=&#123;client&#125;&gt; &lt;MyRootComponent /&gt; &lt;/ApolloHooksProvider&gt; &lt;/ApolloProvider&gt;);render(&lt;App /&gt;, document.getElementById('root')); 具体使用查询组件用法123456789101112131415161718192021222324import gql from 'graphql-tag';import &#123; useQuery &#125; from 'react-apollo-hooks';const GET_DOGS = gql` &#123; dogs &#123; id breed &#125; &#125;`;const Dogs = () =&gt; &#123; const &#123; data, error &#125; = useQuery(GET_DOGS); if (error) return `Error! $&#123;error.message&#125;`; return ( &lt;ul&gt; &#123;data.dogs.map(dog =&gt; ( &lt;li key=&#123;dog.id&#125;&gt;&#123;dog.breed&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;; 可以结合suspense使用1234567import React, &#123; Suspense &#125; from 'react';const MyComponent = () =&gt; ( &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt; &lt;Dogs /&gt; &lt;/Suspense&gt;); apollo自身的状态表示由于apollo自身已经对网络层状态(是网络硬件层的网络信息)信息进行了封装，组件中可以直接使用这些信息 123456789101112131415161718import gql from 'graphql-tag';import &#123; useQuery &#125; from 'react-apollo-hooks';const GET_DOGS = gql`...`;const Dogs = () =&gt; &#123; const &#123; data, error, loading &#125; = useQuery(GET_DOGS, &#123; suspend: false &#125;); if (loading) return &lt;div&gt;Loading...&lt;/div&gt;; if (error) return `Error! $&#123;error.message&#125;`; return ( &lt;ul&gt; &#123;data.dogs.map(dog =&gt; ( &lt;li key=&#123;dog.id&#125;&gt;&#123;dog.breed&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;; Mutation的使用123456789101112131415161718192021import gql from 'graphql-tag';import &#123; useMutation &#125; from 'react-apollo-hooks';const TOGGLE_LIKED_PHOTO = gql` mutation toggleLikedPhoto($id: String!) &#123; toggleLikedPhoto(id: $id) @client //@client是apollo-link-state在本地的状态 &#125;`;const DogWithLikes = (&#123; url, imageId, isLiked &#125;) =&gt; &#123; const toggleLike = useMutation(TOGGLE_LIKED_PHOTO, &#123; variables: &#123; id: imageId &#125;, &#125;); return ( &lt;div&gt; &lt;img src=&#123;url&#125; /&gt; &lt;button onClick=&#123;toggleLike&#125;&gt;&#123;isLiked ? 'Stop liking' : 'like'&#125;&lt;/button&gt; &lt;/div&gt; );&#125;; 服务端渲染123456789101112131415161718192021222324252627282930import express from 'express';import &#123; ApolloProvider, getMarkupFromTree &#125; from 'react-apollo-hooks';import &#123; renderToString &#125; from 'react-dom/server';const HELLO_QUERY = gql` query HelloQuery &#123; hello &#125;`;function Hello() &#123; const &#123; data &#125; = useQuery(HELLO_QUERY); return &lt;p&gt;&#123;data.message&#125;&lt;/p&gt;;&#125;const app = express();app.get('/', async (req, res) =&gt; &#123; const client = createYourApolloClient(); const renderedHtml = await getMarkupFromTree(&#123; renderFunction: renderToString, tree: ( &lt;ApolloProvider client=&#123;client&#125;&gt; &lt;Hello /&gt; &lt;/ApolloProvider&gt; ), &#125;); res.send(renderedHtml);&#125;); ConclusionReact-Hooks让React技术更加简洁，明了。","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"}]},{"title":"翻译| face-api.js  — JavaScript API for Face Recognition in the Browser with  tensorflow.js","slug":"Faceapijs","date":"2019-01-24T13:26:00.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2019/01/24/Faceapijs/","link":"","permalink":"https://React-Apollo.github.io/2019/01/24/Faceapijs/","excerpt":"","text":"face-api.js — JavaScript API for Face Recognition in the Browser with tensorflow.js原文在此 我很高兴的说,在浏览器端运行人脸识别程序终于可以实现了! 在本文我会结合介绍一个 JavaScript模块,也就是 face-api.js, 本模块基于tensroflow.js 核心构建,tensorflow.js的核心实现了几种 CNN(Convolutional Neural network,卷积神经网络),可以用来接解决面部检测,面部识别和面部标记检测任务, 并且对 web 端和移动端做了特别的优化. 因为我们总是想要找简单的代码示例,简单代码可以使用软件包,用几行代码就可以立刻开始项目.如果你想先试试一些示例,看看 Demo页!但是不要忘了回来读文章啊. ;) 开始吧! 注意:文章中的项目还在继续开发中.需要你保证检查一下文章的更新情况,保证获取到最新的face-api.js的特征: Realtime JavaScript Face Tracking and Face Recoginition using face-api.js’MTCNN Face Detector 为什么开始时face-recognition.js,现在是另外一个软件包?如果以读过我的另外一篇文章,使用node.js的面部识别的文章: Node.js + face-recognition.js : Simple and Robust Face Recognition using Deep Learning,你可能知道,不久以前,我发布了一个类似的软件包,就是 face-recognition.js,可以用node.js实现面部识别. 刚开始,我没有想到 Javascript 社区对于面部识别有这么高的要求.对于很多程序员,face-recognition.js似乎是很严肃的取代了付费的产品,例如微软h和亚马逊的产品. 但是也有很多还想更进一步,看看是否有直接在浏览器端运行的面部识别流程. 那么,最终这个软件包就出现了,完全要感谢tensorflow.js! 使用tfjs-core,我成功的实现了部分相似的功能,使用新的软件包可以得到和face-recoginiton.js 同样的结果,但是是运行在浏览器端的!还有,face-api.js提供的模型专门对 web 进行了优化,以便于在移动设备上运行资源,face-api.js是开箱即用的.有点是它是 GPU加速的,操作运行是以 WebGL最为后台的. 这些原因很充分,是我确信 javascript 社区需要浏览器端的包!剩下的就是你的想象力, 可以用这个软件包构建各种应用了.;) 怎么使用深度学习来解决面部识别问题?如果是急性子的人, 想要马上看到结果, 可以直接跳过这一小节,直接去看代码. 但是为了更好的理解face-api.js在面部识别方面的实现原理,我还是强烈建议你继续往下读.因为我经常被请求讲解其中的原理. 为了讲解简单一点,我们实际是想从某人的给定图像例如,输入的图片来识别一个人.方法是提供我们想识别人的一张或者多张图片,并且使用姓名标记,作为参考数据.现在我们可以比较输入图片和参考数据,找到和参考数据图片最相似的图片.如果两张图片相似度足够高,我们就输入是需要识别人的姓名, 否则就输入 未知. 听起来是个完美的计划!但是还有两个问题要解决. 第一个,如果过我们有一张多人的图片,想识别其中每个人,怎么办? 第二个,我们想要获取两张面部照片的相似度,以便于可以对他们进行比较… 面部识别第一个问题的答案是面部检测.简单讲,我们首先定位出输入图片中的所有面部.Fact-api.js实现了用于多面部检测用于不同的用例. 最准确的面部检测器是 SSD(Single Shot Multibox Detector),它的基础是基于 CNN 的 MobileNet V1,它在基础的卷积神经网络上构建了额外的预测层. 此外, face-api.js实现了经过优化的 Tiny Face Detector, 基本上是一个Tiny Yolo V2的更小的版本. Tiny Yolo是一个深度分离卷积网络而不是常规的卷积, 深度分离卷积的速度更快,但是和 SSD MobileNet V1相比精确度稍差一点. 最后,也就是 MTCNN(Mutli-task Cascaded Convolutional Neural Network)的实现, 然而,现在它用于实验性质多一点. 这些网络返回每张脸的边界盒子(bouding boxes),还有对应的得分,例如,每个盒子显示为面部的概率.得分用于对边界盒子进行过滤.一张图片中完全没有人脸出现也是有可能的.注意,为了获得边界盒子,即使没有图片中没有人,也要执行面部检测. 面部标志检测和面部对齐第一个问题解决了.但是我想指出,我们想对齐边界盒子,在把每个盒子传递给面部识别网络之前,我们想让面部位于提取图片的中央, 这样的操作会使面部识别的精确度更高. face-api.js的对策是实现了一个简单的 CNN,返回给定脸部图像的68个标志点: 根据标志点的位置,分解盒子可以被集中到脸部的中央. 下面你可以看到脸部检测结果(左图)和经过对齐的脸部图片(右图)的比较. 面部识别现在,我们把经过对齐的图片输入到面部识别网络,面部识别网络是基于 与ReSNet-34相似的构架,基础构架实现在dlib . 识别网络训练的任务是人脸的特征映射到面部描述(有128个值的特征向量),这个任务通常也称为面部嵌入. 现在返回初始的问题,就是两张脸的对比: 我们把从每张面部图片提取的特征向量描述向量和参考数据的特征向量进行比较. 说的更准确一点,就是比较两张量的特征向量之间的欧几里得距离(euclidean distance,译注:简单的几何,两点之间的距离计算).基于一个阈值(对于150X150大小的图片,0.6是一个比较好的阈值)来进行判断. 欧氏距离的工作出奇的好,当然你可以根据喜好选择其他的分类器.下面的图是比较两张脸的欧式距离: 现在我们已经详细了解了面部识别的理论, 开始来编码一个示例程序 具体代码在这一部分,我们会一步一步实现一个面部识别程序,显示出下面图片中的每个人 引入脚本首先,从dist/face-api.js得到最新的版本,或者是压缩的版本 /dist/face-api.min.js: 1&lt;script src=\"face-api.js\"&gt;&lt;/script&gt; 也可以使用npm安装 1npm i face-api.js 加载模型数据根据应用的需求不同,你可以加载特定的模型,但是从头至尾运行本实例,需要加载面部检测,面部标记和面部识别模型. 模型文件仓库在这里 模型权重已经被quantized,和原始的模型相比大小已经缩减了75%,由此客户端可以只加载必须的数据. 此外, 模型的权重被分外4MB 大小的块,浏览器可以缓存这些文件,不需要再加载第二次. 模型文件也可以通过web app的静态资源提供,或者可以放在任何定义的路由或者 ulr下. 假设你已经在public/models下提供了模型目录: 12345const MODEL_URL = '/models'await faceapi.loadSsdMobilenetv1Model(MODEL_URL)await faceapi.loadFaceLandmarkModel(MODEL_URL)await faceapi.loadFaceRecognitionModel(MODEL_URL) 从输入图片获取所有脸部的完整描述神经网络接收 HTML图片,canvas,或者是视频元素,或者是图片的tensors作为输入. 为了检测输入图片中的所有边界盒子,代码如下: 12const input=document.getElementById('myImage');let fullFaceDescriptions = await faceapi.detectAllFaces(input).withFaceLandmarks().withFaceDescriptors() 完整的面部描述包含了探测的结果(边界盒子+得分),面部标记也作为描述的计算结果. 省略 faceapi.detectAllFaces(input,options) 可选参数,我们就默认使用 SSD MobileNet V1作为默认的模型.如果要使用Tiny Face检测或者是 MTCNN 方法,只需要定义对应的选项就可以了. 有关face detection 选项的细节,可以看看 github仓库的说明文档.注意,必须要提前记载相应的模型,. 返回的边界盒子和标记位置是对应于原始的图片/媒体尺寸的. 万一显示的图片和原始的图片大小不对应,需要 resize: 1fullFaceDescriptions = fullFaceDescriptions.map(fd =&gt; fd.forSize(width, height)) 我们可以直接在画布上画出边界盒子来展示面部探测的结果: 12const detectionsArray = fullFaceDescriptions.map(fd =&gt; fd.detection)faceapi.drawDetection(canvas, detectionsArray, &#123; withScore: true &#125;) 面部标志也可以显示: 12const landmarksArray = fullFaceDescriptions.map(fd =&gt; fd.landmarks)faceapi.drawLandmarks(canvas, landmarksArray, &#123; drawLines: true &#125;) 通常,在做可视化时,都是使用绝对定位来重叠图片(参见github的实例) 面部识别现在,我们需要知道如何获取所有面部的位置和描述特征, 我们得到一些图片显示单个人,计算出每个人的面部描述. 这些描述就是参考数据. 假定我们已经有了一些主题相关的图片,首先从 url或者使用 faceapi.fetchImages获取图片数据. 对于单张图片,都会定位脸部主体,并计算脸部描述,和输入图片是一样的操作. 12345678910111213141516171819const labels = ['sheldon' 'raj', 'leonard', 'howard']const labeledFaceDescriptors = await Promise.all( labels.map(async label =&gt; &#123; // fetch image data from urls and convert blob to HTMLImage element const imgUrl = `$&#123;label&#125;.png` const img = await faceapi.fetchImage(imgUrl) // detect the face with the highest score in the image and compute it's landmarks and face descriptor const fullFaceDescription = await faceapi.detectSingleFace(img).withFaceLandmarks().withFaceDescriptor() if (!fullFaceDescription) &#123; throw new Error(`no faces detected for $&#123;label&#125;`) &#125; const faceDescriptors = [fullFaceDescription.descriptor] return new faceapi.LabeledFaceDescriptors(label, faceDescriptors) &#125;)) 注意,这里我们使用的是 faceapi.detectSingleFace , 将会返回要检测面部的最高得分,因为我们假设, 对于给定的标签,显示出的主体是唯一的. 现在,只剩下一件事,就是匹配参考数据和待检测面部的数据. 执行 factapi.FaceMatcher : 123456// 0.6 is a good distance threshold value to judge// whether the descriptors match or notconst maxDescriptorDistance = 0.6const faceMatcher = new faceapi.FaceMatcher(labeledFaceDescriptors, maxDescriptorDistance)const results = fullFaceDescriptions.map(fd =&gt; faceMatcher.findBestMatch(fd.descriptor)) 面部匹配使用欧式距离作为相似度检测,欧式距离运转的很好. 最终我们为每张输入图片获得了一个最佳的匹配结果, 包含了最匹配的欧式距离结果的标签. 最后,我们使用边界盒子和标签画出结果: 12345678const boxesWithText = results.map((bestMatch, i) =&gt; &#123; const box = fullFaceDescriptions[i].detection.box const text = bestMatch.toString() const boxWithText = new faceapi.BoxWithText(box, text) return boxWithText&#125;)faceapi.drawDetection(canvas, boxesWithText) 成功! 现在,我希望你已经使用api的初步印象. 我也建议你看看代码仓库中其他的实例. JavaScript Face Recognition TensorFlow Machine Learning Deep Learning","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://React-Apollo.github.io/tags/JavaScript/"},{"name":"Medium","slug":"Medium","permalink":"https://React-Apollo.github.io/tags/Medium/"},{"name":"TensorFlow.js","slug":"TensorFlow-js","permalink":"https://React-Apollo.github.io/tags/TensorFlow-js/"}]},{"title":"useLocalStorage的代码","slug":"useLocalStorage的实现代码和用法","date":"2019-01-24T09:53:00.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2019/01/24/useLocalStorage的实现代码和用法/","link":"","permalink":"https://React-Apollo.github.io/2019/01/24/useLocalStorage的实现代码和用法/","excerpt":"","text":"useLocalStorage的Hooks,在使用useState时，先判断localStorage中是否有对应键的键值，如果有就取出，如果没有就设为空，等待后面传入值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import &#123; useState, useEffect &#125; from 'react';// Usagefunction App() &#123; // Similar to useState but we pass in a key to value in local storage // With useState: const [name, setName] = useState('Bob'); const [name, setName] = useLocalStorage('name', 'Bob'); return ( &lt;div&gt; &lt;input type=\"text\" placeholder=\"Enter your name\" value=&#123;name&#125; onChange=&#123;e =&gt; setName(e.target.value)&#125; /&gt; &lt;/div&gt; );&#125;// Hookfunction useLocalStorage(key, initialValue) &#123; // The initialValue arg is only used if there is nothing in localStorage ... // ... otherwise we use the value in localStorage so state persist through a page refresh. // We pass a function to useState so localStorage lookup only happens once. // We wrap in try/catch in case localStorage is unavailable const [item, setInnerValue] = useState(() =&gt; &#123; try &#123; return window.localStorage.getItem(key) ? JSON.parse(window.localStorage.getItem(key)) : initialValue; &#125; catch (error) &#123; // Return default value if JSON parsing fails return initialValue; &#125; &#125;); // Return a wrapped version of useState's setter function that ... // ... persists the new value to localStorage. const setValue = value =&gt; &#123; setInnerValue(value); window.localStorage.setItem(key, JSON.stringify(item)); &#125;; // Alternatively we could update localStorage inside useEffect ... // ... but this would run every render and it really only needs ... // ... to happen when the returned setValue function is called. /* useEffect(() =&gt; &#123; window.localStorage.setItem(key, JSON.stringify(item)); &#125;); */ return [item, setValue];&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"ReactHooks","slug":"ReactHooks","permalink":"https://React-Apollo.github.io/tags/ReactHooks/"}]},{"title":"useContentState代码实例","slug":"useContextState","date":"2019-01-24T08:26:00.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2019/01/24/useContextState/","link":"","permalink":"https://React-Apollo.github.io/2019/01/24/useContextState/","excerpt":"","text":"useContextState函数类似一个容器，返回了一个全局的对象和操作方法。其他组件可以访问方法和用于存储数据的对象。很有启发。","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"Reacthooks","slug":"Reacthooks","permalink":"https://React-Apollo.github.io/tags/Reacthooks/"}]},{"title":"重新翻译版本|Redux-Reselect 文档","slug":"重新翻译版本|Redux-Reselect","date":"2019-01-24T08:26:00.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2019/01/24/重新翻译版本|Redux-Reselect/","link":"","permalink":"https://React-Apollo.github.io/2019/01/24/重新翻译版本|Redux-Reselect/","excerpt":"","text":"“selector”是一个简单的Redux库,灵感来源于NuclearJS. Selector可以计算衍生的数据,可以让Redux做到存储尽可能少的state。 Selector比较高效,只有在某个参数发生变化的时候才发生计算过程. Selector是可以组合的,他们可以作为输入,传递到其他的selector. 123456789101112131415161718192021222324252627282930313233343536//这个例子不必太在意,后面会有详细的介绍import &#123; createSelector &#125; from 'reselect'const shopItemsSelector = state =&gt; state.shop.itemsconst taxPercentSelector = state =&gt; state.shop.taxPercentconst subtotalSelector = createSelector( shopItemsSelector, items =&gt; items.reduce((acc, item) =&gt; acc + item.value, 0))const taxSelector = createSelector( subtotalSelector, taxPercentSelector, (subtotal, taxPercent) =&gt; subtotal * (taxPercent / 100))export const totalSelector = createSelector( subtotalSelector, taxSelector, (subtotal, tax) =&gt; (&#123; total: subtotal + tax &#125;))let exampleState = &#123; shop: &#123; taxPercent: 8, items: [ &#123; name: 'apple', value: 1.20 &#125;, &#123; name: 'orange', value: 0.95 &#125;, ] &#125;&#125;console.log(subtotalSelector(exampleState)) // 2.15console.log(taxSelector(exampleState)) // 0.172console.log(totalSelector(exampleState)) // &#123; total: 2.322 &#125; Table of Contents Installation 实例 Motivation for Memoized Selectors Creating a Memoized Selector Composing Selectors Connecting a Selector to the Redux Store Accessing React Props in Selectors Sharing Selectors with Props Across Multiple Components API createSelector defaultMemoize createSelectorCreator createStructuredSelector FAQ Why isn’t my selector recomputing when the input state changes? Why is my selector recomputing when the input state stays the same? Can I use Reselect without Redux? The default memoization function is no good, can I use a different one? How do I test a selector? How do I create a selector that takes an argument? How do I use Reselect with Immutable.js? Can I share a selector across multiple components? Are there TypeScript typings? How can I make a curried selector? Related Projects License 安装npm install reselect 实例缓存Selcectos的动机 实例是基于 Redux Todos List example. containers/VisibleTodoList.js12345678910111213141516171819202122232425262728293031323334353637import &#123; connect &#125; from 'react-redux'import &#123; toggleTodo &#125; from '../actions'import TodoList from '../components/TodoList'//下面这段代码是根据过滤器的state来改变日程state的函数const getVisibleTodos = (todos, filter) =&gt; &#123; switch (filter) &#123; case 'SHOW_ALL': return todos case 'SHOW_COMPLETED': return todos.filter(t =&gt; t.completed) case 'SHOW_ACTIVE': return todos.filter(t =&gt; !t.completed) &#125;&#125;const mapStateToProps = (state) =&gt; &#123; return &#123; //todos是根据过滤函数返回的state，传入两个实参 todos: getVisibleTodos(state.todos, state.visibilityFilter) &#125;&#125;//mapDispatchToProps来传递dispatch的方法const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; onTodoClick: (id) =&gt; &#123; dispatch(toggleTodo(id)) &#125; &#125;&#125;//使用Redux的connect函数注入state,到TodoList组件const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList)export default VisibleTodoList 在上面的例子中,mapStateToProps调用getVisibleTodos去计算todos.这个函数设计的是相当好的,但是有个缺点：todos在每一次组件更新的时候都会重新计算.如果state树的结构比较大,或者计算比较昂贵,每一次组件更新的时候都进行计算的话,将会导致性能问题.Reselect能够帮助redux避免不必要的计算过程. 创建一个缓存Selector我们可以使用记忆缓存selector代替getVisibleTodos,如果state.todos和state.visibilityFilter发生变化,他会重新计算state,但是只发生在其他部分的state变化,就不会重新计算. Reslect提供一个函数createSelector来创建一个记忆selectors.createSelector接受input-selectors和一个变换函数作为参数.如果Redux的state发生改变造成input-selector的值发生改变,selector会调用变换函数,依据input-selector做参数,返回一个结果.如果input-selector返回的结果和前面的一样,那么就会直接返回有关state,会省略变换函数的调用. 下面我们定义一个记忆selectorgetVisibleTodos替代非记忆的版本 selectors/index.js 123456789101112131415161718import &#123; createSelector &#125; from 'reselect'const getVisibilityFilter = (state) =&gt; state.visibilityFilterconst getTodos = (state) =&gt; state.todos//下面的函数是经过包装的export const getVisibleTodos = createSelector( [ getVisibilityFilter, getTodos ], (visibilityFilter, todos) =&gt; &#123; switch (visibilityFilter) &#123; case 'SHOW_ALL': return todos case 'SHOW_COMPLETED': return todos.filter(t =&gt; t.completed) case 'SHOW_ACTIVE': return todos.filter(t =&gt; !t.completed) &#125; &#125;) 上面的的实例中,getVisibilityfilter和getTodos是input-selectors.这两个函数是普通的非记忆selector函数,因为他们没有变换他们select的数据.getVisibleTodos另一方面是一个记忆selector.他接收getVisibilityfilter和getTodos作为input-selectors,并且作为一个变换函数计算筛选的todo list. 组合selectors一个记忆性selector本身也可以作为另一个记忆性selector的input-selector.这里getVisibleTodos可以作为input-selector作为关键字筛选的input-selector:12345678const getKeyword = (state) =&gt; state.keywordconst getVisibleTodosFilteredByKeyword = createSelector( [ getVisibleTodos, getKeyword ], (visibleTodos, keyword) =&gt; visibleTodos.filter( todo =&gt; todo.text.indexOf(keyword) &gt; -1 )) 把Selector连接到Redux Store如果你正在使用 React Redux, 你可以 直接在mapStateToProps()中调用 selector: containers/VisibleTodoList.js 12345678910111213141516171819202122232425import &#123; connect &#125; from 'react-redux'import &#123; toggleTodo &#125; from '../actions'import TodoList from '../components/TodoList'import &#123; getVisibleTodos &#125; from '../selectors'const mapStateToProps = (state) =&gt; &#123; return &#123; todos: getVisibleTodos(state) &#125;&#125;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; onTodoClick: (id) =&gt; &#123; dispatch(toggleTodo(id)) &#125; &#125;&#125;const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList)export default VisibleTodoList 在Selectors中获取 React 的 props 这一部分我们假设程序将会有一个扩展,我们允许selector支持多重todo List.请注意如果要完全实施这个扩展,reducers,components,actions等等都需要作出改变.这些内容和主题不是太相关,所以这里就省略掉了. 目前为止,我们仅仅看到selectors接收store的state作为一个参数,其实一个selector叶可以接受props. 这里是一个App组件,渲染出三个VisibleTodoList组件,每一个组件有ListId属性. components/App.js 123456789101112import React from 'react'import Footer from './Footer'import AddTodo from '../containers/AddTodo'import VisibleTodoList from '../containers/VisibleTodoList'const App = () =&gt; ( &lt;div&gt; &lt;VisibleTodoList listId=\"1\" /&gt; &lt;VisibleTodoList listId=\"2\" /&gt; &lt;VisibleTodoList listId=\"3\" /&gt; &lt;/div&gt;) 每一个VisibleTodoListcontainer应该根据各自的listId属性获取state的不同部分.所以我们修改一下getVisibilityFilter和getTodos,便于接受一个属性参数 selectors/todoSelectors.js1234567891011121314151617181920212223import &#123; createSelector &#125; from 'reselect'const getVisibilityFilter = (state, props) =&gt; state.todoLists[props.listId].visibilityFilterconst getTodos = (state, props) =&gt; state.todoLists[props.listId].todos //这里是为二维数组了const getVisibleTodos = createSelector( [ getVisibilityFilter, getTodos ], (visibilityFilter, todos) =&gt; &#123; switch (visibilityFilter) &#123; case 'SHOW_COMPLETED': return todos.filter(todo =&gt; todo.completed) case 'SHOW_ACTIVE': return todos.filter(todo =&gt; !todo.completed) default: return todos &#125; &#125;)export default getVisibleTodos props可以从mapStateToProps传递到getVisibleTodos： 12345const mapStateToProps = (state, props) =&gt; &#123; return &#123; todos: getVisibleTodos(state, props) &#125;&#125; 现在getVisibleTodos可以获取props,每一部分似乎都工作的不错. **但是还有个问题!当getVisibleTodosselector和VisibleTodoListcontainer的多个实例一起工作的时候,记忆功能就不能正常运行: containers/VisibleTodoList.js 123456789101112131415161718192021222324252627import &#123; connect &#125; from 'react-redux'import &#123; toggleTodo &#125; from '../actions'import TodoList from '../components/TodoList'import &#123; getVisibleTodos &#125; from '../selectors'const mapStateToProps = (state, props) =&gt; &#123; return &#123; // WARNING: THE FOLLOWING SELECTOR DOES NOT CORRECTLY MEMOIZE //⚠️下面的selector不能正确的记忆 todos: getVisibleTodos(state, props) &#125;&#125;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; onTodoClick: (id) =&gt; &#123; dispatch(toggleTodo(id)) &#125; &#125;&#125;const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList)export default VisibleTodoList 使用createSelector创建的selector时候,如果他的参数集合和上一次的参数机会是一样的,仅仅返回缓存的值.如果我们交替渲染&lt;VisibleTodoList listId=&quot;1&quot; /&gt; 和&lt;VisibleTodoList listId=&quot;2&quot; /&gt;时,共享的selector将会交替接受{listId：1}和{listId:2}作为他的props的参数.这将会导致每一次调用的时候的参数都不同,因此selector每次都会重新来计算而不是返回缓存的值.下一部分我们将会介绍怎么解决这个问题. 跨越多个组件使用selectors共享props 这一部分的实例需要React Redux v4.3.0或者更高版本的支持. 在多个VisibleTodoList组件中共享selector,同时还要保持记忆性,每一个组件的实例需要他们自己的selector私有拷贝. 现在让我们创建一个函数makeGetVisibleTodos,这个函数每次调用的时候返回一个新的getVisibleTodos的拷贝: selectors/todoSelectors.js 12345678910111213141516171819202122232425import &#123; createSelector &#125; from 'reselect'const getVisibilityFilter = (state, props) =&gt; state.todoLists[props.listId].visibilityFilterconst getTodos = (state, props) =&gt; state.todoLists[props.listId].todosconst makeGetVisibleTodos = () =&gt; &#123; return createSelector( [ getVisibilityFilter, getTodos ], (visibilityFilter, todos) =&gt; &#123; switch (visibilityFilter) &#123; case 'SHOW_COMPLETED': return todos.filter(todo =&gt; todo.completed) case 'SHOW_ACTIVE': return todos.filter(todo =&gt; !todo.completed) default: return todos &#125; &#125; )&#125;export default makeGetVisibleTodos 我们也需要设置给每一个组件的实例他们各自获取私有的selector方法.mapStateToProps的connect函数可以帮助完成这个功能. 如果mapStateToProps提供给connect的不是一个对形象,而是一个函数,每个container中就会创建独立的mapStateToProps实例. 在下面的实例中,mapStateProps创建一个新的getVisibleTodosselector,他返回一个mapStateToProps函数,这个函数能够接入新的selector. 123456789const makeMapStateToProps = () =&gt; &#123; const getVisibleTodos = makeGetVisibleTodos() const mapStateToProps = (state, props) =&gt; &#123; return &#123; todos: getVisibleTodos(state, props) &#125; &#125; return mapStateToProps&#125; 如果我们把makeMapStateToprops传递到connect,每一个visibleTodoListcontainer将会获得各自的含有私有getVisibleTodosselector的mapStateToProps函数.这样一来记忆就正常了,不管VisibleTodoListcontainers的渲染顺序怎么样. containers/VisibleTodoList.js 1234567891011121314151617181920212223242526272829import &#123; connect &#125; from 'react-redux'import &#123; toggleTodo &#125; from '../actions'import TodoList from '../components/TodoList'import &#123; makeGetVisibleTodos &#125; from '../selectors'const makeMapStateToProps = () =&gt; &#123; const getVisibleTodos = makeGetVisibleTodos() const mapStateToProps = (state, props) =&gt; &#123; return &#123; todos: getVisibleTodos(state, props) &#125; &#125; return mapStateToProps&#125;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; onTodoClick: (id) =&gt; &#123; dispatch(toggleTodo(id)) &#125; &#125;&#125;const VisibleTodoList = connect( makeMapStateToProps, mapDispatchToProps)(TodoList)export default VisibleTodoList APIcreateSelector(…inputSelectors|[inputSelectors],resultFunc)接受一个或者多个selectors,或者一个selectors数组,计算他们的值并且作为参数传递给resultFunc. createSelector通过判断input-selector之前调用和之后调用的返回值的全等于(===,这个地方英文文献叫reference equality,引用等于,这个单词是本质,中文没有翻译出来).经过createSelector创建的selector应该是immutable(不变的). 经过createSelector创建的Selectors有一个缓存,大小是1.这意味着当一个input-selector变化的时候,他们总是会重新计算state,因为Selector仅仅存储每一个input-selector前一个值. 123456789101112131415const mySelector = createSelector( state =&gt; state.values.value1, state =&gt; state.values.value2, (value1, value2) =&gt; value1 + value2)// You can also pass an array of selectors//可以出传递一个selector数组const totalSelector = createSelector( [ state =&gt; state.values.value1, state =&gt; state.values.value2 ], (value1, value2) =&gt; value1 + value2) 在selector内部获取一个组件的props非常有用.当一个selector通过connect函数连接到一个组件上,组件的属性作为第二个参数传递给selector:12345678910111213141516const abSelector = (state, props) =&gt; state.a * props.b// props only (ignoring state argument)const cSelector = (_, props) =&gt; props.c// state only (props argument omitted as not required)const dSelector = state =&gt; state.dconst totalSelector = createSelector( abSelector, cSelector, dSelector, (ab, c, d) =&gt; (&#123; total: ab + c + d &#125;)) defaultMemoize(func, equalityCheck = defaultEqualityCheck)defaultMemoize能记住通过func传递的参数.这是createSelector使用的记忆函数. defaultMemoize 通过调用equalityCheck函数来决定一个参数是否已经发生改变.因为defaultMemoize设计出来就是和immutable数据一起使用,默认的equalityCheck使用引用全等于来判断变化: 123function defaultEqualityCheck(currentVal, previousVal) &#123; return currentVal === previousVal&#125; defaultMemoize和createSelectorCreator去配置equalityCheck函数. createSelectorCreator(memoize,…memoizeOptions)createSelectorCreator用来配置定制版本的createSelector. memoize参数是一个有记忆功能的函数,来代替defaultMemoize.…memoizeOption展开的参数是0或者更多的配置选项,这些参数传递给memoizeFunc.selectorsresultFunc作为第一个参数传递给memoize,memoizeOptions作为第二个参数: 123456789101112const customSelectorCreator = createSelectorCreator( customMemoize, // function to be used to memoize resultFunc,记忆resultFunc option1, // option1 will be passed as second argument to customMemoize 第二个惨呼 option2, // option2 will be passed as third argument to customMemoize 第三个参数 option3 // option3 will be passed as fourth argument to customMemoize 第四个参数)const customSelector = customSelectorCreator( input1, input2, resultFunc // resultFunc will be passed as first argument to customMemoize 作为第一个参数传递给customMomize) 在customSelecotr内部滴啊用memoize的函数的代码如下:1customMemoize(resultFunc, option1, option2, option3) 下面是几个可能会用到的createSelectorCreator的实例: 为defaultMemoize配置equalityCheck 1234567891011121314import &#123; createSelectorCreator, defaultMemoize &#125; from 'reselect'import isEqual from 'lodash.isEqual'// create a \"selector creator\" that uses lodash.isEqual instead of ===const createDeepEqualSelector = createSelectorCreator( defaultMemoize, isEqual)// use the new \"selector creator\" to create a selectorconst mySelector = createDeepEqualSelector( state =&gt; state.values.filter(val =&gt; val &lt; 5), values =&gt; values.reduce((acc, val) =&gt; acc + val, 0)) 使用loadsh的memoize函数来缓存未绑定的缓存. 1234567891011121314151617import &#123; createSelectorCreator &#125; from 'reselect'import memoize from 'lodash.memoize'let called = 0const hashFn = (...args) =&gt; args.reduce( (acc, val) =&gt; acc + '-' + JSON.stringify(val), '')const customSelectorCreator = createSelectorCreator(memoize, hashFn)const selector = customSelectorCreator( state =&gt; state.a, state =&gt; state.b, (a, b) =&gt; &#123; called++ return a + b &#125;) createStructuredSelector({inputSelectors}, selectorCreator = createSelector)如果在普通的模式下使用createStructuredSelector函数可以提升便利性.传递到connect的selector装饰者(这是js设计模式的概念,可以参考相关的书籍)接受他的input-selectors,并且在一个对象内映射到一个键上. 123456789101112131415const mySelectorA = state =&gt; state.aconst mySelectorB = state =&gt; state.b// The result function in the following selector// is simply building an object from the input selectors 由selectors构建的一个对象const structuredSelector = createSelector( mySelectorA, mySelectorB, mySelectorC, (a, b, c) =&gt; (&#123; a, b, c &#125;)) createStructuredSelector接受一个对象,这个对象的属性是input-selectors,函数返回一个结构性的selector.这个结构性的selector返回一个对象,对象的键和inputSelectors的参数是相同的,但是使用selectors代替了其中的值. 123456789const mySelectorA = state =&gt; state.aconst mySelectorB = state =&gt; state.bconst structuredSelector = createStructuredSelector(&#123; x: mySelectorA, y: mySelectorB&#125;)const result = structuredSelector(&#123; a: 1, b: 2 &#125;) // will produce &#123; x: 1, y: 2 &#125; 结构性的selectors可以是嵌套式的: 12345678910const nestedSelector = createStructuredSelector(&#123; subA: createStructuredSelector(&#123; selectorA, selectorB &#125;), subB: createStructuredSelector(&#123; selectorC, selectorD &#125;)&#125;) FAQQ:为什么当输入的state发生改变的时候,selector不重新计算？A:检查一下你的记忆韩式是不是和你的state更新函数相兼容(例如:如果你正在使用Redux).例如:使用createSelector创建的selector总是创建一个新的对象,原来期待的是更新一个已经存在的对象.createSelector使用(===)检测输入是否改变,因此如果改变一个已经存在的对象没有触发selector重新计算的原因是改变一个对象的时候没有触发相关的检测.提示：如果你正在使用Redux,改变一个state对象的错误可能有. 下面的实例定义了一个selector可以决定数组的第一个todo项目是不是已经被完成:1234const isFirstTodoCompleteSelector = createSelector( state =&gt; state.todos[0], todo =&gt; todo &amp;&amp; todo.completed) 下面的state更新函数和isFirstTodoCompleteSelector将不会正常工作工作: 1234567891011121314export default function todos(state = initialState, action) &#123; switch (action.type) &#123; case COMPLETE_ALL: const areAllMarked = state.every(todo =&gt; todo.completed) // BAD: mutating an existing object return state.map(todo =&gt; &#123; todo.completed = !areAllMarked return todo &#125;) default: return state &#125;&#125; 下面的state更新函数和isFirstTodoComplete一起可以正常工作. 12345678910111213export default function todos(state = initialState, action) &#123; switch (action.type) &#123; case COMPLETE_ALL: const areAllMarked = state.every(todo =&gt; todo.completed) // GOOD: returning a new object each time with Object.assign return state.map(todo =&gt; Object.assign(&#123;&#125;, todo, &#123; completed: !areAllMarked &#125;)) default: return state &#125;&#125; 如果你没有使用Redux,但是有使用mutable数据的需求,你可以使用createSelectorCreator代替默认的记忆函数,并且使用不同的等值检测函数.请参看这里 和 这里作为参考. Q:为什么input state没有改变的时候,selector还是会重新计算?A: 检查一下你的记忆函数和你你的state更新函数是不是兼容(如果是使用Redux的时候,看看reducer).例如:使用每一次更新的时候,不管值是不是发生改变,createSelector创建的selector总是会收到一个新的对象.createSelector函数使用(===)检测input的变化,由此可知如果每次都返回一个新对象,表示selector总是在每次更新的时候重新计算. 123456789101112131415161718192021import &#123; REMOVE_OLD &#125; from '../constants/ActionTypes'const initialState = [ &#123; text: 'Use Redux', completed: false, id: 0, timestamp: Date.now() &#125;]export default function todos(state = initialState, action) &#123; switch (action.type) &#123; case REMOVE_OLD: return state.filter(todo =&gt; &#123; return todo.timestamp + 30 * 24 * 60 * 60 * 1000 &gt; Date.now() &#125;) default: return state &#125;&#125; 下面的selector在每一次REMOVE_OLD调用的时候,都会重新计算,因为Array.filter总是返回一个新对象.但是在大多数情况下,REMOVE_OLD action都不会改变todo列表,所以重新计算是不必要的. 12345678910import &#123; createSelector &#125; from 'reselect'const todosSelector = state =&gt; state.todosexport const visibleTodosSelector = createSelector( todosSelector, (todos) =&gt; &#123; ... &#125;) 你可以通过state更新函数返回一个新对象来减少不必要的重计算操作,这个对象执行深度等值检测,只有深度不相同的时候才返回新对象. 1234567891011121314151617181920212223import &#123; REMOVE_OLD &#125; from '../constants/ActionTypes'import isEqual from 'lodash.isEqual'const initialState = [ &#123; text: 'Use Redux', completed: false, id: 0, timestamp: Date.now() &#125;]export default function todos(state = initialState, action) &#123; switch (action.type) &#123; case REMOVE_OLD: const updatedState = state.filter(todo =&gt; &#123; return todo.timestamp + 30 * 24 * 60 * 60 * 1000 &gt; Date.now() &#125;) return isEqual(updatedState, state) ? state : updatedState default: return state &#125;&#125; 替代的方法是,在selector中使用深度检测方法替代默认的equalityCheck函数: 123456789101112131415161718import &#123; createSelectorCreator, defaultMemoize &#125; from 'reselect'import isEqual from 'lodash.isEqual'const todosSelector = state =&gt; state.todos// create a \"selector creator\" that uses lodash.isEqual instead of ===const createDeepEqualSelector = createSelectorCreator( defaultMemoize, isEqual)// use the new \"selector creator\" to create a selectorconst mySelector = createDeepEqualSelector( todosSelector, (todos) =&gt; &#123; ... &#125;) 检查equalityCheck函数的更替或者在state更新函数中做深度检测并不总是比重计算的花销小.如果每次重计算的花销总是比较小,可能的原因是Reselect没有通过connect函数传递mapStateProps单纯对象的原因. Q:没有Redux的情况下可以使用Reselect吗？A:可以.Reselect没有其他任何的依赖包,因此尽管他设计的和Redux比较搭配,但是独立使用也是可以的.目前的版本在传统的Flux APP下使用是比较成功的. 如果你使用createSelector创建的selectors,需要确保他的参数是immutable的. 看这里 Q:怎么才能创建一个接收参数的selector.A:Reselect没有支持创建接收参数的selectors,但是这里有一些实现类似函数功能的建议. 如果参数不是动态的,你可以使用工厂函数: 1234567891011const expensiveItemSelectorFactory = minValue =&gt; &#123; return createSelector( shopItemsSelector, items =&gt; items.filter(item =&gt; item.value &gt; minValue) )&#125;const subtotalSelector = createSelector( expensiveItemSelectorFactory(200), items =&gt; items.reduce((acc, item) =&gt; acc + item.value, 0)) 总的达成共识看这里和超越 neclear-js是:如果一个selector需要动态的参数,那么参数应该是store中的state.如果你决定好了在应用中使用动态参数,像下面这样返回一个记忆函数是比较合适的: 1234567891011121314import &#123; createSelector &#125; from 'reselect'import memoize from 'lodash.memoize'const expensiveSelector = createSelector( state =&gt; state.items, items =&gt; memoize( minValue =&gt; items.filter(item =&gt; item.value &gt; minValue) ))const expensiveFilter = expensiveSelector(state)const slightlyExpensive = expensiveFilter(100)const veryExpensive = expensiveFilter(1000000) Q：默认的记忆函数不太好,我能用个其他的吗？A: 我认为这个记忆韩式工作的还可以,但是如果你需要一个其他的韩式也是可以的.可以看看这个例子 Q:怎么才能测试一个selector?A:对于一个给定的input,一个selector总是产出相同的结果.基于这个原因,做单元测试是非常简单的. 12345678910111213const selector = createSelector( state =&gt; state.a, state =&gt; state.b, (a, b) =&gt; (&#123; c: a * 2, d: b * 3 &#125;))test(\"selector unit test\", () =&gt; &#123; assert.deepEqual(selector(&#123; a: 1, b: 2 &#125;), &#123; c: 2, d: 6 &#125;) assert.deepEqual(selector(&#123; a: 2, b: 3 &#125;), &#123; c: 4, d: 9 &#125;)&#125;) 在state更新函数调用的时候同时检测selector的记忆函数的功能也是非常有用的(例如 使用Redux的时候检查reducer).每一个selector都有一个recomputations方法返回重新计算的次数:123456789101112131415161718192021222324252627282930313233suite('selector', () =&gt; &#123; let state = &#123; a: 1, b: 2 &#125; const reducer = (state, action) =&gt; ( &#123; a: action(state.a), b: action(state.b) &#125; ) const selector = createSelector( state =&gt; state.a, state =&gt; state.b, (a, b) =&gt; (&#123; c: a * 2, d: b * 3 &#125;) ) const plusOne = x =&gt; x + 1 const id = x =&gt; x test(\"selector unit test\", () =&gt; &#123; state = reducer(state, plusOne) assert.deepEqual(selector(state), &#123; c: 4, d: 9 &#125;) state = reducer(state, id) assert.deepEqual(selector(state), &#123; c: 4, d: 9 &#125;) assert.equal(selector.recomputations(), 1) state = reducer(state, plusOne) assert.deepEqual(selector(state), &#123; c: 6, d: 12 &#125;) assert.equal(selector.recomputations(), 2) &#125;)&#125;) 另外,selectors保留了最后一个函数调用结果的引用,这个引用作为.resultFunc.如果你已经聚合了其他的selectors,这个函数引用可以帮助你测试每一个selector,不需要从state中解耦测试. 例如如果你的selectors集合像下面这样: selectors.js12345678910export const firstSelector = createSelector( ... )export const secondSelector = createSelector( ... )export const thirdSelector = createSelector( ... )export const myComposedSelector = createSelector( firstSelector, secondSelector, thirdSelector, (first, second, third) =&gt; first * second &lt; third) 单元测试就像下面这样:test/selectors.js 1234567891011121314// tests for the first three selectors...test(\"firstSelector unit test\", () =&gt; &#123; ... &#125;)test(\"secondSelector unit test\", () =&gt; &#123; ... &#125;)test(\"thirdSelector unit test\", () =&gt; &#123; ... &#125;)// We have already tested the previous// three selector outputs so we can just call `.resultFunc`// with the values we want to test directly:test(\"myComposedSelector unit test\", () =&gt; &#123; // here instead of calling selector() // we just call selector.resultFunc() assert(selector.resultFunc(1, 2, 3), true) assert(selector.resultFunc(2, 2, 1), false)&#125;) 最后,每一个selector有一个resetRecomputations方法,重置recomputations方法为0,这个参数的意图是在面对复杂的selector的时候,需要很多独立的测试,你不需要管理复杂的手工计算,或者为每一个测试创建”傻瓜”selector. Q:Reselect怎么和Immutble.js一起使用?A:creatSelector创建的Selectors应该可以和Immutable.js数据结构一起完美的工作.如果你的selector正在重计算,并且你认为state没有发生变化,一定要确保知道哪一个Immutable.js更新方法,这个方法只要一更新总是返回新对象.哪一个方法只有集合实际发生变化的时候才返回新对象. 12345678910111213141516import Immutable from 'immutable'let myMap = Immutable.Map(&#123; a: 1, b: 2, c: 3&#125;) // set, merge and others only return a new obj when update changes collectionlet newMap = myMap.set('a', 1)assert.equal(myMap, newMap)newMap = myMap.merge(&#123; 'a', 1 &#125;)assert.equal(myMap, newMap)// map, reduce, filter and others always return a new objnewMap = myMap.map(a =&gt; a * 1)assert.notEqual(myMap, newMap) 如果一个操作导致的selector更新总是返回一个新对象,可能会发生不必要的重计算.看这里.这是一个关于pros的讨论,使用深全等于来检测例如immutable.js来减少不必要的重计算过程. Q:可以在多个组件之间共享selector吗？A: 使用createSelector创建的Selector的缓存的大小只有1.这个设定使得多个组件的实例之间的参数不同,跨组件共享selector变得不合适.这里也有几种办法来解决这个问题: 使用工程函数方法,为每一个组件实例创建一个新的selector.这里有一个内建的工厂方法,React Redux v4.3或者更高版本可以使用. 看这里 创建一个缓存尺寸大于1的定制selector. Q:有TypeScript的类型吗？A: 是的！他们包含在package.json里.可以很好的工作. Q：怎么构建一个柯里化selector?A：尝试一些这里助手函数,由MattSPalmer提供 有关的项目reselect-map因为Reselect不可能保证缓存你所有的需求,在做非常昂贵的计算的时候,这个方法比较有用.查看一下reselect-maps readme reselect-map的优化措施仅仅使用在一些小的案例中,如果你不确定是不是需要他,就不要使用它. LicenseMIT","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"}]},{"title":"翻译|How to conditional create Object with es6","slug":"翻译|选择性创建对象","date":"2019-01-21T19:26:00.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2019/01/21/翻译|选择性创建对象/","link":"","permalink":"https://React-Apollo.github.io/2019/01/21/翻译|选择性创建对象/","excerpt":"","text":"原文参见 在不同资源之间移动用户创建的数据,需要你检查字段是否有值存在.然后可以根据检查结果来构建输出结果. 使用 ES6的特征来做这件事情可以更为简洁. 自从 Sanity.io 发起 Syntax 开始,我就一直在修补 有关 CLIs,Express,Serverless函数方面的博客 RSS. 其中的任务包括解析和构建有很多字段和信息的复杂对象. 因为你要处理来自不同资源的用户数据,所以不能保证所有的字段都是可用的. 因为字段本身也是可选的.而且你也不想在 RSS XML或者 JSON FEED中输出没有值的标签. 很早之前,我的处理方法是在对象上使用新的键,像下面这样: 12345678910111213141516function episodeParser(data) &#123; const &#123; id, title, description, optionalField, anotherOptionalField &#125; = data const parsedEpisode = &#123; guid: id, title, summary: description &#125; if (optionalField) &#123; parsedEpisode.optionalField = optionalField &#125; else if (anotherOptionalField) &#123; parsedEpisode.anotherOptionalField = anotherOptionalField &#125; // and so on return parsedEpisode&#125; 这个方法并不是太优雅(但是还是能工作的),如果你有很多字段,最终会栽在大量的if声明当中. 循环对象键也是类似的归宿. 这意味着代码盘根错节,对于数据对象也不会有什么好的感受. 然而,新的 ES6语法可以改变这些问题. 我发现可以像下面这样来改写代码: 123456789101112131415function episodeParser(&#123; id, title, description = 'No summary', optionalField, anotherOptionalField&#125;) &#123; return &#123; guid: id, title, summary: description, ...(optionalField &amp;&amp; &#123;optionalField&#125;), ...(anotherOptionalField &amp;&amp; &#123;anotherOptionalField&#125;) &#125;&#125; 这个函数有很多属性.第一个参数是参数对象解构,如果在一个函数中有很多参数,对象解构就是一个很好的模式.可以代替下面的模式: 12345function episodePraser(data)&#123; const id=data.id const title=data.title //等等&#125; 可以改写为: 123function(&#123;id,title&#125;)&#123; //等等&#125; 这是一个很好的方法,可以避免在函数中出现很多的参数.也要注意对象解构中的description=&#39;No Summary&#39;部分. 这是默认的使用的参数. 意思是如果description没有定义,可以使用字符串No Summary 作为替补. 第二个是三个小点 展开语法(…) .如果条件为真(&amp;&amp;的用法),就可以解包对象: 123456789&#123; id: 'some-id', ...(true &amp;&amp; &#123; optionalField: 'something'&#125;)&#125;// is the same as&#123; id: 'some-id', optionalField: 'someting'&#125; 最终得到的是一个简洁明了的函数,也很容易测试.一个重要的警告是在使用&amp;&amp;操作符时,数字0是被当做 false的.所以需要注意数据类型. 如果函数用于实战,结果如下 12345678const data = &#123; id: 1, title: 'An episode', description: 'An episode summary', anotherOptionalField: 'some data' &#125;episodeParser(data)//&gt; &#123; guid: 1, title: 'An episode', summary: 'An episode summary', anotherOptionalField: 'some data' &#125;","categories":[{"name":"Medium","slug":"Medium","permalink":"https://React-Apollo.github.io/categories/Medium/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://React-Apollo.github.io/tags/JavaScript/"},{"name":"Ojbect","slug":"Ojbect","permalink":"https://React-Apollo.github.io/tags/Ojbect/"},{"name":"ES6","slug":"ES6","permalink":"https://React-Apollo.github.io/tags/ES6/"}]},{"title":"ML|Basic Linear Algebra for Deep Learning","slug":"ML|Basic Linear Algebra for Deep Learning","date":"2018-04-07T07:52:49.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/04/07/ML|Basic Linear Algebra for Deep Learning/","link":"","permalink":"https://React-Apollo.github.io/2018/04/07/ML|Basic Linear Algebra for Deep Learning/","excerpt":"","text":"原文地址 深度学习的线性代数基础 简介线性代数对于计算机科学家而言有点,有点陌生,因为它是连续的区别于离散量. 线性代数是几何和泛函分析的核心.也是理解机器学习的很关键的前提,尤其是如果你是要编写深度学习的算法. 在机器学习入门时,不需要了解线性代数,但是在某些地方有了线性代数的基础,可以增加理解不同算法差异的直觉. 这会帮助你更好的决定如何来开发机器学习系统. 所以如果你真的想要在这个领域有所建树,线性代数的掌握是必须的. 在线性代数中,数据由线性方程组表征,线性方程组的形式是矩阵(matrices)和矢量(Vector).所以在线性代数中大多数情况下,我们在处理矩阵和矢量,而不是标量(scalar).如果拥有了类似 Nupmy一样的软件包,可以很容易的用几行代码来计算复杂的矩阵乘法. 数学对象 标量(Scalar)标量是简单的数字,例如 23 矢量(Vector)矢量是一组有序的数组,可以是行(row),也可以是列(column).一个矢量只有一个缩影,例如 V2指向矢量内的第二个值,在上图中指的的是-8. 矩阵(Matrix)矩阵是数字的二维数组. 它有两个索引,第一个指向 row,第二个指向 column.例如, M23指向第二行,第三列的值. 是”8”.矩阵可以有多行多列. Vector 也是一个Matrix,只不过只有一行或者一列. 张量(Tensor)Tensor 是一个数字数组, 以规则的网格来排布,拥有一个可变的轴.Tensor有三个轴,第一个指向行,第二个指向列,第三个指向轴.例如, V232指向第二行,第三列,第二个轴上的值.在下图中指向0 Tensor 是最重要的术语,因为 Tensor是一个多维数组,根据 indices 的不同,可以是一个 vector或者一个matrix,.例如一阶 tensor 就是一个 Vector(1索引),二阶(2索引),三阶(3 索引). 还有高阶索引(超过三阶的). 计算的规则1.Matrix-Scalar 操作如果是对一个矩阵执行加减乘除操作,只需要对矩阵的每个元素分别执行操作就可以了. 2.矩阵和矢量的乘法矩阵和矢量的乘积得到一个与矩阵相同行数的矢量. 看看第二张图的计算步骤 11+35=16 41+05=4 21+15=7 另一个例子 这是操作的 cheatsheet 3.Matrix-Matrix 加法和减法矩阵的加减法很简单,必须条件是两个举证要有相同的维度,结果也是同样的维度 4.Matrix-Matrix 乘法其实就是矩阵-矢量的乘法, 把第二个矩阵按列分割为矢量.第一个矩阵分别和矢量做乘法.最后放到一个新的矩阵中. 矩阵乘法的 cheatsheet 矩阵乘法的属性矩阵乘法某些属性可以让我们在一个矩阵乘法中绑定一些计算. 接下来我们逐个介绍. 先从标量开始, 然后是矩阵. 这样做易于理解. 1.Not Commutative标量的乘法是满足交换律的,矩阵的乘法不行.意思是,标量的乘法,73等同于37.但是矩阵的乘法 AB 和 BA是不同的. 2.Associative标量和矩阵都可以用组合律. 标量3(53)等同于(35)3.矩阵一样, A(BC)等同于(A*B)C. 3.Distributive标量和矩阵都满足分配率的3(5+3)=35+33,A(B+C)=AB+AC 4.Identity Matrix单位矩阵是一种特殊的矩阵,首先来看看单位是如何定义的. 数字1是一个单位,因为任何数乘与1都是它本身. 因此矩阵乘一个单位也等于自己. 如果一个矩阵乘与单位矩阵,就满足交换律:AI=IA=A Matrix Inverse(逆) 和 Transpose(转置)Inverse 和 Transpos 是矩阵的两个特殊的属性 1.Inverse什么是 Inverse?一个数字乘与它的逆,等于1. 除了0,每个数字都有逆. 并不是每个矩阵都有逆. 为什么需要逆这个计算? 因为我们不能除矩阵.矩阵没有除法的概念,但是我们可以给矩阵乘一个逆,结果和除法是一样的. 2.Transpose(转置)本质上,转置就是一个矩阵沿着45度轴的一个镜像.获取一个矩阵的转置很容易. 第一个列变为转置矩阵的第一行,第二列变为转置矩阵的第二行. 总结ResourcesDeep Learning (book) — Ian Goodfellow, Joshua Bengio, Aaron Courvillehttps://machinelearningmastery.com/linear-algebra-machine-learning/Andrew Ng’s Machine Learning course on Courserahttps://en.wikipedia.org/wiki/Linear_algebrahttps://www.mathsisfun.com/algebra/scalar-vector-matrix.htmlhttps://www.quantstart.com/articles/scalars-vectors-matrices-and-tensors-linear-algebra-for-deep-learning-part-1https://www.aplustopper.com/understanding-scalar-vector-quantities/","categories":[{"name":"Basic Math","slug":"Basic-Math","permalink":"https://React-Apollo.github.io/categories/Basic-Math/"}],"tags":[{"name":"Linear Algebra","slug":"Linear-Algebra","permalink":"https://React-Apollo.github.io/tags/Linear-Algebra/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://React-Apollo.github.io/tags/Machine-Learning/"}]},{"title":"ML|How to create a Neural Netwrok in javascript in only 30 lines of codes","slug":"ML|How to create a Neural Netwrok in javascript in only 30 lines of codes","date":"2018-04-03T14:51:47.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/04/03/ML|How to create a Neural Netwrok in javascript in only 30 lines of codes/","link":"","permalink":"https://React-Apollo.github.io/2018/04/03/ML|How to create a Neural Netwrok in javascript in only 30 lines of codes/","excerpt":"","text":"使用 synaptic.js 训练一个神经网络 . 解决 XOR 问题 xor 问题实例 num1 xor num2 res 1 xor 1 0 0 xor 0 0 1 xor 0 1 0 xor 1 1 Neurons and synapses神经网络的构建块是: neurons(神经元). neurons类似函数,接收一些输入条件, 返回结果.有不同类型的 neurons,我们使用sigmoid neurons(多层感知),它接收给定的数字, 返回0到1之间的数字 下面的圆环就代表 sigmodi neurons. 接收5返回的是1. 箭头被称为 synapses(突触),负责把 neuron 连接到神经网络的其他层. 那么为什么5是红色的? 因为它是三个 synapses 的总和. 继续来分解一下: 最左侧的的两个绿色的值,和一个被称为 bias 的棕色值. 棕色的值是来源于另一个 neuron 的 首先两个输入值和他们的weights(权重)相乘,分别是蓝色的7,3. 最后,我们在加上 bias ,最终得到红色的5. 这就是我们的人工神经网络的输入值 在这个 sigmoid neuron 上, 所有的输入都被压缩为0~1之间的值. 如果把这些 neuron 的网络连接在一起,就可以得到一个 neural network. 形成的Neural work 会从前到后的传播,彼此通过 synapses 连接在一起. 如下图: neural network 的目标是训练它做归纳,例如识别手写体的数字,或者垃圾邮件.要有一个好的归纳, 拥有正确的 weights bias是重点. 如上述实例中的蓝色和棕色数字. 在训练一个 neural network 时, 简单的给它展示一些手写数字的实例,让 network 可以预测正确的结果. 在每次预测后,将会要计算预测到底有多离谱,逐渐调整 weights 和 bias,直到 networks 在下一轮训练时做的更好. 这个学习过程被称为 backpropagation(反向传播).这个过程重复上千次.neural network 将会非常擅长归纳问题. backpropagation的工作技术超出了本教程. 1234const &#123; Layer, Network &#125; = window.synaptic;var inputLayer = new Layer(2);var hiddenLayer = new Layer(3);var outputLayer = new Layer(1); 接下来,把这些层连接起来,实例化一个新的 network,如下: 1234567inputLayer.project(hiddenLayer);hiddenLayer.project(outputLayer);var myNetwork = new Network(&#123; input: inputLayer, hidden: [hiddenLayer], output: outputLayer&#125;); 由此得到一个2-3-1 network, 如下: 现在来训练这个 network: 12345678910111213141516// train the network - learn XORvar learningRate = .3;for (var i = 0; i &lt; 20000; i++) &#123; // 0,0 =&gt; 0 myNetwork.activate([0,0]); myNetwork.propagate(learningRate, [0]); // 0,1 =&gt; 1 myNetwork.activate([0,1]); myNetwork.propagate(learningRate, [1]); // 1,0 =&gt; 1 myNetwork.activate([1,0]); myNetwork.propagate(learningRate, [1]); // 1,1 =&gt; 0 myNetwork.activate([1,1]); myNetwork.propagate(learningRate, [0]);&#125; 运行2000次, 每次向前,向后传播四次. 传递四个可能的值:[0,0],[0,1],[1,0],[1,1] 从myNetwork.activate([0,0])开始,[0,0]是发送的 network的数据点.这是向前传播,因此被称为 activating 网络. 每次向前传播之后,需要向后传播,这时, network 更新自己的 weights 和 biases. backpropgation通过这一行代码执行:myNetwork.propagate(learningRate,[0]), learningRate是一个常量,告诉 newtork每次要调整多少 weights. 第二个参数0代表给定输入[0,0]应该得到的正确结果. network 之后比较它的预期值和最终的正确值,这会告诉 network 预期到底是正确还是错误的. network 用比较结果作为正确的 weights 和 bias 的基础,以便于下一次能更准确一点. 完成2000次处理过程以后,我们可以用四种可能的输入结果来检查 network 的激活情况. 12345678console.log(myNetwork.activate([0,0])); -&gt; [0.015020775950893527]console.log(myNetwork.activate([0,1]));-&gt;[0.9815816381088985]console.log(myNetwork.activate([1,0]));-&gt; [0.9871822457132193]console.log(myNetwork.activate([1,1]));-&gt; [0.012950087641929467] 如果取整,就会得到争取的结果.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"ML","slug":"ML","permalink":"https://React-Apollo.github.io/tags/ML/"},{"name":"Neural Network","slug":"Neural-Network","permalink":"https://React-Apollo.github.io/tags/Neural-Network/"},{"name":"Javascript","slug":"Javascript","permalink":"https://React-Apollo.github.io/tags/Javascript/"}]},{"title":"Prisma|Reusing & Composing GraphQL APIs with GraphQL Bindings","slug":"Prisma|Reusing   Composing GraphQL APIs with GraphQL Bindings","date":"2018-03-31T12:57:01.000Z","updated":"2019-04-28T05:52:57.892Z","comments":true,"path":"2018/03/31/Prisma|Reusing   Composing GraphQL APIs with GraphQL Bindings/","link":"","permalink":"https://React-Apollo.github.io/2018/03/31/Prisma|Reusing   Composing GraphQL APIs with GraphQL Bindings/","excerpt":"","text":"Prisma|Reusing &amp; Composing GraphQL APIs with GraphQL Bindings 原文地址 使用 GraphQL binding,不需要了解细节问题,可以访问到 GraphQL API 的功能 什么是GraphQL bindings?graphql binding是构建的模块,可以让你在自己的 GraphQL Server中嵌入已经村啊在的 GraphQL APIS 像是搭积木的块. 创建一个 GraphQL API binding的核心思想是提供一个专用的(dedicated)对象,来代表 API 的功能. 这个对象暴露的方法是 GraphQL schema中定义查询的镜像. 不需要在手动构建查询字符串,然后发送到 API(通过fetch或者 GraphQL客户端,例如graphql-request),只需要使用特定程序语言”构建”查询,调用查询方法即可. 在使用 typed 语言时, GraphQL binding 会把 GraphQL API 的 type 映射到对应的编程语言上. GraphQL最具威力的地方就是它的强类型 schema. 然而通过字符串发送查询时, 优势就没有了. Binding可以让我们重新获取这一优势 GraphQL binding 最简单的例子假设有如下的 schema: 123type Query &#123; hello(name:String):String!&#125; 现在,在使用 binding 和这个 schema 交互时,不需要构建查询字符串. 只需要在对象helloWroldBinding对象上调用 代表hello 查询的函数即可: 12345helloWorldBinding.query.hello() .then(result =&gt; console.log(result))helloWorldBinding.query.hello(&#123; name: 'Nikolas' &#125;) .then(result =&gt; console.log(result)) 调用函数时,对象的查询会被发送到 API: 123456789# helloWorldBinding.query.hello()query &#123; hello&#125;# helloWorldBinding.query.hello(&#123; name: &apos;Nikolas&apos; &#125;)query &#123; hello(name: &quot;Nikolas&quot;)&#125; 使用 GraphQL binding 的好处 简化和抽象 API 对IDE的支持 可重用 边编译边做错误检查 语言通用性 构建和共享 GraphQL bindings使用graphql-binding package 这个包的核心是一个Binding类,这个类接收 Graphql shcema 作为构造参数. 这个例子比较简单,实际使用中 schema 需要是远程的 schemas 12345678910111213141516171819202122232425262728const &#123; makeExecutableSchema &#125; = require('graphql-tools')const &#123; Binding &#125; = require('graphql-binding')const users = [ &#123; name: 'Alice', &#125;, &#123; name: 'Bob', &#125;,]const typeDefs = ` type Query &#123; findUser(name: String!): User &#125; type User &#123; name: String! &#125;`const resolvers = &#123; Query: &#123; findUser: (parent, &#123; name &#125;) =&gt; users.find(u =&gt; u.name === name), &#125;,&#125;const schema = makeExecutableSchema(&#123; typeDefs, resolvers &#125;) 上面是创建 schema 的过程,有了 schema 就可以创建Binding实例了: 123const findUserBinding = new Binding(&#123; schema,&#125;) 最后就可以使用 binding 对象findUserBinding来访问 schema 的findUser查询: 1findUserBinding.query.findUser(&#123;name:'Bob'&#125;) 为 GraphQL bidings 生成静态类型使用 GraphQL CLI 生成 TS 类型GraphQL CLI 包含有graphql prepare命令,可以轻松生成静态类型 第一步添加静态类型生成 1234567projects: helloworld: schemaPath: schema.graphql extensions: prepare-binding: output: helloworld.ts generator: binding-ts schemaPaht:指向 GraphQL schema. extensions.prepare-binding.output: 存放生成的 bindings extensions.prepare-binding.generator: generator 使用的地方.. 存在的 generator:binding-js&amp;binding-ts可以用于任何的 GraphQL API.prisma-js&amp;prisma-ts为Prisma 服务提供额外的便利性 假设你的schema 位于shcema.graphql,你可以调用graphql prepare命令生成 TypeScript bindings. 放置在generated/helloworls.ts: 1234567891011121314151617181920212223242526272829303132333435import &#123; Binding as BaseBinding, BindingOptions &#125; from 'graphql-binding'import &#123; GraphQLResolveInfo &#125; from 'graphql'export interface User &#123; name: String&#125;/*The `Boolean` scalar type represents `true` or `false`.*/export type Boolean = boolean/*The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.*/export type String = stringexport interface Schema &#123; query: Query&#125;export type Query = &#123; findUser: (args: &#123; name: String &#125;, context: &#123; [key: string]: any &#125;, info?: GraphQLResolveInfo | string) =&gt; Promise&lt;User | null&gt;&#125;export class Binding extends BaseBinding &#123; constructor(&#123; schema, fragmentReplacements &#125;: BindingOptions) &#123; super(&#123; schema, fragmentReplacements &#125;); &#125; query: Query = &#123; findUser: (args, context, info): Promise&lt;User | null&gt; =&gt; super.delegate('query', 'findUser', args, context, info) &#125;&#125; 这个文件不能手动修改. 新型的ORM: GraphQL database bindingsGraphQL bindings 可以在 database layer 和 application layer 之间生成映射. 在上下文中,可以在 server 中扮演 ORM的角色 例如,使用 Prisma 作为 graphql database layer.你可以直接使用prisma-binding,或者使用prisma-ts生成静态类型 一下是prisma-binding的工作.假设有一个简单的 data model 1234type User&#123; id:ID! @unique name:String!&#125; 在部署以后,会自动生成 Prisma database schema. 这个 schema 定义了 User类型的 CURD 操作. 1234567891011121314type Query &#123; users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]! user(where: UserWhereUniqueInput!): User&#125;type Mutation &#123; createUser(data: UserCreateInput!): User! updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User deleteUser(where: UserWhereUniqueInput!): User&#125;type Subscription &#123; user(where: UserSubscriptionWhereInput): UserSubscriptionPayload&#125; 现在可以实例化Prisma类, 1234567const &#123; Prisma &#125; = require('prisma-binding')const prisma = new Prisma(&#123; schemaPath: 'generated/prisma.graphql', endpoint: 'hhttp://localhost:60000/helloworld/dev', secret: 'my-super-secret-secret' // defined in prisma.yml &#125;) prisma实例现在作为 query,mutations和 subscription的代理. 实例如下: 1234567891011121314// Retrieve `name` of a specific userprisma.query.user(&#123; where &#123; id: 'abc' &#125; &#125;, '&#123; name &#125;')// Retrieve all fields of all usersprisma.query.users()// Create new user called `Sarah` and retrieve the `id`prisma.mutation.createUser(&#123; data: &#123; name: 'Sarah' &#125; &#125;, '&#123; id &#125;')// Update name of a specific user and retrieve the `id`prisma.mutation.updateUser(&#123; where: &#123; id: 'abc' &#125;, data: &#123; name: 'Sarah' &#125; &#125;, '&#123; id &#125;')// Delete a specific userprisma.mutation.deleteUser(&#123; where: &#123; id: 'abc' &#125; &#125;) 实际新版的 prisma 就是这个思路. ==完==","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"Apollo|apollo-link-state local state management","slug":"Apollo|apollo-link-state local state management","date":"2018-03-28T10:40:14.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/03/28/Apollo|apollo-link-state local state management/","link":"","permalink":"https://React-Apollo.github.io/2018/03/28/Apollo|apollo-link-state local state management/","excerpt":"","text":"Apollo-client中的本地数据管理方法. 和远程数据的流动方向一样, 但是在到达 server之前会被 apollo-link-state 截获,并做处理.数据仍然保持单向流动. 调用withClientState方法,并使用 resolver做对应的处理. 12345678910111213141516171819202122import &#123; withClientState &#125; from 'apollo-link-state';// This is the same cache you pass into new ApolloClientconst cache = new InMemoryCache(...);const stateLink = withClientState(&#123; cache, resolvers: &#123; Mutation: &#123; updateNetworkStatus: (_, &#123; isConnected &#125;, &#123; cache &#125;) =&gt; &#123; const data = &#123; networkStatus: &#123; __typename: 'NetworkStatus', isConnected &#125;, &#125;; cache.writeData(&#123; data &#125;); return null; &#125;, &#125;, &#125;&#125;); 在 Apollo-client 上挂载 state,state link 应该在在链的末端,由此其他的 link 可以做逻辑上的处理, 但是必须要在 HttpLink之前,只有这样本地的操作才可以在到达网络之前被截获. 如果使用了持久化查询(persisted queries), 也必须要在apollo-link-persisted-queries之前. 1234const client = new ApolloClient(&#123; cache, link: ApolloLink.from([stateLink, new HttpLink()]),&#125;); 请求远程数据和本地数据,通过@client指令来区分. 12345const UPDATE_NETWORK_STATUS = gql` mutation updateNetworkStatus($isConnected: Boolean) &#123; updateNetworkStatus(isConnected: $isConnected) @client &#125;`; 在组件注入 query 或者 mutate 就可以了 12345const WrappedComponent = graphql(UPDATE_NETWORK_STATUS, &#123; props: (&#123; mutate &#125;) =&gt; (&#123; updateNetworkStatus: isConnected =&gt; mutate(&#123; variables: &#123; isConnected &#125; &#125;), &#125;),&#125;)(NetworkStatus); 如果要从其他组件访问 nework status 怎么办? 因为在访问之前,并不知道是否有UPDATA_NETWORK_STATUS存在,为了防止出现 undefined,需要提供一个默认的 state 作为初始值. 1234567891011121314const stateLink = withClientState(&#123; cache, resolvers: &#123; Mutation: &#123; /* same as above */ &#125;, &#125;, defaults: &#123; networkStatus: &#123; __typename: 'NetworkStatus', isConnected: true, &#125;, &#125;,&#125;); 组件查询 network也使用@client指令 1234567891011const GET_ARTICLES = gql` query &#123; networkStatus @client &#123; isConnected &#125; articles &#123; id title &#125; &#125;`; Defaults123456789101112131415161718const defaults = &#123; todos: [], visibilityFilter: 'SHOW_ALL', networkStatus: &#123; __typename: 'NetworkStatus', isConnected: false, &#125;&#125;;const resolvers = &#123; /* ... */ &#125;;const cache = new InMemoryCache();const stateLink = withClientState(&#123; resolvers, cache, defaults&#125;); Resolversresolvers 是实现 local state 的地方. resolver的 map是对应每个 GraphQL 对象类型的resolver 函数. apollo-link-state有四个重要的部分 cache在上下文中,可以用来读取数据 resolver 应该返回一个有_typename属性的对象, 也可以用dataIdFromObject代替. 目的是 Apollo 用于数据的normalize 如果需要执行异步操作,可以使用 promise. Query只针对 cache. 如果在所有的 mutate 之前执行 query,需要提供默认值 Default resolvers不一定要为每个字段都建立特定的 resolvers,如果从 parent 对象返回的值和children 请求的字段一致,就不需要 resolvers.这就是default resovlers 1234567891011const getUser = gql` query &#123; user(id: 1) @client &#123; name &#123; last first &#125; &#125; &#125;`; Resolvers signatureApollo-client 中的resolver 函数和用graph-tools构建的 server 中的 resolvers 是完全一样的. 1fieldName:(obj,args,context,info)=&gt;result; obj: 包含 parent 字段 或者ROOT_QUERY对象 args: 传递进入的参数, 例如updataNetworkStatus(isConnected:true),args对象就是{isConnected:true} context: 在所有的link 中共享的数据. 重要的的一点是Apollo cache添加在其中,所以可以用cache.writeData({}).如果想设定额外的值,可以在组件内设定,或者使用apollo-link-context. info: 有关 state 执行状态的信息. 个人不会用到 Async resolvers如果想访问 REST 数据,可以参考apollo-link-rest. 对于 RN或者 其他的 browser API,需要在组件的生命周期方法中添加触发函数. 这一部分暂时不写Organizing resolvers使用鸭子类型 ,每个feature都有自己的一套方法,然后合并起来 1234567891011import merge from 'lodash.merge';import &#123; withClientState &#125; from 'apollo-link-state';import currentUser from './resolvers/user';import cameraRoll from './resolvers/camera';import networkStatus from './resolvers/camera';const stateLink = withClientState(&#123; cache, resolvers: merge(currentUser, cameraRoll, networkStatus),&#125;); 可以设定默认值 12345678910111213const currentUser = &#123; defaults: &#123; currentUser: null, &#125;, resolvers: &#123; ... &#125;&#125;;const cameraRoll = &#123; defaults: &#123; ... &#125;, resolvers: &#123; ... &#125;&#125;;const stateLink = withClientState(&#123; ...merge(currentUser, cameraRoll, networkStatus), cache,&#125;); updating the cache可以通过context访问或者更新 cache. Apollo cache API 有几个方法 writeData直接在 Cahce 中写入数据,不用通过 query. 12345678const filter = &#123; Mutation: &#123; updateVisibilityFilter: (_, &#123; visibilityFilter &#125;, &#123; cache &#125;) =&gt; &#123; const data = &#123; visibilityFilter, __typename: 'Filter' &#125;; cache.writeData(&#123; data &#125;); &#125;, &#125;,&#125;; 如果传递id属性,也可以在已经存在的对象中写入片段数据. 这里的id应该对应对象的 cache key. 如果使用InMemroyCache,并且没有覆盖dataObjectFromId,cache key就是_typename:id 12345678const user = &#123; Mutation: &#123; updateUserEmail: (_, &#123; id, email &#125;, &#123; cache &#125;) =&gt; &#123; const data = &#123; email &#125;; cache.writeData(&#123; id: `User:$&#123;id&#125;`, data &#125;); &#125;, &#125;,&#125;; writeQuery 和 readQuery在某些情况下,写入到 cache 的数据依赖于已经存在的数据,例如 ,在 list 中添加一条 item或者对属性做修改. 做法是使用cache.readQuery传递 query,在写入数据之前从 cache 中读取数据. 看看 list的例子 1234567891011121314151617181920212223242526272829303132let nextTodoId = 0;const todos = &#123; defaults: &#123; todos: [], &#125;, resolvers: &#123; Mutation: &#123; addTodo: (_, &#123; text &#125;, &#123; cache &#125;) =&gt; &#123; const query = gql` query GetTodos &#123; todos @client &#123; id text completed &#125; &#125; `; const previous = cache.readQuery(&#123; query &#125;); const newTodo = &#123; id: nextTodoId++, text, completed: false, __typename: 'TodoItem' &#125;, const data = &#123; todos: previous.todos.concat([newTodo]), &#125;; // you can also do cache.writeData(&#123; data &#125;) here if you prefer cache.writeQuery(&#123; query, data &#125;); return newTodo; &#125;, &#125;, &#125;,&#125;; 为了在 list 中添加 todo, 需要当前的 todos, 可以通过cache.readQuery获取. 为了写入数据到 cache.可以使用cache.writeQuery,cache.writeData. 不同点在于cache.writeQuery需要传递 query,来验证 data的结构. 在底层,cache.write自动从data构建了 query. writeFragment 和 readFragmentcache.writeFragment,在有了 cache key 情况下, 可以灵活的读取数据. 1234567891011121314151617181920const todos = &#123; resolvers: &#123; Mutation: &#123; toggleTodo: (_, variables, &#123; cache &#125;) =&gt; &#123; const id = `TodoItem:$&#123;variables.id&#125;`; const fragment = gql` fragment completeTodo on TodoItem &#123; completed &#125; `; const todo = cache.readFragment(&#123; fragment, id &#125;); const data = &#123; ...todo, completed: !todo.completed &#125;; // you can also do cache.writeData(&#123; data, id &#125;) here if you prefer cache.writeFragment(&#123; fragment, id, data &#125;); return null; &#125;, &#125;, &#125;,&#125;; @client directiveCombining local and remote data下面的例子中,我们从 server 获取到 username,从 apollo cache 获取到 cart 信息.两者在结果中融合在一起 1234567891011121314const getUser = gql` query getUser($id: String) &#123; user(id: $id) &#123; id name cart @client &#123; product &#123; name id &#125; &#125; &#125; &#125;`;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"},{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"}]},{"title":"quokka.js 的使用","slug":"quokka 的用法","date":"2018-03-27T17:13:38.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2018/03/27/quokka 的用法/","link":"","permalink":"https://React-Apollo.github.io/2018/03/27/quokka 的用法/","excerpt":"","text":"Instant console tools quokka.js 文档 直接看图, 可以实现Ramda的Try Ramda 类似的效果. 安装 实时反馈 console输出 实际操作效果","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://React-Apollo.github.io/tags/vscode/"},{"name":"tools","slug":"tools","permalink":"https://React-Apollo.github.io/tags/tools/"}]},{"title":"Apollo|Using Fragments","slug":"Apollo|Using Fragments","date":"2018-03-27T10:39:30.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/03/27/Apollo|Using Fragments/","link":"","permalink":"https://React-Apollo.github.io/2018/03/27/Apollo|Using Fragments/","excerpt":"","text":"GraphQL fragments是可以共享的查询逻辑 1234567891011fragment NameParts on Person &#123; firstName lastName&#125;query getPerson &#123; people(id: \"7\") &#123; ...NameParts avatar(size: LARGE) &#125;&#125; 在 Apollo中 fragment 有两个主要的用法: 在多个查询,突变或订阅中共享字段 Breaking your queries up to allow you to co-locate field access with the places they are used. Reusing Fragments直接的用法就是重用片段 123456789101112131415import gql from 'graphql-tag';CommentsPage.fragments = &#123; comment: gql` fragment CommentsPageComment on Comment &#123; id postedBy &#123; login html_url &#125; createdAt content &#125; `,&#125;; 需要使用 fragment 时, 简单的使用...Name语法. 在查询文档中嵌入 12345678910111213141516171819202122const SUBMIT_COMMENT_MUTATION = gql` mutation submitComment($repoFullName: String!, $commentContent: String!) &#123; submitComment(repoFullName: $repoFullName, commentContent: $commentContent) &#123; ...CommentsPageComment &#125; &#125; $&#123;CommentsPage.fragments.comment&#125;`;export const COMMENT_QUERY = gql` query Comment($repoName: String!) &#123; # ... entry(repoFullName: $repoName) &#123; # ... comments &#123; ...CommentsPageComment &#125; # ... &#125; &#125; $&#123;CommentsPage.fragments.comment&#125;`; Colocating FragmentsGraphQL的一个好处是, 响应数据天然是树形结构,在很多实例中, 和组件的层级关系形成映射.由此,结合GraphQL对 fragment 的支持,可以按照对应结构对查询做出分割. 例如在GitHunt 中构建FeedPage实例,有如下的层级结构 12345FeedPage└── Feed └── FeedEntry ├── RepoInfo └── VoteButtons FeedPage 执行一个查询获取Entry列表.每个子组件需要Entry的不同字段. graphql-anywhere包提供的工具可以构建出子组件需要的所有字段的查询,从而让你轻松的传递所有组件需要确切字段 Creating Fragments再次使用gql助手,添加子字段 12345678910VoteButtons.fragments = &#123; entry: gql` fragment VoteButtons on Entry &#123; score vote &#123; vote_value &#125; &#125; `,&#125;; 如果片段包含有子片段, 使用gql助手传递 123456789101112131415161718FeedEntry.fragments = &#123; entry: gql` fragment FeedEntry on Entry &#123; commentCount repository &#123; full_name html_url owner &#123; avatar_url &#125; &#125; ...VoteButtons ...RepoInfo &#125; $&#123;VoteButtons.fragments.entry&#125; $&#123;RepoInfo.fragments.entry&#125; `,&#125;; Filtering With Fragments在字段传递给子组件的时候,也可是过滤出确切的字段 12345678910import &#123; filter &#125; from 'graphql-anywhere';&lt;VoteButtons entry=&#123;filter(VoteButtons.fragments.entry, entry)&#125; canVote=&#123;loggedIn&#125; onVote=&#123;type =&gt; onVote(&#123; repoFullName: full_name, type, &#125;)&#125;/&gt; filter()会从 entry中得到确切的字段 使用 Webpack 导入 fragments在使用graphql-tag/loader导入.graphql文件时,可以使用import, 1#import \"./someFragments.graphql\"","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"}]},{"title":"Cheatsheet|Typescript","slug":"Cheatsheet|TypeScript","date":"2018-03-26T14:21:43.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/03/26/Cheatsheet|TypeScript/","link":"","permalink":"https://React-Apollo.github.io/2018/03/26/Cheatsheet|TypeScript/","excerpt":"","text":"","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://React-Apollo.github.io/tags/javascript/"},{"name":"typescript","slug":"typescript","permalink":"https://React-Apollo.github.io/tags/typescript/"},{"name":"cheatsheet","slug":"cheatsheet","permalink":"https://React-Apollo.github.io/tags/cheatsheet/"}]},{"title":"Apollo| apollo-link 概念","slug":"Apollo| apollo-link 概念","date":"2018-03-22T10:38:59.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/03/22/Apollo| apollo-link 概念/","link":"","permalink":"https://React-Apollo.github.io/2018/03/22/Apollo| apollo-link 概念/","excerpt":"","text":"这个概念实际和 redux的 middleware 类似, 就是在数据流处理中的增加环节 概念总览Apollo Link设计目的是组合围绕 GraphQL数据操作的 actions.每个link代表着创建复杂数据控制流程的子功能. 基础是一个函数接收一个操作,返回一个 observable. 一个操作对象有一下的信息: ① query :DocumentNode(解析 GraphQL Operation)描述发生的操作 ② variables:伴随 operation 发送的变量映射 ③ operationName: 查询的名字,可以为 null ④ extensions:发送到 server 的数据在 Store的映射 ⑤ getContext: 返回请求 context 的函数. 被 link 用来决定执行哪一个 actions ⑥ setContext: 创建一个新的 context 对象,或者是接受之前的 context,返回一个新的 context. 和React 的setState行为类似 ⑦ toKey: 把当前的操作转为字符串作为 uniq的函数 可以链式操作这些操作. compose action,从而实现复杂的操作逻辑 上图中最后 link的终点是 server,实际 结果可以来自于任何地方 Requestlink 的核心是request方法,接收参数如下: operation: 传递给 link的操作 forward: 声明链中接下来的 link Contextlink 可以形成链式操作, 所以需要在链中传递一些数据.context 的操作和 React 的setState类似 123456789101112131415const timeStartLink = new ApolloLink((operation, forward) =&gt; &#123; operation.setContext(&#123; start: new Date() &#125;); return forward(operation);&#125;);const logTimeLink = new ApolloLink((operation, forward) =&gt; &#123; return forward(operation).map((data) =&gt; &#123; // data from a previous link const time = new Date() - operation.getContext().start; console.log(`operation $&#123;operation.operationName&#125; took $&#123;time&#125; to complete`); return data; &#125;)&#125;);const link = timeStartLink.concat(logTimeLink) conxt 可以在 operation 开始的时候发送.例如可以在执行 query时 发送 context 12345678910111213const link = new ApolloLink((operation, forward) =&gt; &#123; const &#123; saveOffline &#125; = operation.getContext(); if (saveOffline) // do offline stuff return forward(operation);&#125;)const client = new ApolloClient(&#123; cache: new InMemoryCache() link,&#125;);// send context to the linkconst query = client.query(&#123; query: MY_GRAPHQL_QUERY, context: &#123; saveOffline: true &#125;&#125;);","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"}]},{"title":"Apollo| Stateless Links","slug":"Apollo|Stateless Links","date":"2018-03-22T10:37:32.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/03/22/Apollo|Stateless Links/","link":"","permalink":"https://React-Apollo.github.io/2018/03/22/Apollo|Stateless Links/","excerpt":"","text":"Stateless Links有些Link在每次请求中做的工作相同, 不需要知道具体的操作是什么. 这样的 Link 被称为 stateless Link. 不会在 link 之间共享 state. 对应的是 stateful Link Stateless Links 可以作为包装ApolloLink接口的简单函数. 例如: 123456789import &#123; ApolloLink &#125; from 'apollo-link';const consoleLink = new ApolloLink((operation, forward) =&gt; &#123; console.log(`starting request for $&#123;operation.operationName&#125;`); return forward(operation).map((data) =&gt; &#123; console.log(`ending request for $&#123;operation.operationName&#125;`); return data; &#125;)&#125;) statelss link 可以作为 middleware. 给 apollo-link-http 添加请求头是非常简单的一件事: 12345678import &#123; ApolloLink &#125; from 'apollo-link';const authLink = new ApolloLink((operation, forward) =&gt; &#123; operation.setContext((&#123; headers &#125;) =&gt; (&#123; headers: &#123; authorization: Meteor.userId() // however you get your token &#125;&#125;)); return forward(operation);&#125;); 可以定制操作函数例如: 12345678910import &#123; ApolloLink &#125; from 'apollo-link';const reportErrors = (errorCallback) =&gt; new ApolloLink((operation, forward) =&gt; &#123; const observer = forward(operation); // errors will be sent to the errorCallback observer.subscribe(&#123; error: errorCallback &#125;) return observer;&#125;);const link = reportErrors(console.error); Extending ApolloLink12345678910111213141516import &#123; ApolloLink &#125; from 'apollo-link';class ReportErrorLink extends ApolloLink &#123; constructor(errorCallback) &#123; super(); this.errorCallback = errorCallback; &#125; request(operation, forward) &#123; const observer = forward(operation); // errors will be sent to the errorCallback observer.subscribe(&#123; error: this.errorCallback &#125;) return observer; &#125;&#125;const link = new ReportErrorLink(console.error);","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"}]},{"title":"Apollo|Stateful Links","slug":"Apollo|Stateful Links","date":"2018-03-22T10:37:07.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/03/22/Apollo|Stateful Links/","link":"","permalink":"https://React-Apollo.github.io/2018/03/22/Apollo|Stateful Links/","excerpt":"","text":"Stateful Links某些 Link 需要在请求之间共享 state,从而完成额外的功能.Stateful links 总是重写ApolloLink 1234567891011121314import &#123; ApolloLink &#125; from 'apollo-link';class OperationCountLink extends ApolloLink &#123; constructor() &#123; super(); this.operations = 0; &#125; request(operation, forward) &#123; this.operations++ return forward(operation); &#125;&#125;const link = new OperationCountLink();","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"}]},{"title":"摘要|Using Apollo with TypeScript","slug":"摘要|Using Apollo with TypeScript","date":"2018-03-16T10:40:34.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/03/16/摘要|Using Apollo with TypeScript/","link":"","permalink":"https://React-Apollo.github.io/2018/03/16/摘要|Using Apollo with TypeScript/","excerpt":"","text":"typescript 需要额外定义类型12345678910111213141516171819202122232425262728293031323334353637383940import React from \"react\";import gql from \"graphql-tag\";import &#123; graphql &#125; from \"react-apollo\";const HERO_QUERY = gql` query GetCharacter($episode: Episode!) &#123; hero(episode: $episode) &#123; name id friends &#123; name id appearsIn &#125; &#125; &#125;`;//类型type Hero = &#123; name: string; id: string; appearsIn: string[]; friends: Hero[];&#125;;//查询结果的类型type Response = &#123; hero: Hero;&#125;;const withCharacter = graphql&lt;Response&gt;(HERO_QUERY, &#123; options: () =&gt; (&#123; variables: &#123; episode: \"JEDI\" &#125; &#125;)&#125;);export default withCharacter((&#123; data: &#123; loading, hero, error &#125; &#125;) =&gt; &#123; if (loading) return &lt;div&gt;Loading&lt;/div&gt;; if (error) return &lt;h1&gt;ERROR&lt;/h1&gt;; return ...// actual component with data;&#125;); 对于查询参数也需要定义类型123456789type InputProps = &#123; episode: string&#125;;const withCharacter = graphql&lt;Response, InputProps&gt;(HERO_QUERY, &#123; options: (&#123; episode &#125;) =&gt; (&#123; variables: &#123; episode &#125; &#125;),&#125;); 在包装组件获取 props 时也需要定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React from \"react\";import gql from \"graphql-tag\";import &#123; graphql, NamedProps, QueryProps&#125; from \"react-apollo\";const HERO_QUERY = gql` query GetCharacter($episode: Episode!) &#123; hero(episode: $episode) &#123; name id friends &#123; name id appearsIn &#125; &#125; &#125;`;type Hero = &#123; name: string; id: string; appearsIn: string[]; friends: Hero[];&#125;;type Response = &#123; hero: Hero;&#125;;type WrappedProps = Response &amp; QueryProps;type InputProps = &#123; episode: string&#125;;const withCharacter = graphql&lt;Response, InputProps, WrappedProps&gt;(HERO_QUERY, &#123; options: (&#123; episode &#125;) =&gt; (&#123; variables: &#123; episode &#125; &#125;), props: (&#123; data &#125;) =&gt; (&#123; ...data &#125;)&#125;);export default withCharacter((&#123; loading, hero, error &#125;) =&gt; &#123; if (loading) return &lt;div&gt;Loading&lt;/div&gt;; if (error) return &lt;h1&gt;ERROR&lt;/h1&gt;; return ...// actual component with data;&#125;); 使用class组件定义","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"}]},{"title":"PokeMon datamodel","slug":"Pokemo-datamodel","date":"2018-03-16T10:04:10.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/03/16/Pokemo-datamodel/","link":"","permalink":"https://React-Apollo.github.io/2018/03/16/Pokemo-datamodel/","excerpt":"","text":"123456789101112type Trainer &#123; id: String! name: String! ownedPokemons: [Pokemon] # 一个训练师有多个宠物&#125;type Pokemon &#123; id: String! url: String! name: String! trainer: Trainer # 一个宠物属于一个训练师&#125; 基础查询 12345678910111213const TrainerQuery = gql` query TrainerQuery($name: String!) &#123; Trainer(name: $name) &#123; id name ownedPokemons &#123; id name url &#125; &#125; &#125;` ownedPokeMons是一个数组,可以用Trainer.ownedPokemons.length,获取到训练师所有的宠物的数量. 宠物详情查询 123456789const PokemonQuery = gql` query PokemonQuery($id: ID!) &#123; Pokemon(id: $id) &#123; id url name &#125; &#125;`","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"datamodel","slug":"datamodel","permalink":"https://React-Apollo.github.io/tags/datamodel/"}]},{"title":"The way to Typescript","slug":"The way to  TypeScript","date":"2018-03-16T08:34:49.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2018/03/16/The way to  TypeScript/","link":"","permalink":"https://React-Apollo.github.io/2018/03/16/The way to  TypeScript/","excerpt":"","text":"The init work to Typescript","categories":[{"name":"Init","slug":"Init","permalink":"https://React-Apollo.github.io/categories/Init/"}],"tags":[{"name":"Anything","slug":"Anything","permalink":"https://React-Apollo.github.io/tags/Anything/"}]},{"title":"摘要|Offline-First Web Application Using Redux and PouchDB","slug":"摘要|Offline-First Web Application Using Redux and PouchDB","date":"2018-03-12T10:07:01.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/03/12/摘要|Offline-First Web Application Using Redux and PouchDB/","link":"","permalink":"https://React-Apollo.github.io/2018/03/12/摘要|Offline-First Web Application Using Redux and PouchDB/","excerpt":"","text":"摘要|Offline-First Web Application Using Redux and PouchDB 5步构建离线优先web 应用 离线应用使用本地存储作为主要数据源, 数据不断和远程数据库同步为什么使用离线优先的模式?离线优先的应用有如下有点: 页面加载更高效 离线,在线工作状态没有区别 避免偶然的数据丢失. 使用 React,Redux和 PouchDB1.React和 Redux 构架 Redux作为 React 的数据管理工具, 模式是单一 store 2.PouchDB PoucdDB来源于 couchDB, 属于客户端的 NO-SQL 数据库. 用来存储本地数据 3.如何使用 Redux 和 PouchDB可以使用开源的包:redux-pouchdb 之后只需要导出 reducer 就可以了 4. 本地数据和远程数据库同步a)使用 CouchDB 使用CouchDB 的原因是,它和 pouchDB 同步很容易. PouchDB提供了同步的方法,允许单向或者双向同步. 只需要在开始的时候使用 Pouch.sync. b)使用已经存在的数据库PouchDB 在后台会一直尝试和远程数据库建立连接, 如果网络状态不稳定,等到有网络连接时,后台就会执行同步操作,发送离线数据 如果用户关掉窗口怎么办?所有的变化都保存在 reducer 中,并和 PouchDB 同步. 所以如果用户关掉窗口,数据也不会丢失. 5. Service Workers","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React-Native","slug":"React-Native","permalink":"https://React-Apollo.github.io/tags/React-Native/"},{"name":"offline","slug":"offline","permalink":"https://React-Apollo.github.io/tags/offline/"},{"name":"PouchDB","slug":"PouchDB","permalink":"https://React-Apollo.github.io/tags/PouchDB/"}]},{"title":"摘要|GraphQL Persisted Queries using GET Requests","slug":"摘要|GraphQL Persisted Queries using GET Requests","date":"2018-03-11T10:28:49.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/03/11/摘要|GraphQL Persisted Queries using GET Requests/","link":"","permalink":"https://React-Apollo.github.io/2018/03/11/摘要|GraphQL Persisted Queries using GET Requests/","excerpt":"","text":"原文:GraphQL Persisted Queries using GET Requests 摘要总结通过express 的中间件实现了 graphql Persisted Queries,在前端查询时使用的普通的GET请求,带有hash变量和具体变量, hash变量用于从服务器获取到对应的查询或者突变 schema,然后和具体的变量组合成真正的查询字符窜, 之后实施真正的 Graphql 查询工作, 并返回信息给前端 实现要点:1. 构建的hash 和查询的映射extracted_queries.js 12345678module.exports = &#123; 1: `query Greeting($name: String!) &#123; greeting(name: $name) &#123; name text &#125; &#125;` &#125; 2. 构建 Presist Query 中间件persistedQueries.js 12345678910111213141516171819const &#123; omit &#125; = require('ramda')const queryMap = require('./extracted_queries.js')const persistedQueries = (req, res, next) =&gt; &#123; const &#123; hash = '' &#125; = req.query if (!hash) return next() const query = queryMap[hash] if (!query) &#123; res.status(400).json(&#123; error: [&#123;&#125;] &#125;) return next(new Error('Invalid query hash')) &#125; req.query = &#123; query, variables: omit(['hash'], req.query) &#125; next()&#125;module.exports = persistedQueries 如果 hash存在,就提取出查询字符串和变量组成新的查询 3. 构建 graphql server1234567891011121314151617181920212223const express = require('express')const bodyParser = require('body-parser') const playground = require('graphql-playground-middleware-express').defaultconst &#123; graphqlExpress, graphiqlExpress &#125; = require('apollo-server-express')const &#123; makeExecutableSchema &#125; = require('graphql-tools')const persistedQueries = require('./persistedQueries')const typeDefs = require('./schemas')const resolvers = require('./resolvers')const port = 4000const app = express()const schema = makeExecutableSchema(&#123; typeDefs, resolvers &#125;)app.use( '/graphql', bodyParser.json(), persistedQueries, //对 get请求进行匹配操作.匹配的查询进入具体的查询操作 graphqlExpress(&#123; schema &#125;))//playground实现app.use( '/playground', playground(&#123; endpoint: '/graphql' &#125;))app.listen(port, () =&gt; console.log(`listening on port: $&#123;port&#125;`)) 构想如果是常规的 Redux 构架, REST API太多, 造成 Action过多, 如果是使用上述的方法, 可以把一个大的页面的数据查询组合成一个单独的 REST请求. 简化了前端的 Action这样还可以使用不同的 GraphQL的数据","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Persisted Queries","slug":"Persisted-Queries","permalink":"https://React-Apollo.github.io/tags/Persisted-Queries/"}]},{"title":"摘要|How do GraphQL remote schemas work?","slug":"摘要|How do GraphQL remote schemas work","date":"2018-03-10T22:16:54.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/03/10/摘要|How do GraphQL remote schemas work/","link":"","permalink":"https://React-Apollo.github.io/2018/03/10/摘要|How do GraphQL remote schemas work/","excerpt":"","text":"Understanding GraphQL schema stitching(part I)目的是使用已经有的 graphql API,通过我们自己的服务器暴露出来. 在配置阶段,我们只是简单的转发收到的GraphQL query 和 mutations. 负责转发这些操作的组件被称为 remote(executable)schema. Remote shcema 作为 schema stitching schema的基础工具. 下面讨论一下细节问题. 回忆一下 GraphQL schemasschema由两个主要组件构成(这里的组件不是 react组件) schema definition: 这部分通常用 schema definition language(SDL).本质上, schema 定义了 server能够接受的操作是什么, 需要报含Query type,可选的Mutations,Subscription. 可以用typeDefs定义 Resolvers: 这里是 shcema 真正进入到实际操作的地方, Resolvers实现了有由 schema 定义的 API 规范. 当一个 schema 有了 definition和 resolver,被称为executable schema. 下面是简单的实例,使用graphql-tools 的makeEcecutableSchema函数: 123456789101112131415161718192021222324252627const &#123; makeExecutableSchema &#125; = require('graphql-tools')// SCHEMA DEFINITIONconst typeDefs = `type Query &#123; user(id: ID!): User&#125;type User &#123; id: ID! name: String&#125;`// RESOLVERSconst resolvers = &#123; Query: &#123; user: (root, args, context, info) =&gt; &#123; return fetchUserById(args.id) //可以是数据库查询,或者是从其他的 //REST API 获取数据 &#125; &#125;,&#125;// (EXECUTABLE) SCHEMAconst schema = makeExecutableSchema(&#123; typeDefs, resolvers&#125;) typeDefs包含了 schema 定义, 由Query和简单的User type组成. resolvers是包含了如何实现Query type 中user字段实现的方案 makeEcecutableSchema: 从 SDL type 映射到对应的 resolver. 返回的实例可以用于直接的查询. 例如graphql函数 123456789101112131415... // other importsconst &#123; graphql &#125; = require('graphql')const schema = ... // the schema from aboveconst query = ` query &#123; user(id: \"abc\") &#123; id name &#125; &#125;`graphql(schema, query) .then(result =&gt; console.log(result)) 因为 grphql 函数可以根据 GraphQLSchema的实例来查询,所以也可以被认为是 GraphQL(execute) 引擎 以上只是回顾. 现在看看如何根据已经存在的 graphql API 创建GraphQLSchema的可执行实例 Introspecting GraphQL APISGraphQL的有一个很趁手的属性, introspection. 可以发起一个 introspection query 来获取schema的定义. 12345678910query &#123; __schema &#123; types &#123; name fields &#123; name &#125; &#125; &#125;&#125; 返回的是 json 格式的数据 12345678910111213141516171819202122232425262728&#123; \"data\": &#123; \"__schema\": &#123; \"types\": [ &#123; \"name\": \"Query\", \"fields\": [ &#123; \"name\": \"user\" &#125; ] &#125;, &#123; \"name\": \"User\", \"fields\": [ &#123; \"name\": \"id\" &#125;, &#123; \"name\": \"name\" &#125; ] &#125;, // ... some more metadata ] &#125; &#125;&#125; 返回的 schema和我们自己定义的 shcema 很像, 稍有差别,但是可以修改 创建一个 remote schema makeRemoteExecutableSchema接收两个参数 一个 shcema 定义(这里通过 introspection 获取). 最佳实践是直接定义为 .grpahql文件 Link连接被代理的 GraphQL API. 本质上, Link 是转发 query 和 mutation 的组件. 没有办法获取到 remote的 resolver.但是可以创建新的 resolver,来转发操作到内部的 GraphQL API. 看看实际的代码, 基于一个 API,用于User模型. 1234567891011121314151617181920212223242526272829const fetch = require('node-fetch')const &#123; makeRemoteExecutableSchema, introspectSchema &#125; = require('graphql-tools')const &#123; GraphQLServer &#125; = require('graphql-yoga')const &#123; createHttpLink &#125; = require('apollo-link-http')const &#123; DATABASE_SERVICE_ID &#125; = require('./services')async function run() &#123; // 1. Create Apollo Link that's connected to the underlying GraphQL API const makeDatabaseServiceLink = () =&gt; createHttpLink(&#123; uri: `https://api.graph.cool/simple/v1/$&#123;DATABASE_SERVICE_ID&#125;`, fetch &#125;) // 2. Retrieve schema definition of the underlying GraphQL API const databaseServiceSchemaDefinition = await introspectSchema(makeDatabaseServiceLink()) // 3. Create the executable schema based on schema definition and Apollo Link const databaseServiceExecutableSchema = makeRemoteExecutableSchema(&#123; schema: databaseServiceSchemaDefinition, link: makeDatabaseServiceLink() &#125;) // 4. Create and start proxy server based on the executable schema const server = new GraphQLServer(&#123; schema: databaseServiceExecutableSchema &#125;) server.start(() =&gt; console.log('Server is running on http://localhost:4000'))&#125;run() 用于User type 的 CRUD API 123456789101112131415type User @model &#123; id: ID! @isUnique name: String!&#125;type Query &#123; allUsers: [User!]! User(id: ID!): User&#125;type Mutation &#123; createUser(name: String!): User updateUser(id: ID!, name: String): User deleteUser(id: ID!): User&#125; 底层的 Remote schemasInspecting GraphQL schemas 篮框显示Query type和他的属性. 有字段allUsers,但是 没有 resolver,所以这不是可执行的. 现在有 resolver了. 继续看看 resolver的实现,(这是由 makeRemoteExecuteableSchema 自动生成的). 1234567891011121314151617181920212223function (root, args, context, info) &#123; return __awaiter(_this, void 0, void 0, function () &#123; var fragments, document, result; return __generator(this, function (_a) &#123; switch (_a.label) &#123; case 0: fragments = Object.keys(info.fragments).map(function (fragment) &#123; return info.fragments[fragment]; &#125;); document = &#123; kind: graphql_1.Kind.DOCUMENT, definitions: [info.operation].concat(fragments), &#125;; return [4 /*yield*/, fetcher(&#123; query: graphql_2.print(document), variables: info.variableValues, context: &#123; graphqlContext: context &#125;, &#125;)]; case 1: result = _a.sent(); return [2 /*return*/, errors_1.checkResultAndHandleErrors(result, info)]; &#125; &#125;); &#125;);&#125; 12-16行代码 函数fetcher用三个参数调用,query,variables,context,","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"GraphQL|Github graphql API  文档示意","slug":"GraphQL|Github graphql API  文档示意","date":"2018-03-09T10:52:29.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/03/09/GraphQL|Github graphql API  文档示意/","link":"","permalink":"https://React-Apollo.github.io/2018/03/09/GraphQL|Github graphql API  文档示意/","excerpt":"","text":"克隆 gitpoint 的项目 ,记录一下 GraphQL 的查询,就可以作为文档了. 按照 gitpoint 的 tab顺序来. 项目初衷, gitpoint 用的是 Redux,写的很好,功能也很完备,Redux的一个优点是单一数据来源.但是如果是远程数据, REST API 提供的数据, 却并不是单一来源的,而且每个远程请求的状态都要自己配置. 代码量太大. 使用 GraphQL的服务, 真正做到了单一数据来源, 把多个数据接口变为一个接口. 返回数据可以灵活安排, 代码减少了很多. 1.Profile 查询1.1 profile.screen 数据查询viewer 查询当前登录用户的信息 123456789101112131415161718192021222324252627282930313233343536373839404142query viewer&#123; viewer&#123; login email bio name avatarUrl location repositories&#123; totalCount &#125; repositoriesContributedTo&#123; totalCount &#125; followers&#123; totalCount &#125; following&#123; totalCount &#125; organizations(first:5)&#123; edges&#123; node&#123; name avatarUrl teams(first:5)&#123; edges&#123; node&#123; name avatarUrl &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 结果 一次查询出 profile 页面的所有数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; \"data\": &#123; \"viewer\": &#123; \"repositoriesContributedTo\": &#123; \"totalCount\": 6 &#125;, \"login\": \"phpsmarter\", \"email\": \"3238355967@qq.com\", \"bio\": \"A React Native code beginner\", \"name\": \"phpsmarter\", \"avatarUrl\": \"https://avatars3.githubusercontent.com/u/10001670?v=4\", \"location\": null, \"repositories\": &#123; \"totalCount\": 486 &#125;, \"followers\": &#123; \"totalCount\": 5 &#125;, \"following\": &#123; \"totalCount\": 0 &#125;, \"organizations\": &#123; \"edges\": [ &#123; \"node\": &#123; \"name\": \"edulamp\", \"avatarUrl\": \"https://avatars2.githubusercontent.com/u/10001682?v=4\", \"teams\": &#123; \"edges\": [ &#123; \"node\": &#123; \"name\": \"Owners\", \"avatarUrl\": \"https://avatars2.githubusercontent.com/t/1156109?s=400&amp;v=4\" &#125; &#125; ] &#125; &#125; &#125; ] &#125; &#125; &#125;&#125; 1.2 查询粉丝12345678910111213query FollowerList &#123; user(login: \"phpsmarter\") &#123; followers(first: 10) &#123; edges &#123; node &#123; name avatarUrl email &#125; &#125; &#125; &#125;&#125; 结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; \"data\": &#123; \"user\": &#123; \"followers\": &#123; \"edges\": [ &#123; \"node\": &#123; \"name\": \"liujian zhang\", \"avatarUrl\": \"https://avatars2.githubusercontent.com/u/4494312?v=4\", \"email\": \"ziaochina@gmail.com\" &#125; &#125;, &#123; \"node\": &#123; \"name\": \"Ömer DOĞAN\", \"avatarUrl\": \"https://avatars2.githubusercontent.com/u/6252528?v=4\", \"email\": \"omer_dogan@outlook.com\" &#125; &#125;, &#123; \"node\": &#123; \"name\": \"Archakov Dennis\", \"avatarUrl\": \"https://avatars3.githubusercontent.com/u/12086860?v=4\", \"email\": \"hello@archakov.im\" &#125; &#125;, &#123; \"node\": &#123; \"name\": \"Prachi Sharma\", \"avatarUrl\": \"https://avatars0.githubusercontent.com/u/13256500?v=4\", \"email\": \"prachi.asm@gmail.com\" &#125; &#125;, &#123; \"node\": &#123; \"name\": null, \"avatarUrl\": \"https://avatars0.githubusercontent.com/u/21312042?v=4\", \"email\": \"\" &#125; &#125; ] &#125; &#125; &#125;&#125; ==================================================================== 2. Repo的查询2.1 repoList的查询2.2 repo的查询12345678910111213141516171819202122232425262728query repo($owner: String!, $name: String!) &#123; repository(owner: $owner, name: $name) &#123; name url stargazers &#123; totalCount &#125; owner &#123; avatarUrl login &#125; collaborators(first: 20) &#123; edges &#123; node &#123; avatarUrl name url &#125; &#125; &#125; pullRequests &#123; totalCount &#125; createdAt description forkCount &#125;&#125; 结果是 1234567891011121314151617181920212223242526272829303132&#123; \"data\": &#123; \"repository\": &#123; \"name\": \"react-native-lagou\", \"url\": \"https://github.com/phpsmarter/react-native-lagou\", \"stargazers\": &#123; \"totalCount\": 1 &#125;, \"owner\": &#123; \"avatarUrl\": \"https://avatars3.githubusercontent.com/u/10001670?v=4\", \"login\": \"phpsmarter\" &#125;, \"collaborators\": &#123; \"edges\": [ &#123; \"node\": &#123; \"avatarUrl\": \"https://avatars3.githubusercontent.com/u/10001670?v=4\", \"name\": \"phpsmarter\", \"url\": \"https://github.com/phpsmarter\" &#125; &#125; ] &#125;, \"pullRequests\": &#123; \"totalCount\": 0 &#125;, \"createdAt\": \"2016-02-18T10:18:18Z\", \"description\": \"用react native写的仿拉勾ios版本demo\", \"forkCount\": 0 &#125; &#125;&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Github","slug":"Github","permalink":"https://React-Apollo.github.io/tags/Github/"},{"name":"API","slug":"API","permalink":"https://React-Apollo.github.io/tags/API/"}]},{"title":"摘要|Functional Components with React stateless functions and Ramda","slug":"摘要|Functional Components with React stateless functions and Ramda","date":"2018-03-08T09:59:14.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/03/08/摘要|Functional Components with React stateless functions and Ramda/","link":"","permalink":"https://React-Apollo.github.io/2018/03/08/摘要|Functional Components with React stateless functions and Ramda/","excerpt":"","text":"原文在这里. 有段时间不看了, 有些忘了,有些地方还有一定的加深. 什么是 React stateless function?es6的语法 12345class List extends React.Component &#123; render() &#123; return (&lt;ul&gt;&#123;this.props.children&#125;&lt;/ul&gt;); &#125;&#125; 简单的 javascripg函数也可以! 1234567//Stateless function syntaxconst List = function(children) &#123; return (&lt;ul&gt;&#123;children&#125;&lt;/ul&gt;);&#125;;//ES6 arrow syntaxconst List = (children) =&gt; (&lt;ul&gt;&#123;children&#125;&lt;/ul&gt;); 彻底的模板,没有自己任何的数据,也没有生命周期方法. 纯粹依赖于输入. 首先来定义一个 App Container目的是最为一个函数接收 app sate 对象 1234567891011import React from 'react';import ReactDOM from 'react-dom';const App = appState =&gt; (&lt;div className=\"container\"&gt; &lt;h1&gt;App name&lt;/h1&gt; &lt;p&gt;Some children here...&lt;/p&gt;&lt;/div&gt;);//这里定义了渲染的方法,作为 APP函数的属性,并且是柯理化的, 等待传入 dom 元素App.render = R.curry((node, props) =&gt; ReactDOM.render(&lt;App &#123;...props&#125;/&gt;, node));export default App; 在纯函数中,state 必须要在外部管理,然后以 props 的形式传递给组件.下面看看这个解释的例子 Stateless Timer component简单的 timer 组件只接受 secondsElapsed 参数: 12345import React from 'react';export default (&#123; secondsElapsed &#125;) =&gt; (&lt;div className=\"well\"&gt; Seconds Elapsed: &#123;secondsElapsed&#125;&lt;/div&gt;); 添加到 APP 中 1234567891011121314import React from 'react';import ReactDOM from 'react-dom';import R from 'ramda';import Timer from './timer';const App = appState =&gt; (&lt;div className=\"container\"&gt; &lt;h1&gt;App name&lt;/h1&gt; //Timer 只从父组件接受 props 作为自己的数据 &lt;Timer secondsElapsed=&#123;appState.secondsElapsed&#125; /&gt;&lt;/div&gt;);App.render = R.curry((node, props) =&gt; ReactDOM.render(&lt;App &#123;...props&#125;/&gt;, node));export default App; 最后创建main.js 文件,启动渲染过程 123456789101112131415161718import App from './components/app'; //导入容器组件// 我们已经有了柯理化的方法//App.render = R.curry((node, props) =&gt; ReactDOM.render(&lt;App &#123;...props&#125;/&gt;, node));//配置好渲染的目标元素const render = App.render(document.getElementById('app'));//state 初始值let appState = &#123; secondsElapsed: 0&#125;;//first render 首次渲染render(appState);//多次重复渲染setInterval(() =&gt; &#123; appState.secondsElapsed++; render(appState);&#125;, 1000); 对于上面的代码, 变化的是组件的 state, 渲染的目标元素是一直不变的, 所以我们用柯理化配置好一个工厂函数 12//闭包再工作!const render = App.render(document.getElementById(‘app’)); 柯理化返回的函数,等待传入 props 1(props) =&gt; ReactDOM.render(...) 只要 State发生变化,我们需要渲染时,只需要传递 state 就可以了 1234setInterval(() =&gt; &#123; appState.secondsElapsed++; render(appState);&#125;, 1000); 每一秒钟, secondsElapsed 属性会递增1, 然后作为参数传递给 render 函数 现在可以实现 Redux 风格的 reduce 函数, reduce式的函数不能突变当前值 1currentState-&gt;newState 使用 Radma 的 Lenses 来实现 1234567const secondsElapsedLens = R.lensProp('secondsElapsed');const incSecondsElapsed = R.over(secondsElapsedLens, R.inc);setInterval(() =&gt; &#123; appState = incSecondsElapsed(appState); render(appState);&#125;, 1000); 首先创建 Lens: 1const secondsElapsedLens = R.lensProp('secondsElapsed'); lens可以聚焦于给定的属性,不会针对特定的对象, 所以可以重用. View 1R.view(secondsElapsedLens, &#123; secondsElapsed: 10 &#125;); //=&gt; 10 Set 1R.set(secondsElapsedLens, 11, &#123; secondsElapsed: 10 &#125;); //=&gt; 11 用给定的函数 Set 1R.over(secondsElapsedLens, R.inc, &#123; secondsElapsed: 10 &#125;); //=&gt; 11 inSecondElapsed reducer 是一个偏应用函数(partial application),这一行1const incSecondsElapsed = R.over(secondsElapsedLens, R.inc); 会返回一个新的函数,一旦用appState 调用, 就会应用 R.inc在 lensed prop secondElapsed 上. 1appState=incSecondElapsed(appState) 组合 React stateless components开篇提到,React 组件可以作为函数, 那么可以用 R.compose来 compose 这些函数吗?当然是可以的 用 React.createClass 是这样的: 123456789101112131415const TodoList = React.createClass(&#123; render: function() &#123; const createItem = function(item) &#123; return (&lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/li&gt;); &#125;; return (&lt;div className=\"panel panel-default\"&gt; &lt;div className=\"panel-body\"&gt; &lt;ul&gt; &#123;this.props.items.map(createItem)&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;); &#125;&#125;); 现在问题是: TodoList 可以由小的可重用部分 composition 而成吗? 可以的. 可以分为三个更小的组件 容器组件 12345const Container = children =&gt; (&lt;div className=\"panel panel-default\"&gt; &lt;div className=\"panel-body\"&gt; &#123;children&#125; &lt;/div&gt;&lt;/div&gt;); 列表组件 123const List = children =&gt; (&lt;ul&gt; &#123;children&#125;&lt;/ul&gt;); 列表项组件 123const ListItem = (&#123; id, text &#125;) =&gt; (&lt;li key=&#123;id&#125;&gt; &lt;span&gt;&#123;text&#125;&lt;/span&gt;&lt;/li&gt;); 现在一步一动,看看每一步的输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133Container(&lt;h1&gt;Hello World!&lt;/h1&gt;);/** * &lt;div className=\"panel panel-default\"&gt; * &lt;div className=\"panel-body\"&gt; * &lt;h1&gt;Hello World!&lt;/h1&gt; * &lt;/div&gt; * &lt;/div&gt; */Container(List(&lt;li&gt;Hello World!&lt;/li&gt;));/** * &lt;div className=\"panel panel-default\"&gt; * &lt;div className=\"panel-body\"&gt; * &lt;ul&gt; * &lt;li&gt;Hello World!&lt;/li&gt; * &lt;/ul&gt; * &lt;/div&gt; * &lt;/div&gt; */const TodoItem = &#123; id: 123, text: 'Buy milk'&#125;;Container(List(ListItem(TodoItem)));/** * &lt;div className=\"panel panel-default\"&gt; * &lt;div className=\"panel-body\"&gt; * &lt;ul&gt; * &lt;li&gt; * &lt;span&gt;Buy milk&lt;/span&gt; * &lt;/li&gt; * &lt;/ul&gt; * &lt;/div&gt; * &lt;/div&gt; */``` - Container(List(ListItem(TodoItem)))这里我们把TodoItem 数据传给 ListItem, 然后结果作为 List 的参数, 返回的结果又作为 Container的参数如果用 compose 函数,过程如下```jsR.compose(Container, List)(&lt;li&gt;Hello World!&lt;/li&gt;);/** * &lt;div className=\"panel panel-default\"&gt; * &lt;div className=\"panel-body\"&gt; * &lt;ul&gt; * &lt;li&gt;Hello World!&lt;/li&gt; * &lt;/ul&gt; * &lt;/div&gt; * &lt;/div&gt; */const ContainerWithList = R.compose(Container, List);R.compose(ContainerWithList, ListItem)(&#123;id: 123, text: 'Buy milk'&#125;);/** * &lt;div className=\"panel panel-default\"&gt; * &lt;div className=\"panel-body\"&gt; * &lt;ul&gt; * &lt;li&gt; * &lt;span&gt;Buy milk&lt;/span&gt; * &lt;/li&gt; * &lt;/ul&gt; * &lt;/div&gt; * &lt;/div&gt; */const TodoItem = &#123; id: 123, text: 'Buy milk'&#125;;const TodoList = R.compose(Container, List, ListItem);TodoList(TodoItem);/** * &lt;div className=\"panel panel-default\"&gt; * &lt;div className=\"panel-body\"&gt; * &lt;ul&gt; * &lt;li&gt; * &lt;span&gt;Buy milk&lt;/span&gt; * &lt;/li&gt; * &lt;/ul&gt; * &lt;/div&gt; * &lt;/div&gt; */``` - const TodoList = R.compose(Container, List, ListItem)列表的工厂函数,TodoList 组件可以看作为Container,List和 ListItem 的组合现在 还只能接受一个参数, 需要可以接受一个数组```jsconst mapTodos = function(todos) &#123; return todos.map(function(todo) &#123; return ListItem(todo); &#125;);&#125;;const TodoList = R.compose(Container, List, mapTodos);const mock = [ &#123;id: 1, text: 'One'&#125;, &#123;id: 1, text: 'Two'&#125;, &#123;id: 1, text: 'Three'&#125;];TodoList(mock);/** * &lt;div className=\"panel panel-default\"&gt; * &lt;div className=\"panel-body\"&gt; * &lt;ul&gt; * &lt;li&gt; * &lt;span&gt;One&lt;/span&gt; * &lt;/li&gt; * &lt;li&gt; * &lt;span&gt;Two&lt;/span&gt; * &lt;/li&gt; * &lt;li&gt; * &lt;span&gt;Three&lt;/span&gt; * &lt;/li&gt; * &lt;/ul&gt; * &lt;/div&gt; * &lt;/div&gt; */ mapTodos 可以有更简单的模式 123456789101112131415161718192021222324252627//Thisreturn todos.map(function(todo) &#123; return ListItem(todo);&#125;);//Is the same asreturn todos.map(ListItem);//So the result would beconst mapTodos = function(todos) &#123; return todos.map(ListItem);&#125;;//The same using Ramdaconst mapTodos = function(todos) &#123; return R.map(ListItem, todos);&#125;;//Now remember two things from Ramda docs:// - Ramda functions are automatically curried// - The parameters to Ramda functions are arranged to make it convenient for currying.// The data to be operated on is generally supplied last.//So:const mapTodos = R.map(ListItem);//At this point mapTodos variable is rendudant, we don't need it anymore:const TodoList = R.compose(Container, List, R.map(ListItem)); const mapTodos = R.map(ListItem); Ramda 函数式自动柯理化的,所以代码是这样的, 等待传递数据数组,返回的数组的形式是{data.item}组成的数组 完整的 TodoList 的代码就是1234567891011121314151617181920import React from 'React';import R from 'ramda';const Container = children =&gt; (&lt;div className=\"panel panel-default\"&gt; &lt;div className=\"panel-body\"&gt; &#123;children&#125; &lt;/div&gt;&lt;/div&gt;);const List = children =&gt; (&lt;ul&gt; &#123;children&#125;&lt;/ul&gt;);const ListItem = (&#123; id, text &#125;) =&gt; (&lt;li key=&#123;id&#125;&gt; &lt;span&gt;&#123;text&#125;&lt;/span&gt;&lt;/li&gt;);const TodoList = R.compose(Container, List, R.map(ListItem));export default TodoList; 工厂配置好了,就等数据了 模拟一下 appState 的 todo 数据 12345678let appState = &#123; secondsElapsed: 0, todos: [ &#123;id: 1, text: 'Buy milk'&#125;, &#123;id: 2, text: 'Go running'&#125;, &#123;id: 3, text: 'Rest'&#125; ]&#125;; 在 App 组件中添加 TodoList 组件作为子组件 123456import TodoList from './todo-list';const App = appState =&gt; (&lt;div className=\"container\"&gt; &lt;h1&gt;App name&lt;/h1&gt; &lt;Timer secondsElapsed=&#123;appState.secondsElapsed&#125; /&gt; &lt;TodoList todos=&#123;appState.todos&#125; /&gt;&lt;/div&gt;); TodoList组件期待的参数是一个todos数组, 12&lt;TodoList todos=&#123;appState.todos&#125; /&gt;//const TodoList = R.compose(Container, List, R.map(ListItem)) React stateless component是作为函数的,所以我们也可以传递参数 1TodoList(&#123;todos: appState.todos&#125;); 最好是传递单个参数,所以这种情况,再改进一下 1const TodoList = R.compose(Container, List, R.map(ListItem), R.prop('todos')); 调用就直接改为: 1TodoList(appState) 结束","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"Ramda","slug":"Ramda","permalink":"https://React-Apollo.github.io/tags/Ramda/"},{"name":"FP","slug":"FP","permalink":"https://React-Apollo.github.io/tags/FP/"}]},{"title":"Prisma|Native Authenticate Method","slug":"Prisma|Native Authenticate method","date":"2018-03-06T22:18:42.000Z","updated":"2019-04-28T05:52:57.892Z","comments":true,"path":"2018/03/06/Prisma|Native Authenticate method/","link":"","permalink":"https://React-Apollo.github.io/2018/03/06/Prisma|Native Authenticate method/","excerpt":"","text":"针对以下的 schema1234567891011121314151617181920212223type Query &#123; vehicles(dealership: ID!): [Vehicle!]!&#125;type Mutation &#123; updateVehicleAskingPrice(id: ID!, askingPrice: Int!): Vehicle&#125;type Vehicle &#123; id: ID! year: Int! make: String! model: Int! askingPrice: Float costBasis: Float numberOfOffers: Int&#125;type User &#123; id: ID! name: String! role: String!&#125; updataVehicleAskingPrice应该只能有管理员操作 costBasis: 仅限于管理员 numberOfOffers: 认证用户可以使用 12345678910111213141516171819const Mutation = &#123; updateVehicleAskingPrice: async (parent, &#123; id, askingPrice &#125;, context, info) =&gt; &#123; const userId = getUserId(context) //用户的 role进行查询,看看是否数据管 const isRequestingUserManager = await context.db.exists.User(&#123; id: userId, role: `MANAGER` &#125;) if (isRequestingUserManager) &#123; return await context.db.mutation.updateVehicle(&#123; where: &#123; id &#125;, data: &#123; askingPrice &#125; &#125;) &#125; throw new Error( `Invalid permissions, you must be a manager to update vehicle year` ) &#125;&#125; 使用exists函数. 字段级别的认证 123456789101112131415const Query = &#123; vehicles: async (parent, args, context, info) =&gt; &#123; const vehicles = await context.db.query.vehicles(&#123; where: &#123; dealership: args.id &#125; &#125;) const user = getUser(context) return vehicles.map(vehicle =&gt; (&#123; ...vehicle, costBasis: user &amp;&amp; user.role.includes(`MANAGER`) ? vehicle.costBasis : null, numberOfOffers: user ? vehicle.numberOfOffers : null &#125;)) &#125;&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"Apollo|Query","slug":"Apollo|API Query","date":"2018-03-06T12:28:41.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/03/06/Apollo|API Query/","link":"","permalink":"https://React-Apollo.github.io/2018/03/06/Apollo|API Query/","excerpt":"","text":"Query核心的理念是这也就是”GraphQL”,并没有什么新内容. 基础查询简单的使用graphql container. 解析查询使用的gql模板字符串,并传递给graphqlcontainer.作为第一个参数. 实例 : 在‘GitHunt’中,我们会在Profile组件显示当前登录的用户 1234567891011121314151617import React, &#123; Component &#125; from 'react';import &#123; graphql &#125; from 'react-apollo';import gql from 'graphql-tag';class Profile extends Component &#123; ... &#125;// We use the gql tag to parse our query string into a query documentconst CurrentUserForLayout = gql` query CurrentUserForLayout &#123; currentUser &#123; login avatar_url &#125; &#125;`;const ProfileWithData = graphql(CurrentUserForLayout)(Profile); 在我们使用graphql时, 会发生两件事: 查询从 Apollo-client的 data store 加载,如果不在 data store 中就从 server 加载 我们的组件订阅到 store. 所以如果数据发生改变, 组件就会更新 此外,对于在 query中的currentUser字段,data属性也包含有字段loading,这是一个布尔值, 表示当前从 server 加载数据的状态. 还有一个字段error,表示是否在加载数据时出现错误. 所以具体的属性的外观如下: 123456(props) =&gt; &#123; const loading = props.data.loading; const error = props.data.error; const currentUser = props.data.currentUser; // render UI with loading, error, or currentUser&#125; data.currentUser属性会随着用户的变化而发生变化. 信息存储在 Apollo client 的 全局 cache 中. data属性的结构如上所示, graphql会传递查询结果到被包装的组件,形式是data属性. 实际也传递所有的父组件的 props. 对于查询, data属性的外观如下 ...fileds: 查询中的每个根字段 loading: 如果有查询进行中, 这个字段为true,包含refetch查询时也是如此 error: APolloError对象代表查询中可能出现的各种错误. 例如下面的查询: 1234 query getUserAndLikes($id: ID!) &#123; user(userId: $id) &#123; name &#125; likes(userId: $id) &#123; count &#125;&#125; 我们得到的 props 如下: 123456789101112 data: &#123; user: &#123; name: \"James\" &#125;, likes: &#123; count: 10 &#125;, loading: false, error: null, variables: &#123; id: 'asdf' &#125;, refetch() &#123; ... &#125;, fetchMore() &#123; ... &#125;, startPolling() &#123; ... &#125;, stopPolling() &#123; ... &#125;, // ... more methods&#125; Variables 和 options如果想定制query,可以提供 option选项,作为graphql的第二个参数(第一个参数为查询字符串).如果需要传递变量,要在这个地方传递 12345678910111213141516171819202122232425262728293031// Suppose our profile query took an avatar sizeconst CurrentUserForLayout = gql` query CurrentUserForLayout($avatarSize: Int!) &#123; currentUser &#123; login avatar_url(avatarSize: $avatarSize) &#125; &#125;`;const ProfileWithData = graphql(CurrentUserForLayout, &#123; options: &#123; variables: &#123; avatarSize: 100 &#125; &#125;,&#125;)(Profile);``` `这里可能会有疑问, 一般在获取当前用户的时候需要传递 token,在 apollo client 中,我们在配置url 时,在头部从本地数据库获得到用户token,然后传递`.## 从 props 进行计算典型应用中,查询的变量或从包装组件的 props 中计算. 无论在什么地方使用组件,调用都会传递参数,所以`options`可以作为函数接受传递给组件的 props```js// The caller could do something like:&lt;ProfileWithData avatarSize=&#123;300&#125; /&gt;// And our HOC could look like:const ProfileWithData = graphql(CurrentUserForLayout, &#123; options: (&#123; avatarSize &#125;) =&gt; (&#123; variables: &#123; avatarSize &#125; &#125;),&#125;)(Profile); 默认情况下, graphql会尝试从ownPorps中获取需要的变量 其他的 options可以传递其他的 options,例如pollInterval 1234const ProfileWithData = graphql(CurrentUserForLayout, &#123; // See the watchQuery API for the options you can provide here options: &#123; pollInterval: 20000 &#125;,&#125;)(Profile); skipping an operation//如果认证没有通过就跳过这个查询,可以直接设为静态的 skip:true123const ProfileWithData = graphql(CurrentUserForLayout, &#123; skip: (ownProps) =&gt; !ownProps.authenticated,&#125;)(Profile); 改变 prop的名字12345678910111213141516171819import React, &#123; Component &#125; from 'react';import &#123; graphql &#125; from 'react-apollo';import gql from 'graphql-tag';class Profile extends Component &#123; ... &#125;const CurrentUserForLayout = gql` query CurrentUserForLayout &#123; currentUser &#123; login avatar_url &#125; &#125;`;// We want the prop to be called 'CurrentUserForLayout' instead of dataconst ProfileWithData = graphql(CurrentUserForLayout, &#123; name: 'CurrentUserForLayout'&#125;)(Profile); 任意的转换想完全控制传递给子组件的 props,可以使用props option 把 query 的data 映射为任意数量的 props 1234567891011121314151617181920212223242526import React, &#123; Component &#125; from 'react';import &#123; graphql &#125; from 'react-apollo';import gql from 'graphql-tag';// Here Profile has a more generic API, that's not coupled to Apollo or the// shape of the query that we've usedclass Profile extends Component &#123; ... &#125;const CurrentUserForLayout = gql` query CurrentUserForLayout &#123; currentUser &#123; login avatar_url &#125; &#125;`;const ProfileWithData = graphql(CurrentUserForLayout, &#123; // ownProps are the props that are passed into the `ProfileWithData` // when it is used by a parent component props: (&#123; ownProps, data: &#123; loading, currentUser, refetch &#125; &#125;) =&gt; (&#123; userLoading: loading, user: currentUser, refetchUser: refetch, &#125;),&#125;)(Profile); 这个方式最大限度的解耦了展示组件(Profile)和 Apollo API Reference123render() &#123; const &#123; data &#125; = this.props; // &lt;- The `data` prop.&#125; 如果我们要下面的查询 1234&#123; viwer&#123;name&#125; todos&#123;text&#125;&#125; 你的data props 将会包含如下数据 123456render() &#123; const &#123; data &#125; = this.props; console.log(data.viewer); // &lt;- The data returned by your query for `viewer`. console.log(data.todos); // &lt;- The data returned by your query for `todos`.&#125; data.networkStatud loading setVariables: query 的变量改变 fetchMore: 表示fetchMore在调用 refetch: refetch 在调用 poll: polling 在调用 ready: 没有操作进行中 error: 没有请求, 但是至少有一个错误 如果 network status 小于7 等同于data.loading==true 实例 1234567891011function MyComponent(&#123; data: &#123; networkStatus &#125; &#125;) &#123; if (networkStatus === 6) &#123; return &lt;div&gt;Polling!&lt;/div&gt;; &#125; else if (networkStatus &lt; 7) &#123; return &lt;div&gt;Loading...&lt;/div&gt;; &#125; else &#123; // ... &#125;&#125;export default graphql(gql`query &#123; ... &#125;`)(MyComponent); data.variablesApollo 用于获取数据的参数, 如果你想渲染一些与参数有关的信息 12345678910function MyComponent(&#123; data: &#123; variables &#125; &#125;) &#123; return ( &lt;div&gt; Query executed with the following variables: &lt;code&gt;&#123;JSON.stringify(variables)&#125;&lt;/code&gt; &lt;/div&gt; );&#125;export default graphql(gql`query &#123; ... &#125;`)(MyComponent); data.refetch(variables) 强制你的组件重新执行在graphql()函数中定义的操作. 当你想重载数据,或者是遇到错误时再次获取数据 data.refetch返回一个promise,resolves返回新的数据. data.fetchMore(options)data.fetchMore函数可以实现组件的分页操作. 接收单个options对象作为参数,有下面的属性: [query]:可选项,如果不使用就从graphql() hoc采用 [variables]: 可选的参数, 和上面一样的用法 updateQuery(previousResult,{fetchMoreResult,queryVariables}):实际执行分页时的函数. 第一个参数previousResult,是之前的查询返回的数据, 第二个参数有两个属性,fetchMoreResult,queryVariables,fetchMoreResult是新查询返回的数据, queryVariables是获取更多数据时采用的参数.使用这些参数,你应该返回一个新的data,和之前的data的外观一致. 参看下面的的实例 12345678910data.fetchMore(&#123; updateQuery: (previousResult, &#123; fetchMoreResult, queryVariables &#125;) =&gt; &#123; return &#123; ...previousResult, // Add the new feed data to the end of the old feed data. //在旧的数据末尾拼接新的数据 feed: [...previousResult.feed, ...fetchMoreResult.feed], &#125;; &#125;,&#125;); data.subscribeToMore(options)这个函数会配置 subscrption,当 server 发布subscription时,触发更新.需要在 server 做相应的工作.还会返回一个unscribe()函数,可以用于解绑定 通常的实践是在componentWillReceiveProps内包装subscribeToMore调用,在原始的查询完成之后,执行订阅. 为了确保不会多次创建 subscription.可以添加到组件实例上. [document]: graphql 的查询字符串 [variables]: 可选的参数, 可以用在documentoption 中 [updataQuery]: 可选的函数, server 发送更新时时会执行. 第一个参数previousResult是之前的查询结果,第二个参数是一个对象,有两个属性,subscriptionData是订阅的结果. variables是用于订阅的参数 [onError]: 可选的出现错误的回调函数 123456789101112131415161718192021222324252627class SubscriptionComponent extends Component &#123; componentWillReceiveProps(nextProps) &#123; if(!nextProps.data.loading) &#123; // Check for existing subscription if (this.unsubscribe) &#123; // Check if props have changed and, if necessary, stop the subscription if (this.props.subscriptionParam !== nextProps.subscriptionParam) &#123; this.unsubscribe(); &#125; else &#123; return; &#125; &#125; // Subscribe this.unsubscribe = nextProps.data.subscribeToMore(&#123; document: gql`subscription &#123;...&#125;`, updateQuery: (previousResult, &#123; subscriptionData, variables &#125;) =&gt; &#123; // Perform updates on previousResult with subscriptionData return updatedResult; &#125; &#125;); &#125; &#125; render() &#123; ... &#125;&#125; data.startPolling(interval)这个函数设置一个间隔, 间隔时间完了以后会发送一个 fetch请求. 直接收一个整数参数. Polling 是保持 UI中数据随时更新的好方法. 通过设置每5秒中重新获取数据. 可以有效的模拟实现实时数据更新, 后台不需要做任何的构建工作 123456789101112class MyComponent extends Component &#123; componentDidMount() &#123; // In this specific case you may want to use `options.pollInterval` instead. this.props.data.startPolling(1000); &#125; render() &#123; // ... &#125;&#125;export default graphql(gql`query &#123; ... &#125;`)(MyComponent); data.stopPolling()通过调用这个函数,可以停止当前的 polling 过程. 1234567891011121314151617181920212223242526class MyComponent extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; &#123; this.props.data.startPolling(1000); &#125;&#125;&gt; Start Polling &lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123; this.props.data.stopPolling(); &#125;&#125;&gt; Stop Polling &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default graphql(gql`query &#123; ... &#125;`)(MyComponent);``` ### `data.updataQuery(updaterFn)`在 query 和 mutate 之外对 data做出改变 data.updateQuery((previousResult) =&gt; ({ …previousResult, count: previousResult.count + 1,}));12345678910111213### `config.options`用于配置查询和更新的对象或者函数如果`config.options`是一个函数,就可以接受一个组件的 props 作为第一个参数.```jsexport default graphql(gql`&#123; ... &#125;`, &#123; options: &#123; // Options go here. &#125;,&#125;)(MyComponent); 12345export default graphql(gql`&#123; ... &#125;`, &#123; options: (props) =&gt; (&#123; // Options are computed from `props` here. &#125;),&#125;)(MyComponent); options.variables用于执行查询的变量. 这些变量应该和查询中定义的变量一一对应. 如果config.options作为函数,就可以从props 中计算变量 实例:123456789101112export default graphql(gql` query ($width: Int!, $height: Int!) &#123; ... &#125;`, &#123; options: (props) =&gt; (&#123; variables: &#123; width: props.size, height: props.size, &#125;, &#125;),&#125;)(MyComponent); optins.fetchPolicyfetchPolicy 是可选项,可以定制组件和 Apollo data cache 交互的方法. 默认情况下, 组件首先尝试从 cache获取数据. 如果需要的所有数据都在 cache 中, Apoll 会直接从 cache 中返回数据. 有效的fetchPolicy如下: cache-first: 默认的选项 cache-and-network : 如果 cache 中有全部数据, 就会直接返回,但是网络获取也会执行, 从而保持了 server 和 cache 的数据一致性. 不仅使用户迅速获得数据,还保持数据的一致性 network-only: 不从 cache 中返回数据 cache-only: 不执行网络获取 123export default graphql(gql`query &#123; ... &#125;`, &#123; options: &#123; fetchPolicy: 'cache-and-network' &#125;,&#125;)(MyComponent); options.errorPolicy用于定制 fetch data error的处理. runtime error和获取数据错误 none: 默认值, ignore: all: options.pollInterval123export default graphql(gql`query &#123; ... &#125;`, &#123; options: &#123; pollInterval: 5000 &#125;,&#125;)(MyComponent); options.notifyOnNetworkStatusChange网络状态发生变化时,触发组件的重新渲染 实例:123export default graphql(gql`query &#123; ... &#125;`, &#123; options: &#123; notifyOnNetworkStatusChange: true &#125;,&#125;)(MyComponent); optins.context在context对象下的所有的内容都可以直接传递到 network chain 中.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Apollo-Client","slug":"Apollo-Client","permalink":"https://React-Apollo.github.io/tags/Apollo-Client/"}]},{"title":"Apollo|API Reference","slug":"Apollo|API Reference","date":"2018-03-06T09:51:39.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/03/06/Apollo|API Reference/","link":"","permalink":"https://React-Apollo.github.io/2018/03/06/Apollo|API Reference/","excerpt":"","text":"ApolloClient link cache ssrMode ssForceFetchDelay connectToDevTools queryDeduplication defaultOptions 12345678910111213const defaultOptions = &#123; watchQuery: &#123; fetchPolicy: 'cache-and-network', errorPolicy: 'ignore', &#125;, query: &#123; fetchPolicy: 'network-only', errorPolicy: 'all', &#125;, mutate: &#123; errorPolicy: 'all' &#125;&#125; ApolloProvider为所有的组件提供一个ApolloClient实例 client 123456ReactDOM.render( &lt;ApolloProvider client=&#123;client&#125;&gt; &lt;MyRootComponent /&gt; &lt;/ApolloProvider&gt;, document.getElementById('root'),); graphql(query,[config])(Component)123456789101112131415161718function TodoApp(&#123; data: &#123; todos &#125; &#125;) &#123; return ( &lt;ul&gt; &#123;todos.map((&#123; id, text &#125;) =&gt; ( &lt;li key=&#123;id&#125;&gt;&#123;text&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;export default graphql(gql` query TodoAppQuery &#123; todos &#123; id text &#125; &#125;`)(TodoApp); 可以定义中间函数 12345678// Create our enhancer function.const withTodoAppQuery = graphql(gql`query &#123; ... &#125;`);// Enhance our component.const TodoAppWithData = withTodoAppQuery(TodoApp);// Export the enhanced component.export default TodoAppWithData; Query Configurationconfig.options12345export default graphql(gql`&#123; ... &#125;`, &#123; options: (props) =&gt; (&#123; // Options are computed from `props` here. &#125;),&#125;)(MyComponent); config.props123456789101112131415export default graphql(gql`&#123; ... &#125;`, &#123; props: (&#123; data: &#123; fetchMore &#125; &#125;) =&gt; (&#123; onLoadMore: () =&gt; &#123; fetchMore(&#123; ... &#125;); &#125;, &#125;),&#125;)(MyComponent);function MyComponent(&#123; onLoadMore &#125;) &#123; return ( &lt;button onClick=&#123;onLoadMore&#125;&gt; Load More! &lt;/button&gt; );&#125; config.skip不会执行其中的React Apollo 功能可以传递布尔值,也是传递函数给config.skip,这里连个查询根据 props.userQuery1的属性来判断实现那个查询, 注意 true 时跳过查询12345678910export default compose( graphql(gql`query MyQuery1 &#123; ... &#125;`, &#123; skip: props =&gt; !props.useQuery1 &#125;), graphql(gql`query MyQuery2 &#123; ... &#125;`, &#123; skip: props =&gt; props.useQuery1 &#125;),)(MyComponent);function MyComponent(&#123; data &#125;) &#123; // The data may be from `MyQuery1` or `MyQuery2` depending on the value // of the prop `useQuery1`. console.log(data);&#125; config.namename 配置传递给组件 props的名字. 默认是query用 data. mutation用mutate. 12345678910111213141516//⛔️注入多个函数时用 compose函数export default compose( graphql(gql`mutation (...) &#123; ... &#125;`, &#123; name: 'createTodo' &#125;), graphql(gql`mutation (...) &#123; ... &#125;`, &#123; name: 'updateTodo' &#125;), graphql(gql`mutation (...) &#123; ... &#125;`, &#123; name: 'deleteTodo' &#125;),)(MyComponent);function MyComponent(props) &#123; // Instead of the default prop name, `mutate`, // we have three different prop names. console.log(props.createTodo); console.log(props.updateTodo); console.log(props.deleteTodo); return null;&#125; config.withRef这个存在时什么意义呢? config.aliascompose(...enhancers)(component)借此可以一次使用多个组件增强子. compose(funcC,funcB,funcA)(component), 实际的执行方式为 funcC(funcB(funcA(component))) 123456export default compose( withApollo, graphql(`query &#123; ... &#125;`), graphql(`mutation &#123; ... &#125;`), connect(...),)(MyComponent); withApollo(component)12345export default withApollo(MyComponent);function MyComponent(&#123; client &#125;) &#123; console.log(client);&#125; 使用 withApollo可以在组件中直接访问到Client 实例","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Apollo-Client","slug":"Apollo-Client","permalink":"https://React-Apollo.github.io/tags/Apollo-Client/"}]},{"title":"Apollo|Recompose Pattern","slug":"Apollo|Recompose Pattern","date":"2018-03-06T07:29:33.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/03/06/Apollo|Recompose Pattern/","link":"","permalink":"https://React-Apollo.github.io/2018/03/06/Apollo|Recompose Pattern/","excerpt":"","text":"Recompose patterns1. Loading status常规做法: 根据 data.loading来显示 Loading 组件 123456789const Component = props =&gt; &#123; if (props.data.loading) &#123; return &lt;LoadingPlaceholder&gt; &#125; return ( &lt;div&gt;Our component&lt;/div&gt; )&#125; Recompose 有一个工具函数branch(),可以基于其中检测函数(test)的结果来组合不同的 Hoc, 可以和另一个 Recompose方法renderComponent(),联合使用.所以可以说:”如果处于 loading 状态, 就渲染LoadingPlaceholder而不是默认要展示内容的组件”,实例如下: Recompose loading 12345678910111213141516171819 import &#123; propType &#125; from 'graphql-anywhere'//props.data.loading为真时就渲染传入的组件,这里是LoadingPlaceholderconst renderWhileLoading = (component, propName = 'data') =&gt; branch( props =&gt; props[propName] &amp;&amp; props[propName].loading, renderComponent(component), );// 这个组件是实际展示数据的组件const Component = props =&gt; (&lt;div&gt;Our component for &#123;props.user.name&#125;&lt;/div&gt;)Component.propTypes = &#123; user: propType(getUser).isRequired, // autogenerating proptypes, as we expect them to be always there (yeah, if no error)&#125;//如果 graphql 的状态是 data.loading, renderWhileLoading 会劫持渲染const enhancedComponent = compose( graphql(getUser, &#123; name: \"user\" &#125;), renderWhileLoading(LoadingPlaceholder, \"user\"))(Component);export default enhancedComponent; 注意事项: Loading只有才查询的第一次才会为真. 如果使用options.notifyOnNetworkStatusChange,可以用data.networkStatus字段来跟踪其他的 loading 状态.模式和上面的一样 2. 处理错误和 loadingStatus 的方法类似,如果出了问题,我们想显示一个不同的组件,或者允许用户重新加载(refetch()). 使用withProps()方法直接用 props 传递 refetch 方法. 这里的方法是通用的, 没有和任何的组件耦合. 12345678910111213141516171819202122232425const renderForError = (component, propName = \"data\") =&gt; branch( props =&gt; props[propName] &amp;&amp; props[propName].error, renderComponent(component), );const ErrorComponent = props =&gt;( &lt;span&gt; Something went wrong, you can try to //⛔️ props 传入的 refetch 方法 &lt;button onClick=&#123;props.refetch&#125;&gt;refetch&lt;/button&gt; &lt;/span&gt;)//为组件注入新的props 和 refetch 方法const setRefetchProp = (propName = \"data\") =&gt; withProps(props =&gt; (&#123;refetch: props[propName] &amp;&amp; props[propName].data&#125;))const enhancedComponent = compose( graphql(getUser, &#123; name: \"user\" &#125;), renderWhileLoading(LoadingPlaceholder, \"user\"), setRefetchProp(\"user\"), renderForError(ErrorComponent, \"user\"),)(Component);export default enhancedComponent; 3. 查询周期在有些用例中,需要在查询完成之后执行一些其他工作. 上面的实例中,没有错误出现,没有 loading 的时候会渲染默认组件. 但是组件是无状态的,没有生命周期函数的钩子(hook).如果还要使用额外的周期功能,可以用 Recompose 的lifecycle()函数来补救 12345678910111213const execAtMount = lifecycle(&#123; componentWillMount() &#123; executeSomething(); &#125;,&#125;)const enhancedComponent = compose( graphql(getUser, &#123; name: \"user\" &#125;), renderWhileLoading(LoadingPlaceholder, \"user\"), setRefetchProp(\"user\"), renderForError(ErrorComponent, \"user\"), execAtMount,)(Component); 上面的实例,如果我们需要在组件加载时做些额外的工作,可以这么操作 来看看另一个更为复杂的用例, 例如我正在使用re-select,可以让用户从查询的结果中挑选部分内容. 想一直显示 re-select,它有自己的 loading state indicator.接着在查询成功以后自动的选择预定义的选项. 如果使用默认的访问策略(fetchPolicy)让每个组件都获取数据,只有一个特别的地方需要处理. 需要留意的地方:要查询的数据已经在 cache 中的时候,就会跳过 loading state. 这种情况下,我们需要在组件加载时处理networkStatus===7. 同时还要使用recompose的withState()方法保存选项值. 在这个例子中我们保持默认的data属性不变. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const DEFAULT_PICK = \"orange\";const withPickerValue = withState(\"pickerValue\", \"setPickerValue\", null);// find matching optionconst findOption = (options, ourLabel) =&gt; lodashFind(options, option =&gt; option.label.toLowerCase() === ourLabel.toLowerCase());const withAutoPicking = lifecycle(&#123; componentWillReceiveProps(nextProps) &#123; // when value was already picked if (nextProps.pickerValue) &#123; return; &#125; // networkStatus change from 1 to 7 - initial load finished successfully if (this.props.data.networkStatus === 1 &amp;&amp; nextProps.data.networkStatus === 7) &#123; const match = findOption(nextProps.data.options) if (match) &#123; nextProps.setPickerValue(match); &#125; &#125; &#125;, componentWillMount() &#123; const &#123; pickerValue, setPickerValue, data &#125; = this.props; if (pickerValue) &#123; return; &#125; // when Apollo query is resolved from cache, // it already have networkStatus 7 at mount time if (data.networkStatus === 7 &amp;&amp; !data.error) &#123; const match = findOption(data.options); if (match) &#123; setPickerValue(match); &#125; &#125; &#125;,&#125;);const Component = props =&gt; ( &lt;Select loading=&#123;props.data.loading&#125; value=&#123;props.pickerValue &amp;&amp; props.pickerValue.value || null&#125; onChange=&#123;props.setPickerValue&#125; options=&#123;props.data.options || undefined&#125; /&gt;);const enhancedComponent = compose( graphql(getOptions), withPickerValue, withAutoPicking,)(Component); 4. 控制轮询 这个例子是一个显示 meteor框架中的数据库迁移状态的组件:migrations panel.并不总是运行迁移,所以设置轮询为30s,就比较好.但是如果在数据库迁移过程中,我们需要竟可能快的显示进度. 解决问题的关键是 react-apollo 的options参数, 这个参数可以是一个依赖于 React props 为参数的函数.(options参数描述了查询自身的参数, 和 React 的 props 是不同的). 我们可以根据传递到graphql 组件的 props,通过使用recompose的withState()函数设定轮询的周期,并且使用componentWillReceiveProps React的生命周期函数来查看从 GraphQL获取的数据,并作出相应的调整. 基本的流程就是,默认30秒查询一次数据库迁移状态的数据,如果数据存在时,就立刻把查询的轮询时间改为0.5s. 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import &#123; graphql &#125; from \"react-apollo\";import gql from \"graphql-tag\";import &#123; compose, withState, lifecycle &#125; from \"recompose\";const DEFAULT_INTERVAL = 30 * 1000;const ACTIVE_INTERVAL = 500;const withData = compose( // Pass down two props to the nested component: `pollInterval`, // which defaults to our normal slow poll, and `setPollInterval`, // which lets the nested components modify `pollInterval`. withState(\"pollInterval\", \"setPollInterval\", DEFAULT_INTERVAL), graphql( gql` query getMigrationStatus &#123; activeMigration &#123; name version progress &#125; &#125; `, &#123; // If you think it's clear enough, you can abbreviate this as: // options: (&#123;pollInterval&#125;) =&gt; (&#123;pollInterval&#125;), options: props =&gt; &#123; return &#123; pollInterval: props.pollInterval &#125;; &#125; &#125; ), lifecycle(&#123; componentWillReceiveProps(&#123; data: &#123; loading, activeMigration &#125;, pollInterval, setPollInterval &#125;) &#123; if (loading) &#123; return; &#125; if (activeMigration &amp;&amp; pollInterval !== ACTIVE_INTERVAL) &#123; setPollInterval(ACTIVE_INTERVAL); &#125; else if ( !activeMigration &amp;&amp; pollInterval !== DEFAULT_INTERVAL ) &#123; setPollInterval(DEFAULT_INTERVAL); &#125; &#125; &#125;));const MigrationPanelWithData = withData(MigrationPanel); 但是这个轮询似乎还有缺陷, 如果在30s轮询周期内, 数据库迁移完成了,我们就看不到任何的提示. 或许要使用 subscription方法.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"}]},{"title":"Prisma|Github oAuth登录操作","slug":"Prisma|Github oAuth登录操作","date":"2018-03-05T15:27:47.000Z","updated":"2019-04-28T05:52:57.892Z","comments":true,"path":"2018/03/05/Prisma|Github oAuth登录操作/","link":"","permalink":"https://React-Apollo.github.io/2018/03/05/Prisma|Github oAuth登录操作/","excerpt":"","text":"之前有版本,经过Prisma 的版本变更.做修改.Prisma的改变还比较大,但是登录的原理是不变的 OAuth 协议的认证和授权的过程如下： 1. 用户打开我的应用，我想要通过GitHub获取改用户的基本信息 2. 在转跳到GitHub的授权页面后，用户同意我获取他的基本信息 3. 页面获得GitHub提供的授权码(githubCode)，使用该授权码向GitHub申请一个令牌 4. GitHub对博客提供的授权码进行验证，验证无误后，发放一个令牌(githubToken)给博客端 5. 应用使用令牌，向GitHub获取用户信息 6. GitHub 确认令牌无误，返回给我基本的用户信息 在本应用中,从github 中获取用户基本信息以后,在 prisma数据库中存储信息,并且返回给用于一个应用内的 token.后续应用内的操作通过这个 token换取用户信息进行操作datamodel 12345678910111213141516171819202122type User &#123; id: ID! @unique createdAt: DateTime! updatedAt: DateTime! githubUserId: String! @unique name: String! bio: String! public_repos: Int! public_gists: Int! notes: [Note!]! @relation(name: \"UserNote\")&#125;type Note &#123; id: ID! @unique owner: User! @relation(name: \"UserNote\") text: String!&#125; schemamodel 12345678910111213141516type Query &#123; me: User, note(id: ID!): Note&#125;type Mutation &#123; createNote(text: String!): Note! updateNote(id: ID!, text: String!): Note deleteNote(id: ID!): Note authenticate(githubCode: String!): AuthenticateUserPayload&#125;type AuthenticateUserPayload &#123; user: User! token: String!&#125; datamodel定义了数据库要使用的 model, schemamodel定义了要提供给用户使用的 API接口. 所以编程就围绕 schemamodel 展开 重点关注 authenticate 这个 model. 通过参数 githubCode获得用户的 token 获取 token 的代码从 github 获取信息的代码的两个工具函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546import * as fetch from 'isomorphic-fetch'export interface GithubUser &#123; id: string, name: string, bio: string, public_repos: number, public_gists: number&#125;//获取 githubToken 的方法export async function getGithubToken(githubCode: string): Promise&lt;string&gt; &#123; const endpoint = 'https://github.com/login/oauth/access_token' const data = await fetch(endpoint, &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json', 'Accept': 'application/json' &#125;, body: JSON.stringify(&#123; client_id: process.env.GITHUB_CLIENT_ID, client_secret: process.env.GITHUB_CLIENT_SECRET, code: githubCode, &#125;) &#125;) .then(response =&gt; response.json()) if (data.error) &#123; throw new Error(JSON.stringify(data.error)) &#125; return data.access_token&#125;//获取 githubUser 的方法,获取的是 User的详细信息export async function getGithubUser(githubToken: string): Promise&lt;GithubUser&gt; &#123; const endpoint = `https://api.github.com/user?access_token=$&#123;githubToken&#125;` const data = await fetch(endpoint) .then(response =&gt; response.json()) if (data.error) &#123; throw new Error(JSON.stringify(data.error)) &#125; return data&#125; 从 prisma 获取用户信息的工具函数在其他操作需要用户信息时,可以从 http 请求只能获取用户 token,换取用户信息, 1234567891011121314151617181920212223242526272829303132333435import * as jwt from 'jsonwebtoken'import &#123; Prisma &#125; from 'prisma-binding'//在上下文中提供可以操作的 prisma 数据库句柄export interface Context &#123; db: Prisma request: any&#125;export interface User &#123; id: string name: string bio: string public_repos: string public_gists: string&#125;export function getUserId(ctx: Context) &#123; //从 http request 头部获得 token const Authorization = ctx.request.get('Authorization') if (Authorization) &#123; const token = Authorization.replace('Bearer ', '') const &#123; userId &#125; = jwt.verify(token, process.env.JWT_SECRET!) as &#123; userId: string &#125; return userId &#125; throw new AuthError()&#125;export class AuthError extends Error &#123; constructor() &#123; super('Not authorized') &#125;&#125; auth的 resolvers1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//Context是可以操作 prisma 数据库的句柄import &#123; Context, User &#125; from '../../utils'import &#123; getGithubToken, getGithubUser, GithubUser &#125; from '../../github'import * as jwt from 'jsonwebtoken'// Helpers -------------------------------------------------------------------async function getPrismaUser(ctx: Context, githubUserId: string): Promise&lt;User&gt; &#123; return await ctx.db.query.user(&#123; where: &#123; githubUserId &#125; &#125;)&#125;async function createPrismaUser(ctx, githubUser: GithubUser): Promise&lt;User&gt; &#123; const user = await ctx.db.mutation.createUser(&#123; data: &#123; githubUserId: githubUser.id, name: githubUser.name, bio: githubUser.bio, public_repos: githubUser.public_repos, public_gists: githubUser.public_gists, notes: [], &#125;, &#125;) return user&#125;// Resolvers -----------------------------------------------------------------export const auth = &#123; authenticate: async (parent, &#123; githubCode &#125;, ctx: Context, info) =&gt; &#123; const githubToken = await getGithubToken(githubCode) const githubUser = await getGithubUser(githubToken) //在 prisma 中查找用户,如果不存在就创建一个,然后返回一个 token 给用户 let user = await getPrismaUser(ctx, githubUser.id) if (!user) &#123; user = await createPrismaUser(ctx, githubUser) &#125; return &#123; token: jwt.sign(&#123; userId: user.id &#125;, process.env.JWT_SECRET), user, &#125; &#125;,&#125;// --------------------------------------------------------------------------- 执行其他操作时需要用户信息时的操作下面操作由于,已经在 schemamodel 中定义了 user和 note 的关联关系, 只需要在 owner中关联 userID就可以了,其他信息可以灵活查询获取. 12345678910111213141516171819202122232425262728293031323334353637383940414243mport &#123; Context, getUserId, AuthError &#125; from '../../utils'export const notes = &#123; async createNote(_, &#123; text &#125;, ctx: Context, info) &#123; const userId = getUserId(ctx) return await ctx.db.mutation.createNote(&#123; data: &#123; owner: &#123; connect: &#123; id: userId &#125; &#125;, text &#125;&#125;) &#125;, async updateNote(_, &#123; id, text &#125;, ctx: Context, info) &#123; const userId = getUserId(ctx) //检查这条消息是不是该用户创建的,是的话才能执行更新操作 const hasPermission = await ctx.db.exists.Note(&#123; id, owner: &#123; id: userId &#125; &#125;) if (!hasPermission) &#123; throw new AuthError() &#125; return await ctx.db.mutation.updateNote(&#123; where: &#123; id &#125;, data: &#123; text &#125; &#125;) &#125;, async deleteNote(_, &#123; id &#125;, ctx: Context, info) &#123; const userId = getUserId(ctx) //检查这条消息是不是该用户创建的,是的话才能执行删除操作 const hasPermission = await ctx.db.exists.Note(&#123; id, owner: &#123; id: userId &#125; &#125;) if (!hasPermission) &#123; throw new AuthError() &#125; return await ctx.db.mutation.deleteNote(&#123; where: &#123; id &#125; &#125;) &#125;&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"},{"name":"oAuth","slug":"oAuth","permalink":"https://React-Apollo.github.io/tags/oAuth/"}]},{"title":"Prisma|HackerNews_clone","slug":"Prisma|HackerNews_Clone","date":"2018-03-05T10:27:34.000Z","updated":"2019-04-28T05:52:57.892Z","comments":true,"path":"2018/03/05/Prisma|HackerNews_Clone/","link":"","permalink":"https://React-Apollo.github.io/2018/03/05/Prisma|HackerNews_Clone/","excerpt":"","text":"from howtographql.com API需求: Retrieve a list (feed) of link elements Allow users to signup up with their name, email and password Users who signed up should be able to login again with their email and password Allow authenticated users to post new link elements Allow authenticated users to upvote an existing link element Send realtime updates to subscribed clients when a new link element is created Send realtime updates to subscribed clients when an existing link element is upvoted 定义 应用 schema这一步非常好,根据应用的需求首先定义需要实现的 query,mutation,subscribe,然后围绕这个schema 展开工作,目前我们不关注User,Link,Vote的实现细节 123456789101112131415161718192021222324252627type Query &#123; # Retrieve a list (\"feed\") of link elements feed(filter: String, skip: Int, first: Int): [Link!]!&#125;type Mutation &#123; # Allow users to signup up with their name, email and password signup(name: String!, email: String!, password: String!): AuthPayload! # Users who signed up should be able to login again with their email and password login(email: String!, password: String!): AuthPayload! # Allow authenticated users to post new link elements post(url: String!, description: String!): Link # Allow authenticated users to upvote an existing link element vote(linkId: ID!): Vote&#125;type Subscription &#123; # Send realtime updates to subscribed clients when a new link element is created newLink: LinkSubscriptionPayload # Send realtime updates to subscribed clients when an existing link element is upvoted newVote: VoteSubscriptionPayload&#125;type AuthPayload &#123; token: String user: User&#125; 接下来就是逐渐实现这些操作.每一步实现的流程实际是基本类似的-这也就是schema-driven-development 调整 data model 调整之后,部署服务 用新的根字段扩展应用的 schema 实现 resolver, 通过代理执行对应的 Prisma resolver 初始化文件结构12345678910.├── package.json├── src│ ├── index.js│ ├── schema.graphql│ └── generated│ └── prisma.graphql└── database ├── prisma.yml └── datamodel.graphql src包含应用的实现代码和应用schema(application schema),Prisma根据 dataModel生成的 Prisma schema database 包含初始化配置文件 prisma.yml和应用的 data model \u001b src/schema.graphql(Apllication schema)定义了暴露给 client 端的 graphql API. src/generated/prisma.graphql(Prisma schema)定义了对数据库操作的 CRUD API. 对于在 data model 中的每个类型, Prisma会生成读写数据库节点的操作 data model并不是实际的 Graphql schema,缺少 root type. data model 用于生成实际执行的 schema. 理解初始化步骤有两个依赖包: graphql-yoga: GraphQL Server 需要的文件,实际是 express 服务器 prisma-binding: 可以允许绑定应用 schema 的 resolvers到自动生成的 Prisma database服务. 123456789101112const server = new GraphQLServer(&#123; typeDefs: './src/schema.graphql', resolvers, context: req =&gt; (&#123; ...req, db: new Prisma(&#123; typeDefs: 'src/generated/database.graphql', endpoint: 'http://localhost:60000/hackernews-node/dev', secret: 'mysecret123', &#125;), &#125;),&#125;) 查询在 data model 中定义 Link type12345type Link &#123; id: ID! @unique description: String! url: String!&#125; yarn prisma deploy 之后 会自动生成prisma.graphql 123456789101112type Query &#123; links(where: LinkWhereInput, orderBy: LinkOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Link]! link(where: LinkWhereUniqueInput!): Link&#125;type Mutation &#123; createLink(data: LinkCreateInput!): Link! updateLink(data: LinkUpdateInput!, where: LinkWhereUniqueInput!): Link deleteLink(where: LinkWhereUniqueInput!): Link updateManyLinks(data: LinkUpdateInput!, where: LinkWhereInput!): BatchPayload! deleteManyLinks(where: LinkWhereInput!): BatchPayload!&#125; 对 应用的 schema 做出调整定义feed查询 12345# import Link from \"./generated/prisma.graphql\"type Query &#123; feed(filter: String, skip: Int, first: Int): [Link!]!&#125; 实现 feed的 resolver每个Query,Mutation都由 resolver 支撑. 相应的定义为 Query.js,Mutation.js,Subscription.js. 123456789101112function feed(parent, args, context, info) &#123; const &#123; filter, first, skip &#125; = args // destructure input arguments const where = filter ? &#123; OR: [&#123; url_contains: filter &#125;, &#123; description_contains: filter &#125;] &#125; : &#123;&#125; return context.db.query.links(&#123; first, skip, where &#125;, info)&#125;module.exports = &#123; feed,&#125; resolver 函数接收四个参数, parent:包含 resolver 链的初始值 args:包含查询参数的对象. context:包含定制的数据,可以在 resolver 链中传递.例如每个 resolver 都可以读写 info包含了 AST信息 打开 index.js替换下面的resolver对象: 123456789const resolvers = &#123; Query,&#125;``` 导入我们自己定义的`Query`对象```jsconst Query=require('./resolvers/Query') 测试 API在项目的根目录执行1yarn dev 打开 graphiQL, 输入 12345678mutation &#123; createLink(data: &#123; url: \"https://www.graph.cool\", description: \"A GraphQL Database\" &#125;) &#123; id &#125;&#125; MutationsMutation for posting new links打开 src/schema.graphql添加如下代码 123type Mutation &#123; post(url: String!, description: String!): Link!&#125; 在src/resolvers创建新的Mutation.js,添加代码: 12345678function post(parent, args, context, info) &#123; const &#123; url, description &#125; = args return context.db.mutation.createLink(&#123; data: &#123; url, description &#125; &#125;, info)&#125;module.exports = &#123; post,&#125; 在index.js中添加新的mutation声明 123456const Mutation = require('./resolvers/Mutation')const resolvers = &#123; Query, Mutation,&#125; 测试一下 12345mutation &#123; post(url: \"https://www.howtographql.com\", description: \"Fullstack tutorial website for GraphQL\") &#123; id &#125;&#125; Signup&amp;Login为用户提供登录功能Signup注册的实现步骤: 服务器收到新用户的email,password(还有name) 服务器在数据库创建新用户,并储存name,email和 hash过的密码 服务器创建一个认证 token(JWT) 服务器把 token返回给用户 Login 服务器收到login mutation 服务器比较password的一致性 如果密码一致, 服务器创建一个 token 服务器把 token 返回给用户 实现注册流程创建secret 12345const APP_SECRET = 'GraphQL-is-aw3some'module.exports = &#123; APP_SECRET&#125; 在应用的 schema 中添加 signup Mutation 1234type Mutation &#123; post(url: String!, description: String!): Link! signup(email: String!, password: String!, name: String!): AuthPayload&#125; src/schema.graphql1234type AuthPayload &#123; token: String user: User&#125; database/datamodel.graphql 123456type User &#123; id: ID! @unique name: String! email: String! @unique password: String!&#125; 部署以后会生成 12345678910111213type Query &#123; users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]! user(where: UserWhereUniqueInput!): User&#125;type Mutation &#123; createUser(data: UserCreateInput!): User! updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User deleteUser(where: UserWhereUniqueInput!): User upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User! updateManyUsers(data: UserUpdateInput!, where: UserWhereInput!): BatchPayload! deleteManyUsers(where: UserWhereInput!): BatchPayload!&#125; 打开应用 schema src/schema.graphql添加如下的类型 12345type User&#123; id: ID! name:String! email:String!&#125; 这里的定义和 Prisma schema 里的定义类似,但是没有password,也就是不允许用户查询 password 接下来需要signup mutation 12345678910111213async function signup(parent, args, context, info) &#123; const password = await bcrypt.hash(args.password, 10) const user = await context.db.mutation.createUser(&#123; data: &#123; ...args, password &#125;, &#125;) const token = jwt.sign(&#123; userId: user.id &#125;, APP_SECRET) return &#123; token, user, &#125;&#125; 在signup resolver 中, 首先创建密码的加密版本, 接下来, 使用Prisma的实例,创建新的User节点.最后返回包含AuthPayload包含创建的 token 和新的 user 对象 实现login mutation接下来,实现login mutation. src/schema.graphql中添加Mutation 类型 12345type Mutation &#123; post(url: String!, description: String!): Link! signup(email: String!, password: String!, name: String!): AuthPayload login(email: String!, password: String!): AuthPayload&#125; 打开 src/resolvers/Mutation.js添加如下函数 123456789101112131415161718async function login(parent, args, context, info) &#123; const user = await context.db.query.user(&#123; where: &#123; email: args.email &#125; &#125;) if (!user) &#123; throw new Error(`Could not find user with email: $&#123;args.email&#125;`) &#125; const valid = await bcrypt.compare(args.password, user.password) if (!valid) &#123; throw new Error('Invalid password') &#125; const token = jwt.sign(&#123; userId: user.id &#125;, APP_SECRET) return &#123; token, user, &#125;&#125; 首先使用 email 查询是否存在, 然后比较密码是否一致. 完成后,返回一个 token 给用户 应用 Authentication创建User和Link的关联在需求中,我们提出只有通过认证的用户才可以创建新的 Link元素. 打开 database/datamodel.js 改变User和Link类型 1234567891011121314type Link &#123; id: ID! @unique description: String! url: String! postedBy: User&#125;type User &#123; id: ID! @unique name: String! email: String! @unique password: String! links: [Link!]!&#125; 可以执行如下的操作 12345678910111213mutation &#123; createLink(data: &#123; url: \"https://www.graphql.org\", description: \"Official GraphQL Website\", postedBy: &#123; connect: &#123; email: \"johndoe@graph.cool\" &#125; &#125; &#125;) &#123; id &#125;&#125; 打开 src/resolvers/Mutation.js改变post 1234567function post(parent, &#123; url, description &#125;, context, info) &#123; const userId = getUserId(context) return context.db.mutation.createLink( &#123; data: &#123; url, description, postedBy: &#123; connect: &#123; id: userId &#125; &#125; &#125; &#125;, info, )&#125; 和之前的版本不同的地方是,首先获取到用户的 id, 然后传递给createLink-mutation 作为connect的参数. 现在我们需要一个工具函数 getUserId, src/utils.js 12345678910function getUserId(context) &#123; const Authorization = context.request.get('Authorization') if (Authorization) &#123; const token = Authorization.replace('Bearer ', '') const &#123; userId &#125; = jwt.verify(token, APP_SECRET) return userId &#125; throw new Error('Not authenticated')&#125; context参数有一个request属性,代表着携带 query 或者 mutation的 HTTP 请求. 重要的是,它提供了访问头 .token就在头部中 认证一个用户 在 playground中, 发送signup或者login mutation,从 graphql server 中获取到 token. 在PlayGround中设置Header 发送post mutation,创建新的Link 元素 12345678mutation &#123; login( email: \"johndoe@graph.cool\" password: \"graphql\" ) &#123; token &#125;&#125; 设置好以后,执行 12345678mutation &#123; post( url: \"https://www.graphqlweekly.com\" description: \"Weekly GraphQL Newsletter\" ) &#123; id &#125;&#125; 投票部分Subscriptions实现 GraphQL订阅打开src/schema.graphql,添加Subscription 1234type Subscription &#123; newLink: LinkSubscriptionPayload newVote: VoteSubscriptionPayload&#125; 在src/resolvers创建一个新的文件, SubScription.js添加如下代码: 12345678910111213141516171819202122const newLink = &#123; subscribe: (parent, args, ctx, info) =&gt; &#123; return ctx.db.subscription.link( &#123; &#125;, info, ) &#125;,&#125;const newVote = &#123; subscribe: (parent, args, ctx, info) =&gt; &#123; return ctx.db.subscription.vote( &#123; &#125;, info, ) &#125;,&#125;module.exports = &#123; newLink, newVote,&#125; 现在的src/inde.js文件 1234567891011const &#123; GraphQLServer &#125; = require('graphql-yoga')const &#123; Prisma &#125; = require('prisma-binding')const Query = require('./resolvers/Query')const Mutation = require('./resolvers/Mutation')const Subscription = require('./resolvers/Subscription')const resolvers = &#123; Query, Mutation, Subscription&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"algolia-cnode即时搜索实现- React版","slug":"algolia-cnode搜索实现","date":"2018-03-04T14:59:12.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2018/03/04/algolia-cnode搜索实现/","link":"","permalink":"https://React-Apollo.github.io/2018/03/04/algolia-cnode搜索实现/","excerpt":"","text":"参考的文献是: Algolia Auto-Sync for GraphQL backends. 实现了 Graphql 数据数据添加和删除时的数据同步 基本流程是,你给 algolia 提供一个需要索引的文本或者资源, algolia 会做出索引,之后就可以使用提供的 API获取结果. 总共索引了1-95页的数据, 可能排序上还要优化, 方法现在没有问题 基础流程没有什么问题.遇到的问题是,之前从 medium 网站抓取了300多篇文章, 建完索引之后,没有结果. algolia 实现的是在建立索引机制以后的数据才可以使用, 我索性把 cnode 1-95页的数据都建了索引. cnode 每页是40条, 总共是3800条数据, 现在有3600数据加了索引,没有插入的还没看是什么原因. 大概步骤项目分为四大块:①:后台服务器,组要是由于目前在使用 graphql,觉得很有潜力,而且 graphcool 提供了 algolia 的整合服务,使用还是比较简单的,主要工作是建立模型,导入和 aloglia 对接的 APP ID和 Token. ②: algolia上的配置, 主要 是获取 APPID和 Token. ③: 从 cnode,导入数据,严格说这一部分和这里的文章关系不太大.④: 前端的配置, 这个有教程,最简单的异步, 获取数据的方法都封装好了, 直接使用即可. 实现的结果 实现方案注册,建立应用,获取 APPID ①登录:https://www.algolia.com,注册直接用 github 登录. ②:点击右上角 dashboard 进入管理界面 ③: 点击 创建一个应用 ④:进入应用,其他不动, 我们只会使用到 key, 点击钥匙 ⑤: 这里会有一个 search-only-key,专门用于前端搜索用的, 我们在 all api key下创建一个新的有用读写记录的key. 注意还有 application ID ⑥ 点击 ⑦: 设置,名字,还有权限,只需要读写的权限就可以了.点击生成, 而搜索的 key是这样 通过以上的步骤,现在我们有三个要使用的 id, 一个应用的 ID,一个所有使用的key,一个用于配置服务的key. 由于用于索引的数据都是从后台同步的,这里目前就不要再做任何的工作了. 后续可以做些优化工作. 后台服务服务的建立建立模型 创建graphcool服务器, 这个参看 graphcool网站的教程, 建立模型 创建了一个简单的模型包含有 title,content, tab 字段,添加其他的也可以.首要任务是跑通流程 使用整合服务 整合 aloglia 的服务, 点击进入添加key 有两个key,我们要使用允许读写的的那个key才行 点击 添加index. 123456789101112131415161718192021222324 &#123; node &#123; content tab title &#125; &#125;``` ---点击创建 index,我们的配置工作就完成了现在可以添加一条索引,验证一项 algolia 会不会自动同步数据![](https://ws3.sinaimg.cn/large/006tNc79gy1fp0uzl3kthj30yj06n74c.jpg) dashboard 中如果有记录,证明数据同步成功了.如果这里是0,要看看前面的配置有没有问题,如果有问题,不要急着做下一步, 到这里配置就完成了, 导入数据和配置是独立的过程. ![](https://ws4.sinaimg.cn/large/006tNc79gy1fp0v1aiw8cj30fq05pt8l.jpg) 在 graphcool 手动输入一条信息, algolia如果有记录出现,配置完成 接着进行下一步, 导入数据### 导入数据, 这里不详细说, 通过 cnode的 API获取数据,然后依照 graphql 的mutate 方法,导入到 Graphcool 的数据库.参见下面的代码 ‘use strict’import express from ‘express’import bodyParser from ‘body-parser’import cors from ‘cors’import * as R from ‘ramda’var path = require(‘path’)require(‘es6-promise’).polyfill()require(‘isomorphic-fetch’)import fetch from ‘node-fetch’import { request } from ‘graphql-request’const dataArray = []var t = require(‘transducers-js’) // 导入transducers-js执行tranducer操作const URL = ‘http://localhost&#39;const PORT = 3001const api = ‘https://api.graph.cool/simple/v1/cjearwrd40zes01671xikrsnh&#39; // graphcool API// graphql模板-数据插入的模板const mu = `mutation createList( $tab: String!, $content:String!, $title: String!){ createList( content: $content, tab:$tab, title:$title, ){ id } }`//主方法export const start = async () =&gt; { try { const app = express() app.use(cors()) app.use(express.static(__dirname)) app.listen(PORT, () =&gt; { console.log(Visit ${URL}:${PORT}) }) const startTime = Date.now() for (var i = 1; i &lt;= 95; i++) { const pageData = await singlePageData(i) //获取单页数据 dataArray.push(pageData) } const flattenData = R.flatten(dataArray) const getData = compose(R.map(insertData), flattenData) await getData(dataArray); //插入数据库 const endTime = Date.now() const spend = endTime - startTime console.log(&apos;spending time:&apos;, spend) } catch (e) { console.log(e) }}//单条记录插入 graphcool数据库的方法const insertData = data =&gt; { var flattenData = function (n) { return { content: n.content, tab: n.tab, title: n.title} };//数据插入 graphql 数据方法柯理化 const func = R.curry((api, template, variables) =&gt; request(api, template, variables).then(data =&gt; { console.log(‘data:’, data) }) ) const waitForData = func(api, mu) var xf = t.comp(R.map(flattenData), R.map(waitForData)) //这里用了 transducer.js 的方法 const mediateFunc = R.curry((xf, data) =&gt; t.into([], xf, data)) const getFinalRes = mediateFunc(xf) getFinalRes(data)}; //异步 compose 方法const compose = (…functions) =&gt; input =&gt; functions.reduceRight((chain, func) =&gt; chain.then(func), Promise.resolve(input))//拼接 API的方法const variablesTemp = num =&gt; https://cnodejs.org/api/v1/topics?page=${num}//获取数据,并取出 data字段的方法const fetchData = url =&gt; fetch(url).then(res =&gt; res.json()).then(data =&gt; data.data)//异步 compose 组合的获取 API url 并 获取数据的方法const singlePageData = compose(fetchData, variablesTemp)12345678910插入数据以后, 在 graphcool 后台可以看到记录数, 在 algolia的 dashboard 也可以看到记录数. 整个配置和数据导入就完成了. 由于我们这里是从 cnode获取手动获取数据, 如果是原生使用 Graphcool 的数据库, 插入条目以后,会立刻自动通过. 用 cnode 的 API稍微麻烦一点### 前端的配置React/React-Native的配置可以在github搜索,有很多代码实例#### app.js 文件配置 导入 app ID 和仅用于搜索的 key和 index name.这个 name 是在后台配置时建立的, algolia 显示的就是这个名字. import React from “react”;import { Text, View } from “react-native”;import { InstantSearch } from “react-instantsearch/native”;import styles from “./src/styles”;import SearchBox from “./src/SearchBox”;import Results from “./src/Results”; export default class App extends React.PureComponent { render() { return ( Medium Search ); }}12345678910111213141516171819202122232425#### Searchbox.js 输入的数据和 algolia 发生联系的组件```jsimport React from \"react\";import &#123; TextInput &#125; from \"react-native\";import &#123; connectSearchBox &#125; from \"react-instantsearch/connectors\";import styles from \"./styles\";const SearchBox = connectSearchBox((&#123; refine, currentRefinement &#125;) =&gt; &#123; return ( &lt;TextInput style=&#123;styles.textBox&#125; onChangeText=&#123;text =&gt; refine(text)&#125; value=&#123;currentRefinement&#125; placeholder=\"Search Something\" clearButtonMode=\"always\" spellCheck=&#123;false&#125; autoCorrect=&#123;false&#125; autoCapitalize=\"none\" /&gt; );&#125;);export default SearchBox; List 列表显示数据123456789101112131415161718192021222324252627import React from \"react\";import &#123; FlatList &#125; from \"react-native\";import &#123; connectInfiniteHits &#125; from \"react-instantsearch/connectors\";import Repository from \"./Repository\";import ItemSeperator from \"./ItemSeperator\";const Results = connectInfiniteHits((&#123; hits, hasMore, refine &#125;) =&gt; &#123; const onEndReached = () =&gt; &#123; if (hasMore) &#123; refine(); &#125; &#125;; //终端打印搜索数据 console.log(hits); return ( &lt;FlatList data=&#123;hits&#125; onEndReached=&#123;onEndReached&#125; keyExtractor=&#123;repo =&gt; repo.objectID&#125; renderItem=&#123;(&#123; item &#125;) =&gt; &lt;Repository repo=&#123;item&#125; /&gt;&#125; ItemSeparatorComponent=&#123;ItemSeperator&#125; /&gt; );&#125;);export default Results; 具体的 item,就不写了. 其实上面 console.log 打印出数据整个流程就完成了.在 algolia 的 dashboard 也可以查看搜索的情况 整个即时搜索的流程完成, 速度还是挺快的, 大部分工作人家的算法帮我们完成了. 如果查看页面发现还有许多要优化的地方,后面再说.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"cnode","slug":"cnode","permalink":"https://React-Apollo.github.io/tags/cnode/"},{"name":"algolia","slug":"algolia","permalink":"https://React-Apollo.github.io/tags/algolia/"},{"name":"express","slug":"express","permalink":"https://React-Apollo.github.io/tags/express/"}]},{"title":"cnode GraphQL 版本","slug":"Cnode-Graphql-API","date":"2018-03-02T16:35:42.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/03/02/Cnode-Graphql-API/","link":"","permalink":"https://React-Apollo.github.io/2018/03/02/Cnode-Graphql-API/","excerpt":"","text":"按照cnode-api的顺序来的, 基本只是做了包装,需要修改的可以看代码,做出修改. 通过 graphql 的 rest-wrapper resolver 包装以后,就可以获得 graphql的一些很好的特征了. 因为没有数据写入的Grpahql 的数据库,所以所有的操作都用的是query. 没有用 mutate. 因为最终还是访问的 REST API.这的graphql采用的是 graphcool 的服务器, 尽管试, 没有写入操作. Graphcool-cnode-server graphiQL地址 服务器的初始化可以参考这里Graphcool Server 可以选择部署在本地docker 中, 如果用于测试可以 直接部署在云上. 大致的流程如下在 GraphQL客户端或者是 GraphiQL执行的操作,会经过 resolver 函数的处理, resolver 实际是 express 服务器, 在这里可以执行数据库操作,或者是执行转发任务, 如果是为 API 提供服务, 就使用转发. 我们这里就是转发. 主题1 get/tpoics 主题首页就是数据列表,tab用于分类, page 用于分页 allTopics.graphql 123456789101112131415161718//⛔️有些字段没有列出,可以做修改type AllTopicsPayload &#123; id: String! tab: String title: String! visit: Int! aurl: String! author_id: String!&#125;input QueryInput &#123; page: Int! tab: String!&#125;extend type Query &#123; AllTopics(page: Int!, tab: String!): [AllTopicsPayload!]!&#125; allTopics.js 123456789101112131415161718192021222324252627282930require('isomorphic-fetch');const R = require('ramda');const url = 'https://cnodejs.org/api/v1/topics';module.exports = (event) =&gt; &#123; const &#123; tab, page &#125; = event.data; urlWithParams = `$&#123;url&#125;?tab=$&#123;tab&#125;&amp;page=$&#123;page&#125;`; let options = &#123; method: 'GET' &#125;; return fetch(urlWithParams, options).then((response) =&gt; response.json()).then((responseData) =&gt; &#123; const NodeList = responseData.data; const allCnode = []; const selectPropertyX = (x) =&gt; (&#123; id: x.id, tab: x.tab, aurl: x.author.avatar_url, visit: x.visit_count, title: x.title, author_id: x.author_id &#125;); const allTopics = R.map(selectPropertyX, NodeList); //const getIdcollections=R.curry(R.map(selectPropertyX,data)); //const allCnode=getIdcollections(NodeList); return &#123; data: allTopics &#125;; &#125;);&#125;; 查询示意图 注意事项graphiQL里执行的操作就是最好的文档, 这里执行的查询结果, 在其他地方可以完全复现,如果复现不了,就是你的客户端代码由问题. 在客户端我们可以使用 graphql-tag 的方法把这段查询的字符串给拼接出来.如果拼接没有问题, 得到的结果是完全一样的 2 get/topics主题详情 getOneTopic.graphql 12345678910 type OneTopicPayload &#123; id: String! tab: String title: String!, content:String!,&#125;extend type Query &#123; getOneTopic(id:String!): OneTopicPayload!&#125; getOneTopic.js 1234567891011121314require('isomorphic-fetch')const R = require('ramda');module.exports = event =&gt; &#123; const &#123;id&#125; = event.data const url = `https://cnodejs.org/api/v1/topic/$&#123;id&#125;` return fetch(url) .then(response =&gt; response.json()) .then(responseData =&gt; &#123; return &#123;data: responseData.data&#125; &#125;)&#125; 查询 3新建主题 post/topicscreateTopic.graphql 123456789101112type createTopicPayload &#123; tab: String!@default(value: \"dev\") #默认选了 dev title:String! accesstoken: String! content: String! success: Boolean &#125;extend type Query &#123; createTopic(title: String!,accesstoken:String!,tab:String!,content:String!): createTopicPayload&#125; createTopic.js 123456789101112131415161718192021222324'use latest'import fetch from 'node-fetch'const api = 'https://cnodejs.org/api/v1/topics' module.exports = async event =&gt; &#123; const &#123;tab, accesstoken, title, content&#125; = event.data const body = &#123; accesstoken: accesstoken, tab: tab, title: title, content: content &#125; const ress = await fetch(api, &#123; method: 'POST', body: JSON.stringify(body), headers: &#123;'Accept': 'application/json', 'Content-Type': 'application/json'&#125;, &#125;) .then(res =&gt; res.json()) .then(json =&gt; json) const success = &#123; 'success': ress.success &#125; console.log(ress); return &#123;data: success&#125;&#125; 查询示意 4编辑主题 post/topics/updateupdateTopic.graphql 12345678910111213type updateTopicPayload &#123; tab: String!@default(value: \"dev\") title:String! accesstoken: String! content: String! success: Boolean topic_id:String! &#125;extend type Query &#123; updateTopic(title: String!,accesstoken:String!,tab:String!,content:String!,topic_id:String!): updateTopicPayload&#125; updateTopic.js 12345678910111213141516171819202122232425'use latest';import fetch from 'node-fetch';const api = 'https://cnodejs.org/api/v1/topics/update';module.exports = async event =&gt; &#123; const &#123; tab, accesstoken, title, content, topic_id &#125; = event.data; const body = &#123; accesstoken: accesstoken, tab: tab, title: title, content: content, topic_id: topic_id &#125;; const ress = await fetch(api, &#123; method: 'POST', body: JSON.stringify(body), headers: &#123; Accept: 'application/json', 'Content-Type': 'application/json' &#125; &#125;) .then(res =&gt; res.json()) .then(json =&gt; json); const success = &#123; success: ress.success &#125;; console.log(ress); return &#123; data: ress &#125;;&#125;; 查询结果和创建基本是一样的 收藏1收藏主题 get topic_collection/collectcreateTopicCollection.graphql 12345678910type createTopicCollectionPayload &#123; topic_id: String accesstoken: String success: Boolean &#125;extend type Query &#123; createTopicCollection(topic_id: String!,accesstoken:String!): createTopicCollectionPayload&#125; createTopicCollection.js 123456789101112131415161718192021'use latest'import fetch from 'node-fetch'const api = 'https://cnodejs.org/api/v1/topic_collect/collect'module.exports = async event =&gt; &#123; const &#123;topic_id, accesstoken&#125; = event.data const body = &#123; accesstoken: accesstoken, topic_id: topic_id &#125; const ress = await fetch(api, &#123; method: 'POST', body: JSON.stringify(body), headers: &#123;'Accept': 'application/json', 'Content-Type': 'application/json'&#125;, &#125;) .then(res =&gt; res.json()) .then(json =&gt; json) const success = &#123; 'success': ress.success &#125; return &#123;data: success&#125;&#125; 2取消主题收藏 post/topic_collection/de_collectcancelTopicCollection.graphql 12345678910type cancelTopicCollectionPayload &#123; topic_id: String accesstoken: String success: Boolean &#125;extend type Query &#123; cancelTopicCollection(topic_id: String!,accesstoken:String!): cancelTopicCollectionPayload&#125; cancelTopicCollection.js 123456789101112131415161718192021'use latest'import fetch from 'node-fetch'const api = 'https://cnodejs.org/api/v1/topic_collect/de_collect'module.exports = async event =&gt; &#123; const &#123;topic_id, accesstoken&#125; = event.data const body = &#123; accesstoken: accesstoken, topic_id: topic_id &#125; const ress = await fetch(api, &#123; method: 'POST', body: JSON.stringify(body), headers: &#123;'Accept': 'application/json', 'Content-Type': 'application/json'&#125;, &#125;) .then(res =&gt; res.json()) .then(json =&gt; json) const success = &#123; 'success': ress.success &#125; return &#123;data: success&#125;&#125; 3 主题首页 get/topic_collection/:loginnameallCollections.graphql 12345678910type AllCollectionsPayload &#123; id: String! tab: String title: String! visit: Int! &#125;extend type Query &#123; AllCollections(name:String!): [AllCollectionsPayload !]!&#125; allCollections.js 12345678910111213141516171819require('isomorphic-fetch')const R = require('ramda')const url = 'https://cnodejs.org/api/v1/topic_collect/'module.exports = (event) =&gt; &#123; const &#123;name&#125; = event.data urlWithParams = `$&#123;url&#125;$&#123;name&#125;` let options = &#123; method: 'GET' &#125; return fetch(urlWithParams, options).then((response) =&gt; response.json()).then((responseData) =&gt; &#123; const Collections = responseData.data const selectPropertyX = (x) =&gt; (&#123;id: x.id, tab: x.tab, title: x.title, visit: x.visit_count, author_id: x.author_id&#125;) const allCollections = R.map(selectPropertyX, Collections) return &#123;data: allCollections&#125; &#125;)&#125;; 查询结果 评论1 新建评论 post/ topic/:topic_id/repliescreateReplies.graphql 123456789101112type createRepliesPayload &#123; topic_id:String! accesstoken:String! content: String! reply_id: String success:Boolean &#125;extend type Query &#123; createReplies(topic_id: String!,accesstoken:String!,content:String!,reply_id:String): createRepliesPayload&#125; createReplies.js 123456789101112131415161718192021222324'use latest'import fetch from 'node-fetch'module.exports = async event =&gt; &#123; const &#123;topic_id, accesstoken, content, reply_id&#125; = event.data const body = &#123; accesstoken: accesstoken, content: content, reply_id: reply_id &#125; const api=`https://cnodejs.org/api/v1/topic/$&#123;topic_id&#125;/replies` const ress = await fetch(api, &#123; method: 'POST', body: JSON.stringify(body), headers: &#123;'Accept': 'application/json', 'Content-Type': 'application/json'&#125; &#125;) .then(res =&gt; res.json()) .then(json =&gt; json) const success = &#123; 'success': ress.success &#125; console.log(ress) return &#123;data: success&#125;&#125; 查询结果 2为评论点赞 post /reply/:reply_id/upscreateUps.graphql 123456789101112type createUpsPayload &#123; accesstoken:String! reply_id: String! success:Boolean &#125;extend type Query &#123; createUps(accesstoken:String!,reply_id:String): createUpsPayload&#125; createUps.js 123456789101112131415161718192021222324'use latest'import fetch from 'node-fetch'module.exports = async event =&gt; &#123; const &#123; accesstoken, reply_id&#125; = event.data const body = &#123; accesstoken: accesstoken &#125; const api = `https://cnodejs.org/api/v1/reply/$&#123;reply_id&#125;/ups` const ress = await fetch(api, &#123; method: 'POST', body: JSON.stringify(body), headers: &#123;'Accept': 'application/json', 'Content-Type': 'application/json'&#125; &#125;) .then(res =&gt; res.json()) .then(json =&gt; json) const success = &#123; 'success': ress.success &#125; console.log(ress) return &#123;data: success&#125;&#125; 查询结果 用户1用户详情 get /user/:loginnamegetUserInfo.graphql 123456789101112type UserInfoPayload &#123; loginname: String! avatar_url: String! score: Int! recent_topics:[Json!]! recent_replies:[Json!]!&#125;extend type Query &#123; getUserInfo(name:String!): UserInfoPayload!&#125; getUserInfo.js 1234567891011121314151617require('isomorphic-fetch')const url = 'https://cnodejs.org/api/v1/user/'module.exports =async (event) =&gt; &#123; const &#123;name&#125; = event.data urlWithParams = `$&#123;url&#125;$&#123;name&#125;` let options = &#123; method: 'GET' &#125; return fetch(urlWithParams, options) .then(response =&gt; response.json()) .then(responseData =&gt; &#123; return &#123;data: responseData.data&#125; &#125;)&#125; 查询结果 消息通知获取未读消息 get/message/countgetMessageCount.graphql 12345678type MessageCountPayload &#123; accesstoken:String! data:Int success:Boolean&#125;extend type Query &#123; getMessageCount(accesstoken:String!): MessageCountPayload!&#125; getMessageCount.js 123456789101112131415require('isomorphic-fetch')const url = 'https://cnodejs.org/api/v1/message/count?accesstoken='module.exports =async (event) =&gt; &#123; const &#123;accesstoken&#125; = event.data urlWithParams = `$&#123;url&#125;$&#123;accesstoken&#125;` let options = &#123; method: 'GET' &#125; return fetch(urlWithParams, options) .then(response =&gt; response.json()) .then(responseData =&gt; &#123; return &#123;data: responseData&#125; &#125;) &#125; 2获取已读和未读消息 get /messagesgetMessages.graphql 1234567891011 type MessagesPayload &#123; has_read_messages:[Json] hasnot_read_messages:[Json] &#125;extend type Query &#123; getMessages(accesstoken:String!): MessagesPayload!&#125; getMessages.js 123456789101112131415require('isomorphic-fetch')const url = 'https://cnodejs.org/api/v1/messages?accesstoken='module.exports =async (event) =&gt; &#123; const &#123;accesstoken&#125; = event.data urlWithParams = `$&#123;url&#125;$&#123;accesstoken&#125;` let options = &#123; method: 'GET' &#125; return fetch(urlWithParams, options) .then(response =&gt; response.json()) .then(responseData =&gt; &#123; return &#123;data: responseData.data&#125; &#125;)&#125; 查询结果 3全部标记已读 post /message/mark_allmarkAll.graphql 12345678type markAllPayload &#123; accesstoken: String! success: Boolean&#125;extend type Query &#123; markAll(accesstoken:String!): markAllPayload&#125; markAll.js 12345678910111213141516171819202122'use latest';import fetch from 'node-fetch';const api = 'https://cnodejs.org/api/v1/message/mark_all';module.exports = async event =&gt; &#123; const &#123;accesstoken&#125; = event.data; const body = &#123; accesstoken: accesstoken, &#125;; const ress = await fetch(api, &#123; method: 'POST', body: JSON.stringify(body), headers: &#123; Accept: 'application/json', 'Content-Type': 'application/json' &#125; &#125;) .then(res =&gt; res.json()) .then(json =&gt; json); const success = &#123; success: ress.success &#125;; console.log(ress); return &#123; data: ress &#125;;&#125;; 查询结果 后记,如果要在 客户端使用 GraphQL查询,怎么操作呢?我使用的的 Apollo-client的方法 ① 在顶层组件导入配置文件1234567891011121314151617181920import &#123; ApolloProvider &#125; from 'react-apollo'import &#123; ApolloClient, HttpLink, InMemoryCache&#125; from 'apollo-client-preset'const httpLink = new HttpLink(&#123; uri: 'https://api.graph.cool/simple/v1/cjaxudkum2ugf0127kok921bc' &#125;)const client = new ApolloClient(&#123; link: httpLink, cache: new InMemoryCache(), connectToDevTools: false&#125;)export default class App extends React.Component &#123; render() &#123; return ( &lt;ApolloProvider client=&#123;client&#125;&gt; &lt;Navigator /&gt; &lt;/ApolloProvider&gt; ) &#125;&#125; ②实际是单一数据来源的 store, 在组件中可以直接使用查询了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import &#123; graphql &#125; from 'react-apollo';import gql from 'graphql-tag';//这里拼接的查询字符串和我们在浏览器中使用的字符串完全相同//如果在浏览器中正常,这里没有结果,或者结果不一致, 问题就在这里了.const getCollections = gql` query ($name: String!)&#123; AllCollections(name:$name) &#123; id, tab, title, visit &#125; &#125;`;class Collection extends Component &#123; componentDidMount() &#123; &#125; render() &#123; const &#123;navigate&#125; = this.props.navigation; //console.log(this.props.data) if(this.props.data.loading)&#123; return ( &lt;View style=&#123;&#123;flex:1,alignItems:'center',justifyContent:'center'&#125;&#125;&gt; &lt;Text&gt;Loading...&lt;/Text&gt; &lt;/View&gt; ) &#125; //console.log(this.props.data.AllCollections); return ( &lt;List containerStyle=&#123;&#123; borderTopWidth: 0, borderBottomWidth: 0 &#125;&#125;&gt; &lt;FlatList data=&#123;this.props.data.AllCollections&#125; renderItem=&#123;(&#123; item &#125;) =&gt; ( &lt;ListItem roundAvatar title=&#123;`$&#123;item.title&#125;`&#125; subtitle=&#123;`访问次数:$&#123;item.visit&#125;`&#125; avatar=&#123;&#123; uri: \"https://avatars3.githubusercontent.com/u/3118295?v=4&amp;s=120\" &#125;&#125; containerStyle=&#123;&#123; borderBottomWidth: 0.2 &#125;&#125; onPress=&#123;() =&gt; navigate('Detail',&#123;id:`$&#123;item.id&#125;`&#125;)&#125; /&gt; )&#125; keyExtractor=&#123;item =&gt; item.id&#125; onEndReachedThreshold=&#123;50&#125; /&gt; &lt;/List&gt; ); &#125; &#125; //注入 graphql 查询 export default graphql(getCollections, &#123;options: (&#123;navigation&#125;) =&gt; &#123; return (&#123; variables: &#123; name: 'alsotang', &#125; &#125;); &#125;&#125;)(Collection) GraphQL在这里不仅仅是对 API进行了包装这么简单,它大概提供了一下的好处: ①:严格了类型,类型错误,或者缺少都会报错 ②:可以根据需求灵活的选择需要返回的数据,例如 列表并不需要 cotent,我们可以选择性的在 graphql 返回数据时省掉这一个字段. 如果 graphQL 服务器和 REST 服务器在同一个主机下,效率会大大提高. ③:为 API生成了一个单一的入口,多个查询可以一次返回. 减少请求次数 ④: 提供了强有力的测试和说明工具: graphiql, 统一前后端的操作. ⑤: graphQL自带说明性质, 有很好的代码提示和自动完成功能. 后续的客户端也会提供这个功能, 出错的机会大大降低了","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"},{"name":"cnode","slug":"cnode","permalink":"https://React-Apollo.github.io/tags/cnode/"}]},{"title":"摘要|有关 Redux 模式最好的一张图","slug":"摘要|有关 Redux 模式最好的一张图","date":"2018-03-02T05:10:46.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/03/02/摘要|有关 Redux 模式最好的一张图/","link":"","permalink":"https://React-Apollo.github.io/2018/03/02/摘要|有关 Redux 模式最好的一张图/","excerpt":"","text":"今天在 medium 网,看到这篇文章When do I know I’m ready for Redux? 要点: ① Redux的单向数据流. 数据只从 Redux=&gt;component. 其实 Redux 也是一个 React 组件, 这个组件的state有特殊的意义. 处理的数据把它转变为 props 就可以传递给子组件了. 这个做法就是 React 的标准模式. 所以如果有一个问题, Redux到底是什么? 它其实也是一个 React 的组件 ② 组件的 dispatch 操作, 并没有真正的操作组件里的函数, 只是通过引用赋值,调用了 Redux中定义的 action 函数, 所以这幅图中从组件到Redux并没有直接相连. 这里阐述的很好.","categories":[{"name":"Readme","slug":"Readme","permalink":"https://React-Apollo.github.io/categories/Readme/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"}]},{"title":"摘要|Better Redux Selectors with Ramda","slug":"摘要| Better  Redux Selectors with Ramda","date":"2018-02-28T09:55:17.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/02/28/摘要| Better  Redux Selectors with Ramda/","link":"","permalink":"https://React-Apollo.github.io/2018/02/28/摘要| Better  Redux Selectors with Ramda/","excerpt":"","text":"原文 目标目标是把Redux中selector: 1234567export const getUserName = state =&gt; state.user.nameexport const isLoggedIn = state =&gt; state.user.id != nullexport const getTotalItemCount = state =&gt; Object.values(state.items.byId) .reduce((total, item) =&gt; total + item.count, 0) 转换为: 1234567891011121314import R from 'ramda'// Helper functionsconst isNotNil = R.complement(R.isNil)const pathIsNotNil = path =&gt; R.compose(isNotNil, R.path(path))const addProp = propName =&gt; R.useWith(R.add, [R.identity, R.prop(propName)])const sumProps = propName =&gt; R.reduce(addProp(propName), 0)const sumCounts = sumProps('count')// Selector functionsexport const getUserName = R.path(['user', 'name'])export const isLoggedIn = pathIsNotNil(['user', 'id'])export const getTotalItemCount = R.compose(sumCounts, R.values, R.path(['items', 'byId'])) 介绍Selector函数回顾selector 的概念在 Redux 的文档中出现过, 为了代替直接在 React 组件中访问 state tree,可以定义从 state 获取数据的函数. 可以认为是从 state获取数据的 API. 不是必须的, 甚至 Redux也不是一定要用. Selector函数接收 Redux的 state 对象作为参数, 返回任何你需要的数据. 实例: 从 State tree 获取 属性 123function getUserName(state) &#123; return state.user.name&#125; 从属性衍生数据 123function isLoggedIn(state) &#123; return state.user.id != null&#125; 从一个列表数据中衍生数据 123456function getTotalItemCount(state) &#123; return Object.keys(state.items.byId) .reduce(function(total, id) &#123; return total + state.items.byId[id].count &#125;, 0)&#125; 假定列表的每个 item都有一个count属性, 这个 selector 使用array.reduce()函数计算count的综合. 123456789101112131415export function getUserName(state) &#123; return state.user.name&#125;export function isLoggedIn(state) &#123; return state.user.id != null&#125;export function getTotalItemCount(state) &#123; return Object.keys(state.items.byId) .reduce(function(total, id) &#123; return total + state.items.byId[id].count &#125;, 0)&#125; 如果使用 ES2015语法,会更简洁 1234567export const getUserName = state =&gt; state.user.nameexport const isLoggedIn = state =&gt; state.user.id != nullexport const getTotalItemCount = state =&gt; Object.values(state.items.byId) .reduce((total, item) =&gt; total + item.count, 0) Object.values 是 ES2017的语法 Ramda 的原则 自动柯理化 数据最后传入 使用 Ramda编写 SelectorsgetUserName1export const getUserName = state =&gt; R.path(['user', 'name'], state) 改为柯理化的版本: 1export const getUserName = state =&gt; R.path(['user', 'name'])(state) 就可以等待数据了 1export const getUserName = R.path(['user', 'name']) 这里的函数就看不到数据了, 这个技术被称为 point-free style 或者tacit programming. isLoggedIn我们想要的版本是获取用于的 ID, 然后判断是否为 true 1export const isLoggedIn = pathIsNotNullOrUndefined(['user', 'id']) Ramda的 isNil 方法123R.isNil(null) // trueR.isNil(undefined) // trueR.isNil(false) // false 现在可以改为: 1const isNotNil = val =&gt; !R.isNil(val) 在更进一步: 1const isNotNil = val =&gt; R.not(R.isNil(val)) 另一个方法: 12345const isNotNil = R.complement(R.isNil)isNotNil(true) // trueisNotNil(null) // falseisNotNil(undefined) // false 进一步重构的版本: 12345const pathIsNotNil = (path, state) =&gt; isNotNil(R.path(path, state))//⛔️柯理化的版本const pathIsNotNil = path =&gt; state =&gt; isNotNil(R.path(path, state)) 也就是从一个 state获取嵌套属性,并且判断是否为 true, 由于属性的路径是在 default 中已经配置好的, 所以我们可以使用柯理化提前配置获取的方法, 等待变化的 state 数据. 这就配置出了一个处理 state 的工厂. 为什么柯理化在函数式编程中很重要,这就是原因. 配置出的工厂是与数据独立的, 这就是上面提到的 tacit programming 无参数编程, 函数的配置和传入的参数是无关的, 顶多是对参数的类型做出约束. 在使用 R.compose 做重构 12const pathIsNotNil = path =&gt; state =&gt; R.compose(isNotNil, R.path)(path, state) 整个操作和path,state 有关, 通过 path从 state 获取属性, 然后判断是否为 true, 1234const pathIsNotNil = path =&gt; state =&gt; R.compose(isNotNil, R.path(path))(state)//👇👇柯理化const pathIsNotNil = path =&gt; R.compose(isNotNil, R.path(path)) 在 pathIsNotNil中实际的数据只有 state,path 是属于配置项, 也就是在程序中是不改变的. 123export const isLoggedIn = pathIsNotNil(['user', 'id'])//配置了从对象的路径 user.id 获取属性值,然后判断是否为 true getTotalItemCount//刚开始的方法123export const getTotalItemCount = state =&gt; Object.values(state.items.byId) .reduce((total, item) =&gt; total + item.count, 0) 面对复杂的问题, 使用函数式风格进行分解是比较好的选择.创建一个函数sumCounts,接收一个数组, 返回项目中count属性的总计. 12const sumCounts = items =&gt; items.reduce((total, item) =&gt; total + item.count, 0) 使用 map1const sumCounts = R.compose(R.sum, R.map(R.prop('count'))) R.map 对数组的每一项调用 R.prop(‘count’)函数, 获取的所有count 属性,放到一个新的数组中, 之后用 R.sum 对数组中的属性值做合计 Ramda 针对map 这个函数的使用,也有更简单的方法 1const sumCounts = R.compose(R.sum, R.pluck('count')) R.pluck 从数组中获取每一项的属性值 使用 Reduce 函数的替代方案1const sumCounts = R.reduce((total, item) =&gt; total + item.count, 0) 12const addCount=(total,item)=&gt;total+item.countconst sumCounts = R.reduce(addCount, 0) 使用 Ramda 的 R.add 方法 1const addCount = (total, item) =&gt; R.add(total, item.count) 从对象中获取属性 1234const addCount = (total, item) =&gt; R.add(total, prop('count', item))// 柯理化形式const addCount = (total, item) =&gt; R.add(total, prop('count')(item)) 上面的函数通用的模式是: 接收两个参数,传递给另一个函数, 第一个参数不懂, 对第二个参数运用一个函数进行处理,之后再执行第一个函数 Ramda 有一个函数可以帮我们完成这个任务, useWith,useWith函数接收两个参数, 第一个参数是单个的函数,和一个函数数组. 数组中的函数被称为变换函数-在对应位置的参数被第一个函数调用之前进行变换处理. 换句话说,数组的第一个函数对第一个参数进行处理, 第二个函数对第二个参数进行处理,以此类推.转换后的参数传递个第一个参数的函数. 在我们的实例中,第一个参数的函数 R.add, 1const addCount = R.useWith(R.add, [/* transformers */]) 需要对 R.add 的第二个参数进行处理, 从 count属性中获取值, 所以放在第二个函数的位置 1const addCount = R.useWith(R.add [/* 1st */, R.prop('count')]) 第一个参数怎么办? 这个参数对应的是 total 值, 不需要转换 , Ramda有一个函数可以原封不动的返回一个数值, R.identity. 1const addCount = R.useWith(R.add, [R.identity, R.prop('count')]) 现在的函数: 123const addCount = R.useWith(R.add, [R.identity, R.prop('count')])const sumCounts = R.reduce(addCount, 0) 现在可以获得更为通用的方式,获取任意的属性, 12345const addProp = propName =&gt; R.useWith(R.add, [R.identity, R.prop(propName)])const sumProps = propName =&gt; R.reduce(addProp(propName), 0)const sumCounts = sumProps('count') 参数的转换方式也可以抽象出来: 123456789const addTransformedItem = transformer =&gt; R.useWith(R.add, [R.identity, transformer])const sumTransformedItems = transformer =&gt; R.reduce(addTransformedItem(transformer), 0)const totalItemComments = R.compose(R.length, R.prop('comments'))const sumComments = sumTransformedItems(totalItemComments) 最终在 Ramda 的帮助下, 总的数据获取流是有更小的可以重用的函数组成的.. 结构如果有下面的数据 123456789const state = &#123; items: &#123; byId: &#123; 'item1': &#123; id: 'item1', count: 2 &#125;, 'item2': &#123; id: 'item2', count: 4 &#125;, 'item3': &#123; id: 'item3', count: 7 &#125; &#125; &#125;&#125; 12export const getTotalItemCount = R.compose(sumCounts, R.values, R.path(['items', 'byId'])) 最终得到的结果1234567891011121314mport R from 'ramda'// Helper functionsconst isNotNil = R.complement(R.isNil)const pathIsNotNil = path =&gt; R.compose(isNotNil, R.path(path))const addProp = propName =&gt; R.useWith(R.add, [R.identity, R.prop(propName)])const sumProps = propName =&gt; R.reduce(addProp(propName), 0)const sumCounts = sumProps('count')// Selector functionsexport const getUserName = R.path(['user', 'name'])export const isLoggedIn = pathIsNotNil(['user', 'id'])export const getTotalItemCount = R.compose(sumCounts, R.values, R.path(['items', 'byId'])) 函数式编程最好的解释应该是: 数据和要对数据进行操作的函数式分离开的. 基于此, 就可以发现, React的组件也可以看成一个函数, 接收应用的数据, 对数据进行处理,之后进行渲染.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"Ramda","slug":"Ramda","permalink":"https://React-Apollo.github.io/tags/Ramda/"},{"name":"FP","slug":"FP","permalink":"https://React-Apollo.github.io/tags/FP/"}]},{"title":"摘要| Functional Redux Reducers with Ramda","slug":"摘要| Functional Redux Reducers with Ramda","date":"2018-02-27T21:44:34.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/02/27/摘要| Functional Redux Reducers with Ramda/","link":"","permalink":"https://React-Apollo.github.io/2018/02/27/摘要| Functional Redux Reducers with Ramda/","excerpt":"","text":"原文地址 Example Redux Reducer———————–假设我们要在 React 组件中展示一组 短吻鳄(gators)的列表,数据从 GatorAPI获取, 具体的数据并不重要. 现在需要把 fetch 的数据添加到 redux 的 state 树中 这个 state 的结构是 ① 在 all 数组中包括 gatorIds,没有重复值(Ramda中如何实现唯一值?) ② 在 lookup 添加新的 gator对象的 hash ById 索引, 索引值是 id(如何实现索引) ③ 在获取数据成功以后, 改变 loading flag的状态, 以便于在渲染时,去掉 spinning组件 Redux reducer的模式Redux reducer 的模式其实是固定的:(prevState,action)=&gt;nextState根据传入的 action,对State 做出修改. 就这么简单, 修改是 Immutable的. 哪怕是一个数字加1, 也会形成新的 state, 这里很有必要使用 FB 的 Immutable.js. 如果是 prevState 和 nextState 之间有公共部分, 虽然是两个不同的对象,但是在底层Immutable.js 可以共享两个对象的共同部分.注意这并不是引用. 实例代码123456789101112131415const reverseMerge = flip(merge);export function fetchSuccess(state, &#123; payload: &#123; gators &#125; &#125;) &#123; const gatorIds = map(prop(\"id\"), gators); const gatorLookup = indexBy(prop(\"id\"), gators); return evolve( &#123; all: compose(uniq, concat(gatorIds)), byId: reverseMerge(gatorLookup), loading: always(false) &#125;, state ); &#125; 使用的 Ramda函数①always: Ramda 中一切都是函数, 如果想使用 int或者字符串,也有通过函数返回 always就是为了这个出发点, val=()=&gt;val, ②compose 函数: 看家函数, Ramda数据流思考的方向, 数据从右传入,经过一系列操作. 实例代码中的 用法可以翻译为 uniq(concat(gatorIds,all)),把 prevState 的 all 属性取出,然后和远程获取的数据拼接, 使用 uniq 函数去重 ③evolve: 接收两个参数, 一组转换函数, 一个对象, 函数对对象的属性递归的进行处理 ④ flip 函数: 翻转两个参数的位置, merge(a,b), 在 merge()中, 如果存在两个属性名相同, b对象的属性值会覆盖 a 的属性值, 在 Redux中, 操作是merge(state,payload.data) 我们希望在出现同名属性的时候, payload 的属性会覆盖 state 的属性. 但是在evolve函数中, state是作为最后一个参数传递, 所以这里借助flip函数交换一下参数的位置. ⑤ indexBy 函数: 提取一个对象的键值作为索引 123[&#123; id: 1, title: \"one\" &#125;, &#123; id: 2, title: \"two\" &#125;]&#123; 1: &#123; id: 1, title: \"one\" &#125;, 2: &#123; id: 2, title: \"two\" &#125; &#125; ⑥ map 函数 , map(elem=&gt;console.log(elm),elements) ⑦ merge 函数 ⑧ prop 函数: 返回对象的属性值, 123prop(\"a\",&#123;a:\"alligator\",b:\"bayou\",c:\"cayman\"&#125;)//=&gt; \"alligator\" ⑨ uniq函数, 接收一个列表,返回一个新列表, 重复值被去除 再看看代码123456789101112131415const reverseMerge = flip(merge);export function fetchSuccess(state, &#123; payload: &#123; gators &#125; &#125;) &#123; const gatorIds = map(prop(\"id\"), gators); const gatorLookup = indexBy(prop(\"id\"), gators); return evolve( &#123; all: compose(uniq, concat(gatorIds)), byId: reverseMerge(gatorLookup), loading: always(false) &#125;, state ); &#125; 定义函数 reverseMerge,交换 merge 函数的参数 map, gators列表, 应用 prop(“id”),因此获取到 ids列表 indexBy函数返回的列表可以通过 id属性值作为索引来访问 evolve 函数, 接收三个函数和 state, 三个函数分别对 state 的不同属性做出修改 state 中的all列表传递给 compose 函数和从 API获取的 gatorIds 合并, 去重, 然后返回 state中的 byId 对象传递给 reverseMerge 函数,和 gatorLookup 合并, 重复值会被 gatorLookup 的属性值覆盖到 Loading的值被修改为 false. 结论实际使用时还有很多的函数可以使用, 在 Redux中有两个地方,ramda可以大有所为,一个就是这里, 还有一个地方就是container 组件包装时对state的筛选 , mapStateToProps,","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"Ramda","slug":"Ramda","permalink":"https://React-Apollo.github.io/tags/Ramda/"},{"name":"FP","slug":"FP","permalink":"https://React-Apollo.github.io/tags/FP/"}]},{"title":"摘要| Recompose recipes","slug":"摘要| Recompose recipes","date":"2018-02-26T14:57:50.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/02/26/摘要| Recompose recipes/","link":"","permalink":"https://React-Apollo.github.io/2018/02/26/摘要| Recompose recipes/","excerpt":"","text":"","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"摘要| Recompose 文档","slug":"摘要| Recompose","date":"2018-02-26T13:30:14.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/02/26/摘要| Recompose/","link":"","permalink":"https://React-Apollo.github.io/2018/02/26/摘要| Recompose/","excerpt":"","text":"Recompose API在文档中, HOC 指的是一个函数接收一个 React 组件,返回另一个新的 React 组件 1const EnhancedComponent=hoc(BaseComponent) 有时是可以组合的 123const composedHoc=compose(hoc1,hoc2,hoc3)//等同于const composedHoc=BaseComponent=&gt;hoc1(hoc2(hoc3(BaseComponent))) 绝大多数的 Recompose 助手函数都是返回 hoc的函数 Higher-order componentsmapProps123mapProps( propsMapper:(ownerProps:Object)=&gt;Object, ):HigherOrderComponent 接收一个函数,映射拥有者的 props成为新的 props 集合, 并传递给 baseComponent.mapProps()和其他的函数式工具可以很好的一起工作, 例如 Recomopose 没有omitProps()函数,但是可以很容易的使用 lodash 的函数omit() 1234const omitProps = keys =&gt; mapProps(props =&gt; omit(keys, props))// 因为 lodash-fp 是支持柯理化的,所以也可以写为const omitProps = compose(mapProps, omit) withProps123withProps( createProps: (ownerProps: Object) =&gt; Object | Object): HigherOrderComponent 新创建的props 和 owner props 合并 withPropsOnChange()1234withPropsOnChange( shouldMapOrKeys: Array&lt;string&gt; | (props: Object, nextProps: Object) =&gt; boolean, createProps: (ownerProps: Object) =&gt; Object): HigherOrderComponent 只有在 shouldMapKeys 发生变化时才可以创建新的 props. 确保 createProps 内的计算只有在必要的情况下才进行. withHandlers()12345678withHandlers( handlerCreators: &#123; [handlerName: string]: (props: Object) =&gt; Function &#125; | handlerCreatorsFactory: (initialProps) =&gt; &#123; [handlerName: string]: (props: Object) =&gt; Function &#125;): HigherOrderComponent 接收一组 handler creator 或者是 工厂函数. 这些函数都是高阶函数, 接收一组 props,返回操作函数 这么做,就是让 handler 通过闭包访问当前的 props,但是又不用改变函数的签名 传递给组件的handlers都是 immutable 属性, 在渲染器中会一直保持不变.这么做避免了在函数式组件中创建函数的一个缺陷, 就是原先的函数式组件中,每次渲染都会创建新的 handler,打断了使用shouldComponentUpdate()函数通过判读 props 变化的优化措施. 所以在创建 handler 时最好使用 withHandlers() ,mapProps和withProps每次会创建新的 handler 实例: 1234567891011121314151617181920const enhance = compose( withState('value', 'updateValue', ''), withHandlers(&#123; onChange: props =&gt; event =&gt; &#123; props.updateValue(event.target.value) &#125;, onSubmit: props =&gt; event =&gt; &#123; event.preventDefault() submitForm(props.value) &#125; &#125;))const Form = enhance((&#123; value, onChange, onSubmit &#125;) =&gt; &lt;form onSubmit=&#123;onSubmit&#125;&gt; &lt;label&gt;Value &lt;input type=\"text\" value=&#123;value&#125; onChange=&#123;onChange&#125; /&gt; &lt;/label&gt; &lt;/form&gt;) defaultProps()123defaultProps( props: Object): HigherOrderComponent default 的 props 会和 owner props合并,但是owner props 的优先级更高,有相同属性的,不会被替换 renameProps()12345renameProp( oldName: string, newName: string): HigherOrderComponent Rename 单个属性 renameProps() :更改多个属性名withState()12345withState( stateName: string, stateUpdaterName: string, initialState: any | (props: Object) =&gt; any): HigherOrderComponent 传递两个额外的 props 到 base component: state value和一个 更新 state value 的函数, state updater 的签名如下: 123stateUpdater&lt;T&gt;((prevValue: T) =&gt; T, ?callback: Function): voidstateUpdater(newValue: any, ?callback: Function): void 第一个形式接收之前的state,映射为新的 state value. withState()和withHadlers()一起创建特定的 updater 函数. 例如 123456789const addCounting = compose( withState('counter', 'setCounter', 0), withHandlers(&#123; increment: (&#123; setCounter &#125;) =&gt; () =&gt; setCounter(n =&gt; n + 1), decrement: (&#123; setCounter &#125;) =&gt; () =&gt; setCounter(n =&gt; n - 1), reset: (&#123; setCounter &#125;) =&gt; () =&gt; setCounter(0) &#125;)) 第二种形式接收单个值, 被作为新的 state 两种形式都接受可选的参数,这个参数是一个回调函数, 一旦setState()完成,组件重新渲染,回调函数会执行. 初始值是必须的. 要么是 state 值, 或者是从初始 props 返回的初始 State. withStateHandlers()123456withStateHandlers( initialState: Object | (props: Object) =&gt; any, stateUpdaters: &#123; [key: string]: (state:Object, props:Object) =&gt; (...payload: any[]) =&gt; Object &#125;) 传递 state对象属性和 immutable 版本的 updater 函数到 base component 每个 state updater 函数接收state,props和 payload必须返回新的 state 或者 undefined. 新的 state 和之前的 state 进行浅层比较, 如果返回 undefined,组件就不会重新渲染. 实例: 1234567891011121314151617181920212223const Counter = withStateHandlers( (&#123; initialCounter = 0 &#125;) =&gt; (&#123; counter: initialCounter, &#125;), &#123; incrementOn: (&#123; counter &#125;) =&gt; (value) =&gt; (&#123; counter: counter + value, &#125;), decrementOn: (&#123; counter &#125;) =&gt; (value) =&gt; (&#123; counter: counter - value, &#125;), resetCounter: (_, &#123; initialCounter = 0 &#125;) =&gt; () =&gt; (&#123; counter: initialCounter, &#125;), &#125; )( (&#123; counter, incrementOn, decrementOn, resetCounter &#125;) =&gt; &lt;div&gt; &lt;Button onClick=&#123;() =&gt; incrementOn(2)&#125;&gt;Inc&lt;/Button&gt; &lt;Button onClick=&#123;() =&gt; decrementOn(3)&#125;&gt;Dec&lt;/Button&gt; &lt;Button onClick=&#123;resetCounter&#125;&gt;Reset&lt;/Button&gt; &lt;/div&gt; ) withReducer()1234567withReducer&lt;S, A&gt;( stateName: string, dispatchName: string, reducer: (state: S, action: A) =&gt; S, initialState: S | (ownerProps: Object) =&gt; S): HigherOrderComponent 和withState()类似,但是使用的是 reducer 函数. reducer 函数接收一个 state,一个 action, 返回一个新的 state. 之后新的 state 被应用 branch()12345branch( test: (props: Object) =&gt; boolean, left: HigherOrderComponent, right: ?HigherOrderComponent): HigherOrderComponent 接收一个检测函数, 和两个高阶组件, test 函数接受 owner 的 props.如果返回的是 true, left高阶组件被应用到 basecomponent, 反之,right 高阶组件被应用的 base component . 如果没有提供right 高阶组件, 返回包装的组件 renderComponent()123renderComponent( Component: ReactClass | ReactFunctionalComponent | string): HigherOrderComponent 接受一个组件, 返回高阶组件版本. 和其他的期待高阶组件的助手函数联合使用,例如branch(): 123456789101112131415161718192021// `isLoading()` is a function that returns whether or not the component// is in a loading stateconst spinnerWhileLoading = isLoading =&gt; branch( isLoading, renderComponent(Spinner) // `Spinner` is a React component )// Now use the `spinnerWhileLoading()` helper to add a loading spinner to any// base componentconst enhance = spinnerWhileLoading( props =&gt; !(props.title &amp;&amp; props.author &amp;&amp; props.content))const Post = enhance((&#123; title, author, content &#125;) =&gt; &lt;article&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;h2&gt;By &#123;author.name&#125;&lt;/h2&gt; &lt;div&gt;&#123;content&#125;&lt;/div&gt; &lt;/article&gt;) renderNothing()1renderNothing: HigherOrderComponent 总是渲染null的高阶组件 也是和其他期待高阶组件的助手函数一起工作 12345678910111213141516171819// `hasNoData()` is a function that returns true if the component has// no dataconst hideIfNoData = hasNoData =&gt; branch( hasNoData, renderNothing )// Now use the `hideIfNoData()` helper to hide any base componentconst enhance = hideIfNoData( props =&gt; !(props.title &amp;&amp; props.author &amp;&amp; props.content))const Post = enhance((&#123; title, author, content &#125;) =&gt; &lt;article&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;h2&gt;By &#123;author.name&#125;&lt;/h2&gt; &lt;div&gt;&#123;content&#125;&lt;/div&gt; &lt;/article&gt;) shouldUpdate()123shouldUpdate( test: (props: Object, nextProps: Object) =&gt; boolean): HigherOrderComponent 高阶组件版本的 shouldComponentUpdate(),test 函数接受当前的props和下一个 props pure()1pure: HigherOrderComponent 阻止组件更新,除非是 props 发生变化. 使用shallowEquall()检测变化. onlyUdateForKeys()1234onlyUpdateForKeys( propKeys: Array&lt;string&gt;): HigherOrderComponent 阻止组件更新,只有在对应的 props中给定key的部分发生变化时才能执行更新. 使用的是shallowEqual()检测变化 这个方法对于优化是最好的, 因为只关心特定的 props 部分. 实例: 123456789101112131415/** * If the owner passes unnecessary props (say, an array of comments), it will * not lead to wasted render cycles. * * Goes well with destructuring because it's clear which props the component * actually cares about. */const enhance = onlyUpdateForKeys(['title', 'content', 'author'])const Post = enhance((&#123; title, content, author &#125;) =&gt; &lt;article&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;h2&gt;By &#123;author.name&#125;&lt;/h2&gt; &lt;div&gt;&#123;content&#125;&lt;/div&gt; &lt;/article&gt;) onlyUpdateForPropTypes()工作方式和onlyUpdateForKeys()类似,只是 props keys 是从 base component 的propTypes中获取的,和setPropTypes()一起非常有用. 如果base component 没有任何的propTypes,组件不会执行任何更新操作. 这可能不是想要的结果,所以会在终端打印警告信息 123456789101112131415161718import PropTypes from 'prop-types'; // You need to import prop-types. See https://facebook.github.io/react/docs/typechecking-with-proptypes.htmlconst enhance = compose( onlyUpdateForPropTypes, setPropTypes(&#123; title: PropTypes.string.isRequired, content: PropTypes.string.isRequired, author: PropTypes.object.isRequired &#125;))const Post = enhance((&#123; title, content, author &#125;) =&gt; &lt;article&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;h2&gt;By &#123;author.name&#125;&lt;/h2&gt; &lt;div&gt;&#123;content&#125;&lt;/div&gt; &lt;/article&gt;) withContext()1234withContext( childContextTypes: Object, getChildContext: (props: Object) =&gt; Object): HigherOrderComponent 为子组件提供上下文. getContext()123getContext( contextTypes: Object): HigherOrderComponent 从上下文中获取值并以 props 的形式传递. lifycycle()123lifecycle( spec: Object,): HigherOrderComponent 这是高阶组件版本的React.Component(),支持除了render()之外的所有Component API, render()方式是默认实现的. 任何lifecycle()方法引起的 state改变, 会传递给包装组件 实例: 1234567891011const PostsList = (&#123; posts &#125;) =&gt; ( &lt;ul&gt;&#123;posts.map(p =&gt; &lt;li&gt;&#123;p.title&#125;&lt;/li&gt;)&#125;&lt;/ul&gt;)const PostsListWithData = lifecycle(&#123; componentDidMount() &#123; fetchPosts().then(posts =&gt; &#123; this.setState(&#123; posts &#125;); &#125;) &#125;&#125;)(PostsList); toClass()1toClass:HigherOrderComponent 接收一个函数组件,包装成一个类. 如果是已经是一个类,就直接返回了 Sattic property helpers这些方法不仅仅是要返回新的组件, 还改变了组建的属性 setStatic()1234setStatic( key: string, value: any): HigherOrderComponent 为 base component 赋予propTypes 属性 setDisplayName123setDisplayName( displayName: string): HigherOrderComponent 赋予displayName属性 UtilitiesRecompose 包含一些额外的助手, 不是高阶组件,但是仍然非常有用 compose()1compose(...functions: Array&lt;Function&gt;): Function 把多个高阶组件组合成一个. 这个方法和 Redux 中的 compose(), lodash-fp的 flowRight(), Ramda 的compose()工作原理是类似的. getDisplayName()123getDisplayName( component: ReactClass | ReactFunctionalComponent): string 返回 React 组件的显示名 wrapDisplayName()1234wrapDisplayName( component: ReactClass | ReactFunctionalComponent, wrapperName: string): string 返回显示名包装的React 组件. shallowEqual()1shallowEqual(a:Object,b:Object):boolean isClassComponent()1isClassComponent(value:any):boolean createSink()1createSink(callback:(props:Object)=&gt;void):ReactClass 什么也渲染,仅仅调用回调函数 componentFromProp()1componentFromProp(propName: string): ReactFunctionalComponent 创建一个组件以 props的形式接收另一个组件, 并使用剩余的 props 渲染这个组件 123456const enhance = defaultProps(&#123; component: 'button' &#125;)const Button = enhance(componentFromProp('component'))&lt;Button foo=\"bar\" /&gt; // renders &lt;button foo=\"bar\" /&gt;&lt;Button component=\"a\" foo=\"bar\" /&gt; // renders &lt;a foo=\"bar\" /&gt;&lt;Button component=&#123;Link&#125; foo=\"bar\" /&gt; // renders &lt;Link foo=\"bar\" /&gt; nest()123nest( ...Components: Array&lt;ReactClass | ReactFunctionalComponent | string&gt;): ReactClass 返回嵌套的组件 123456789101112// Given components A, B, and Cconst ABC = nest(A, B, C)&lt;ABC pass=\"through\"&gt;Child&lt;/ABC&gt;// Effectively the same as&lt;A pass=\"through\"&gt; &lt;B pass=\"through\"&gt; &lt;C pass=\"through\"&gt; Child &lt;/C&gt; &lt;/B&gt;&lt;/A&gt; hoistStatics()1hoistStatics(hoc: HigherOrderComponent): HigherOrderComponent","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"FP","slug":"FP","permalink":"https://React-Apollo.github.io/tags/FP/"},{"name":"HOC","slug":"HOC","permalink":"https://React-Apollo.github.io/tags/HOC/"}]},{"title":"Prisma|GraphQL Server Basics:Schema","slug":"Prisma|GraphQL Server Basics:Schema","date":"2018-02-25T10:28:43.000Z","updated":"2019-04-28T05:52:57.892Z","comments":true,"path":"2018/02/25/Prisma|GraphQL Server Basics:Schema/","link":"","permalink":"https://React-Apollo.github.io/2018/02/25/Prisma|GraphQL Server Basics:Schema/","excerpt":"","text":"GraphQL Server Basics: The Schema 原文在这里 构建 GraphQL 服务器第一步是设计 schema. 这里讲解 schema 的组成 GraphQL schema 定义了服务器的 API定义语言: Schema Definition Language(SDL) 示例: 1234type User&#123; id:ID! name:String!&#125; 只有User,并不能给客户端提供任何的功能. 只是简单的定义了用户的模型. 为了添加功能, 需要在 root type 中添加字段:Query,Mutation,Subscription. 这些字段定义了 GraphQL API 的入口 示例代码: 123456query &#123; user(id:\"abc\")&#123; id name &#125;&#125; 对于这个查询,要想获取结果, 必须要定义Query类型 123type Query&#123; user(id:ID!):User&#125; 因此shcema 的 root type定义了 server 可以接受的 query,mutation的结构 GraphQLSchema对象是 GraphQL Server 的核心主要包括两个主要的组件: ①schema 定义 ②实际实现的 resolvers 函数 针对上面的例子, GraphQLSchema对象是: 12345678910111213141516171819202122//const UserType = new GraphQLObjectType(&#123; name: 'User', fields: &#123; id: &#123; type: GraphQLID &#125;, name: &#123; type: GraphQLString &#125; &#125;&#125;)const schema = new GraphQLSchema(&#123; query: new GraphQLObjectType(&#123; name: 'Query', fields: &#123; user: &#123; type: UserType, args: &#123; id: &#123; type: GraphQLID &#125; &#125; &#125; &#125; &#125;)&#125;) SDL版的 schema 被翻译为 JS的形式.这里还没有 resolvers,所以还实现不了具体的功能 Resolvers负责具体实现 APIGraphQL Server 中的结构和行为在 GraphQL Server 中结构和行为是明显分开的, 结构就是 shcema,行为实现的关键组件就是resolver函数. 下面这一点是非常重要的一句总结: 每个GraphQL schema的字段都有 resolver 支撑 在基础结构中, GraphQL Server 为每个字段都提供 resolver 函数.每个resolver 都知道怎么获取对应字段的数据. 因为GraphQL 查询的精髓:仅仅返回字段的集合(collection) GraphQL Server 要做的事情**只是为查询中的每个字段调用 resolver 函数. 简单说: 只是调用远程的函数**. resolver 函数的剖析针对上面的user 字段: 123456789101112131415161718192021const UserType = new GraphQLObjectType(&#123; name: 'User', fields: &#123; id: &#123; type: GraphQLID &#125;, name: &#123; type: GraphQLString &#125; &#125;&#125;)const schema = new GraphQLSchema(&#123; query: new GraphQLObjectType(&#123; name: 'Query', fields: &#123; user: &#123; type: UserType, args: &#123; id: &#123; type: GraphQLID &#125; &#125; &#125; &#125; &#125;)&#125;) 假设有一个函数fetchUserById,被实际调用,返回一个 js 对象(有id,name字段), resolver 函数使得 schema 可以执行实际的功能了. 下面看看 resolver 函数中的四个参数: root: resolver 中的root 是之前调用的结果 args: 包含了查询的参数,这个例子中是id context:在 resolver 函数链中传递的对象, 每个 resolver 都可以访问(用于 resolver 之间通讯和共享信息) info: 查询或者 mutation 的 AST结构图. 完整的查询 resolver 返回的字段: 这就是实际的操作, 每个字段都是单独返回的1234567891011121314151617const UserType = new GraphQLObjectType(&#123; name: 'User', fields: &#123; id: &#123; type: GraphQLID, resolve: (root, args, context, info) =&gt; &#123; return root.id &#125; &#125;, name: &#123; type: GraphQLString, resolve: (root, args, context, info) =&gt; &#123; return root.name &#125; &#125; &#125;&#125;) 执行查询 具体的步骤: ① query到达服务器 ② 服务器调用 resolver 用于查询user的字段 ③ 为type User的字段 id调用 resolver函数, root 为这个 resolver 提供参数,就是之前调用的返回值, root.id. ④ 和③类似,只是返回root.name ,③和④是并行操作 ⑤操作结束, 最终的结果包装在data 字段中 12345678&#123; \"data\": &#123; \"user\": &#123; \"id\": \"abc\", \"name\": \"Sarah\" &#125; &#125;&#125; 这些琐碎的流程实际GraphQL.js已经为我们完成了 优化请求: DataLoader 模式在客户端发送嵌套查询时, 很容易出现性能问题 例如: 12345678910111213query &#123; user(id: \"abc\") &#123; name article(title: \"GraphQL is great\") &#123; comments &#123; text writtenBy &#123; name &#125; &#125; &#125; &#125;&#125; 如果一篇文章有五条评论,我们要执行五次writtenBy resolver.DataLoader可以让你避免这个问题,简单说就是函数调用是批量进行的 GraphQL.js VS. graphql-toolsGraphQL.js 为 graphql-tools提供了基础GraphQL.js 是底层干活的, graphql-tools 提供了一个易于使用的应用层. GraphQL.js 的组成部分 parse和buildASTSchema:给定一个 schema 的字符串,这两个函数会创建一个GraphQLSchema的实例:const schema=buildASTSchema(parse(sdlString)) validate: validate确保 query符合 API的定义 execute: 给定一个schema 实例和一个查询, execute负责调用字段的 resolver函数,根据 GraphQL 规范创建响应. printSchema: 接收 schema实例用 SDL 形式返回它的定义 GraphQL 中最重要的函数是graphql,接收GraphQLSchema实例和查询-然后调用验证和执行 1graphql(schema, query).then(result =&gt; console.log(result)) 可以认为graphql的功能就是作为GraphQL engine. graphql-tools 桥接接口和实现在GraphQL.js的基础上, graphql-tools提供了一个重要的功能addResolverFunctionToSchema. 基于 SDL 创建 schema的问题就解决了.准确的讲应该是makeEcecutableSchema: 1234567891011121314151617181920212223const &#123; makeExecutableSchema &#125; = require('graphql-tools')const typeDefs = `type Query &#123; user(id: ID!): User&#125;type User &#123; id: ID! name: String&#125;`const resolvers = &#123; Query: &#123; user: (root, args, context, info) =&gt; &#123; return fetchUserById(args.id) &#125; &#125;,&#125;const schema = makeExecutableSchema(&#123; typeDefs, resolvers&#125;) 所以使用graphql-tools的最大好处是连接你的scehma 和 resolvers 什么时候不要使用 graphql-tools?graphql-tools 只是在GraphQL.js的基础是提供一个便于使用的抽象. 所以有的时候直接使用 graphql-tools 可能不太好 这是以牺牲灵活性为代价的. 如果你的服务器需要定制很多需求, 例如动态构建或者修改 scehma. 可能要返回去使用GraphQL.js graphene.js 快速浏览graphene.js是从 Python表兄那里获取的灵感. 底层仍然是 GraphQL.js, 但是不能声明式定义 schema. graphenes.js使用了最新的 js 语法, 查询和 mutation可以以 js 的类形式表现.丰富了 graphql的 Ecosystem 结论 GraqhQL.js 是实现功能的引擎.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"Prisma|DataModel_airbnb","slug":"Prisma|DataModel_airbnb ","date":"2018-02-25T08:59:29.000Z","updated":"2019-04-28T05:52:57.892Z","comments":true,"path":"2018/02/25/Prisma|DataModel_airbnb /","link":"","permalink":"https://React-Apollo.github.io/2018/02/25/Prisma|DataModel_airbnb /","excerpt":"","text":"primsa文档中的示例代码片段","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"GraphQL query 实现的细节","slug":"GraphQL-query 的实现细节","date":"2018-02-24T23:57:50.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/02/24/GraphQL-query 的实现细节/","link":"","permalink":"https://React-Apollo.github.io/2018/02/24/GraphQL-query 的实现细节/","excerpt":"","text":"graphql在执行操作的时候,是如何体现灵活性的? ①查询字符串的组成 ②解析 ③再解析 ④返回结果 原来这里每个字段实际是独立的,每个 resolver 实际是单独返回每个字段 注意③和④的结果和返回的结果, 每个字段是单独返回的.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"SVG|Doughnut","slug":"SVG-doughnut","date":"2018-02-24T10:15:32.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2018/02/24/SVG-doughnut/","link":"","permalink":"https://React-Apollo.github.io/2018/02/24/SVG-doughnut/","excerpt":"","text":"See the Pen CSS only interactive donut chart by phpsmarter (@phpsmarter) on CodePen.","categories":[{"name":"UI","slug":"UI","permalink":"https://React-Apollo.github.io/categories/UI/"}],"tags":[{"name":"UI","slug":"UI","permalink":"https://React-Apollo.github.io/tags/UI/"},{"name":"SVG","slug":"SVG","permalink":"https://React-Apollo.github.io/tags/SVG/"}]},{"title":"聊天软件的 Prisma_DataModel","slug":"聊天软件的DataModel","date":"2018-02-23T22:08:10.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/02/23/聊天软件的DataModel/","link":"","permalink":"https://React-Apollo.github.io/2018/02/23/聊天软件的DataModel/","excerpt":"","text":"基于 Chatty clone 数据的关联模型 一个用户可以属于多个小组, 有多个朋友, 有多条消息 一个小组可以有多个用户,可以有多条消息 一条消息来自于一个用户, 发送给某个或某几个组 多播 系统消息可以发送给所有组.广播 流程具体的模型流程来自 Node in Action 用户注册流程 加组,如果组不存在就创建新的 发送消息, 获取用户名,来自组名, 发送到组, 消息内容 1234567891011121314151617181920212223242526272829type User &#123; id: ID! @isUnique email: String @isUnique username: String!@isUnique password: String! userOfGroups: [Group!]@relation(name: \"userOnGroup\") #一个用户可以属于一个小组 userOfFriends: [User] #一个用户可以有多个朋友 userOfMessages: [Message]@relation(name: \"userOfMessage\") #一个用户有多条消息 createdAt: Date! updatedAt:Date!&#125;type Group &#123; id: ID!@isUnique nameOfGroup: String usersOfGroup: [User]@relation(name: \"userOnGroup\")# 一个小组有多个用户 messagesOfGroup: [Message]@relation(name: \" messageOfGroup\") #一个小组可以有多条消息 createdAt: Date! updatedAt:Date!&#125;type Message &#123; id: Int! toGroup: [Group]@relation(name:\"messageOfGroup\") #一条消息可以发送多个组 fromUser: User!@relation(name:\"userOfMessage\")#一条消息有一个发送用户 text: String! createdAt: Date! updatedAt:Date!&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"Apollo-Server 实例代码","slug":"Apollo-Server 代码","date":"2018-02-23T19:31:50.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/02/23/Apollo-Server 代码/","link":"","permalink":"https://React-Apollo.github.io/2018/02/23/Apollo-Server 代码/","excerpt":"","text":"和之前的网站抓取时实际一样的, Prisma内部使用的是Apollo-server 的服务, 在这个实例中,使用的是 mongodb-mongoose的接口, 在 resolvers 中实际不限制任何获取数据的方法, graphql 的核心只是按照 schema 来组织数据.接下来再看看直接在 resolvers 中返回另一个 graphql 数据的实例","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphql","slug":"Graphql","permalink":"https://React-Apollo.github.io/tags/Graphql/"},{"name":"prisma","slug":"prisma","permalink":"https://React-Apollo.github.io/tags/prisma/"}]},{"title":"EcoSystem|如何用 GraphQL包装 REST API","slug":"EcoStystem|如何用 GraphQL包装 REST API","date":"2018-02-23T11:54:55.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/02/23/EcoStystem|如何用 GraphQL包装 REST API/","link":"","permalink":"https://React-Apollo.github.io/2018/02/23/EcoStystem|如何用 GraphQL包装 REST API/","excerpt":"","text":"数组和对象的处理是常规编程中处理的主要内容, 可说是数据的表现形式,但是原始数据可能达不到我们的要求,所以有很多的处理方法. 我想在 GraphQL的模式下,在 resolver 中处理 REST API,或者其他的 graphQL server 的数据,出发点是类似的.数据的本质并没有改变.GrahQL 的核心是提供了: 单一的入口 严格的类型约束 灵活的查询构成 所以如果我们要使用 graphQL 包装 REST API,从 REST API返回的数据必须要遵循 GraphQL 的核心概念. 保证严格约束下的灵活性. 核心概念就如此. Analyze the data model of the REST API Derive the GraphQL schema for the API based on the data model Implement resolver functions for the schema resolverresolver 函数只是简单的 express 服务器, 可以在其中调用任何的接口,根据 schema 返回数据. 复杂的操作都要在 resolver中实现.Prisma的内核其实就是一个 Node.js Express server. 对于简单的schema, 自动生成了很多的 CURD方法,现阶段从 mysql 数据库获取数据,然后按照 schema的要求返回 json 数据. 这个 server, 就是 graphql-yoga. 简单和容易体现在, resolvers 是系统自动生成的,还是我们来编写.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"EcoSystem|Graphql-binding","slug":"EcoSystem|Graphql-binding","date":"2018-02-23T08:30:29.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/02/23/EcoSystem|Graphql-binding/","link":"","permalink":"https://React-Apollo.github.io/2018/02/23/EcoSystem|Graphql-binding/","excerpt":"","text":"🔗 graphql-binding 可以在 graphql server 中嵌入grahql API核心概念是通过为 GraphQL API 创建一个对象,表现出 API 的功能. 这个对象暴露的方法和GraphQL API schema 中定义的查询方法是镜像关系. Install1yarn add graphql-binding APIconstructor1constructor(options: BindingOptions): Binding Key Required Type Default Note schema Yes GraphQLSchema - The executable GraphQL schema for binding fragmentReplacements No FragmentReplacements {} A list of GraphQL fragment definitions, specifying fields that are required for the resolver to function correctly before No () =&gt; void (() =&gt; undefined) A function that will be executed before a query/mutation is sent to the GraphQL API handler No any null The handler object from JS Proxy subscriptionHandler No any null … query&amp;mutation12binding.query.&lt;rootField&gt;: QueryMap&lt;any&gt; // where &lt;rootField&gt; is the name of a field on the Query type in the mapped GraphQL schemabinding.mutation.&lt;rootField&gt;: QueryMap&lt;any&gt; // where &lt;rootField&gt; is the name of a field on the Mutation type in the mapped GraphQL schema binding对象暴露出两个接口 query,mutate可以用于执行操作.分别接收三个参数 实例假设有下面的 schema 1234567type Query &#123; user(id: ID!): User&#125;type Mutation &#123; createUser(): User!&#125; 12binding.query.user(&#123; id: 'abc' &#125;)binding.mutation.createUser() 1234567findUser(parent, args, context, info) &#123; return binding.user(&#123; id: args.id &#125;, context, info)&#125;newUser(parent, args, context, info) &#123; return binding.createUser(&#123;&#125;, context, info)&#125; subscription123binding.subscription.&lt;rootField&gt;(...): AsyncIterator&lt;any&gt; | Promise&lt;AsyncIterator&lt;any&gt;&gt; // where &lt;rootField&gt; is the name of a field //on the Subscription type in the mapped GraphQL schema 简单实例1234567891011121314151617181920212223242526272829303132333435const &#123; makeExecutableSchema &#125; = require('graphql-tools')const &#123; Binding &#125; = require('graphql-binding')const users = [ &#123; name: 'Alice', &#125;, &#123; name: 'Bob', &#125;,]const typeDefs = ` type Query &#123; findUser(name: String!): User &#125; type User &#123; name: String! &#125;`const resolvers = &#123; Query: &#123; findUser: (parent, &#123; name &#125;) =&gt; users.find(u =&gt; u.name === name), &#125;,&#125;const schema = makeExecutableSchema(&#123; typeDefs, resolvers &#125;)const findUserBinding = new Binding(&#123; schema,&#125;)findUserBinding.findUser(&#123; name: 'Bob' &#125;) .then(result =&gt; console.log(result)) 与 Prisma 的联系graphcool-binding(prisma) 是这个版本的实现方案 123456789101112131415161718192021// Instantiate `Prisma` based on concrete serviceconst prisma = new Prisma(&#123; typeDefs: 'schemas/database.graphql', endpoint: 'https://us1.prisma.sh/demo/my-service/dev' secret: 'my-super-secret-secret'&#125;)// Retrieve `name` of a specific userprisma.query.user(&#123; where &#123; id: 'abc' &#125; &#125;, '&#123; name &#125;')// Retrieve `id` and `name` of all usersprisma.query.users(null, '&#123; id name &#125;')// Create new user called `Sarah` and retrieve the `id`prisma.mutation.createUser(&#123; data: &#123; name: 'Sarah' &#125; &#125;, '&#123; id &#125;')// Update name of a specific user and retrieve the `id`prisma.mutation.updateUser(&#123; where: &#123; id: 'abc' &#125;, data: &#123; name: 'Sarah' &#125; &#125;, '&#123; id &#125;')// Delete a specific user and retrieve the `name`prisma.mutation.deleteUser(&#123; where: &#123; id: 'abc' &#125; &#125;, '&#123; id &#125;') 内部机制 prisma 的函数调用最终翻译为 graphql-binding 的方式 123456prisma.exists.Post(&#123; id: 'abc', author: &#123; name: 'Sarah' &#125;&#125;)","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"F8App_DataModel_Prisma_version","slug":"F8app-2016-dataModel-Prisma-version","date":"2018-02-22T21:52:32.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/02/22/F8app-2016-dataModel-Prisma-version/","link":"","permalink":"https://React-Apollo.github.io/2018/02/22/F8app-2016-dataModel-Prisma-version/","excerpt":"","text":"F8App GraphQL 服务器 Prisma版本的Datamodel重构版添加了关联的类型, Tag类型, 关联条件实际只有演讲↔️演讲者, 演讲↔️地图,演讲↔️标签的关系 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879type Agenda &#123; id: ID! @unique startTime:String endTime:String speakers:[Speaker!]! @relation(name:\"AgendaBySpeaker\") #一个 agenda可以有多个发言者 tags:[Tag!]! # 一个 Agenda可以有多个 tag, 不会发生歧义所以不用@ relation关联条件 allDay:Boolean@default(value:\"false\") day:Int! hasDetails:Boolean@default(value:\"true\") onMySchedule:Boolean@default(value:\"false\") sessionDescription:String sessionLocation:Map!@relation(name:\"AgendaOfMap\") #每个 agenda有一个地理位置 sessionSlug: String sessionTitle:String! createdAt: DateTime! updatedAt: DateTime!&#125;type Speaker &#123; id: ID! @unique speakerPic: String speakerName: String! speakerTitle:String! createdAt: DateTime! updatedAt: DateTime! agendas:[Agenda!]!@relation(name:\"AgendaBySpeaker\") #一个发言者可以有多个 agenda&#125;type Map &#123; id:ID!@unique x1:String x2:String x3:String name:String createdAt: DateTime! updatedAt: DateTime! mapOfAgendas:[Agenda!]!@relation(name:\"AgendaOfMap\") # 一个地图可以有多个 agenda&#125;type Faq &#123; id:ID!@unique question:String anwser:String createdAt: DateTime! updatedAt: DateTime!&#125;type Notification &#123; id:ID!@unique text:String! createdAt: DateTime! updatedAt: DateTime!&#125;type Page &#123; id:ID!@unique alias: String title:String createdAt: DateTime! updatedAt: DateTime!&#125;type Todo &#123; id:ID!@unique createdAt: DateTime! updatedAt: DateTime! text: String isCompleted:Boolean@default(value:\"false\")&#125;type Tag &#123;id:ID!@unique createdAt: DateTime! updatedAt: DateTime! text: String description:String agenda:Agenda &#125; playground中的方法 单个 Agenda 的mutate 操作12345678910111213141516171819202122232425262728mutate AgendaCreateInput &#123; startTime: String endTime: String allDay: Boolean day: Int! hasDetails: Boolean onMySchedule: Boolean sessionDescription: String sessionSlug: String sessionTitle: String! speakers:&#123; speakerPic: String speakerName: String! speakerTitle: String! &#125; tags:&#123; text: String description: String &#125; sessionLocation:&#123; x1: String x2: String x3: String name: String &#125;&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"f8App-datamodel","slug":"f8App-datamodel-item","date":"2018-02-22T14:56:04.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2018/02/22/f8App-datamodel-item/","link":"","permalink":"https://React-Apollo.github.io/2018/02/22/f8App-datamodel-item/","excerpt":"","text":"","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"EcoSystem|graphql-yoga-todo-app","slug":"Graphql-yoga-todo-app","date":"2018-02-21T21:42:39.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/02/21/Graphql-yoga-todo-app/","link":"","permalink":"https://React-Apollo.github.io/2018/02/21/Graphql-yoga-todo-app/","excerpt":"","text":"","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"摘要| Query Component  in  apollo-client","slug":"摘要| Query component","date":"2018-02-20T10:11:49.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/02/20/摘要| Query component/","link":"","permalink":"https://React-Apollo.github.io/2018/02/20/摘要| Query component/","excerpt":"","text":"","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphql","slug":"Graphql","permalink":"https://React-Apollo.github.io/tags/Graphql/"},{"name":"apollo","slug":"apollo","permalink":"https://React-Apollo.github.io/tags/apollo/"}]},{"title":"Prisma API","slug":"Prisma API","date":"2018-02-19T20:00:40.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/02/19/Prisma API/","link":"","permalink":"https://React-Apollo.github.io/2018/02/19/Prisma API/","excerpt":"","text":"Prisma的 API 是什么?Prisma服务暴露的 GraphQL API是基于部署的 data model 自动生成的. Prisma API 为 data model 中的 type 定义了 CRUD 操作, 探索 Prisma APIGraphql Playground是探索 Prisma API 的最好工具. 使用prisma playground可以打开这个工具 Conceptsdata model 和 Prisma database schema高级概念12345type Post &#123; id: ID! @unique title: String! published: Boolean @default(value: \"false\")&#125; Retrive a single node by its email 1234567query &#123; post(where: &#123; email: \"hello@graph.cool\" &#125;) &#123; id &#125;&#125; update single node title 123456789101112mutation &#123; updatePost( where: &#123; id: \"ohco0iewee6eizidohwigheif\" &#125; data: &#123;//⛔️这里注意这个 data title: \"GraphQL is awesome\" &#125; ) &#123; id &#125;&#125; 立刻更新多个 node 的published 123456789101112mutation &#123; updatePost( where: &#123; id_in: [\"ohco0iewee6eizidohwigheif\", \"phah4ooqueengij0kan4sahlo\", \"chae8keizohmiothuewuvahpa\"] &#125; data: &#123; published: true &#125; ) &#123; count &#125;&#125; connectionsconnections基于的是 Relay connection model.除了提供分页信息,还提供诸如 aggregation 等信息 1234567891011121314query &#123; postsConnection &#123; # `aggregate` allows to perform common aggregation operations aggregate &#123; count &#125; edges &#123; # each `node` refers to a single `Post` element node &#123; title &#125; &#125; &#125;&#125; 认证token:在发送 query 和 mutation 时要在 http header 中 添加 token Error handling有两种错误: Application error: 表示请求无效 Internal server errors: 通常意味着 Prisma的服务有问题. 查看服务日志可以提供更多的信息. QueriesPrisma 提供两种查询 对象查询: 获取特定 type的单个或多个 node Connection 查询:提供高级特性 Hierarchical 查询: 跨关联获取数据 Query 参数: 允许过滤,排序, 分页等操作 Prisma API 都是基于 data model. 1234567891011121314151617181920type Post &#123; id: ID! @unique title: String! published: Boolean! author: User!&#125;type User &#123; id: ID! @unique age: Int email: String! @unique name: String! accessRole: AccessRole posts: [Post!]!&#125;enum AccessRole &#123; USER ADMIN&#125; 对象查询:123456query &#123; posts &#123; id title &#125;&#125; 使用 where 参数 123456789query &#123; post(where: &#123; id: \"cixnen24p33lo0143bexvr52n\" &#125;) &#123; id title published &#125;&#125; 获取 大于18岁的用户: 12345678query &#123; users(where: &#123; age_gt: 18 &#125;) &#123; id name &#125;&#125; 也可以跨关系查询, 获取Post作者年龄超过18岁的节点 1234567891011121314query &#123; posts(where: &#123; author: &#123; age_gt: 18 &#125; &#125;) &#123; id title author &#123; name age &#125; &#125;&#125; connections queries在特殊案例中要使用高级特性, 可以用 connection queries. 他们是 Relay connection 的扩展. Relay connections 的核心概念是提供 data graph 中edge 的 meta-information.例如 例如 edge 不仅提供对象的信息,还提供关联的cursor,可以借此实现强有力的分页功能. 我们使用postsConnectionquery 来获取所有的Posts nodes.同时也请求了每个 edge的cursor. 123456789101112# Fetch all postsquery &#123; postsConnection &#123; edges &#123; cursor node &#123; id title &#125; &#125; &#125;&#125; connection 查询也提供聚合方式 12345678910# Count all posts with a title containing 'GraphQL'query &#123; postsConnection(where: &#123; title_contains: \"GraphQL\" &#125;) &#123; aggregate &#123; count &#125; &#125;&#125; 跨关联查询数据datamodel 中可用的每个 relation 都在两个 model 中添加新的字段 如下,我们活儿特定的 User, 所有与之有关的 Post nodes, 123456789101112query &#123; user(where: &#123; id: \"cixnekqnu2ify0134ekw4pox8\" &#125;) &#123; id name posts &#123; id published &#125; &#125;&#125; Query 参数 使用orderBy对数据排序 使用where对查询的标量或者过滤器进行筛选 使用first,last,after和skip提供分页 通过字段进行排序orderBy:&lt;field&gt;_ASC,orderBy:&lt;field&gt;_DESC 根据标题升序排列所有的 Post node 1234567query &#123; posts(orderBy: title_ASC) &#123; id title published &#125;&#125; Filtering by value查询所有未出版的 Post: 123456789query &#123; posts(where: &#123; published: false &#125;) &#123; id title published &#125;&#125; 查询含有列表标题之一的所有 Post: 123456789query &#123; posts(where: &#123; title_in: [\"My biggest Adventure\", \"My latest Hobbies\"] &#125;) &#123; id title published &#125;&#125; Relation filters查询用户角色作者的所有 Post 123456789query &#123; posts(where: &#123; author: &#123; accessRole: USER &#125; &#125;) &#123; title &#125;&#125; 组合多个 过滤器使用 OR或者AND查询所有的已经出版的Post nodes, 并且标题在列表中 12345678910111213query &#123; posts(where: &#123; AND: [&#123; title_in: [\"My biggest Adventure\", \"My latest Hobbies\"] &#125;, &#123; published: true &#125;] &#125;) &#123; id title published &#125;&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"Primsa-YAML 配置文件","slug":"Prisma-yaml","date":"2018-02-19T08:05:43.000Z","updated":"2019-04-28T05:52:57.892Z","comments":true,"path":"2018/02/19/Prisma-yaml/","link":"","permalink":"https://React-Apollo.github.io/2018/02/19/Prisma-yaml/","excerpt":"","text":"example每个 Prisma 服务包括一个配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# REQUIRED# `my-demo-app` is the name of this Prisma service.service: my-demo-app# REQUIRED# This service is based on the type definitions in the two files# `database/types.graphql` and `database/enums.graphql`datamodel: - database/types.graphql - database/enums.graphql# OPTIONAL# The service will be deployed to the `local` cluster.# Note that if you leave out this option, you will be# asked which cluster to deploy to, and your decision# will be persisted here.cluster: local# REQUIRED# This service will be deployed to the `dev` stage.stage: dev# OPTIONAL (default: false)# Whether authentication is required for this service# is based on the value of the `PRISMA_DISABLE_AUTH`# environment variable.disableAuth: $&#123;env:PRISMA_DISABLE_AUTH&#125;# OPTIONAL# If your Prisma service requires authentication, this is the secret for creating JWT tokens.secret: # OPTIONAL# Path where the full GraphQL schema will be written to# after deploying. Note that it is generated based on your# data model.schema: schemas/prisma.graphql# OPTIONAL# This service has one event subscription configured. The corresponding# subscription query is located in `database/subscriptions/welcomeEmail.graphql`.# When the subscription fires, the specified `webhook` is invoked via HTTP.subscriptions: sendWelcomeEmail: query: database/subscriptions/sendWelcomeEmail.graphql webhook: url: https://$&#123;self.custom:serverlessEndpoint&#125;/sendWelcomeEmail headers: Authorization: $&#123;env:MY_ENDPOINT_SECRET&#125;# OPTIONAL# Points to a `.graphql` file containing GraphQL operations that will be# executed when initially deploying a service.seed: import: database/seed.graphql# OPTIONAL# This service only defines one custom variable that's referenced in# the `webhook` of the `subscription`custom: serverlessEndpoint: https://bcdeaxokbj.execute-api.eu-west-1.amazonaws.com/dev 文件结构如下: 123456789.├── prisma.yml├── database│ ├── subscriptions│ │ └── welcomeEmail.graphql│ ├── types.graphql│ └── enums.graphql└── schemas └── prisma.graphql YAML 文件结构/Applications/Chromium.app/Contents/MacOS/Chromium","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"Prisma DataModel","slug":"Prisma Data Model","date":"2018-02-17T21:34:38.000Z","updated":"2019-04-28T05:52:57.892Z","comments":true,"path":"2018/02/17/Prisma Data Model/","link":"","permalink":"https://React-Apollo.github.io/2018/02/17/Prisma Data Model/","excerpt":"","text":"alias: eiroozae8u description: An overview of how to design data models with Prisma. Data ModellingOverviewPrisma uses the GraphQL Schema Definition Language (SDL) for data modeling. Your data model is written in one or more .graphql-files and is the foundation for the actual database schema that Prisma generates under the hood. If you’re using just a single file for your type definitions, this file is typically called datamodel.graphql. To learn more about the SDL, you can check out the official GraphQL documentation. The .graphql-files containing the data model need to be specified in prisma.yml under the datamodel property. For example: 123datamodel: - types.graphql - enums.graphql If there is only a single file that defines the data model, it can be specified as follows: 1datamodel: datamodel.graphql The data model is the foundation for the GraphQL API of your Prisma service. Based on the data model, Prisma will generate a powerful GraphQL schema (called Prisma database schema) which defines CRUD operations for the types in the data model. A GraphQL schema defines the operations of a GraphQL API. It effectively is a collection of types written in SDL (the SDL also supports primitives like interfaces, enums, union types and more, you can learn everything about GraphQL’s type system here). A GraphQL schema has three special root types: Query, Mutation and Subscription. These types define the entry points for the API and define what operations the API will accept. To learn more about GraphQL schema, check out this article. ExampleA simple datamodel.graphql file: 123456789101112131415161718192021type Tweet &#123; id: ID! @unique createdAt: DateTime! text: String! owner: User! location: Location!&#125;type User &#123; id: ID! @unique createdAt: DateTime! updatedAt: DateTime! handle: String! @unique name: String tweets: [Tweet!]!&#125;type Location &#123; latitude: Float! longitude: Float!&#125; This example illustrates a few important concepts when working with your data model: The three types Tweet, User and Location are mapped to tables in the database. There is a bidirectional relation between User and Tweet There is a unidirectional relation from Tweet to Location Except for the name field on User, all fields are required in the data model (as indicated by the ! following the type). The id, createdAt and updatedAt fields are managed by Prisma and read-only in the exposed GraphQL API (meaning they can not be altered via mutations). Creating and updating your data model is as simple as writing a text file. Once you’re happy with your data model, you can apply the changes to your Prisma service by running prisma deploy: 1234567891011121314151617181920212223242526272829303132333435363738$ prisma deployChanges: Tweet (Type) + Created type `Tweet` + Created field `id` of type `GraphQLID!` + Created field `createdAt` of type `DateTime!` + Created field `text` of type `String!` + Created field `owner` of type `Relation!` + Created field `location` of type `Relation!` + Created field `updatedAt` of type `DateTime!` User (Type) + Created type `User` + Created field `id` of type `GraphQLID!` + Created field `createdAt` of type `DateTime!` + Created field `updatedAt` of type `DateTime!` + Created field `handle` of type `String!` + Created field `name` of type `String` + Created field `tweets` of type `[Relation!]!` Location (Type) + Created type `Location` + Created field `latitude` of type `Float!` + Created field `longitude` of type `Float!` + Created field `id` of type `GraphQLID!` + Created field `updatedAt` of type `DateTime!` + Created field `createdAt` of type `DateTime!` TweetToUser (Relation) + Created relation between Tweet and User LocationToTweet (Relation) + Created relation between Location and TweetApplying changes... (22/22)Applying changes... 0.4s Building blocks of the data modelThere are several available building blocks to shape your data model. Types consist of multiple fields and are used to group similar entities together. Each type in your data model is mapped to the database and CRUD operations are added to the GraphQL schema. Relations describe relationships between types. Interfaces are abstract types that include a certain set of fields which a type must include to implement the interface. Currently, interfaces cannot be user-defined, but there’s a pending feature request for advanced interface support. Special directives covering different use cases such as type constraints or cascading delete behaviour. The rest of this page describes these building blocks in more detail. Prisma database schema vs Data modelWhen starting out with GraphQL and Prisma, the amount of .graphql-files you’re working with can be confusing. Yet, it’s crucial to understand what the role of each of them is. In general, a .graphql-file can contain either of the following: GraphQL operations (i.e. queries, mutations or subscriptions) GraphQL type definitions in SDL In the context of distinguishing the Prisma database schema from the data model, only the latter is relevant! Note that not every .graphql-file that falls into the latter category is per se a valid GraphQL schema. As mentioned in the info box above, a GraphQL schema is characterised by the fact that it has three root types: Query, Mutation and Subscription in addition to any other types that are required for the API. Now, by that definition the data model is not actually a GraphQL schema, despite being a .graphql-file written in SDL. It lacks the root types and thus doesn’t actually define API operations! Prisma simply uses the data model as a handy tool for you to express what the data model looks like. As mentioned above, Prisma will then generate an actual GraphQL schema that contains the Query, Mutation and Subscription root types. This schema is typically stored inside your project as prisma.graphql and called the Prisma database schema. Note that you should never make any manual changes to this file! As an example, consider the following very simple data model: datamodel.graphql 1234type User &#123; id: ID! @uniue name: String!&#125; If you’re deploying this data model to your Prisma service, Prisma will generate the following Prisma database schema that defines the GraphQL API of your service: prisma.graphql 1234567891011121314type Query &#123; users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]! user(where: UserWhereUniqueInput!): User&#125;type Mutation &#123; createUser(data: UserCreateInput!): User! updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User deleteUser(where: UserWhereUniqueInput!): User&#125;type Subscription &#123; user(where: UserSubscriptionWhereInput): UserSubscriptionPayload&#125; Note that this is a simplified version of the generated schema, you can find the full schema here. If you’ve already looked into building your own GraphQL server based on Prisma, you might have come across another .graphql-file which is referred to as your application schema. This is another proper GraphQL schema (meaning it contains the Query, Mutation and Subscription root types) that defines the API exposed to your client applications. It uses the underlying Prisma GraphQL API as a “query engine” to actually run the queries, mutations and subscriptions against the database.A GraphQL server based on Prisma usually has two GraphQL APIs, think of them as two layers for your service:- Application layer: Defined by the application schema (here is where you implement business logic, authentication, integrate with 3rd-party services, etc)- Database layer: Defined by the Prisma database service Object typesAn object type (or short type) defines the structure for one concrete part of your data model. It is used to represents entities from your application domain. If you are familiar with SQL databases you can think of an object type as the schema for a table in your relational database. A type has a name and one or multiple fields. An instantiation of a type is called a node. This term refers to a node inside your data graph.Every type you define in your data model will be available as an analogous type in the generated Prisma database schema. Defining an object typeA object type is defined in the data model with the keyword type: 12345type Article &#123; id: ID! @unique text: String! isPublished: Boolean @default(value: &quot;false&quot;)&#125; The type defined above has the following properties: Name: Article Fields: id, text and isPublished (with the default value false) Generated API operations for typesThe types in your data model affect the available operations in the Prisma GraphQL API. For every type, queries allow you to fetch one or many nodes of that type mutations allow you to create, update or delete nodes of that type subscriptions allow you to get notified of changes to nodes of that type (i.e. new nodes are created or existing nodes are updated or deleted) FieldsFields are the building blocks of a type, giving a node its shape. Every field is referenced by its name and is either scalar or a relation field. Scalar typesStringA String holds text. This is the type you would use for a username, the content of a blog post or anything else that is best represented as text. Note: String values are currently limited to 256KB in size on the shared demo cluster. This limit can be increased on other clusters using the cluster configuration. In queries or mutations, String fields have to be specified using enclosing double quotes: string: &quot;some-string&quot;. IntegerAn Int is a number that cannot have decimals. Use this to store values such as the weight of an ingredient required for a recipe or the minimum age for an event. Note: Int values range from -2147483648 to 2147483647. In queries or mutations, Int fields have to be specified without any enclosing characters: int: 42. FloatA Float is a number that can have decimals. Use this to store values such as the price of an item in a store or the result of complex calculations. In queries or mutations, Float fields have to be specified without any enclosing characters and an optional decimal point: float: 42, float: 4.2. BooleanA Boolean can have the value true or false. This is useful to keep track of settings such as whether the user wants to receive an email newsletter or if a recipe is appropriate for vegetarians. In queries or mutations, Boolean fields have to be specified without any enclosing characters: boolean: true, boolean: false. DateTimeThe DateTime type can be used to store date or time values. A good example might be a person’s date of birth. In queries or mutations, DateTime fields have to be specified in ISO 8601 format with enclosing double quotes: datatime: &quot;2015&quot; datatime: &quot;2015-11&quot; datatime: &quot;2015-11-22&quot; datetime: &quot;2015-11-22T13:57:31.123Z&quot;. EnumEnums are defined on a service scope. Like a Boolean an Enum can have one of a predefined set of values. The difference is that you can define the possible values. For example you could specify how an article should be formatted by creating an Enum with the possible values COMPACT, WIDE and COVER. Note: Enum values can at most be 191 characters long. In queries or mutations, Enum fields have to be specified without any enclosing characters. You can only use values that you defined for the enum: enum: COMPACT, enum: WIDE. JSONSometimes you need to store arbitrary JSON values for loosely structured data. The JSON type makes sure that it is actually valid Json and returns the value as a parsed Json object/array instead of a string. Note: Json values are currently limited to 256KB in size on the shared demo cluster. This limit can be increased on other clusters using the cluster configuration. In queries or mutations, Json fields have to be specified with enclosing double quotes. Special characters have to be escaped: json: &quot;{\\&quot;int\\&quot;: 1, \\&quot;string\\&quot;: \\&quot;value\\&quot;}&quot;. IDAn ID value is a generated unique 25-character string based on cuid. Fields with ID values are system fields and just used internally, therefore it is not possible to create new fields with the ID type. Type modifiersListScalar fields can be marked with the list field type. A field of a relation that has the many multiplicity will also be marked as a list. In queries or mutations, list fields have to be enclosed by square brackets, while the separate entries of the list adhere to the same formatting rules as lined out above: listString: [&quot;a string&quot;, &quot;another string&quot;], listInt: [12, 24]. RequiredFields can be marked as required (sometimes also referred to as “non-null”). When creating a new node, you need to supply a value for fields which are required and don’t have a default value. Required fields are marked using a ! after the field type: name: String!. Field constraintsFields can be configured with certain field constraints to add further semantics to your data model. UniqueSetting the unique constraint makes sure that two nodes of the type in question cannot have the same value for a certain field. The only exception is the null value, meaning that multiple nodes can have the value null without violating the constraint. A typical example would be an email field on the User type where the assumption is that every User should have a globally unique email address. Please note that only the first 191 characters in a String field are considered for uniqueness and the unique check is case insensitive. Storing two different strings is not possible if the first 191 characters are the same or if they only differ in casing. To mark a field as unique, simply append the @unique directive to it: 1234type User &#123; email: String! @unique age: Int!&#125; For every field that’s annotated with @unique, you’re able to query the corresponding node by providing a value for that field. For example, for the above data model, you can now retrieve a particular User node by its email address: 1234567query &#123; user(where: &#123; email: &quot;alice@graph.cool&quot; &#125;) &#123; age &#125;&#125; More constraintsMore database constraints will be added going forward according to this feature request. Default valueYou can set a default value for scalar fields. The value will be taken for new nodes when no value was supplied during creation. To specify a default value for a field, you can use the @default directive: 123456type Story &#123; isPublished: Boolean @default(value: &quot;false&quot;) someNumber: Int! @default(value: &quot;42&quot;) title: String! @default(value: &quot;My New Post&quot;) publishDate: DateTime! @default(value: &quot;2018-01-26&quot;)&#125; Notice that you need to always provide the value in double-quotes, even for non-string types such as Boolean or Int. System fieldsThe three fields id, createdAt and updatedAt have special meaning. They are optional in your data model, but will always be maintained in the underlying database. This way you can always add the field to your data model later, and the data will be available for existing nodes. The values of these fields are currently read-only in the GraphQL API (except when importing data) but will be made configurable in the future. See this proposal for more information. Notice that you cannot have custom fields that are called id, createdAt and updatedAt since these field names are reserved for the system fields. Here are the only supported declarations for these three fields: id: ID! @unique createdAt: DateTime!* updatedAt: DateTime! System field: idA node will automatically get assigned a globally unique identifier when it’s created, this identifier is stored in the id field. Whenever you add the id field to a type definition to expose it in the GraphQL API, you must annotate it with the @unique directive. The id has the following properties: Consists of 25 alphanumeric characters (letters are always lowercase) Always starts with a (lowercase) letter c Follows cuid (collision resistant unique identifiers) scheme Notice that all your object types will implement the Node interface in the database schema. This is what the Node interface looks like: 123interface Node &#123; id: ID! @unique&#125; System fields: createdAt and updatedAtThe data model further provides two special fields which you can add to your types: createdAt: DateTime!: Stores the exact date and time for when a node of this object type was created. updatedAt: DateTime!: Stores the exact date and time for when a node of this object type was last updated. If you want your types to expose these fields, you can simply add them to the type definition, for example: 12345type User &#123; id: ID! @unique createdAt: DateTime! updatedAt: DateTime!&#125; Generated API operations for fieldsFields in the data model affect the available query arguments. RelationsA relation defines the semantics of a connection between two types. Two types in a relation are connected via a relation field. When a relation might be ambiguous, the relation field needs to be annotated with the @relation directive to disambiguate it. A relation can also connect a type with itself. It is then referred to as a self-relation. Required relationsFor a to-one relation field, you can configure whether it is required or optional. The required flag acts as a contract in GraphQL that this field can never be null. A field for the address of a user would therefore be of type Address or Address!. Nodes for a type that contains a required to-one relation field can only be created using a nested mutation to ensure the according field will not be null. Note that a to-many relation field is always set to required. For example, a field that contains many user addresses always uses the type [Address!]! and can never be of type [Address!]. The reason is that in case the field doesn’t contain any nodes, [] will be returned, which is not null. The @relation directiveWhen defining relations between types, there is the @relation directive which provides meta-information about the relation. It can take two arguments: name: An identifier for this relation (provided as a string). This argument is only required if relations are ambiguous. Note that the name argument is required every time you’re using the @relation directive. onDelete: Specifies the deletion behaviour and enables cascading deletes. In case a node with related nodes gets deleted, the deletion behaviour determines what should happen to the related nodes. The input values for this argument are defined as an enum with the following possible values: SET_NULL (default): Set the related node(s) to null. CASCADE: Delete the related node(s). Note that is not possible to set both ends of a bidirectional relation to CASCADE. Note: Here is an example of a data model where the @relation directive is used: 12345678910type User &#123; id: ID! @unique stories: [Story!]! @relation(name: &quot;StoriesByUser&quot; onDelete: CASCADE)&#125;type Story &#123; id: ID! @unique text: String! author: User @relation(name: &quot;StoriesByUser&quot;)&#125; The deletion behaviour in this example is as follows: When a User node gets deleted, all its related Story nodes will be deleted as well. When a Story node gets deleted, it will simply be removed from the stories list on the related User node. Omitting the @relation directiveIn the simplest case, where a relation between two types is unambiguous and the default deletion behaviour (SET_NULL) should be applied, the corresponding relation fields do not have to be annotated with the @relation directive. Here we are defining a bidirectional one-to-many relation between the User and Story types. Since onDelete has not been provided, the default deletion behaviour is used: SET_NULL: 12345678910type User &#123; id: ID! @unique stories: [Story!]!&#125;type Story &#123; id: ID! @unique text: String! author: User&#125; The deletion behaviour in this example is as follows: When a User node gets deleted, the author field on all its related Story nodes will be set to null. Note that if the author field was marked as required, the operation would result in an error. When a Story node gets deleted, it will simply be removed from the stories list on the related User node. Using the name argument of the @relation directiveIn certain cases, your data model may contain ambiguous relations. For example, consider you not only want a relation to express the “author-relationship” between User and Story, but you also want a relation to express which Story nodes have been liked by a User. In that case, you end up with two different relations between User and Story! In order to disambiguate them, you need to give the relation a name: 123456789101112type User &#123; id: ID! @unique writtenStories: [Story!]! @relation(name: &quot;WrittenStories&quot;) likedStories: [Story!]! @relation(name: &quot;LikedStories&quot;)&#125;type Story &#123; id: ID! @unique text: String! author: User! @relation(name: &quot;WrittenStories&quot;) likedBy: [User!]! @relation(name: &quot;LikedStories&quot;)&#125; If the name wasn’t provided in this case, there would be no way to decide whether writtenStories should relate to the author or the likedBy field. Using the onDelete argument of the @relation directiveAs mentioned above, you can specify a dedicated deletion behaviour for the related nodes. That’s what the onDelete argument of the @relation directive is for. Consider the following example: 1234567891011121314151617type User &#123; id: ID! @unique comments: [Comment!]! @relation(name: &quot;CommentAuthor&quot;, onDelete: CASCADE) blog: Blog @relation(name: &quot;BlogOwner&quot;, onDelete: CASCADE)&#125;type Blog &#123; id: ID! @unique comments: [Comment!]! @relation(name: &quot;Comments&quot;, onDelete: CASCADE) owner: User! @relation(name: &quot;BlogOwner&quot;, onDelete: SET_NULL)&#125;type Comment &#123; id: ID! @unique blog: Blog! @relation(name: &quot;Comments&quot;, onDelete: SET_NULL) author: User @relation(name: &quot;CommentAuthor&quot;, onDelete: SET_NULL)&#125; Let’s investigate the deletion behaviour for the three types: When a User node gets deleted, all related Comment nodes will be deleted. the related Blog node will be deleted. When a Blog node gets deleted, all related Comment nodes will be deleted. the related User node will have its blog field set to null. When a Comment node gets deleted, the related Blog node continues to exist and the deleted Comment node is removed from its comments list. the related User node continues to exist and the deleted Comment node is removed from its comments list. Generated API operations for relationsThe relations that are included in your schema affect the available operations in the GraphQL API. For every relation, relation queries allow you to query data across types or aggregated for a relation (note that this is also possible using Relay‘s connection model) nested mutations allow you to create, connect, update, upsert and delete nodes across types relation subscriptions allow you to get notified of changes to a relation GraphQL directivesDirectives are used to provide additional information in your data model. They look like this: @name(argument: &quot;value&quot;) or simply @name when there are no arguments. Data model directivesData model directives describe additional information about types or fields in the GraphQL schema. Unique scalar fieldsThe @unique directive marks a scalar field as unique. Unique fields will have a unique index applied in the underlying database. 1234# the `User` type has a unique `email` fieldtype User &#123; email: String @unique&#125; Find more info about the @unique directive above. Relation fieldsThe directive @relation(name: String, onDelete: ON_DELETE! = NO_ACTION) can be attached to a relation field. See above for more information. Default value for scalar fieldsThe directive @default(value: String!) sets a default value for a scalar field. Note that the value argument is of type String for all scalar fields (even if the fields themselves are not strings): 123456# the `title`, `published` and `someNumber` fields have default values `New Post`, `false` and `42`type Post &#123; title: String! @default(value: &quot;New Post&quot;) published: Boolean! @default(value: &quot;false&quot;) someNumber: Int! @default(value: &quot;42&quot;)&#125; Temporary directivesTemporary directives are used to perform one-time migration operations. After deploying a service that contain a temporary directive, it needs to be manually removed from the type definitions file. Renaming a type or fieldThe temporary directive @rename(oldName: String!) is used to rename a type or field. 1234# renaming the `Post` type to `Story`, and its `text` field to `content`type Story @rename(oldName: &quot;Post&quot;) &#123; content: String @rename(oldName: &quot;text&quot;)&#125; If the rename directive is not used, Prisma would remove the old type and field before creating the new one, resulting in loss of data! Migrating the value of a scalar fieldThe temporary directive @migrationValue(value: String!) is used to migrate the value of a scalar field. When changing an optional field to a required field, it is necessary to also use this directive. Naming conventionsDifferent objects you encounter in a Prisma service like types or relations follow separate naming conventions to help you distinguish them. TypesThe type name determines the name of derived queries and mutations as well as the argument names for nested mutations. Type names can only contain alphanumeric characters and need to start with an uppercase letter. They can contain at most 64 characters. It’s recommended to choose type names in the singular form. Type names are unique on a service level. Examples Post PostCategory Scalar and relation fieldsThe name of a scalar field is used in queries and in query arguments of mutations. Field names can only contain alphanumeric characters and need to start with a lowercase letter. They can contain at most 64 characters. The name of relation fields follows the same conventions and determines the argument names for relation mutations. It’s recommended to only choose plural names for list fields. Field names are unique on a type level. Examples name email categoryTags RelationsRelation names can only contain alphanumeric characters and need to start with an uppercase letter. They can contain at most 64 characters. Relation names are unique on a service level. Examples UserOnPost, UserPosts or PostAuthor, with field names user and posts Appointments, EmployeeOnAppointment or AppointmentEmployee, with field names employee and appointments EnumsEnum values can only contain alphanumeric characters and underscores and need to start with an uppercase letter. The name of an enum value can be used in query filters and mutations. They can contain at most 191 characters. Enum names are unique on a service level. Enum value names are unique on an enum level. Examples A ROLE_TAG RoleTag More SDL featuresIn this section, we describe further SDL features that are not yet supported for data modelling with Prisma. Interfaces“Like many type systems, GraphQL supports interfaces. An interface is an abstract type that includes a certain set of fields that a type must include to implement the interface.” From the official GraphQL Documentation Note: To learn more about when and how interfaces are coming to Prisma, check out this feature request. Interfaces“Like many type systems, GraphQL supports interfaces. An interface is an abstract type that includes a certain set of fields that a type must include to implement the interface.” From the official GraphQL Documentation Note: To learn more about when and how interfaces are coming to Prisma, check out this feature request. Union types“Union types are very similar to interfaces, but they don’t get to specify any common fields between the types.” From the official GraphQL Documentation Note: To learn more about when and how union types are coming to Prisma, check out this feature request.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"Readme|Reactpattern","slug":"Readme|React-pattern","date":"2018-02-17T13:29:04.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2018/02/17/Readme|React-pattern/","link":"","permalink":"https://React-Apollo.github.io/2018/02/17/Readme|React-pattern/","excerpt":"","text":"原文在reactpattern这个Readme 来的正是时候. Contents Stateless function JSX spread attributes Destructuring arguments Conditional rendering Children types Array as children Function as children Render callback Children pass-through Proxy component Style component Event switch Layout component Container component Higher-order component State hoisting Controlled input Stateless functionStateless functions are a brilliant way to define highly reusable components. They don’t hold state; they’re just functions. 1const Greeting = () =&gt; &lt;div&gt;Hi there!&lt;/div&gt; They get passed props and context. 12const Greeting = (props, context) =&gt; &lt;div style=&#123;&#123;color: context.color&#125;&#125;&gt;Hi &#123;props.name&#125;!&lt;/div&gt; They can define local variables, where a function block is used. 12345678const Greeting = (props, context) =&gt; &#123; const style = &#123; fontWeight: \"bold\", color: context.color, &#125; return &lt;div style=&#123;style&#125;&gt;&#123;props.name&#125;&lt;/div&gt;&#125; But you could get the same result by using other functions. 1234567const getStyle = context =&gt; (&#123; fontWeight: \"bold\", color: context.color,&#125;)const Greeting = (props, context) =&gt; &lt;div style=&#123;getStyle(context)&#125;&gt;&#123;props.name&#125;&lt;/div&gt; They can have defined defaultProps, propTypes and contextTypes. 123456789Greeting.propTypes = &#123; name: PropTypes.string.isRequired&#125;Greeting.defaultProps = &#123; name: \"Guest\"&#125;Greeting.contextTypes = &#123; color: PropTypes.string&#125; JSX spread attributesSpread Attributes is a JSX feature. It’s syntactic sugar for passing all of an object’s properties as JSX attributes. These two examples are equivalent.12345// props written as attributes&lt;main className=\"main\" role=\"main\"&gt;&#123;children&#125;&lt;/main&gt;// props \"spread\" from object&lt;main &#123;...&#123;className: \"main\", role: \"main\", children&#125;&#125; /&gt; Use this to forward props to underlying components. 12const FancyDiv = props =&gt; &lt;div className=\"fancy\" &#123;...props&#125; /&gt; Now, I can expect FancyDiv to add the attributes it’s concerned with as well as those it’s not. 123&lt;FancyDiv data-id=\"my-fancy-div\"&gt;So Fancy&lt;/FancyDiv&gt;// output: &lt;div className=\"fancy\" data-id=\"my-fancy-div\"&gt;So Fancy&lt;/div&gt; Keep in mind that order matters. If props.className is defined, it’ll clobber the className defined by FancyDiv 123&lt;FancyDiv className=\"my-fancy-div\" /&gt;// output: &lt;div className=\"my-fancy-div\"&gt;&lt;/div&gt; We can make FancyDivs className always “win” by placing it after the spread props ({...props}). 123// my `className` clobbers your `className`const FancyDiv = props =&gt; &lt;div &#123;...props&#125; className=\"fancy\" /&gt; You should handle these types of props gracefully. In this case, I’ll merge the author’s props.className with the className needed to style my component. 12345const FancyDiv = (&#123; className, ...props &#125;) =&gt; &lt;div className=&#123;[\"fancy\", className].join(' ')&#125; &#123;...props&#125; /&gt; destructuring argumentsDestructuring assignment is an ES2015 feature. It pairs nicely with props in Stateless Functions. These examples are equivalent.123const Greeting = props =&gt; &lt;div&gt;Hi &#123;props.name&#125;!&lt;/div&gt;const Greeting = (&#123; name &#125;) =&gt; &lt;div&gt;Hi &#123;name&#125;!&lt;/div&gt; The rest parameter syntax (...) allows you to collect all the remaining properties in a new object. 12const Greeting = (&#123; name, ...props &#125;) =&gt; &lt;div&gt;Hi &#123;name&#125;!&lt;/div&gt; In turn, this object can use JSX Spread Attributes to forward props to the composed component. 12const Greeting = (&#123; name, ...props &#125;) =&gt; &lt;div &#123;...props&#125;&gt;Hi &#123;name&#125;!&lt;/div&gt; Avoid forwarding non-DOM props to composed components. Destructuring makes this very easy because you can create a new props object without component-specific props. conditional renderingYou can’t use regular if/else conditions inside a component definition. The conditional (ternary) operator is your friend. if 1&#123;condition &amp;&amp; &lt;span&gt;Rendered when `truthy`&lt;/span&gt; &#125; unless 1&#123;condition || &lt;span&gt;Rendered when `falsey`&lt;/span&gt; &#125; if-else (tidy one-liners) 1234&#123;condition ? &lt;span&gt;Rendered when `truthy`&lt;/span&gt; : &lt;span&gt;Rendered when `falsey`&lt;/span&gt;&#125; if-else (big blocks) 123456789&#123;condition ? ( &lt;span&gt; Rendered when `truthy` &lt;/span&gt;) : ( &lt;span&gt; Rendered when `falsey` &lt;/span&gt;)&#125; Children typesReact can render children of many types. In most cases it’s either an array or a string. string 123&lt;div&gt; Hello World!&lt;/div&gt; array 123&lt;div&gt; &#123;[\"Hello \", &lt;span&gt;World&lt;/span&gt;, \"!\"]&#125;&lt;/div&gt; Functions may be used as children. However, it requires coordination with the parent component to be useful. function 123&lt;div&gt; &#123;(() =&gt; &#123; return \"hello world!\"&#125;)()&#125;&lt;/div&gt; Array as childrenProviding an array as children is a very common. It’s how lists are drawn in React. We use map() to create an array of React Elements for every value in the array. 12345&lt;ul&gt; &#123;[\"first\", \"second\"].map((item) =&gt; ( &lt;li&gt;&#123;item&#125;&lt;/li&gt; ))&#125;&lt;/ul&gt; That’s equivalent to providing a literal array. 123456&lt;ul&gt; &#123;[ &lt;li&gt;first&lt;/li&gt;, &lt;li&gt;second&lt;/li&gt;, ]&#125;&lt;/ul&gt; This pattern can be combined with destructuring, JSX Spread Attributes, and other components, for some serious terseness. 12345&lt;ul&gt; &#123;arrayOfMessageObjects.map((&#123; id, ...message &#125;) =&gt; &lt;Message key=&#123;id&#125; &#123;...message&#125; /&gt; )&#125;&lt;/ul&gt; Function as childrenUsing a function as children isn’t inherently useful. 1&lt;div&gt;&#123;() =&gt; &#123; return \"hello world!\"&#125;()&#125;&lt;/div&gt; However, it can be used in component authoring for some serious power. This technique is commonly referred to as render callbacks. This is a powerful technique used by libraries like ReactMotion. When applied, rendering logic can be kept in the owner component, instead of being delegated. See Render callbacks, for more details. Render callbackHere’s a component that uses a Render callback. It’s not useful, but it’s an easy illustration to start with. 1const Width = (&#123; children &#125;) =&gt; children(500) The component calls children as a function, with some number of arguments. Here, it’s the number 500. To use this component, we give it a function as children. 123&lt;Width&gt; &#123;width =&gt; &lt;div&gt;window is &#123;width&#125;&lt;/div&gt;&#125;&lt;/Width&gt; We get this output. 1&lt;div&gt;window is 500&lt;/div&gt; With this setup, we can use this width to make rendering decisions. 1234567&lt;Width&gt; &#123;width =&gt; width &gt; 600 ? &lt;div&gt;min-width requirement met!&lt;/div&gt; : null &#125;&lt;/Width&gt; If we plan to use this condition a lot, we can define another components to encapsulate the reused logic. 12345678const MinWidth = (&#123; width: minWidth, children &#125;) =&gt; &lt;Width&gt; &#123;width =&gt; width &gt; minWidth ? children : null &#125; &lt;/Width&gt; Obviously a static Width component isn’t useful but one that watches the browser window is. Here’s a sample implementation. 123456789101112131415161718192021class WindowWidth extends React.Component &#123; constructor() &#123; super() this.state = &#123; width: 0 &#125; &#125; componentDidMount() &#123; this.setState( &#123;width: window.innerWidth&#125;, window.addEventListener( \"resize\", (&#123; target &#125;) =&gt; this.setState(&#123;width: target.innerWidth&#125;) ) ) &#125; render() &#123; return this.props.children(this.state.width) &#125;&#125; Many developers favor Higher Order Components for this type of functionality. It’s a matter of preference. Children pass-throughYou might create a component designed to apply context and render its children. 123456789class SomeContextProvider extends React.Component &#123; getChildContext() &#123; return &#123;some: \"context\"&#125; &#125; render() &#123; // how best do we return `children`? &#125;&#125; You’re faced with a decision. Wrap children in an extraneous &lt;div /&gt; or return children directly. The first options gives you extra markup (which can break some stylesheets). The second will result in unhelpful errors. 12345// option 1: extra divreturn &lt;div&gt;&#123;children&#125;&lt;/div&gt;// option 2: unhelpful errorsreturn children It’s best to treat children as an opaque data type. React provides React.Children for dealing with children appropriately. 1return React.Children.only(this.props.children) Proxy component(I’m not sure if this name makes sense) Buttons are everywhere in web apps. And every one of them must have the type attribute set to “button”. 1&lt;button type=\"button\"&gt; Writing this attribute hundreds of times is error prone. We can write a higher level component to proxy props to a lower-level button component. 12const Button = props =&gt; &lt;button type=\"button\" &#123;...props&#125;&gt; We can use Button in place of button and ensure that the type attribute is consistently applied everywhere. 12345&lt;Button /&gt;// &lt;button type=\"button\"&gt;&lt;button&gt;&lt;Button className=\"CTA\"&gt;Send Money&lt;/Button&gt;// &lt;button type=\"button\" class=\"CTA\"&gt;Send Money&lt;/button&gt; Style componentThis is a Proxy component applied to the practices of style. Say we have a button. It uses classes to be styled as a “primary” button. 1&lt;button type=\"button\" className=\"btn btn-primary\"&gt; We can generate this output using a couple single-purpose components. 123456789101112131415import classnames from 'classnames'const PrimaryBtn = props =&gt; &lt;Btn &#123;...props&#125; primary /&gt;const Btn = (&#123; className, primary, ...props &#125;) =&gt; &lt;button type=\"button\" className=&#123;classnames( \"btn\", primary &amp;&amp; \"btn-primary\", className )&#125; &#123;...props&#125; /&gt; It can help to visualize this. 1234PrimaryBtn() ↳ Btn(&#123;primary: true&#125;) ↳ Button(&#123;className: \"btn btn-primary\"&#125;, type: \"button\"&#125;) ↳ '&lt;button type=\"button\" class=\"btn btn-primary\"&gt;&lt;/button&gt;' Using these components, all of these result in the same output.123&lt;PrimaryBtn /&gt;&lt;Btn primary /&gt;&lt;button type=\"button\" className=\"btn btn-primary\" /&gt; This can be a huge boon to style maintenance. It isolates all concerns of style to a single component. Event switchWhen writing event handlers it’s common to adopt the handle{eventName} naming convention. 1handleClick(e) &#123; /* do something */ &#125; For components that handle several event types, these function names can be repetitive. The names themselves might not provide much value, as they simply proxy to other actions/functions. 123handleClick() &#123; require(\"./actions/doStuff\")(/* action stuff */) &#125;handleMouseEnter() &#123; this.setState(&#123; hovered: true &#125;) &#125;handleMouseLeave() &#123; this.setState(&#123; hovered: false &#125;) &#125; Consider writing a single event handler for your component and switching on event.type. 123456789101112handleEvent(&#123;type&#125;) &#123; switch(type) &#123; case \"click\": return require(\"./actions/doStuff\")(/* action dates */) case \"mouseenter\": return this.setState(&#123; hovered: true &#125;) case \"mouseleave\": return this.setState(&#123; hovered: false &#125;) default: return console.warn(`No case for event type \"$&#123;type&#125;\"`) &#125;&#125; Alternatively, for simple components, you can call imported actions/functions directly from components, using arrow functions. 1&lt;div onClick=&#123;() =&gt; someImportedAction(&#123; action: \"DO_STUFF\" &#125;)&#125; Don’t fret about performance optimizations until you have problems. Seriously don’t. Layout componentLayout components result in some form of static DOM element. It might not need to update frequently, if ever. Consider a component that renders two children side-by-side. 1234&lt;HorizontalSplit leftSide=&#123;&lt;SomeSmartComponent /&gt;&#125; rightSide=&#123;&lt;AnotherSmartComponent /&gt;&#125;/&gt; We can aggressively optimize this component. While HorizontalSplit will be parent to both components, it will never be their owner. We can tell it to update never, without interrupting the lifecycle of the components inside. 123456789101112class HorizontalSplit extends React.Component &#123; shouldComponentUpdate() &#123; return false &#125; render() &#123; &lt;FlexContainer&gt; &lt;div&gt;&#123;this.props.leftSide&#125;&lt;/div&gt; &lt;div&gt;&#123;this.props.rightSide&#125;&lt;/div&gt; &lt;/FlexContainer&gt; &#125;&#125; Container component“A container does data fetching and then renders its corresponding sub-component. That’s it.”&mdash;Jason Bonta Given this reusable CommentList component. 123456const CommentList = (&#123; comments &#125;) =&gt; &lt;ul&gt; &#123;comments.map(comment =&gt; &lt;li&gt;&#123;comment.body&#125;-&#123;comment.author&#125;&lt;/li&gt; )&#125; &lt;/ul&gt; We can create a new component responsible for fetching data and rendering the stateless CommentList component. 12345678910111213141516171819class CommentListContainer extends React.Component &#123; constructor() &#123; super() this.state = &#123; comments: [] &#125; &#125; componentDidMount() &#123; $.ajax(&#123; url: \"/my-comments.json\", dataType: 'json', success: comments =&gt; this.setState(&#123;comments: comments&#125;); &#125;) &#125; render() &#123; return &lt;CommentList comments=&#123;this.state.comments&#125; /&gt; &#125;&#125; We can write different containers for different application contexts. Higher-order componentA higher-order function is a function that takes and/or returns a function. It’s not more complicated than that. So, what’s a higher-order component? If you’re already using container components, these are just generic containers, wrapped up in a function. Let’s start with our stateless Greeting component. 12345const Greeting = (&#123; name &#125;) =&gt; &#123; if (!name) &#123; return &lt;div&gt;Connecting...&lt;/div&gt; &#125; return &lt;div&gt;Hi &#123;name&#125;!&lt;/div&gt;&#125; If it gets props.name, it’s gonna render that data. Otherwise it’ll say that it’s “Connecting…”. Now for the the higher-order bit. 123456789101112131415161718192021const Connect = ComposedComponent =&gt; class extends React.Component &#123; constructor() &#123; super() this.state = &#123; name: \"\" &#125; &#125; componentDidMount() &#123; // this would fetch or connect to a store this.setState(&#123; name: \"Michael\" &#125;) &#125; render() &#123; return ( &lt;ComposedComponent &#123;...this.props&#125; name=&#123;this.state.name&#125; /&gt; ) &#125; &#125; This is just a function that returns component that renders the component we passed as an argument. Last step, we need to wrap our our Greeting component in Connect. 1const ConnectedMyComponent = Connect(Greeting) This is a powerful pattern for providing fetching and providing data to any number of stateless function components. State hoistingStateless functions don’t hold state (as the name implies). Events are changes in state.Their data needs to be passed to stateful container components parents. This is called “state hoisting”.It’s accomplished by passing a callback from a container component to a child component. 12345678class NameContainer extends React.Component &#123; render() &#123; return &lt;Name onChange=&#123;newName =&gt; alert(newName)&#125; /&gt; &#125;&#125;const Name = (&#123; onChange &#125;) =&gt; &lt;input onChange=&#123;e =&gt; onChange(e.target.value)&#125; /&gt; Name receives an onChange callback from NameContainer and calls on events. The alert above makes for a terse demo but it’s not changing state.Let’s change the internal state of NameContainer. 12345678910class NameContainer extends React.Component &#123; constructor() &#123; super() this.state = &#123;name: \"\"&#125; &#125; render() &#123; return &lt;Name onChange=&#123;newName =&gt; this.setState(&#123;name: newName&#125;)&#125; /&gt; &#125;&#125; The state is hoisted to the container, by the provided callback, where it’s used to update local state.This sets a nice clear boundary and maximizes the re-usability of stateless function. This pattern isn’t limited to stateless functions.Because stateless function don’t have lifecycle events,you’ll use this pattern with component classes as well. Controlled input is an important pattern to know for use with state hoisting (It’s best to process the event object on the stateful component) Controlled inputIt’s hard to talk about controlled inputs in the abstract.Let’s start with an uncontrolled (normal) input and go from there. 1&lt;input type=\"text\" /&gt; When you fiddle with this input in the browser, you see your changes.This is normal. A controlled input disallows the DOM mutations that make this possible.You set the value of the input in component-land and it doesn’t change in DOM-land. 1&lt;input type=\"text\" value=\"This won't change. Try it.\" /&gt; Obviously static inputs aren’t very useful to your users.So, we derive a value from state. 12345678910class ControlledNameInput extends React.Component &#123; constructor() &#123; super() this.state = &#123;name: \"\"&#125; &#125; render() &#123; return &lt;input type=\"text\" value=&#123;this.state.name&#125; /&gt; &#125;&#125; Then, changing the input is a matter of changing component state. 123456return ( &lt;input value=&#123;this.state.name&#125; onChange=&#123;e =&gt; this.setState(&#123; name: e.target.value &#125;)&#125; /&gt;) This is a controlled input.It only updates the DOM when state has changed in our component.This is invaluable when creating consistent UIs. If you’re using stateless functions for form elements,read about using state hoisting to move new state up the component tree.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"pattern","slug":"pattern","permalink":"https://React-Apollo.github.io/tags/pattern/"}]},{"title":"摘要|React Higher Order Components in depth","slug":"摘要|React Higher Order Components in depth","date":"2018-02-13T23:32:45.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/02/13/摘要|React Higher Order Components in depth/","link":"","permalink":"https://React-Apollo.github.io/2018/02/13/摘要|React Higher Order Components in depth/","excerpt":"","text":"原文在React Higher Order Components in depth 已经有了中文版的翻译, 只做摘要 什么是高阶组件 HOC? HOC是包装另一个组件的 React 组件 通常是一个函数,作为类工厂,1hocFactory:: W: React.Component =&gt; E: React.Component “wrap”部分: Props 代理: HOC负责操作传递给包装组件W 的 props. HOC 扩展了 W的功能 HOC可以做什么 代码重用,逻辑抽象和 bootstrap 式的抽象(一般-&gt;特殊的样式定义) 渲染劫持 State抽象和操作 Props 操作 HOC 工厂的实现讨论一下 props 代理和继承反转(Inheritance Inversion) Props Proxy1234567function ppHOC(WrappedComponent) &#123; return class PP extends React.Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125;/&gt; &#125; &#125;&#125; 通过 Props 代理可以做的事情 操控 props 通过 Refs 访问实例 抽象 State 用其他的元素包装组件 操控 props可以在 props 传递给包装组件之前,对 props 做出 read,add, edit和 remove 操作,例如添加 props 12345678910function ppHOC(WrappedComponent) &#123; return class PP extends React.Component &#123; render() &#123; const newProps = &#123; user: currentLoggedInUser &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125;/&gt; &#125; &#125;&#125; 通过 Refs 访问实例可以通过 this 关键字访问包装的组件 例如 123456789101112function refsHOC(WrappedComponent) &#123; return class RefsHOC extends React.Component &#123; proc(wrappedComponentInstance) &#123; wrappedComponentInstance.method() &#125; render() &#123; const props = Object.assign(&#123;&#125;, this.props, &#123;ref: this.proc.bind(this)&#125;) return &lt;WrappedComponent &#123;...props&#125;/&gt; &#125; &#125;&#125; state 抽象可以通过给包装组件提供 props 和 回调函数来抽象出 state实例是 smart component 处理 dumb component 1234567891011121314151617181920212223242526function ppHOC(WrappedComponent) &#123; return class PP extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; name: '' &#125; this.onNameChange = this.onNameChange.bind(this) &#125; onNameChange(event) &#123; this.setState(&#123; name: event.target.value &#125;) &#125; render() &#123; const newProps = &#123; name: &#123; value: this.state.name, onChange: this.onNameChange &#125; &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125;/&gt; &#125; &#125;&#125; 使用方法如下: 123456@ppHOCclass Example extends React.Component &#123; render() &#123; return &lt;input name=\"name\" &#123;...this.props.name&#125;/&gt; &#125;&#125; 通过抽象 state, 把包装组件和 props,method 就分离开了 可以用其他的元素包裹包装组件例如可以提供样式 1234567891011function ppHOC(WrappedComponent) &#123; return class PP extends React.Component &#123; render() &#123; return ( &lt;div style=&#123;&#123;display: 'block'&#125;&#125;&gt; &lt;WrappedComponent &#123;...this.props&#125;/&gt; &lt;/div&gt; ) &#125; &#125;&#125; 继承反转这个没看懂1234567function iiHOC(WrappedComponent) &#123; return class Enhancer extends WrappedComponent &#123; render() &#123; return super.render() &#125; &#125;&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"hoc","slug":"hoc","permalink":"https://React-Apollo.github.io/tags/hoc/"},{"name":"fp","slug":"fp","permalink":"https://React-Apollo.github.io/tags/fp/"}]},{"title":"FlowType cheatsheet","slug":"FlowType cheatsheet","date":"2018-02-13T10:44:12.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/02/13/FlowType cheatsheet/","link":"","permalink":"https://React-Apollo.github.io/2018/02/13/FlowType cheatsheet/","excerpt":"","text":"","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"cheatsheet","slug":"cheatsheet","permalink":"https://React-Apollo.github.io/tags/cheatsheet/"},{"name":"flowtype","slug":"flowtype","permalink":"https://React-Apollo.github.io/tags/flowtype/"}]},{"title":"摘要|Why use static types in JavaScript? (A 4-part primer on static typing with Flow)","slug":"摘要|Why use static types in JavaScript?","date":"2018-02-12T20:48:38.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/02/12/摘要|Why use static types in JavaScript?/","link":"","permalink":"https://React-Apollo.github.io/2018/02/12/摘要|Why use static types in JavaScript?/","excerpt":"","text":"原文参见Why use static types in JavaScript part one Flow 的快速介绍boolean描述boolean值1var isFetching: boolean = false; numbernumber 包含了Infinity和NaN123var luckyNumber: number = 10;var notSoLuckyNumber: number = NaN; string:1var myName: string = 'Preethi'; null1var data: null = null; void1var data: void = undefined; Array可以用Array&lt;T&gt;描述数组的元素类型, 例如下面1var messages: Array&lt;string&gt; = ['hello', 'world', '!']; object可以定义对象的规格: 1234var aboutMe: &#123; name: string, age: number &#125; = &#123; name: 'Preethi', age: 26,&#125;; function123var calculateArea = (radius: number): number =&gt; &#123; return 3.14 * radius * radius&#125;; 异步函数也可以添加类型12345678async function amountExceedsPurchaseLimit( amount: number, getPurchaseLimit: () =&gt; Promise&lt;number&gt;): Promise&lt;boolean&gt; &#123; var limit = await getPurchaseLimit(); return limit &gt; amount;&#125; type alias可以组合现有的类型,创建新的类型12345type PaymentMethod = &#123; id: number, name: string, limit: number,&#125;; 上面创建了一个新的类型PaymentMethod,组合了三个类型 现在可以直接使用了: 12345var myPaypal: PaymentMethod = &#123; id: 123456, name: 'Preethi Paypal', limit: 10000,&#125;; generics12345type GenericObject&lt;T&gt; = &#123; key: T &#125;;var numberT: GenericObject&lt;number&gt; = &#123; key: 123 &#125;;var stringT: GenericObject&lt;string&gt; = &#123; key: \"Preethi\" &#125;;var arrayT: GenericObject&lt;Array&lt;number&gt;&gt; = &#123; key: [1, 2, 3] &#125; 创建了一个抽象类型T,现在可以用来表示 numberT代表number类型, 以此类推. part two规范参数和返回值的类型:12const calculateArea = (radius: number): number =&gt; 3.14 * radius * radius; 带有说明性质12345678910function calculatePayoutDate( quote: boolean, amount: number, paymentMethod: string): Date &#123; let payoutDate; /* business logic */ return payoutDate;&#125; 很清楚的展示了参数类型,和函数的意图 减少了复杂的错误处理机制代码有关的错误检查的代码不需要了12345678const calculateAreas = (radii: Array&lt;number&gt;): Array&lt;number&gt; =&gt; &#123; var areas = []; for (var i = 0; i &lt; radii.length; i++) &#123; areas[i] = 3.14 * (radii[i] * radii[i]); &#125; return areas;&#125;; 可以很放心的实行重构隔离行为和数据再来看看calculateAreas函数 12345678const calculateAreas = (radii: Array&lt;number&gt;): Array&lt;number&gt; =&gt; &#123; var areas = []; for (var i = 0; i &lt; radii.length; i++) &#123; areas[i] = 3.14 * (radii[i] * radii[i]); &#125; return areas;&#125;; 首先我们要考虑数据的类型 ,之后才能考虑具体的操作 减少了整整一类的 bugs.因为远程获取数据是不可靠的, message 有可能没有数据,所以声明数据为? maybe类型123456789type AppState = &#123; isFetching: boolean, messages: ?Array&lt;string&gt;&#125;;var appState: AppState = &#123; isFetching: false, messages: null,&#125;; 减少了单元测试的数量提供了 domain 模型工具","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://React-Apollo.github.io/tags/javascript/"}]},{"title":"摘要|A gentle Introduction to React's Higher Order Components","slug":"摘要|A gentle Introduction to React's Higher Order Components","date":"2018-02-12T18:02:51.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/02/12/摘要|A gentle Introduction to React's Higher Order Components/","link":"","permalink":"https://React-Apollo.github.io/2018/02/12/摘要|A gentle Introduction to React's Higher Order Components/","excerpt":"","text":"原文在A gentle Introduction to React’s Higher Order Components副标题是:如何在在高阶组件中使用条件性渲染 Higher order components缩写为 HOCs.可以用于各种用例, 这里集中在条件性渲染上. 不断增长的组件假设有给TodoList组件,实例代码如下: 12345678910111213function App(props) &#123; return ( &lt;TodoList todos=&#123;props.todos&#125; /&gt; );&#125;function TodoList(&#123; todos &#125;) &#123; return ( &lt;div&gt; &#123;todos.map(todo =&gt; &lt;TodoItem key=&#123;todo.id&#125; todo=&#123;todo&#125; /&gt;)&#125; &lt;/div&gt; );&#125; 实际编程中,光有这些是远远不够的, 需要有为空, 长度为0,渲染中的状态 123456789101112131415161718192021222324252627function TodoList(&#123; todos, isLoadingTodos &#125;) &#123; if (isLoadingTodos) &#123; return ( &lt;div&gt; &lt;p&gt;Loading todos ...&lt;/p&gt; &lt;/div&gt; ); &#125; if (!todos) &#123; return null; &#125; if (!todos.length) &#123; return ( &lt;div&gt; &lt;p&gt;You have no Todos.&lt;/p&gt; &lt;/div&gt; ); &#125; return ( &lt;div&gt; &#123;todos.map(todo =&gt; &lt;TodoItem key=&#123;todo.id&#125; todo=&#123;todo&#125; /&gt;)&#125; &lt;/div&gt; );&#125; 由此代码就显得复杂了.高阶组件可以让这个问题简化一下. 导入高阶组件HOCS通常接收一个组件和可选的参数,然后返回一个输入组件(input component)的增强版本(enhanced components). 定义第一个高阶组件 withTodosNull高阶组件返回 stateless-component或者 ES6 class 组件都可以,如果需要访问组件生命周期中的方法,或者是this.state,应该要返回一个 ES6 class 组件 1234567function withTodosNull(Component) &#123; return function (props) &#123; return !props.todos ? null : &lt;Component &#123; ...props &#125; /&gt; &#125;&#125; 这是一个三元操作符,高阶组件根据 props 来决定是渲染null 还是组件本身.所有的 props 都向下传递. 改为 ES6的箭头函数,更容易理解: 1234const withTodosNull = (Component) =&gt; (props) =&gt; !props.todos ? null : &lt;Component &#123; ...props &#125; /&gt; 最终的高阶函数完成了: 1234567891011121314const withTodosNull = (Component) =&gt; (props) =&gt; ...function TodoList(&#123; todos &#125;) &#123; ...&#125;const TodoListWithNull = withTodosNull(TodoList);function App(props) &#123; return ( &lt;TodoListWithNull todos=&#123;props.todos&#125; /&gt; );&#125; 与 null 组件类似 123456789const withTodosEmpty = (Component) =&gt; (props) =&gt; !props.todos.length ? &lt;div&gt;&lt;p&gt;You have no Todos.&lt;/p&gt;&lt;/div&gt; : &lt;Component &#123; ...props &#125; /&gt;const withLoadingIndicator = (Component) =&gt; (props) =&gt; props.isLoadingTodos ? &lt;div&gt;&lt;p&gt;Loading todos ...&lt;/p&gt;&lt;/div&gt; : &lt;Component &#123; ...props &#125; /&gt; 如果在 input 子类的组件中使用 loading 时, 并不需要出传递其他的 props,可以用 ES6 的展开操作符 把 props 分割一下: 1234const withLoadingIndicator = (Component) =&gt; (&#123; isLoadingTodos, ...others &#125;) =&gt; isLoadingTodos ? &lt;div&gt;&lt;p&gt;Loading todos ...&lt;/p&gt;&lt;/div&gt; : &lt;Component &#123; ...others &#125; /&gt; 最终在TodoList组件中的使用: 12345678910111213141516171819202122232425const withTodosNull = (Component) =&gt; (props) =&gt; ...const withTodosEmpty = (Component) =&gt; (props) =&gt; ...const withLoadingIndicator = (Component) =&gt; (&#123; isLoadingTodos, ...others &#125;) =&gt; ...function TodoList(&#123; todos &#125;) &#123; ...&#125;const TodoListOne = withTodosEmpty(TodoList);const TodoListTwo = withTodosNull(TodoListOne);const TodoListThree = withLoadingIndicator(TodoListTwo);function App(props) &#123; return ( &lt;TodoListThree todos=&#123;props.todos&#125; isLoadingTodos=&#123;props.isLoadingTodos&#125; /&gt; );&#125; 高阶组件中的顺序也很重要,因为,前一个组件的条件满足,就直接返回了. 使用 Recompose 进一步改进代码123456789import &#123; compose &#125; from 'recompose';...const withConditionalRenderings = compose( withLoadingIndicator, withTodosNull, withTodosEmpty); 这个增强的过程就是: 1const TodoListWithConditionalRendering = withConditionalRenderings(TodoList); 12345678910111213141516171819202122232425262728293031import &#123; compose &#125; from 'recompose';const withTodosNull = (Component) =&gt; (props) =&gt; ...const withTodosEmpty = (Component) =&gt; (props) =&gt; ...const withLoadingIndicator = (Component) =&gt; (&#123; isLoadingTodos, ...others &#125;) =&gt; ...function TodoList(&#123; todos &#125;) &#123; ...&#125;const withConditionalRenderings = compose( withLoadingIndicator, withTodosNull, withTodosEmpty);const TodoListWithConditionalRendering = withConditionalRenderings(TodoList);function App(props) &#123; return ( &lt;TodoListWithConditionalRendering todos=&#123;props.todos&#125; isLoadingTodos=&#123;props.isLoadingTodos&#125; /&gt; );&#125; 重用抽象的高阶组件上面的组件适应于特定的渲染, 不能用在其他地方. 考虑到长期的使用,应该抽象出来,以便于其他的组价也可以使用 在withTodoNull中添加一个 optional 负载,这个负载是一个函数,负责返回 true 或者 false, 用于决定最终的渲染结果: 1234const withTodosNull = (Component, conditionalRenderingFn) =&gt; (props) =&gt; conditionalRenderingFn(props) ? null : &lt;Component &#123; ...props &#125; /&gt; 现在这个函数的名字就有点误导了, 改为: 1234const withCondition = (Component, conditionalRenderingFn) =&gt; (props) =&gt; conditionalRenderingFn(props) ? null : &lt;Component &#123; ...props &#125; /&gt; 现在就可以用这个抽象的条件判断组件来实现具体的逻辑 12345678const withCondition = (Component, conditionalRenderingFn) =&gt; (props) =&gt; conditionalRenderingFn(props) ? null : &lt;Component &#123; ...props &#125; /&gt;const conditionFn = (props) =&gt; !props.todos;const TodoListWithCondition = withCondition(TodoList, conditionFn); 为了利于实现柯理化, 把负载的函数也分开传递: 1234const withCondition = (conditionalRenderingFn) =&gt; (Component) =&gt; (props) =&gt; conditionalRenderingFn(props) ? null : &lt;Component &#123; ...props &#125; /&gt; 在使用时传递条件函数就可以了: 12345678910111213import &#123; compose &#125; from 'recompose';...const conditionFn = (props) =&gt; !props.todos;const withConditionalRenderings = compose( withLoadingIndicator, withCondition(conditionFn), withTodosEmpty);const TodoListWithConditionalRendering = withConditionalRenderings(TodoList); maybe 和 either 高阶组件什么也不返回,或者返回输入组件的类型,在函数式编程中有名字的叫 Maybe.1234const withMaybe = (conditionalRenderingFn) =&gt; (Component) =&gt; (props) =&gt; conditionalRenderingFn(props) ? null : &lt;Component &#123; ...props &#125; /&gt; 两个组件返回其一的在函数式编程中称为 either 1234const withEither = (conditionalRenderingFn, EitherComponent) =&gt; (Component) =&gt; (props) =&gt; conditionalRenderingFn(props) ? &lt;EitherComponent /&gt; : &lt;Component &#123; ...props &#125; /&gt; 最最终的版本终于是最后一个版本了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import &#123; compose &#125; from 'recompose';const withMaybe = (conditionalRenderingFn) =&gt; (Component) =&gt; (props) =&gt; conditionalRenderingFn(props) ? null : &lt;Component &#123; ...props &#125; /&gt;const withEither = (conditionalRenderingFn, EitherComponent) =&gt; (Component) =&gt; (props) =&gt; conditionalRenderingFn(props) ? &lt;EitherComponent /&gt; : &lt;Component &#123; ...props &#125; /&gt;const EmptyMessage = () =&gt; &lt;div&gt; &lt;p&gt;You have no Todos.&lt;/p&gt; &lt;/div&gt;const LoadingIndicator = () =&gt; &lt;div&gt; &lt;p&gt;Loading todos ...&lt;/p&gt; &lt;/div&gt;const isLoadingConditionFn = (props) =&gt; props.isLoadingTodos;const nullConditionFn = (props) =&gt; !props.todos;const isEmptyConditionFn = (props) =&gt; !props.todos.lengthconst withConditionalRenderings = compose( withEither(isLoadingConditionFn, LoadingIndicator), withMaybe(nullConditionFn), withEither(isEmptyConditionFn, EmptyMessage));const TodoListWithConditionalRendering = withConditionalRenderings(TodoList);function App(props) &#123; return ( &lt;TodoListWithConditionalRendering todos=&#123;props.todos&#125; isLoadingTodos=&#123;props.isLoadingTodos&#125; /&gt; );&#125;function TodoList(&#123; todos &#125;) &#123; return ( &lt;div&gt; &#123;todos.map(todo =&gt; &lt;TodoItem key=&#123;todo.id&#125; todo=&#123;todo&#125; /&gt;)&#125; &lt;/div&gt; );&#125; 确实赏心悦目的代码改进, 每一步都体现了程序员的思考过程.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"hoc","slug":"hoc","permalink":"https://React-Apollo.github.io/tags/hoc/"}]},{"title":"摘要|Full-stack React + GraphQL Tutorial(part4)","slug":"摘要|Full-stack React + GraphQL Tutorial(part4)","date":"2018-02-10T20:23:46.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/02/10/摘要|Full-stack React + GraphQL Tutorial(part4)/","link":"","permalink":"https://React-Apollo.github.io/2018/02/10/摘要|Full-stack React + GraphQL Tutorial(part4)/","excerpt":"","text":"这个是之前看到apollo-client 的入门文章,随着学习,回过头来看看,觉得非常有意思 不准备全部翻译,有些有用的地方强调一下 系列文章 Part 1 : Setting up a simple client Part 2: Setting up a simple server Part 3: Writing mutations and keeping the client in sync Part 4: (this part)Optimistic UI and client side store updates Part 5: Input types and custom cache resolvers Part 6: Subscriptions on the server Part 7: GraphQL Subscriptions on the client Part 8: PaginationMutation 和延迟网络操作存在不可预测的延迟,这个没有办法去估计和预测. 只有通过一定的策略去提供更为友好的操作方法.mutation 之后的 store 更新针对 mutation 和其他需要根据客户端的操作来更新 store的操作, Apollo-client提供了一套有力的工具:readQuery,writeQuery,readFragment和writeFragment. 客户端的添加操作,可以如下操作,先写入缓存里 1234567891011121314151617181920212223242526272829303132333435363738394041424344const handleKeyUp = (evt) =&gt; &#123; if (evt.keyCode === 13) &#123; evt.persist(); mutate(&#123; variables: &#123; name: evt.target.value &#125;, update: (store, &#123; data: &#123; addChannel &#125; &#125;) =&gt; &#123; // Read the data from the cache for this query. const data = store.readQuery(&#123;query: channelsListQuery &#125;); // Add our channel from the mutation to the end. data.channels.push(addChannel); // Write the data back to the cache. store.writeQuery(&#123; query: channelsListQuery, data &#125;); &#125;, &#125;) .then( res =&gt; &#123; evt.target.value = ''; &#125;); &#125; &#125;;``` 这样一旦, mutation 操作完成,可以立刻得到结果,不会有延迟存在.![](https://ws1.sinaimg.cn/large/006tNc79gy1fobmr5zy1sj30c2092q2w.jpg)实际的延迟仍然存在,但是通过技巧处理了这个问题#### Optimistic UIapollo-client提供了 Optimistic UI 来完美的解决这个问题途径通过在mutation中添加`optimisticResponse`属性.```jsmutate(&#123; variables: &#123; name: evt.target.value &#125;, optimisticResponse: &#123; addChannel: &#123; name: evt.target.value, id: Math.round(Math.random() * -1000000), __typename: 'Channel', &#125;, &#125;, update: ...&#125;) 为了让用户知道,添加的数据还没有被服务器确认,还需要一些小技巧保持条目也 optimistic我们在上面生成了一个负的 id 1id: Math.round(Math.random() * -1000000), 为了让未经服务器确认的消息和真实的消息 有所区分,要添加额外的 CSS: 12345678return ( &lt;div className=\"channelsList\"&gt; &lt;AddChannel /&gt; &#123; channels.map( ch =&gt; (&lt;div key=&#123;ch.id&#125; className=&#123;'channel ' + (ch.id &lt; 0 ? 'optimistic' : '')&#125;&gt;&#123;ch.name&#125;&lt;/div&gt;) )&#125; &lt;/div&gt; ); 123div.optimistic &#123; color: rgba(255, 255, 255, 0.5);&#125; 注意:这里的 id 并不重要,重要的是显示的内容,所以用了一个 id 为负值的参数,既区分了真实和模拟的数据,又据此添加了对应的样式. 当真实的数据从服务器返回以后,会替代负id的样式, 就确认mutation 了.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Apollo-client","slug":"Apollo-client","permalink":"https://React-Apollo.github.io/tags/Apollo-client/"},{"name":"Grahpql","slug":"Grahpql","permalink":"https://React-Apollo.github.io/tags/Grahpql/"}]},{"title":"摘要|Full-stack React + GraphQL Tutorial(part1)","slug":"摘要|Full-stack React + GraphQL Tutorial","date":"2018-02-10T20:10:01.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/02/10/摘要|Full-stack React + GraphQL Tutorial/","link":"","permalink":"https://React-Apollo.github.io/2018/02/10/摘要|Full-stack React + GraphQL Tutorial/","excerpt":"","text":"这个是之前看到apollo-client 的入门文章,随着学习,回过头来看看,觉得非常有意思 不准备全部翻译,有些有用的地方强调一下 系列文章 Part 1 (this part): Setting up a simple client Part 2: Setting up a simple server Part 3: Writing mutations and keeping the client in sync Part 4: Optimistic UI and client side store updates Part 5: Input types and custom cache resolvers Part 6: Subscriptions on the server Part 7: GraphQL Subscriptions on the client Part 8: Pagination配置使用 create-react-app 的方法,很简单,而且可以部署到 github, 因为这是静态文件,嵌入的 js打包文件. app.js 文件修改如下-导入一个列表组件:12345678910111213141516171819202122import React, &#123; Component &#125; from 'react'; import logo from './logo.svg'; import './App.css';const ChannelsList = () =&gt; (&lt;ul&gt; &lt;li&gt;Channel 1&lt;/li&gt; &lt;li&gt;Channel 2&lt;/li&gt; &lt;/ul&gt;);class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;div className=\"App-header\"&gt; &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; &lt;h2&gt;Welcome to Apollo&lt;/h2&gt; &lt;/div&gt; &lt;ChannelsList /&gt; &lt;/div&gt; ); &#125; &#125;export default App; 编写 graphql schema 文件1234567891011export const typeDefs = `type Channel &#123; id: ID! # \"!\" denotes a required field name: String&#125;# This type specifies the entry points into our API. In this case# there is only one - \"channels\" - which returns a list of channels.type Query &#123; channels: [Channel] # \"[]\" means this is a list of channels&#125;`; 这是标准的做法,如果是定义了一个 schema 实体, 返回列表就是一个数组根据这个 schmea 可以编写查询 123456query ChannelsListQuery &#123; channels &#123; id name &#125;&#125; 对组件进行包装: 123456789const channelsListQuery = gql` query ChannelsListQuery &#123; channels &#123; id name &#125; &#125; `;const ChannelsListWithData = graphql(channelsListQuery)(ChannelsList); 由于 apollo-client 利用了网络层的状态标志,省去了自己构建的麻烦:1234567891011const ChannelsList = (&#123; data: &#123;loading, error, channels &#125;&#125;) =&gt; &#123; if (loading) &#123; return &lt;p&gt;Loading ...&lt;/p&gt;; &#125; if (error) &#123; return &lt;p&gt;&#123;error.message&#125;&lt;/p&gt;; &#125; return &lt;ul&gt; &#123; channels.map( ch =&gt; &lt;li key=&#123;ch.id&#125;&gt;&#123;ch.name&#125;&lt;/li&gt; ) &#125; &lt;/ul&gt;; &#125;; 直接可以使用的loading 和 error 标记 后面的模拟数据部分,新版已经改进了,不能再使用","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Apollo-client","slug":"Apollo-client","permalink":"https://React-Apollo.github.io/tags/Apollo-client/"},{"name":"Grahpql","slug":"Grahpql","permalink":"https://React-Apollo.github.io/tags/Grahpql/"}]},{"title":"翻译|Prisma  Data Model","slug":"翻译|Prisma  Data Model","date":"2018-02-09T11:02:23.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/02/09/翻译|Prisma  Data Model/","link":"","permalink":"https://React-Apollo.github.io/2018/02/09/翻译|Prisma  Data Model/","excerpt":"","text":"概览Prisma 使用 GraphQL Schema Definition Language 定义数据模型.数据模型可以写在一个或多个.graphql文件中.在内部它是 Prisma 生成实际数据库 schema 的基础.如果只使用单个的定义文件,可以被称为datamodel.graphql. .graphql文件需要在prisma.yml中声明. 例如: 123datamodel: - types.graphql - enums.graphql 如果是单个文件:1datamodel:datamodel.graphql data model 是 基于Prisma服务的 GraphQL API 的基础. Prisma会以此生成一套强有力的 Graphql Schema(被称为 Prisma data schema),为 data model 定义了全部的 CRUD 操作. 实例一个简单的datamodel.graphql文件: 123456789101112131415161718192021type Tweet &#123; id: ID! @unique createdAt: DateTime! text: String! owner: User! location: Location!&#125;type User &#123; id: ID! @unique createdAt: DateTime! updatedAt: DateTime! handle: String! @unique name: String tweets: [Tweet!]!&#125;type Location &#123; latitude: Float! longitude: Float!&#125; 实例展示了一些data model 的重要概念: 三个类型 Tweet,User,Location被映射到数据库的表中 User,Tweet之间是双向关系 Tweet到Location是单向关系 除了 User的 name字段,所有的字段都是必须的(用!表示) id,createdAt,updateAt字段由 Prisma 管理,在 GraphQL API 中只读 创建和更新 datamodel 和修改文本文件一样简单.一旦 datamodel 的修改达到你的需求,可以执行prisma deploy命令 :1234567891011121314151617181920212223242526272829303132333435363738$ prisma deployChanges: Tweet (Type) + Created type `Tweet` + Created field `id` of type `GraphQLID!` + Created field `createdAt` of type `DateTime!` + Created field `text` of type `String!` + Created field `owner` of type `Relation!` + Created field `location` of type `Relation!` + Created field `updatedAt` of type `DateTime!` User (Type) + Created type `User` + Created field `id` of type `GraphQLID!` + Created field `createdAt` of type `DateTime!` + Created field `updatedAt` of type `DateTime!` + Created field `handle` of type `String!` + Created field `name` of type `String` + Created field `tweets` of type `[Relation!]!` Location (Type) + Created type `Location` + Created field `latitude` of type `Float!` + Created field `longitude` of type `Float!` + Created field `id` of type `GraphQLID!` + Created field `updatedAt` of type `DateTime!` + Created field `createdAt` of type `DateTime!` TweetToUser (Relation) + Created relation between Tweet and User LocationToTweet (Relation) + Created relation between Location and TweetApplying changes... (22/22)Applying changes... 0.4s 构建 data model 模块有几种可以使用的模块用于描述 data model Types 包含fields,用于把类似的实体分组. 每个data model 中的 type 都被映射到数据库的表和 CRUD操作,然后添加的 graphQL 的 schema 中 Relations 描述 typee 之间的关系 Interfaces属于抽象 types,包含了一组特定的字段, type在实现时必须要遵循. 现在 interface 还不能由用户定义.但是已经有这样的需求. 特定的directives指令,包含不同的使用用例, 例如 type 约束或者是级联删除的行为. 接下里的内容就是描述这些构建块的具体细节问题 Prisma 的 database 和 data model刚开使用 GraphQL和 Prisma时, .graphql文件的数量会让你不是所措.然而理解每个文件扮演的角色又是很关键的问题.总体上讲,一个graphql文件可以包含下面的内容: GraphQL 的操作(例如 query, mutate或者 subscriptions) 使用 SDL 定义的 GraphQL type 如果要区分 Prisma database schema 和 data model的话,只有后者是有关联的! 现在这一很重要data model 并不是实际的 GraphQL schema,虽然也是用 SDL定义的,但是缺少 root types,所以不能生成实际的 API 操作符! Prisma 只是使用 data model作为一个硬工具表达一下具体的 data model 的外观. 正如上面提到的, Prisma 会生成实际的 GraphQL schema,包含query,mutation,subscription 三种 root type. 生成的 prisma.graphql文件被称为 Prisma database schema .注意了,一定不要修改这个文件.这是系统自己生成的. 作为实例,看看一个最简单的 data model: datamodel graphql 1234type User &#123; id: ID! @uniue name: String!&#125; 如果部署了 Prisma 的服务, Prisma 将会生成服务所需的一些 API: prisma.graphql 1234567891011121314type Query &#123; users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]! user(where: UserWhereUniqueInput!): User&#125;type Mutation &#123; createUser(data: UserCreateInput!): User! updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User deleteUser(where: UserWhereUniqueInput!): User&#125;type Subscription &#123; user(where: UserSubscriptionWhereInput): UserSubscriptionPayload&#125; 其实在生成的 Graphql server 中还有一个.graphql文件, 这个文件被称为 application shema. 这里定义的 API是实际暴露给最终用户的. Prisma 的 API 就作为 “query egine”来实际执行操作. 所以,一个 基于PRISMA的Graphql server实际包含两个 API.可以认为是服务的两个数据层: Aplication layer: 定义客户端可以使用的操作 Database layer: 定义 Prisma database 的服务 Object typesobject type(简称为 type)定义了实现data model 的实际组成部分. 用于代表应用主域的实体.如果你很熟悉 SQL databases,可以把 type 看成是 关系型数据库的 table,一个 type 有一个名字,一个或者多个字段.type的实例称为 node,这个术语指的是 data graph 中的 node. 在 data model 中定义的每个 type和 Prisma生成的 database schema 很类似. 定义一个 object type用type关键字定义一个object type 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566type Article &#123; id: ID! @unique text: String! isPublished: Boolean @default(value: \"false\")&#125;``` 上面的 type 定义包含下面的属性:- Name:`Article`- Fields: `id`,`text`,`isPublished`(默认值是`false`)### 为 type 生成 API 操作符在 datamodel 中定义的 type 会影响 prisma graphql API 的生成. - queries- mutations- subscriptions## FieldsFields 是构建 type的基础块. 每个字段由名字来引用, 要么是标量,要么是 relation 字段### 标量类型#### String`String`承载 text,可以用于 username,blog的正文,或者代表 txt 的内容注意: String在共享的 cluster 中容量是256kb.可以通过 clusters 的配置来扩增.在 query 或者 mutation 中, String字段要用双引号定义:`string:\"some-string\"`#### Integer`Int`是没有小数位的数字,可以用来储存成分重量, 或者最小年龄等. `int:42`#### Float`float`是有小数位的数字, `float:42`,`float:4.2`#### Boolean`boolean:true`,`boolean:false`#### DateTime`DateTime` type 用来保存日期或者时间值. 某人的出生日期就是一个例子.在`query`和`mutations`中,`DateTime`字段要定义为`ISO8601 format`.- `datetime:\"2015\"`#### Enum 枚举用于定义服务的范围和 boolean 一样,有一套预设值,不同点是可以自己设置. 限定为`191个字符`#### JSON有时候要储存松散的数据结构,可以可以用 JSON.`json: \"&#123;\\\"int\\\": 1, \\\"string\\\": \\\"value\\\"&#125;\"`#### ID25个字符串,基于 cuid.### Type modifiers#### List`listString: [\"a string\", \"another string\"], listInt: [12, 24]`.#### Requiredfields 可以被标记位 required(non-null). `name:String!`### field 限定字段可以使用特定的字段限定#### Unique连个 node,不能有同样的值.唯一例外是`null`.&gt;通常 User type 的`email`是唯一的只有开始的191个字符是唯一的, 并且是区分大小写的. ```jstype User &#123; email: String! @unique age: Int!&#125; 对于使用@unique限定的字段可以借此查询对应的 node.例如可以返回拥有此 email 的用户节点:1234567query &#123; user(where: &#123; email: \"alice@graph.cool\" &#125;) &#123; age &#125;&#125; 后续还有其他的限定条件加入Default Value可以为标量设定默认值. @default指令 123456type Story &#123; isPublished: Boolean @default(value: \"false\") someNumber: Int! @default(value: \"42\") title: String! @default(value: \"My New Post\") publishDate: DateTime! @default(value: \"2018-01-26\")&#125; 一定要用双引号,即使不是字符串 System fields三个字段id,createdAt,updatedAT有特殊的意义. 在 datamodel 中是可选,但是在底层的数据库中会一直存在.除非要是导入的数据, 否则, 这三个值在 graphql API 中是只读的. Relationsrelation 定义了连接两个 type 的语法. 两个类型通过 relation fields 连接在一起.如果 relation 可能会混淆的时候,要使用@relation来区分开连接自身的字段也可以 Required relations@relation directive有两个参数 name: 用于识别 relation. onDelete:用于定义删除行为: SET_NULL(default):设定 related node 为null CASCADE:删除 related nodes. 实例:12345678910type User &#123; id: ID! @unique stories: [Story!]! @relation(name: \"StoriesByUser\" onDelete: CASCADE)&#125;type Story &#123; id: ID! @unique text: String! author: User @relation(name: \"StoriesByUser\")&#125; 上面例子的删除行为: 当Usernode被删除以后, 与之有关的Story node 也被删除 当Story node被删除,只会从User 的stories列表中删除 省略@relation指令当两个 type 不会发生歧义的时候,可以不用写这个指令 12345678910type User &#123; id: ID! @unique stories: [Story!]!&#125;type Story &#123; id: ID! @unique text: String! author: User&#125; 当User删除掉, author中所有的相关Story都会被设为null.如果 author 被设定为 required,操作就会引发错误 当一个Story被删除掉以后,只会从User node list 中删除 在@relation指令中使用name参数123456789101112type User &#123; id: ID! @unique writtenStories: [Story!]! @relation(name: \"WrittenStories\") likedStories: [Story!]! @relation(name: \"LikedStories\")&#125;type Story &#123; id: ID! @unique text: String! author: User! @relation(name: \"WrittenStories\") likedBy: [User!]! @relation(name: \"LikedStories\")&#125; 在@relation指令中使用onDelete参数1234567891011121314151617type User &#123; id: ID! @unique comments: [Comment!]! @relation(name: \"CommentAuthor\", onDelete: CASCADE) blog: Blog @relation(name: \"BlogOwner\", onDelete: CASCADE)&#125;type Blog &#123; id: ID! @unique comments: [Comment!]! @relation(name: \"Comments\", onDelete: CASCADE) owner: User! @relation(name: \"BlogOwner\", onDelete: SET_NULL)&#125;type Comment &#123; id: ID! @unique blog: Blog! @relation(name: \"Comments\", onDelete: SET_NULL) author: User @relation(name: \"CommentAuthor\", onDelete: SET_NULL)&#125; 看看三个不同的类型: User node 被删除 所有的Comment nodes 被删除 Blog node 也被删除 当Blog node 被删除, 所有相关的Commentnodes被删除 拥有blog字段的User node 被设置为空 当Comment node 被删除 相关的Blog node会继续存在,Comments会从comment list 中删掉 相关的User会一直存在, Comment node会从comments list 中删掉 为 relations 生成 API 操作 relation queries 会跨 types查询数据或者聚合 relation nest mutations 跨 types, create,connect,update upsert和 delete nodes relation subscription 改变 relation时获取通知 GraphQL 指令临时性指令renaming a type or field@rename(oldName:String!) 1234# renaming the `Post` type to `Story`, and its `text` field to `content`type Story @rename(oldName: \"Post\") &#123; content: String @rename(oldName: \"text\")&#125;","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"}]},{"title":"Prisma 实现新特性的步骤","slug":"在 prisma 中实现新特性的步骤","date":"2018-02-08T21:11:39.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/02/08/在 prisma 中实现新特性的步骤/","link":"","permalink":"https://React-Apollo.github.io/2018/02/08/在 prisma 中实现新特性的步骤/","excerpt":"","text":"Adjust data model (if necessary) Deploy Prisma database service to apply changes to data model (if necessary) Add new root field (on the Query, Mutation or Subscription field) to application schema Implement the resolver for the new root field","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"摘要|GraphQL Databases — A preview into the future of Graphcool","slug":"摘要|GraphQL Databases — A preview into the future of Graphcool","date":"2018-02-08T18:08:58.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/02/08/摘要|GraphQL Databases — A preview into the future of Graphcool/","link":"","permalink":"https://React-Apollo.github.io/2018/02/08/摘要|GraphQL Databases — A preview into the future of Graphcool/","excerpt":"","text":"GraphQL 数据库- Graphcool 未来展望 构建 GraphQL 服务器的方法更加符合常规定义的 GraphQL schema 如何映射到数据库在 graphql的应用中有两层,一层是数据库层,一层是应用层(graphql发挥作用的地方).可以作为 REST API 的”gateway”,整合多个 API,或者是遗留的资源. GraphQL DataBase 使用 SDL 简单明了的进行数据模型管理 建立 GraphQL CRUD API. Graphcool database service graphcool.yml:graphcool服务的根配置. 在 Prisma里结构已经改变了 database/datamodel.graphql:定义应用的数据模型,之前的版本叫types.graphql database/schema.grphql:这是根据命令自动生成的. 包括完整的根据 datamodel生成的 database schema.绝大多数都是 CRUD 操作的方法.是应用的基础. Application(GraphQL Server)这个一部分是之前的版本没有的部分 所以要留心.新版本(Prisma)现在只是覆盖数据库层.所以需要额外的层作为实际的 web 服务. 这就是这个一部分的目的. 这一部分也有 schema.graphql,包含了应用的 schema. 定义了最终暴露给客户端的 API. graphQL 配置.因为现在有两个独立的 GraphQL API(一个是应用的,一个是数据库的).添加工具管理这两个部分是很有意义的.grqphqlconfig.yml就是配置文件 在 database/datamodel中会生成完整的 CRUD 操作, 但是如果不想完全暴露给应用. 可以对其进行进行裁剪. 应用的 schema 就是这个目的.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"摘要|GraphQL Server Basics  The Network Layer","slug":"摘要|GraphQL Server Basics- The Network Layer","date":"2018-02-08T12:12:39.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/02/08/摘要|GraphQL Server Basics- The Network Layer/","link":"","permalink":"https://React-Apollo.github.io/2018/02/08/摘要|GraphQL Server Basics- The Network Layer/","excerpt":"","text":"#GraphQL Server Basics: The Network LayerGraphQL Server Basics: The Network Layer Graphql 通过 HTTP协议提供服务以 schema 为核心,定义好了以后后端的 schema和 resolver 之后, 如何实现 Graphql 就是问题了 express.js 的中间件Express 中间件接收req,res,next函数.因为 express 可以处理 http 请求, Graphql 定义的 schema 和 resolver 提供了功能, 需要的就是把他们粘合起来 中间的桥梁有express-grahpql,apollo-server.本质上他们都是 express 的中间件 GraphQL 中间件GraphQL 结合了 HTTP请求和 Graphlql.jsexpress-grahpql是 facebook 版本的 GraphQL的中间件,主要有两个作用: 解析请求中的查询和 mutate, 转发给 graphql函数,最终做处理 把结果附加到 res对象,返回给客户端 12345678910111213141516171819202122232425const express = require('express')const graphqlHTTP = require('express-graphql')const &#123; GraphQLSchema, GraphQLObjectType, GraphQLString &#125; = require('graphql')const app = express()const schema = new GraphQLSchema(&#123; query: new GraphQLObjectType(&#123; name: 'Query', fields: &#123; hello: &#123; type: GraphQLString, resolve: (root, args, context, info) =&gt; &#123; return 'Hello World' &#125; &#125; &#125;&#125;)app.use('/graphql', graphqlHTTP(&#123; schema, graphiql: true // enable GraphiQL&#125;))app.listen(4000) apollo-server 与 express-graphql 类似两者类似, apollo-server 提供了对更多框架的支持而已. graphql-yoga这是最容易使用的,就是 Graphql 背后的中间件 12345678910111213141516const &#123; GraphQLServer &#125; = require('graphql-yoga')const typeDefs = ` type Query &#123; hello: String! &#125;`const resolvers = &#123; Query: &#123; hello: (root, args, context, info) =&gt; 'Hello World' &#125;&#125;const server = new GraphQLServer(&#123; typeDefs, resolvers &#125;)server.start() // defaults to port 4000","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"graqhql","slug":"graqhql","permalink":"https://React-Apollo.github.io/tags/graqhql/"}]},{"title":"Apollo-client 的Incremental loading(增量加载)","slug":"apollo-client-Incremental loading","date":"2018-02-04T13:22:27.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2018/02/04/apollo-client-Incremental loading/","link":"","permalink":"https://React-Apollo.github.io/2018/02/04/apollo-client-Incremental loading/","excerpt":"","text":"Incremental loadingfetchmore方法1234567891011121314151617181920212223242526272829const FeedQuery = gql` query Feed($type: FeedType!, $offset: Int, $limit: Int) &#123; # ... &#125;`;const FeedWithData = graphql(FeedQuery, &#123; props(&#123; data: &#123; loading, feed, currentUser, fetchMore &#125; &#125;) &#123; return &#123; loading, feed, currentUser, loadNextPage() &#123; return fetchMore(&#123; variables: &#123; offset: feed.length, &#125;, updateQuery: (previousResult, &#123; fetchMoreResult &#125;) =&gt; &#123; if (!fetchMoreResult) &#123; return previousResult; &#125; return Object.assign(&#123;&#125;, previousResult, &#123; feed: [...previousResult.feed, ...fetchMoreResult.feed], &#125;); &#125;, &#125;); &#125;, &#125;; &#125;,&#125;)(Feed); 执行查询任务的时候, props里会有一个length属性, 可以作为无限加载的一个偏移标记,比如在 cnode 的查询 REST中,如果下一页page+1,就可以用这个 length+1来作为下一个加载的查询参数1page=length+1","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphql","slug":"Graphql","permalink":"https://React-Apollo.github.io/tags/Graphql/"},{"name":"apollo","slug":"apollo","permalink":"https://React-Apollo.github.io/tags/apollo/"}]},{"title":"Recompose  libary Readme","slug":"Recompose  libary Readme","date":"2018-02-02T20:12:01.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2018/02/02/Recompose  libary Readme/","link":"","permalink":"https://React-Apollo.github.io/2018/02/02/Recompose  libary Readme/","excerpt":"","text":"APIIn these API docs, a higher-order component (HOC) refers to a function that accepts a single React component and returns a new React component. 1const EnhancedComponent = hoc(BaseComponent) This form makes HOCs (sometimes called enhancers) composable: 1234const composedHoc = compose(hoc1, hoc2, hoc3)// Same asconst composedHoc = BaseComponent =&gt; hoc1(hoc2(hoc3(BaseComponent))) Most Recompose helpers are functions that return higher-order components: 12345const hoc = mapProps(ownerProps =&gt; childProps)const EnhancedComponent = hoc(BaseComponent)// Same asconst EnhancedComponent = mapProps(ownerProps =&gt; childProps)(BaseComponent) Some, like pure, are higher-order components themselves: 1const PureComponent = pure(BaseComponent) TOC Higher-order components mapProps() withProps() withPropsOnChange() withHandlers() defaultProps() renameProp() renameProps() flattenProp() withState() withStateHandlers() withReducer() branch() renderComponent() renderNothing() shouldUpdate() pure() onlyUpdateForKeys() onlyUpdateForPropTypes() withContext() getContext() lifecycle() toClass() Static property helpers setStatic() setPropTypes() setDisplayName() Utilities compose() getDisplayName() wrapDisplayName() shallowEqual() isClassComponent() createSink() componentFromProp() nest() hoistStatics() Observable utilities componentFromStream() componentFromStreamWithConfig() mapPropsStream() mapPropsStreamWithConfig() createEventHandler() createEventHandlerWithConfig() setObservableConfig() Higher-order componentsmapProps()123mapProps( propsMapper: (ownerProps: Object) =&gt; Object,): HigherOrderComponent Accepts a function that maps owner props to a new collection of props that are passed to the base component. mapProps() pairs well with functional utility libraries like lodash/fp. For example, Recompose does not come with a omitProps() function, but you can easily build one using lodash-fp’s omit(): 1234const omitProps = keys =&gt; mapProps(props =&gt; omit(keys, props))// Because of currying in lodash-fp, this is the same asconst omitProps = compose(mapProps, omit) withProps()123withProps( createProps: (ownerProps: Object) =&gt; Object | Object): HigherOrderComponent Like mapProps(), except the newly created props are merged with the owner props. Instead of a function, you can also pass a props object directly. In this form, it is similar to defaultProps(), except the provided props take precedence over props from the owner. withPropsOnChange()1234withPropsOnChange( shouldMapOrKeys: Array&lt;string&gt; | (props: Object, nextProps: Object) =&gt; boolean, createProps: (ownerProps: Object) =&gt; Object): HigherOrderComponent Like withProps(), except the new props are only created when one of the owner props specified by shouldMapOrKeys changes. This helps ensure that expensive computations inside createProps() are only executed when necessary. Instead of an array of prop keys, the first parameter can also be a function that returns a boolean, given the current props and the next props. This allows you to customize when createProps() should be called. withHandlers()12345678withHandlers( handlerCreators: &#123; [handlerName: string]: (props: Object) =&gt; Function &#125; | handlerCreatorsFactory: (initialProps) =&gt; &#123; [handlerName: string]: (props: Object) =&gt; Function &#125;): HigherOrderComponent Takes an object map of handler creators or a factory function. These are higher-order functions that accept a set of props and return a function handler: This allows the handler to access the current props via closure, without needing to change its signature. Handlers are passed to the base component as immutable props, whose identities are preserved across renders. This avoids a common pitfall where functional components create handlers inside the body of the function, which results in a new handler on every render and breaks downstream shouldComponentUpdate() optimizations that rely on prop equality. This is the main reason to use withHandlers to create handlers instead of using mapProps or withProps, which will create new handlers every time when it get updated. Usage example: 1234567891011121314151617181920const enhance = compose( withState('value', 'updateValue', ''), withHandlers(&#123; onChange: props =&gt; event =&gt; &#123; props.updateValue(event.target.value) &#125;, onSubmit: props =&gt; event =&gt; &#123; event.preventDefault() submitForm(props.value) &#125; &#125;))const Form = enhance((&#123; value, onChange, onSubmit &#125;) =&gt; &lt;form onSubmit=&#123;onSubmit&#125;&gt; &lt;label&gt;Value &lt;input type=\"text\" value=&#123;value&#125; onChange=&#123;onChange&#125; /&gt; &lt;/label&gt; &lt;/form&gt;) defaultProps()123defaultProps( props: Object): HigherOrderComponent Specifies props to be passed by default to the base component. Similar to withProps(), except the props from the owner take precedence over props provided to the HoC. Although it has a similar effect, using the defaultProps() HoC is not the same as setting the static defaultProps property directly on the component. renameProp()1234renameProp( oldName: string, newName: string): HigherOrderComponent Renames a single prop. renameProps()123renameProps( nameMap: &#123; [key: string]: string &#125;): HigherOrderComponent Renames multiple props, using a map of old prop names to new prop names. flattenProp()123flattenProp( propName: string): HigherOrderComponent Flattens a prop so that its fields are spread out into the props object. 12345678910const enhance = compose( withProps(&#123; object: &#123; a: 'a', b: 'b' &#125;, c: 'c' &#125;), flattenProp('object'))const Abc = enhance(BaseComponent)// Base component receives props: &#123; a: 'a', b: 'b', c: 'c', object: &#123; a: 'a', b: 'b' &#125; &#125; An example use case for flattenProp() is when receiving fragment data from Relay. Relay fragments are passed as an object of props, which you often want flattened out into its constituent fields: 123456789// The `post` prop is an object with title, author, and content fieldsconst enhance = flattenProp('post')const Post = enhance((&#123; title, content, author &#125;) =&gt; &lt;article&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;h2&gt;By &#123;author.name&#125;&lt;/h2&gt; &lt;div&gt;&#123;content&#125;&lt;/div&gt; &lt;/article&gt;) withState()12345withState( stateName: string, stateUpdaterName: string, initialState: any | (props: Object) =&gt; any): HigherOrderComponent Passes two additional props to the base component: a state value, and a function to update that state value. The state updater has the following signature: 12stateUpdater&lt;T&gt;((prevValue: T) =&gt; T, ?callback: Function): voidstateUpdater(newValue: any, ?callback: Function): void The first form accepts a function which maps the previous state value to a new state value. You’ll likely want to use this state updater along with withHandlers() to create specific updater functions. For example, to create a HoC that adds basic counting functionality to a component: 12345678const addCounting = compose( withState('counter', 'setCounter', 0), withHandlers(&#123; increment: (&#123; setCounter &#125;) =&gt; () =&gt; setCounter(n =&gt; n + 1), decrement: (&#123; setCounter &#125;) =&gt; () =&gt; setCounter(n =&gt; n - 1), reset: (&#123; setCounter &#125;) =&gt; () =&gt; setCounter(0) &#125;)) The second form accepts a single value, which is used as the new state. Both forms accept an optional second parameter, a callback function that will be executed once setState() is completed and the component is re-rendered. An initial state value is required. It can be either the state value itself, or a function that returns an initial state given the initial props. withStateHandlers()123456withStateHandlers( initialState: Object | (props: Object) =&gt; any, stateUpdaters: &#123; [key: string]: (state:Object, props:Object) =&gt; (...payload: any[]) =&gt; Object &#125;) Passes state object properties and immutable updater functionsin a form of (...payload: any[]) =&gt; Object to the base component. Every state updater function accepts state, props and payload and must return a new state or undefined. The new state is shallowly merged with the previous state.Returning undefined does not cause a component rerender. Example: 1234567891011121314151617181920212223const Counter = withStateHandlers( (&#123; initialCounter = 0 &#125;) =&gt; (&#123; counter: initialCounter, &#125;), &#123; incrementOn: (&#123; counter &#125;) =&gt; (value) =&gt; (&#123; counter: counter + value, &#125;), decrementOn: (&#123; counter &#125;) =&gt; (value) =&gt; (&#123; counter: counter - value, &#125;), resetCounter: (_, &#123; initialCounter = 0 &#125;) =&gt; () =&gt; (&#123; counter: initialCounter, &#125;), &#125;)( (&#123; counter, incrementOn, decrementOn, resetCounter &#125;) =&gt; &lt;div&gt; &lt;Button onClick=&#123;() =&gt; incrementOn(2)&#125;&gt;Inc&lt;/Button&gt; &lt;Button onClick=&#123;() =&gt; decrementOn(3)&#125;&gt;Dec&lt;/Button&gt; &lt;Button onClick=&#123;resetCounter&#125;&gt;Reset&lt;/Button&gt; &lt;/div&gt;) withReducer()123456withReducer&lt;S, A&gt;( stateName: string, dispatchName: string, reducer: (state: S, action: A) =&gt; S, initialState: S | (ownerProps: Object) =&gt; S): HigherOrderComponent Similar to withState(), but state updates are applied using a reducer function. A reducer is a function that receives a state and an action, and returns a new state. Passes two additional props to the base component: a state value, and a dispatch method. The dispatch method sends an action to the reducer, and the new state is applied. branch()12345branch( test: (props: Object) =&gt; boolean, left: HigherOrderComponent, right: ?HigherOrderComponent): HigherOrderComponent Accepts a test function and two higher-order components. The test function is passed the props from the owner. If it returns true, the left higher-order component is applied to BaseComponent; otherwise, the right higher-order component is applied. If the right is not supplied, it will by default render the wrapped component. renderComponent()123renderComponent( Component: ReactClass | ReactFunctionalComponent | string): HigherOrderComponent Takes a component and returns a higher-order component version of that component. This is useful in combination with another helper that expects a higher-order component, like branch(): 1234567891011121314151617181920// `isLoading()` is a function that returns whether or not the component// is in a loading stateconst spinnerWhileLoading = isLoading =&gt; branch( isLoading, renderComponent(Spinner) // `Spinner` is a React component )// Now use the `spinnerWhileLoading()` helper to add a loading spinner to any// base componentconst enhance = spinnerWhileLoading( props =&gt; !(props.title &amp;&amp; props.author &amp;&amp; props.content))const Post = enhance((&#123; title, author, content &#125;) =&gt; &lt;article&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;h2&gt;By &#123;author.name&#125;&lt;/h2&gt; &lt;div&gt;&#123;content&#125;&lt;/div&gt; &lt;/article&gt;) renderNothing()1renderNothing: HigherOrderComponent A higher-order component that always renders null. This is useful in combination with another helper that expects a higher-order component, like branch(): 12345678910111213141516171819// `hasNoData()` is a function that returns true if the component has// no dataconst hideIfNoData = hasNoData =&gt; branch( hasNoData, renderNothing )// Now use the `hideIfNoData()` helper to hide any base componentconst enhance = hideIfNoData( props =&gt; !(props.title &amp;&amp; props.author &amp;&amp; props.content))const Post = enhance((&#123; title, author, content &#125;) =&gt; &lt;article&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;h2&gt;By &#123;author.name&#125;&lt;/h2&gt; &lt;div&gt;&#123;content&#125;&lt;/div&gt; &lt;/article&gt;) shouldUpdate()123shouldUpdate( test: (props: Object, nextProps: Object) =&gt; boolean): HigherOrderComponent Higher-order component version of shouldComponentUpdate(). The test function accepts both the current props and the next props. pure()1pure: HigherOrderComponent Prevents the component from updating unless a prop has changed. Uses shallowEqual() to test for changes. onlyUpdateForKeys()123onlyUpdateForKeys( propKeys: Array&lt;string&gt;): HigherOrderComponent Prevents the component from updating unless a prop corresponding to one of the given keys has updated. Uses shallowEqual() to test for changes. This is a much better optimization than the popular approach of using PureRenderMixin, shouldPureComponentUpdate(), or Recompose’s own pure() helper, because those tools compare every prop, whereas onlyUpdateForKeys() only cares about the props that you specify. Example: 123456789101112131415/** * If the owner passes unnecessary props (say, an array of comments), it will * not lead to wasted render cycles. * * Goes well with destructuring because it's clear which props the component * actually cares about. */const enhance = onlyUpdateForKeys(['title', 'content', 'author'])const Post = enhance((&#123; title, content, author &#125;) =&gt; &lt;article&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;h2&gt;By &#123;author.name&#125;&lt;/h2&gt; &lt;div&gt;&#123;content&#125;&lt;/div&gt; &lt;/article&gt;) onlyUpdateForPropTypes()1onlyUpdateForPropTypes: HigherOrderComponent Works like onlyUpdateForKeys(), but prop keys are inferred from the propTypes of the base component. Useful in conjunction with setPropTypes(). If the base component does not have any propTypes, the component will never receive any updates. This probably isn’t the expected behavior, so a warning is printed to the console. 123456789101112131415161718import PropTypes from 'prop-types'; // You need to import prop-types. See https://facebook.github.io/react/docs/typechecking-with-proptypes.htmlconst enhance = compose( onlyUpdateForPropTypes, setPropTypes(&#123; title: PropTypes.string.isRequired, content: PropTypes.string.isRequired, author: PropTypes.object.isRequired &#125;))const Post = enhance((&#123; title, content, author &#125;) =&gt; &lt;article&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;h2&gt;By &#123;author.name&#125;&lt;/h2&gt; &lt;div&gt;&#123;content&#125;&lt;/div&gt; &lt;/article&gt;) withContext()1234withContext( childContextTypes: Object, getChildContext: (props: Object) =&gt; Object): HigherOrderComponent Provides context to the component’s children. childContextTypes is an object of React prop types. getChildContext() is a function that returns the child context. Use along with getContext(). getContext()123getContext( contextTypes: Object): HigherOrderComponent Gets values from context and passes them along as props. Use along with withContext(). lifecycle()123lifecycle( spec: Object,): HigherOrderComponent A higher-order component version of React.Component(). It supports the entire Component API, except the render() method, which is implemented by default (and overridden if specified; an error will be logged to the console). You should use this helper as an escape hatch, in case you need to access component lifecycle methods. Any state changes made in a lifecycle method, by using setState, will be propagated to the wrapped component as props. Example:1234567891011const PostsList = (&#123; posts &#125;) =&gt; ( &lt;ul&gt;&#123;posts.map(p =&gt; &lt;li&gt;&#123;p.title&#125;&lt;/li&gt;)&#125;&lt;/ul&gt;)const PostsListWithData = lifecycle(&#123; componentDidMount() &#123; fetchPosts().then(posts =&gt; &#123; this.setState(&#123; posts &#125;); &#125;) &#125;&#125;)(PostsList); toClass()1toClass: HigherOrderComponent Takes a function component and wraps it in a class. This can be used as a fallback for libraries that need to add a ref to a component, like Relay. If the base component is already a class, it returns the given component. Static property helpersThese functions look like higher-order component helpers — they are curried and component-last. However, rather than returning a new component, they mutate the base component by setting or overriding a static property. setStatic()1234setStatic( key: string, value: any): HigherOrderComponent Assigns a value to a static property on the base component. setPropTypes()123setPropTypes( propTypes: Object): HigherOrderComponent Assigns to the propTypes property on the base component. setDisplayName()123setDisplayName( displayName: string): HigherOrderComponent Assigns to the displayName property on the base component. UtilitiesRecompose also includes some additional helpers that aren’t higher-order components, but are still useful. compose()1compose(...functions: Array&lt;Function&gt;): Function Use to compose multiple higher-order components into a single higher-order component. This works exactly like the function of the same name in Redux, or lodash’s flowRight(). getDisplayName()123getDisplayName( component: ReactClass | ReactFunctionalComponent): string Returns the display name of a React component. Falls back to &#39;Component&#39;. wrapDisplayName()1234wrapDisplayName( component: ReactClass | ReactFunctionalComponent, wrapperName: string): string Returns a wrapped version of a React component’s display name. For instance, if the display name of component is &#39;Post&#39;, and wrapperName is &#39;mapProps&#39;, the return value is &#39;mapProps(Post)&#39;. Most Recompose higher-order components use wrapDisplayName(). shallowEqual()1shallowEqual(a: Object, b: Object): boolean Returns true if objects are shallowly equal. isClassComponent()1isClassComponent(value: any): boolean Returns true if the given value is a React component class. createSink()1createSink(callback: (props: Object) =&gt; void): ReactClass Creates a component that renders nothing (null) but calls a callback when receiving new props. componentFromProp()1componentFromProp(propName: string): ReactFunctionalComponent Creates a component that accepts a component as a prop and renders it with the remaining props. Example: 123456const enhance = defaultProps(&#123; component: 'button' &#125;)const Button = enhance(componentFromProp('component'))&lt;Button foo=\"bar\" /&gt; // renders &lt;button foo=\"bar\" /&gt;&lt;Button component=\"a\" foo=\"bar\" /&gt; // renders &lt;a foo=\"bar\" /&gt;&lt;Button component=&#123;Link&#125; foo=\"bar\" /&gt; // renders &lt;Link foo=\"bar\" /&gt; nest()123nest( ...Components: Array&lt;ReactClass | ReactFunctionalComponent | string&gt;): ReactClass Composes components by nesting each one inside the previous. For example: 123456789101112// Given components A, B, and Cconst ABC = nest(A, B, C)&lt;ABC pass=\"through\"&gt;Child&lt;/ABC&gt;// Effectively the same as&lt;A pass=\"through\"&gt; &lt;B pass=\"through\"&gt; &lt;C pass=\"through\"&gt; Child &lt;/C&gt; &lt;/B&gt;&lt;/A&gt; hoistStatics()1hoistStatics(hoc: HigherOrderComponent): HigherOrderComponent Augments a higher-order component so that when used, it copies non-react static properties from the base component to the new component. This is helpful when using Recompose with libraries like Relay. Note that this only hoists non-react statics. The following static properties will not be hoisted: childContextTypes, contextTypes, defaultProps, displayName, getDefaultProps, mixins, propTypes, and type. The following native static methods will also be ignored: name, length, prototype, caller, arguments, and arity. Observable utilitiesIt turns out that much of the React Component API can be expressed in terms of observables: Instead of setState(), combine multiple streams together. Instead of getInitialState(), use startWith() or concat(). Instead of shouldComponentUpdate(), use distinctUntilChanged(), debounce(), etc. Other benefits include: No distinction between state and props – everything is a stream. No need to worry about unsubscribing from event listeners. Subscriptions are handled for you. Sideways data loading is trivial – just combine the props stream with an external stream. Access to an ecosystem of observable libraries, such as RxJS. Recompose’s observable utilities can be configured to work with any observable or stream-like library. See setObservableConfig() below for details. componentFromStream()123componentFromStream( propsToReactNode: (props$: Observable&lt;object&gt;) =&gt; Observable&lt;ReactNode&gt;): ReactComponent Creates a React component by mapping an observable stream of props to a stream of React nodes (vdom). You can think of propsToReactNode as a function f such that 1const vdom$ = f(props$) where props$ is a stream of props and vdom$ is a stream of React nodes. This formulation similar to the popular notion of React views as a function, often communicated as 1v = f(d) Example: 1234567891011121314151617181920const Counter = componentFromStream(props$ =&gt; &#123; const &#123; handler: increment, stream: increment$ &#125; = createEventHandler() const &#123; handler: decrement, stream: decrement$ &#125; = createEventHandler() const count$ = Observable.merge( increment$.mapTo(1), decrement$.mapTo(-1) ) .startWith(0) .scan((count, n) =&gt; count + n, 0) return props$.combineLatest( count$, (props, count) =&gt; &lt;div &#123;...props&#125;&gt; Count: &#123;count&#125; &lt;button onClick=&#123;increment&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;decrement&#125;&gt;-&lt;/button&gt; &lt;/div&gt; )&#125;) componentFromStreamWithConfig()12345678componentFromStreamWithConfig&lt;Stream&gt;( config: &#123; fromESObservable&lt;T&gt;: ?(observable: Observable&lt;T&gt;) =&gt; Stream&lt;T&gt;, toESObservable&lt;T&gt;: ?(stream: Stream&lt;T&gt;) =&gt; Observable&lt;T&gt;, &#125;) =&gt; ( propsToReactNode: (props$: Stream&lt;object&gt;) =&gt; Stream&lt;ReactNode&gt;): ReactComponent Alternative to componentFromStream() that accepts an observable config and returns a customized componentFromStream() which uses the specified observable library. This option is recommended if you want to avoid global state with setObservableConfig(). Note: The following configuration modules are not included in the main export. You must import them individually, as shown in the examples. RxJS12import rxjsConfig from 'recompose/rxjsObservableConfig'const componentFromStream = componentFromStreamWithConfig(rxjsConfig) RxJS 4 (legacy)12import rxjs4Config from 'recompose/rxjs4ObservableConfig'const componentFromStream = componentFromStreamWithConfig(rxjs4Config) most12import mostConfig from 'recompose/mostObservableConfig'const componentFromStream = componentFromStreamWithConfig(mostConfig) xstream12import xstreamConfig from 'recompose/xstreamObservableConfig'const componentFromStream = componentFromStreamWithConfig(xstreamConfig) Bacon12import baconConfig from 'recompose/baconObservableConfig'const componentFromStream = componentFromStreamWithConfig(baconConfig) Kefir12import kefirConfig from 'recompose/kefirObservableConfig'const componentFromStream = componentFromStreamWithConfig(kefirConfig) Flyd12import flydConfig from 'recompose/flydObservableConfig'const componentFromStream = componentFromStreamWithConfig(flydConfig) mapPropsStream()1234mapPropsStream( ownerPropsToChildProps: (props$: Observable&lt;object&gt;) =&gt; Observable&lt;object&gt;, BaseComponent: ReactElementType): ReactComponent A higher-order component version of componentFromStream() — accepts a function that maps an observable stream of owner props to a stream of child props, rather than directly to a stream of React nodes. The child props are then passed to a base component. You may want to use this version to interoperate with other Recompose higher-order component helpers. mapPropsStreamWithConfig()123456789mapPropsStreamWithConfig&lt;Stream&gt;( config: &#123; fromESObservable&lt;T&gt;: ?(observable: Observable&lt;T&gt;) =&gt; Stream&lt;T&gt;, toESObservable&lt;T&gt;: ?(stream: Stream&lt;T&gt;) =&gt; Observable&lt;T&gt;, &#125;,) =&gt; ( ownerPropsToChildProps: (props$: Stream&lt;object&gt;) =&gt; Stream&lt;object&gt;, BaseComponent: ReactElementType): ReactComponent Alternative to mapPropsStream() that accepts a observable config and returns a customized mapPropsStream() that uses the specified observable library. See componentFromStreamWithConfig() above. 1234567891011const enhance = mapPropsStream(props$ =&gt; &#123; const timeElapsed$ = Observable.interval(1000) return props$.combineLatest(timeElapsed$, (props, timeElapsed) =&gt; (&#123; ...props, timeElapsed &#125;))&#125;)const Timer = enhance((&#123; timeElapsed &#125;) =&gt; &lt;div&gt;Time elapsed: &#123;timeElapsed&#125;&lt;/div&gt;) createEventHandler()1234createEventHandler&lt;T&gt;(): &#123; handler: (value: T) =&gt; void, stream: Observable&lt;T&gt;&#125; Returns an object with properties handler and stream. stream is an observable sequence, and handler is a function that pushes new values onto the sequence. Useful for creating event handlers like onClick. createEventHandlerWithConfig()123456789createEventHandlerWithConfig&lt;T&gt;( config: &#123; fromESObservable&lt;T&gt;: ?(observable: Observable&lt;T&gt;) =&gt; Stream&lt;T&gt;, toESObservable&lt;T&gt;: ?(stream: Stream&lt;T&gt;) =&gt; Observable&lt;T&gt;, &#125;) =&gt; (): &#123; handler: (value: T) =&gt; void, stream: Observable&lt;T&gt;&#125; Alternative to createEventHandler() that accepts an observable config and returns a customized createEventHandler() that uses the specified observable library. See componentFromStreamWithConfig() above. setObservableConfig()1234setObservableConfig&lt;Stream&gt;(&#123; fromESObservable&lt;T&gt;: ?(observable: Observable&lt;T&gt;) =&gt; Stream&lt;T&gt;, toESObservable&lt;T&gt;: ?(stream: Stream&lt;T&gt;) =&gt; Observable&lt;T&gt;&#125;) Note: setObservableConfig() uses global state, and could break apps if used inside a package intended to be shared. See componentFromStreamWithConfig() and mapPropsStreamWithConfig() as alternatives for package authors. Observables in Recompose are plain objects that conform to the ES Observable proposal. Usually, you’ll want to use them alongside an observable library like RxJS so that you have access to its suite of operators. By default, this requires you to convert the observables provided by Recompose before applying any transforms: 12345mapPropsStream(props$ =&gt; &#123; const rxjsProps$ = Rx.Observable.from(props$) // ...now you can use map, filter, scan, etc. return transformedProps$&#125;) This quickly becomes tedious. Rather than performing this transform for each stream individually, setObservableConfig() sets a global observable transform that is applied automatically. 1234567import Rx from 'rxjs'import &#123; setObservableConfig &#125; from 'recompose'setObservableConfig(&#123; // Converts a plain ES observable to an RxJS 5 observable fromESObservable: Rx.Observable.from&#125;) In addition to fromESObservable, the config object also accepts toESObservable, which converts a stream back into an ES observable. Because RxJS 5 observables already conform to the ES observable spec, toESObservable is not necessary in the above example. However, it is required for libraries like RxJS 4 or xstream, whose streams do not conform to the ES observable spec. Fortunately, you likely don’t need to worry about how to configure Recompose for your favorite stream library, because Recompose provides drop-in configuration for you. Note: The following configuration modules are not included in the main export. You must import them individually, as shown in the examples. RxJS12import rxjsconfig from 'recompose/rxjsObservableConfig'setObservableConfig(rxjsconfig) RxJS 4 (legacy)12import rxjs4config from 'recompose/rxjs4ObservableConfig'setObservableConfig(rxjs4config) most12import mostConfig from 'recompose/mostObservableConfig'setObservableConfig(mostConfig) xstream12import xstreamConfig from 'recompose/xstreamObservableConfig'setObservableConfig(xstreamConfig) Bacon12import baconConfig from 'recompose/baconObservableConfig'setObservableConfig(baconConfig) Kefir12import kefirConfig from 'recompose/kefirObservableConfig'setObservableConfig(kefirConfig) Flyd12import flydConfig from 'recompose/flydObservableConfig'setObservableConfig(flydConfig)","categories":[{"name":"Readme","slug":"Readme","permalink":"https://React-Apollo.github.io/categories/Readme/"}],"tags":[{"name":"Recompose","slug":"Recompose","permalink":"https://React-Apollo.github.io/tags/Recompose/"},{"name":"hoc","slug":"hoc","permalink":"https://React-Apollo.github.io/tags/hoc/"}]},{"title":"翻译| Simplify your React components with Apollo and Recompose","slug":"翻译| Simplify your React components with Apollo and Recompose","date":"2018-02-02T19:14:54.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/02/02/翻译| Simplify your React components with Apollo and Recompose/","link":"","permalink":"https://React-Apollo.github.io/2018/02/02/翻译| Simplify your React components with Apollo and Recompose/","excerpt":"","text":"使用 Apollo和 Recompse 来简化 React 组件使用 hoc 保持组件的纯度Apollo client和 Apollo项目的任务之一就是和现代的 React开发者工具无缝对接.这就是卫生我们专注于higher-order components(高阶组件), server-side rendering(服务端渲染),和React Native的原因. 随着日益发展, React的开发者现在集中于开发更小巧,焦点更加集中的组件,由Andrew Clark 创建的Recompose库把这种趋势提高到了更高的高度.当 Andrew Clark 去年在 React Europe 做演讲的时候,他把 Recompose看做是类似 Underscore 和 Lodash 之类的工具集,目标是专门用于 React的组件的开发. 下面是你可以通过 Recompose 所做的事情: 通过纯粹的渲染,优化 React 组件 设定默认值 添加限制性 state 变量 通过使用 React函数式组件的语法,你可以做完成上面的任务.这么做是的代码更加直白,减少了在组件渲染时不小心引入的 state或者复杂度. 经过 React-apollo包装的的 React 高阶组件符合这种模式.这些组件只是把一件事做的非常好:即他们让你可以把 GraphQl查询和组件放在一起,并且通过 props 获得数据.其他的事情一概不做,例如管理变量的状态.这时候, React 组件组合, Recompose就可以派上用场了. 纷繁芜杂不见了,这里是第一个如何共同使用 Recompose 和 React apollo 的实例.Recompose 和 React apollo一起使拥有 GraphQl 的 UI简明,漂亮. 使用withState管理变量函数式组件最好的特征是他们是无状态的.意思是如果提供一套同样的props,你总是会得到同样的输出结果,这样就使得组件容易预测和测试.然而,有时候,你还是需要使用一些临时的 state,组好是能把这些东西放在执行渲染的组件之外,保持事情简单化. 让我们来看看如何使用withState容器构建一个具有搜索框(search box)和 Graphql 查询的 React 组件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import React from 'react';import &#123; withState, pure, compose &#125; from 'recompose';import gql from 'graphql-tag';import &#123; graphql &#125; from 'react-apollo';import &#123; Link &#125; from 'react-router';// The data prop, which is provided by the wrapper below, contains// a `loading` key while the query is in flight, and the bookSearch// results when they are readyconst BookSearchResultsPure = (&#123; data: &#123; loading, bookSearch &#125; &#125;) =&gt; &#123; if (loading) &#123; return &lt;div&gt;Loading&lt;/div&gt;; &#125; else &#123; return ( &lt;ul&gt; &#123;bookSearch.map(book =&gt; &lt;li key=&#123;book.id&#125;&gt; &lt;Link to=&#123;`/details/$&#123;book.id&#125;`&#125;&gt; &#123;book.title&#125; by &#123;book.author.name&#125; &lt;/Link&gt; &lt;/li&gt; )&#125; &lt;/ul&gt; ); &#125;&#125;;// The `graphql` wrapper executes a GraphQL query and makes the results// available on the `data` prop of the wrapped component.//// Note that if you type a search field and then hit backspace, the// Apollo cache kicks in and no actual data loading is done.const data = graphql(gql` query BookSearchQuery($keyword: String!) &#123; bookSearch(keyword: $keyword) &#123; id image title author &#123; id name &#125; &#125; &#125;`, &#123; // The variable $keyword for the query is computed from the // React props passed to this container. options: (props) =&gt; (&#123; variables: &#123; keyword: props.keyword &#125;, &#125;),&#125;);// Attach the data HoC to the pure componentconst BookSearchResults = compose( data, pure,)(BookSearchResultsPure);// Use recompose to keep the state of the input so that we// can use functional component syntaxconst keyword = withState('keyword', 'setKeyword', '');const BookSearchPure = (&#123; keyword, setKeyword &#125;) =&gt; ( &lt;div&gt; &lt;input type=\"text\" value=&#123; keyword &#125; onChange=&#123;(e) =&gt; setKeyword(e.target.value)&#125; /&gt; &lt;BookSearchResults keyword=&#123;keyword&#125; /&gt; &lt;/div&gt;);// Attach the state to the pure componentconst BookSearch = compose( keyword, pure,)(BookSearchPure);export default BookSearch; import TodoList from ‘../components/TodoList/TodoList’const Comp=(todos)=&gt; function mapStateToProps(store) { return { todos: store.todolist };} export default connect(mapStateToProps)(Comp);","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"},{"name":"Recompose","slug":"Recompose","permalink":"https://React-Apollo.github.io/tags/Recompose/"},{"name":"hoc","slug":"hoc","permalink":"https://React-Apollo.github.io/tags/hoc/"}]},{"title":"Redux-action readme","slug":"redux-actions","date":"2018-02-01T11:13:31.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2018/02/01/redux-actions/","link":"","permalink":"https://React-Apollo.github.io/2018/02/01/redux-actions/","excerpt":"","text":"redux-actions Flux Standard Action utilities for Redux. Installation1npm install --save redux-actions The npm package provides a CommonJS build for use in Node.js, and with bundlers like Webpack and Browserify. It also includes an ES modules build that works well with Rollup and Webpack2‘s tree-shaking. If you don’t use npm, you may grab the latest UMD build from unpkg (either a development or a production build). The UMD build exports a global called window.ReduxActions if you add it to your page via a &lt;script&gt; tag. We don’t recommend UMD builds for any serious application, as most of the libraries complementary to Redux are only available on npm. UsagecreateAction(type, payloadCreator = Identity, ?metaCreator)1import &#123; createAction &#125; from 'redux-actions'; Wraps an action creator so that its return value is the payload of a Flux Standard Action. payloadCreator must be a function, undefined, or null. If payloadCreator is undefined or null, the identity function is used. Example: 12345678let increment = createAction('INCREMENT', amount =&gt; amount);// same asincrement = createAction('INCREMENT');expect(increment(42)).to.deep.equal(&#123; type: 'INCREMENT', payload: 42&#125;); If the payload is an instance of an Errorobject,redux-actions will automatically set to true.123456789101112Example:```jsconst increment = createAction(&apos;INCREMENT&apos;);const error = new TypeError(&apos;not a number&apos;);expect(increment(error)).to.deep.equal(&#123; type: &apos;INCREMENT&apos;, payload: error, error: true&#125;); createAction also returns its type when used as type in handleAction or handleActions. Example: 1234567891011121314const increment = createAction('INCREMENT');// As parameter in handleAction:handleAction(increment, &#123; next(state, action) &#123;...&#125;, throw(state, action) &#123;...&#125;&#125;);// As object key in handleActions:const reducer = handleActions(&#123; [increment]: (state, action) =&gt; (&#123; counter: state.counter + action.payload &#125;)&#125;, &#123; counter: 0 &#125;); NOTE: The more correct name for this function is probably createActionCreator(), but that seems a bit redundant. Use the identity form to create one-off actions: 1createAction('ADD_TODO')('Use Redux'); metaCreator is an optional function that creates metadata for the payload. It receives the same arguments as the payload creator, but its result becomes the meta field of the resulting action. If metaCreator is undefined or not a function, the meta field is omitted. createActions(?actionMap, ?...identityActions)1import &#123; createActions &#125; from 'redux-actions'; Returns an object mapping action types to action creators. The keys of this object are camel-cased from the keys in actionMap and the string literals of identityActions; the values are the action creators. actionMap is an optional object and a recursive data structure, with action types as keys, and whose values must be either a function, which is the payload creator for that action an array with payload and meta functions in that order, as in createAction meta is required in this case (otherwise use the function form above) an actionMap identityActions is an optional list of positional string arguments that are action type strings; these action types will use the identity payload creator. 12345678910111213141516171819202122232425262728const &#123; actionOne, actionTwo, actionThree &#125; = createActions(&#123; // function form; payload creator defined inline ACTION_ONE: (key, value) =&gt; (&#123; [key]: value &#125;), // array form ACTION_TWO: [ (first) =&gt; [first], // payload (first, second) =&gt; (&#123; second &#125;) // meta ], // trailing action type string form; payload creator is the identity&#125;, 'ACTION_THREE');expect(actionOne('key', 1)).to.deep.equal(&#123; type: 'ACTION_ONE', payload: &#123; key: 1 &#125;&#125;);expect(actionTwo('first', 'second')).to.deep.equal(&#123; type: 'ACTION_TWO', payload: ['first'], meta: &#123; second: 'second' &#125;&#125;);expect(actionThree(3)).to.deep.equal(&#123; type: 'ACTION_THREE', payload: 3,&#125;); If actionMap has a recursive structure, its leaves are used as payload and meta creators, and the action type for each leaf is the combined path to that leaf: 123456789101112131415161718192021222324252627282930const actionCreators = createActions(&#123; APP: &#123; COUNTER: &#123; INCREMENT: [ amount =&gt; (&#123; amount &#125;), amount =&gt; (&#123; key: 'value', amount &#125;) ], DECREMENT: amount =&gt; (&#123; amount: -amount &#125;) &#125;, NOTIFY: [ (username, message) =&gt; (&#123; message: `$&#123;username&#125;: $&#123;message&#125;` &#125;), (username, message) =&gt; (&#123; username, message &#125;) ] &#125;&#125;);expect(actionCreators.app.counter.increment(1)).to.deep.equal(&#123; type: 'APP/COUNTER/INCREMENT', payload: &#123; amount: 1 &#125;, meta: &#123; key: 'value', amount: 1 &#125;&#125;);expect(actionCreators.app.counter.decrement(1)).to.deep.equal(&#123; type: 'APP/COUNTER/DECREMENT', payload: &#123; amount: -1 &#125;&#125;);expect(actionCreators.app.notify('yangmillstheory', 'Hello World')).to.deep.equal(&#123; type: 'APP/NOTIFY', payload: &#123; message: 'yangmillstheory: Hello World' &#125;, meta: &#123; username: 'yangmillstheory', message: 'Hello World' &#125;&#125;); When using this form, you can pass an object with key namespace as the last positional argument, instead of the default /. handleAction(type, reducer | reducerMap = Identity, defaultState)1import &#123; handleAction &#125; from 'redux-actions'; Wraps a reducer so that it only handles Flux Standard Actions of a certain type. If a reducer function is passed, it is used to handle both normal actions and failed actions. (A failed action is analogous to a rejected promise.) You can use this form if you know a certain type of action will never fail, like the increment example above. Otherwise, you can specify separate reducers for next() and throw() using the reducerMap form. This API is inspired by the ES6 generator interface. 1234handleAction('FETCH_DATA', &#123; next(state, action) &#123;...&#125;, throw(state, action) &#123;...&#125;&#125;, defaultState); If either next() or throw() are undefined or null, then the identity function is used for that reducer. If the reducer argument (reducer | reducerMap) is undefined, then the identity function is used. The third parameter defaultState is required, and is used when undefined is passed to the reducer. handleActions(reducerMap, defaultState)1import &#123; handleActions &#125; from 'redux-actions'; Creates multiple reducers using handleAction() and combines them into a single reducer that handles multiple actions. Accepts a map where the keys are passed as the first parameter to handleAction() (the action type), and the values are passed as the second parameter (either a reducer or reducer map). The map must not be empty. The second parameter defaultState is required, and is used when undefined is passed to the reducer. (Internally, handleActions() works by applying multiple reducers in sequence using reduce-reducers.) Example: 123456789const reducer = handleActions(&#123; INCREMENT: (state, action) =&gt; (&#123; counter: state.counter + action.payload &#125;), DECREMENT: (state, action) =&gt; (&#123; counter: state.counter - action.payload &#125;)&#125;, &#123; counter: 0 &#125;); combineActions(...types)Combine any number of action types or action creators. types is a list of positional arguments which can be action type strings, symbols, or action creators. This allows you to reduce multiple distinct actions with the same reducer. 1234567891011121314const &#123; increment, decrement &#125; = createActions(&#123; INCREMENT: amount =&gt; (&#123; amount &#125;), DECREMENT: amount =&gt; (&#123; amount: -amount &#125;),&#125;)const reducer = handleAction(combineActions(increment, decrement), &#123; next: (state, &#123; payload: &#123; amount &#125; &#125;) =&gt; (&#123; ...state, counter: state.counter + amount &#125;), throw: state =&gt; (&#123; ...state, counter: 0 &#125;),&#125;, &#123; counter: 10 &#125;)expect(reducer(undefined, increment(1)).to.deep.equal(&#123; counter: 11 &#125;)expect(reducer(undefined, decrement(1)).to.deep.equal(&#123; counter: 9 &#125;)expect(reducer(undefined, increment(new Error)).to.deep.equal(&#123; counter: 0 &#125;)expect(reducer(undefined, decrement(new Error)).to.deep.equal(&#123; counter: 0 &#125;) Here’s an example using handleActions: 123456789101112131415const &#123; increment, decrement &#125; = createActions(&#123; INCREMENT: amount =&gt; (&#123; amount &#125;), DECREMENT: amount =&gt; (&#123; amount: -amount &#125;)&#125;);const reducer = handleActions(&#123; [combineActions(increment, decrement)](state, &#123; payload: &#123; amount &#125; &#125;) &#123; return &#123; ...state, counter: state.counter + amount &#125;; &#125;&#125;, &#123; counter: 10 &#125;);expect(reducer(&#123; counter: 5 &#125;, increment(5))).to.deep.equal(&#123; counter: 10 &#125;);expect(reducer(&#123; counter: 5 &#125;, decrement(5))).to.deep.equal(&#123; counter: 0 &#125;);expect(reducer(&#123; counter: 5 &#125;, &#123; type: 'NOT_TYPE', payload: 1000 &#125;)).to.equal(&#123; counter: 5 &#125;);expect(reducer(undefined, increment(5))).to.deep.equal(&#123; counter: 15 &#125;); Usage with middlewareredux-actions is handy all by itself, however, its real power comes when you combine it with middleware. The identity form of createAction is a great way to create a single action creator that handles multiple payload types. For example, using redux-promise and redux-rx: 1234567891011121314151617const addTodo = createAction('ADD_TODO');// A single reducer...handleAction('ADD_TODO', (state = &#123; todos: [] &#125;, action) =&gt; (&#123; ...state, todos: [...state.todos, action.payload]&#125;));// ...that works with all of these forms:// (Don't forget to use `bindActionCreators()` or equivalent.// I've left that bit out)addTodo('Use Redux')addTodo(Promise.resolve('Weep with joy'));addTodo(Observable.of( 'Learn about middleware', 'Learn about higher-order stores')).subscribe(); See alsoUse redux-actions in combination with FSA-compliant libraries. redux-promise - Promise middleware redux-rx - Includes observable middleware.","categories":[{"name":"readme","slug":"readme","permalink":"https://React-Apollo.github.io/categories/readme/"}],"tags":[{"name":"react","slug":"react","permalink":"https://React-Apollo.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"https://React-Apollo.github.io/tags/redux/"}]},{"title":"React Navigation导航的模板","slug":"React-Navigation嵌套导航版本","date":"2018-02-01T10:20:45.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2018/02/01/React-Navigation嵌套导航版本/","link":"","permalink":"https://React-Apollo.github.io/2018/02/01/React-Navigation嵌套导航版本/","excerpt":"","text":"根据 GitPoint来的多层嵌套的导航版本大体的路径是 进入 splash 界面, componentDidMount 周期中对用于登录信息进行查找和判断,如果是为登录就跳到登录界面,如果登录就跳到主界面这个三个文件作为入口的 StackNavigator: 123456789101112131415161718192021222324252627282930//这个文件单独建立, route.js,在 app.js 中 导入 NavEntryPoint 就可以了export const NavEntryPoint = StackNavigator( &#123; Splash: &#123; screen: SplashScreen, navigationOptions: &#123; header: null, &#125;, &#125;, Login: &#123; screen: LoginScreen, navigationOptions: &#123; header: null, &#125;, &#125;, Main: &#123; screen: MainTabNavigator, navigationOptions: &#123; header: null, &#125;, &#125;, &#125;, &#123; headerMode: 'screen', URIPrefix: 'gitpoint://', cardStyle: &#123; backgroundColor: '#c397d8', &#125;, &#125;); login如果登录成功,也跳转到主界面 主界面TabNavigator主界面是 TabNavigator,由单独的 StackNavigator 构成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const MainTabNavigator=TabNavigator(&#123; Home: &#123; screen: HomeStackNavigator, navigationOptions: &#123; tabBarLabel: 'Home', tabBarIcon: (&#123; tintColor, focused &#125;) =&gt; ( &lt;Image source=&#123;focused?require('./app/assets/tabs/tab-icon1/active.png'):require('./app/assets/tabs/tab-icon1/default.png')&#125; /&gt; ),header: null, &#125;, &#125;, About:&#123; screen :AboutStackNavigator, navigationOptions: &#123; tabBarLabel: 'About', tabBarIcon: (&#123; tintColor, focused &#125;) =&gt; ( &lt;Image source=&#123;focused?require('./app/assets/tabs/tab-icon2/active.png'):require('./app/assets/tabs/tab-icon2/default.png')&#125; /&gt; ),header: null, &#125;, &#125;, Contact:&#123; screen :ContactStackNavigator, navigationOptions: &#123; tabBarLabel: 'Contact', tabBarIcon: (&#123; tintColor, focused &#125;) =&gt; ( &lt;Image source=&#123;focused?require('./app/assets/tabs/tab-icon5/active.png'):require('./app/assets/tabs/tab-icon5/default.png')&#125; /&gt; ),header: null, &#125;, &#125;, More:&#123; screen :MoreStackNavigator, navigationOptions: &#123; tabBarLabel: 'More', tabBarIcon: (&#123; tintColor, focused &#125;) =&gt; ( &lt;Image source=&#123;focused?require('./app/assets/tabs/tab-icon3/active.png'):require('./app/assets/tabs/tab-icon3/default.png')&#125; /&gt; ),header: null, &#125;, &#125;, &#125;, &#123; tabBarPosition: 'bottom', animationEnabled: false, tabBarOptions: &#123; activeTintColor: '#e91e63', &#125;, &#125;) 以上两部分,定制好以后,就可以不动了,主要的页面的添加都是在四个 StackNavigator 中进行的. 承载主要功能页面的StackNavigator123456789101112131415161718192021import &#123;tab1,list1 &#125; from './app/tab1';const HomeStackNavigator = StackNavigator( &#123; Home: &#123; screen: tab1, navigationOptions: &#123; headerTitle: 'Tab1', &#125;, &#125;, List1: &#123; screen: list1, navigationOptions: &#123; headerTitle: 'list1', &#125;, &#125;, &#125;, &#123; headerMode: 'screen', &#125;); 每个Tab 下的功能就在这里扩展,按照 GitPoint 的思路,有一些公共的页面,可以用 shareRoute 的形式,导入到单个 Tab的 StackNavigator下面. 这就是完整的 React Navigation嵌套导航的模板,基本的 APP都可以直接套用了","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React-native","slug":"React-native","permalink":"https://React-Apollo.github.io/tags/React-native/"}]},{"title":"Transducer 关键代码的解析","slug":"Transducer 原理的解释代码","date":"2018-01-31T19:05:07.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2018/01/31/Transducer 原理的解释代码/","link":"","permalink":"https://React-Apollo.github.io/2018/01/31/Transducer 原理的解释代码/","excerpt":"","text":"代码块12345678910111213141516171819202122const mapping = (f) =&gt; (reducing) =&gt; (result, input) =&gt; reducing(result, f(input));const filtering = (predicate ) =&gt; (reducing) =&gt; (result, input) =&gt; predicate(input) ? reducing(result, input) : result;//2 mapping((x) =&gt; x + 1)(filtering((x) =&gt; x % 2 === 0)((xs, x) =&gt; &#123; xs.push(x); return xs;&#125;));mapping(fn)(reducing) ====&gt; reducuing(result, fn(input))在flitering 中 ， fn(input)就作为filtering的 input了 predicate(fn(input))const xform = R.compose( mapping((x) =&gt; x + 1), filtering((x) =&gt; x % 2 === 0), mapping((x=&gt;x*x)) ); 解释mapping,filter 函数上例中的mapping 函数和 filter 函数都是 Reducer函数 mapping 函数的传入 fn 作为处理遍历数组值的函数,result是作为accum 变量, input作为数组的初始值. reducing就是 reducer 函数.上面的代码可以改写为:1mapping(fn)(reducing) ==可以变化为reducer的标准模式==&gt; reducuing(result, fn(input)) 传入的 fn先对输入的数组元素做一下应用.然后再执行 reduce的操作. 实际如果 reducing 函数之前 compose 了很多的函数,那个都会传入到compose时，filtering就作为 mapping 的reducing传入。和上面的方式是一样的 。这里有点绕， 还是高阶函数的问题。compose函数时， 方向从左向右， 但是 transducing中compose的最后一个函数是作为fn传递给后面的reducing函数的。这个地方就是理解transducer的难点。 compose的方向和reducing中的方向是不同的。","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"hoc","slug":"hoc","permalink":"https://React-Apollo.github.io/tags/hoc/"},{"name":"transducer","slug":"transducer","permalink":"https://React-Apollo.github.io/tags/transducer/"}]},{"title":"翻译|The Elegance Of React","slug":"The Elegance Of React","date":"2018-01-30T08:17:07.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2018/01/30/The Elegance Of React/","link":"","permalink":"https://React-Apollo.github.io/2018/01/30/The Elegance Of React/","excerpt":"","text":"原文参见 内容 General Compose组件 Compose和组件的限制 Reducing组件 Adding ReduxGeneral 本篇文章着眼是如何编写优雅的 React 代码.我们会结合 React和Ramda,以函数式风格来编写应用.所有的概念对于 lodash/fp其他的函数式编程库也是适合的.关键在于你使用哪种库. 本文示例使用*eslint-config-cleanjs*,来强化函数式风格,其中包括no-this和no-classes规则.这些函数式规则可以让我在开始下面的示例时采用更规范.如果你对配置感兴趣,可以到 github 仓库看看具体的规则设置 Compose组件让我们从更为容易接受的方法开始吧!看看下面的代码: 1const comp=(f,g)=&gt;x=&gt;f(g(x)) 如果是组件,实现代码是这样的: 1const TodoList=(List,mapItems)=&gt;s=&gt;List(mapItems(s)) 这么做就有意义了,可以让我们通过compose小的组件来构建更大的组件. 1234const List = c =&gt; &lt;ul&gt;&#123;c&#125;&lt;/ul&gt;const Item = todo =&gt; &lt;li key=&#123;todo.id&#125;&gt;&#123;todo.name&#125;&lt;/li&gt;const TodoList = compose(List, map(Item))const result = TodoList([&#123;id: 1, name: 'foo'&#125;]) TodoList是一个函数等待应用的 state并且根据对应的 state 返回新的组件.代码非常简洁,有意义.我们遍历了一些 todo 的条目,并由此创建Item列表.之后结果借助 props 传递给 TodoList,并且在组件内部渲染. 牢记: 1const App = state =&gt; List(map(Item, state))) 组件渲染其他子组件的想法工作良好,编写的大多数组件都不依赖JSX,只依赖传递进入的 state.所以这个方法只对小的子组件起作用. 下面是使用 Ramda map,compose,prop 方法的实例代码: 123456789import React from 'react'import &#123; render &#125; from 'react-dom'import &#123; compose, map, prop &#125; from 'ramda'const List = items =&gt; &lt;ul&gt;&#123;items&#125;&lt;/ul&gt;const Item = todo =&gt; &lt;li key=&#123;todo.id&#125;&gt;&#123;todo.text&#125;&lt;/li&gt;const getTodos = prop('todos')const TodoList = compose(List, map(Item), getTodos)const props = &#123;todos: [&#123;id: 1, text: 'foo'&#125;, &#123;id: 2, text: 'bar'&#125;]&#125;render(&lt;TodoList &#123;...props&#125; /&gt;, document.getElementById('root')) Compose和组件的限制现在我们已经可以compose 组件并渲染出 Todo list. 接下来看看更为常见的方法,也就是 props 可以自顶向下传递.这些 props可以是任何内容,包括回调函数,其他组件以及数组和对象.下面的代码和 Todo List 的代码相同,只是包含额外的 Header 组件 123const Header = title =&gt; &lt;h1&gt;A Todo List: &#123;title&#125;&lt;/h1&gt;const List = items =&gt; &lt;ul&gt;&#123;items&#125;&lt;/ul&gt;const Item = todo =&gt; &lt;li key=&#123;todo.id&#125;&gt;&#123;todo.text&#125;&lt;/li&gt; 没有什么特别的,但是看看回头看看之前的实现方法,明确的表明,在 List 中包含一个 header 是不可能的.之前的compse: 1const TodoList = compose(List, map(Item), getTodos) 实际编程中我们需要能够 compose Header 和 List 的方法, Header放在哪里合适? 我们向 TodoList 函数传递了应用的state,接着经过筛选,然后遍历筛选过的 todos创建Items 的数组,然后传递给 List.Header组件如何才能从 state 中获取到标题信息?需要更好的办法. 说的更明白一点: 1const TodoHeader = mapStateToProps =&gt; Header(mapStateProps) 订正 这里哟一个更好的实现方法(感谢Thai Pangsakulyanont) 12const TodoHeader = todoState =&gt; Header(getTitleFromTodoState(todoState)) 我们希望是传递应用的 state接着使所有的组件各取所需的 properties.为了让思路更清晰,调用 mapStateToProps 函数 1const mapStateToProps = curry((f, g) =&gt; compose(g, f)) mapStateToProps等待一个函数还有组件,之后首先针对提供的 state 应用函数,之后结果传递给组件.需要注意这一点,我们柯理化了函数,仅仅是想把筛选 state的定义和实际的组件分离开. 在这个问题上, Ramda的绝大多数函数都是自动柯理化的. 下面代码是如何在 Header组价中应用mapStateToProps. 12const TodoHeader = mapStateToProps(s =&gt; s.title, Header)const result = TodoHeader(state) 这看起来和 react-redux 的connect()函数和类似了.我们使用mapStateToProps把state的特定部分转化为 props. 现在 Header 和之前的 List组价可以分别获取各自的 state信息了. 12const TodoList = mapStateToProps(getTodos, compose(List, map(Item))const result = TodoList(state) 显然,mapStateToProps只解决了一部分问题,我们仍然需要 compose TodoList 和 Header来创建整个应用的能力. 使用 compose 不能解决这个问题.所以来实现我们自己的工具函数combine.需要两个组件并返回一个新的组件. 1const combine = curry((c, o) =&gt; x =&gt; (&lt;div&gt;&#123;c(x)&#125; &#123;o(x)&#125;&lt;/div&gt;)) 使用 combine函数可以 compose Header 和 List创建新的函数. 1234const TodoHeader = mapStateToProps(s =&gt; s.title, Header)const TodoList = mapStateToProps(getTodos, compose(List, map(Item)))const App = combine(TodoHeader, TodoList)render(&lt;App &#123;...state&#125; /&gt;, document.getElementById('root')) 现在 compose 两个分别获取特定state 的方式已经有了.接着更进一步看看怎么 compose 更多的组件 Reducing组件如果需要在应用中添加一个显示当前年份的 Footer 组件.怎么才能做到这一点? 首先想到的办法是: 1const App = combine(TodoHeader, combine(TodoList, TodoFooter)) 首先Combine TodoList 和 TodoFooter,接着再 combine 之前的结果和 TodoHeader.这么做是可行的,但是如果组件再多一点,代码就不太好懂了. 可以考虑像下面一样操作: 1234// array of components const comps = [TodoHeader, TodoList, TodoFooter]const App = comps =&gt; reduce((acc, x) =&gt; combine(acc, x), init, comps) 有了想法,看看实际的实现 1234const combineComponents = (...args) =&gt; &#123; const [first, ...rest] = args return reduce((acc, c) =&gt; combine(acc, c), first, rest)&#125; 参考 redux中的combineReducers,我们把自己的 reducer 称为combineComponents, combineComponents 接收一组组件,并 Reduce为等待组件 state 的单个函数. 12const App = combineComponents(TodoHeader, TodoList, TodoFooter)render(&lt;App &#123;...state&#125; /&gt;, document.getElementById('root')) 有了mapStateToProps, combine, combineComponents 的协助,我们现在就可以 compose 组件了.考虑到 mapStateToProps, 我们可以最一下最后的提炼.看看刚开始的实现方法 1const mapStateToProps = curry((f, g) =&gt; compose(g, f)) 实际上,我们完全没有必要自己实现它.Ramda或者 lodash/fp 已经提供了一个函数:pipe. pipe函数从左至右运行所有的函数.看看下面的例子 123456const add = x =&gt; x + 1const multiplyByFour = x =&gt; x * 4// pipe === flip(compose)const rCompose = flip(compose)rCompose(add, multiplyByFour)(1) === compose(multiplyByFour, add)(1)rCompose(add, multiplyByFour)(1) === pipe(add, multiplyByFour)(1) 所以pipe和 compose很像,只不过参数方向是相反的. 我们使用了 Ramda的flip函数,这个函数在本实例中 翻转两个参数的方向.意味着,我们现在可以重构 mapStatToProps为: 1const mapStateToProps = pipe 或者直接使用pipe函数,让 Ramda 担起全责.这么做以后,留给我们两个函数combine和combineRedcers需要处理.甚至combine 函数都可以隐藏起来,但是为了推理清晰一点,还是保留吧! 完整的代码如下: 1234567891011121314151617181920212223242526272829import React from 'react'import &#123; render &#125; from 'react-dom'import &#123; compose, map, prop, curry, reduce, pipe &#125; from 'ramda'const combine = curry((c, o) =&gt; x =&gt; (&lt;div&gt;&#123;c(x)&#125; &#123;o(x)&#125;&lt;/div&gt;))const combineComponents = (...args) =&gt; &#123; const [first, ...rest] = args return reduce((acc, c) =&gt; combine(acc, c), first, rest)&#125;const state = &#123; year: '2016', title: 'Random stuff', todos: [&#123;id:1, text: 'foo'&#125;, &#123; id:2, text: 'bar'&#125;]&#125;const getTodos = prop('todos')const Header = title =&gt; &lt;h1&gt;A Todo List: &#123;title&#125;&lt;/h1&gt;const List = items =&gt; &lt;ul&gt;&#123;items&#125;&lt;/ul&gt;const Item = todo =&gt; &lt;li key=&#123;todo.id&#125;&gt;&#123;todo.text&#125;&lt;/li&gt;const Footer = text =&gt; &lt;div&gt;&#123;text&#125;&lt;/div&gt;const TodoHeader = pipe(s =&gt; s.title, Header)const TodoList = pipe(getTodos, compose(List, map(Item)))const TodoFooter = pipe(s =&gt; s.year, Footer)const App = combineComponents(TodoHeader, TodoList, TodoFooter)const result = render(&lt;App &#123;...state&#125; /&gt;, document.getElementById('root')) Adding Redux Reduce一切组件? 下面的伪代码,帮助我们创建要达成目标的心里模型 1const App=(state,action)=&gt;TodoList 上面的代码看起来有点像典型的 Redux reducers,不同点是我们在这里返回的是一个 React 组件,并不是经过计算的state.如果要借助 Readux 来完成这个目标? 试试看 我们仍然来构建一个 TodoList,并且保持清晰明了,会使用译注 redux todomvc 的actions 和 todo reducer. 12345678910111213141516// constantsconst ADD_TODO = 'ADD_TODO'const DELETE_TODO = 'DELETE_TODO'// actionsconst addTodo = text =&gt; (&#123;type: ADD_TODO, text &#125;)const deleteTodo = id =&gt; (&#123; type: DELETE_TODO, id &#125;)// reducersconst todos = createReducer([], &#123; [ADD_TODO]: (state, action) =&gt; [ &#123; id: getNextId(state), completed: false, text: action.text &#125;, ...state ], [DELETE_TODO]:(state, action) =&gt; reject(propEq('id', action.id), state),&#125;) 部分原始的reducer 代码通过使用 Ramda的 reject和propEq重构来过滤已经删除掉的 todo条目.万一你想知道reject是什么函数,reject是 filter的补集.我们可以编写一组助手函数: 123456789// redux utils// alternative is to use defaultTo instead propOrconst createReducer = (init, handlers) =&gt; (state = init, action) =&gt; propOr(identity, prop('type', action), handlers)(state, action)const addOne = add(1)const getAllIds = pluck('id')const getMax = reduce(max, 0)const getNextId = compose(addOne, getMax, getAllIds) getNextId是用于获取下一个 id 的函数,在添加新的条目是,需要用到它.createReducer已经在在 Redux的顶层输出中出现了,但是这里的是使用 Ramda重写的版本.现在我们已经有了 reducers和 Action.现在需要适配他们和我们的组件以便于处理添加和删除组件.为了保持简单,我们用一个 add 按钮来代替输入文本添加 todo项文本的操作. 12345const Add = onSave =&gt; ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; onSave('foobar')&#125;&gt;Add&lt;/button&gt; &lt;/div&gt;) 最后还需要一个删除按钮.在 Item组件中添加一个删除按钮就足够了. 12345const Item = (&#123;todo, removeTodo &#125;) =&gt; ( &lt;li key=&#123;todo.id&#125;&gt; &#123;todo.text&#125; &lt;button onClick=&#123;removeTodo&#125;&gt;Remove&lt;/button&gt; &lt;/li&gt;) 需要的部分都已经就绪了.这里仍然有一些部分需要澄清:removeTodo应该 dispatch deleteTodo action. 另一个需要考虑的方面是,我们需要一个方法定义必须要提供的 dispatcher. 现在我们还仅仅是映射 state 到 props. 来添加一个 getRender函数,等待输入应用入口节点,返回一个等待 React 组件的函数. 123const getRender = node =&gt; app =&gt; ReactDOM.render(app, node)const render = getRender(document.getElementById('root'))render(&lt;App &#123;...state&#125; /&gt;) 接下来编写一个 bindActionCreator. 1234// define a bindActionCreatorconst bindAction = curry((dispatch, actionCreator) =&gt; compose(dispatch, actionCreator))const bindActionCreator = bindAction(store.dispatch) 接着隐藏掉 dispatch方法,同时传递bindActionCreator 和 state 到应用,并且订阅到 Redux 的 store,当代触发渲染. 要声明一下, Redux 已经有可以直接使用的 bindActionCreators 函数. 12345const run = store.subscribe(() =&gt; render( &lt;App &#123;...store.getState()&#125; dispatch=&#123;bindActionCreator&#125; /&gt; )) 最后的一些收尾工作是适配 Item和 TodoList 组件, Items 期待 todo条目还有 onDelete函数 123456const Item = (&#123;todo, onDelete&#125;) =&gt; ( &lt;li key=&#123;todo.id&#125;&gt; &#123;todo.text&#125; &lt;button onClick=&#123;() =&gt; onDelete(todo.id)&#125;&gt;Remove&lt;/button&gt; &lt;/li&gt;) 因为现在 Item组件也需要onDelete函数,我们需要适配map to props函数.我们已经获取了 dispatch,所以返回一个todo items 的数组了,需要范湖一个包含 todo数组和onDelete函数的对象. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// for clearer understanding extracted mapItemsconst mapItems = (&#123;todos, onDelete&#125;) =&gt; map(todo =&gt; Item(&#123;todo, onDelete&#125;), todos)const TodoList = pipe(props =&gt; (&#123;todos: props.todos, onDelete: props.dispatch(deleteTodo)&#125;), compose(List, mapItems))``` 下面就是最终的代码,也可以查看[`实例代码`](https://plnkr.co/edit/adPsyH9r6OIjsu9fDhgz?p=preview)```jsimport React from 'react'import ReactDOM from 'react-dom'import &#123; createStore, combineReducers &#125; from 'redux'import * as R from 'ramda'// composition helperconst combine = R.curry((c, o) =&gt; x =&gt; (&lt;div&gt;&#123;c(x)&#125; &#123;o(x)&#125;&lt;/div&gt;))const combineComponents = (...args) =&gt; &#123; const [first, ...rest] = args return R.reduce((acc, c) =&gt; combine(acc, c), first, rest)&#125;// helpersconst targetValue = e =&gt; e.target.valueconst getTodos = R.prop('todos')// redux utilsconst createReducer = (init, handlers) =&gt; (state = init, action) =&gt; R.propOr(R.identity, R.prop('type', action), handlers)(state, action)const addOne = R.add(1)const getAllIds = R.pluck('id')const getMax = R.reduce(R.max, 0)const getNextId = R.compose(addOne, getMax, getAllIds)// constantsconst ADD_TODO = 'ADD_TODO'const DELETE_TODO = 'DELETE_TODO'// actionsconst addTodo = text =&gt; (&#123;type: ADD_TODO, text &#125;)const deleteTodo = id =&gt; (&#123; type: DELETE_TODO, id &#125;)// reducersconst todos = createReducer([], &#123; [ADD_TODO]: (state, action) =&gt; [ &#123; id: getNextId(state), completed: false, text: action.text &#125;, ...state ], [DELETE_TODO]:(state, action) =&gt; R.reject(R.propEq('id', action.id), state),&#125;)const year = createReducer('', &#123;&#125;)const title = createReducer('', &#123;&#125;)// combine reducer and create storeconst reducers = combineReducers(&#123;todos, year, title&#125;)const initialState = &#123; year: '2016', title: 'Random stuff', todos: [&#123;id:1, text: 'foo'&#125;, &#123; id:2, text: 'bar'&#125;]&#125;const store = createStore(reducers, initialState)// componentsconst Header = title =&gt; &lt;h1&gt;A Todo List: &#123;title&#125;&lt;/h1&gt;const Add = (&#123;onSave&#125;) =&gt; ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; onSave('foobar')&#125;&gt;Add&lt;/button&gt; &lt;/div&gt;)const List = items =&gt; &lt;ul&gt;&#123;items&#125;&lt;/ul&gt;const Item = (&#123;todo, onDelete&#125;) =&gt; ( &lt;li key=&#123;todo.id&#125;&gt; &#123;todo.text&#125; &lt;button onClick=&#123;() =&gt; onDelete(todo.id)&#125;&gt;Remove&lt;/button&gt; &lt;/li&gt;)const Footer = text =&gt; &lt;div&gt;&#123;text&#125;&lt;/div&gt;// define a bindActionCreatorconst bindAction = R.curry((dispatch, actionCreator) =&gt; R.compose(dispatch, actionCreator))const bindActionCreator = bindAction(store.dispatch)// map state to propsconst TodoHeader = R.pipe(props =&gt; props.title, Header)const TodoAdd = R.pipe(props =&gt; (&#123;onSave: props.dispatch(addTodo)&#125;), Add)const mapItems = (&#123;todos, onDelete&#125;) =&gt; R.map(todo =&gt; Item(&#123;todo, onDelete&#125;), todos)const TodoList = R.pipe(props =&gt; (&#123;todos: props.todos, onDelete: props.dispatch(deleteTodo)&#125;), R.compose(List, mapItems))const TodoFooter = R.pipe(props =&gt; props.year, Footer)// combine all componentsconst App = combineComponents(TodoHeader, TodoAdd, TodoList, TodoFooter)// we could also have used curry...const getRender = node =&gt; app =&gt; ReactDOM.render(app, node)const render = getRender(document.getElementById('root'))const run = store.subscribe(() =&gt; render(&lt;App &#123;...store.getState()&#125; dispatch=&#123;bindActionCreator&#125; /&gt;))// startconst init = store.dispatch(&#123;type: '@@INIT'&#125;) Outro这篇文章的目的是介绍如何联合 Ramda,React和 Redux来编写更加优雅的代码.例子只是用来说明如何在React 或者 Redux 中使用 Ramda.在实际的编程中,你可以在应用的某些部分借助Ramda或者 lodash/fp 来编写优雅的代码. 例如可以重构mapDispatchToProps函数,根据定义好的 propTypes自动映射 state到应用的props,代替手动输入. 12345const getPropTypes = prop('propTypes')const pickKeys = compose(pick, keys)const mapStateToProps = compose(pickKeys, getPropTypes)// map state to defined propTypes.export default connect(mapStateToProps(App))(App) 也可以使用 Ramda 的 pick函数替代 mapDispatchToProps 函数. 1export default connect(pick(['todos']))(App) If you have any questions or feedback don’t hesitate to leave feedback @ twitter. 这篇文章受到Brian Lonsdorf 在 React Rally上演讲的启发.","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"javascript","slug":"javascript","permalink":"https://React-Apollo.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"hoc","slug":"hoc","permalink":"https://React-Apollo.github.io/tags/hoc/"}]},{"title":"Cnoder 项目列表","slug":"Cnoder 项目列表","date":"2018-01-29T12:21:07.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/01/29/Cnoder 项目列表/","link":"","permalink":"https://React-Apollo.github.io/2018/01/29/Cnoder 项目列表/","excerpt":"","text":"内容 项目内容 文件结构 项目内容文件结构根据 F8APP的文件结构做了文件夹重新安排, 从导航触发,这里不会提前登陆, 只有导航到my Tab时点击登录才会通过github登录.每个 tab 下面是 StackNavigator,这样导航就是树形结构, 每个 tab作为父节点, 下面的导航是专项的, 有公用的作为 publicRoute的形式,导入每个 tab下面.例如几个地方会用到 detail页面,这个作为公共的导航页面,放到 common文件夹下.还有 Utils工具,commonent组件","categories":[{"name":"Readme","slug":"Readme","permalink":"https://React-Apollo.github.io/categories/Readme/"}],"tags":[{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"},{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"node.js","slug":"node-js","permalink":"https://React-Apollo.github.io/tags/node-js/"},{"name":"expo","slug":"expo","permalink":"https://React-Apollo.github.io/tags/expo/"}]},{"title":"博客模板","slug":"博客模板","date":"2018-01-28T08:17:07.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/01/28/博客模板/","link":"","permalink":"https://React-Apollo.github.io/2018/01/28/博客模板/","excerpt":"","text":"","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"Prisma|GraphQL Server Basics-networklayer","slug":"Prisma|GraphQL Server Baiscs:Network layer","date":"2018-01-28T08:17:07.000Z","updated":"2019-04-28T05:52:57.892Z","comments":true,"path":"2018/01/28/Prisma|GraphQL Server Baiscs:Network layer/","link":"","permalink":"https://React-Apollo.github.io/2018/01/28/Prisma|GraphQL Server Baiscs:Network layer/","excerpt":"","text":"","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphql","slug":"Graphql","permalink":"https://React-Apollo.github.io/tags/Graphql/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"Prisma服务器构建","slug":"Prisma远程服务器部署问题备忘","date":"2018-01-27T13:18:28.000Z","updated":"2019-04-28T05:52:57.892Z","comments":true,"path":"2018/01/27/Prisma远程服务器部署问题备忘/","link":"","permalink":"https://React-Apollo.github.io/2018/01/27/Prisma远程服务器部署问题备忘/","excerpt":"","text":"缘由 准备使用Prisma的服务，本来觉得是Graphcool的升级版本，没有什么问题，但是碰到很多问题，奋战一晚，都要睡着了，node.js服务器的报错信息一条都没有了。还是很值得的 在stackflow一搜，有同样问题的人很多。 其实问题很简单，主要的祸首就是Prisma引入的token,原来graphcool没遇到过要toke的情况。 流程安装步骤 全局安装prisma — prisma init projectName 进入server目录 — cd server. 部署 ———— prisma deploy 获得endpoint地址 启动本地服务——- 回到项目目录 ，yarn start 获得本地服务 获取token——– prisma token 最坑人的地方是获取token， 用playground的时候需要token，stackflow中很多人遇到这个问题。要在header中设置.12&#123; \"Authorization\": \"Bearer --token放这里，并删掉短杠--\"&#125; 后面在使用node服务器的时候也要配置 schema的配置这里还是不太熟悉，新的版本是有优势，但是还没发挥出来，在选择部署的时候，如果是全栈的full stack 的模式，很容易误导人,在movie这个服务器里干脆放弃了，直接使用服务器，结果没有产生歧义，在database中的data.model.graphql中添加shcema从某网站抓取数据的保存的schema123456789101112131415type ReactScript &#123; id:ID! @unique title:String url: String funcCat:String platformCat:String dateUpdate:String comments:String img: String excerpt:String demoUrl: String tag1: String tag2: String tag3: String&#125; 添加完成后，重新部署，然后，使用地址登录graphiql服务。 这个就遇到为了。要输入上面的token,才行。 输入以后token以后， 如果在右端的schema中看到有 ReactScript出现，配置就算完成了， 牢记以shcma为中心，schema中有什么数据结构才可以查询，有什么方法才可使用。配置的方法和结构和预期不一样，根本没有必要进行下去，只会让问题更加的复杂。 schema是一个分水岭，昨天东查查，西看看，浪费不少时间，先在这里把问题做切割。 然后使用手工配置的参数，完成CRUD的操作，看看发方法，模型等是否正常。 如果这里都正常了，但是服务端还有问题，那么根源在后面，prisma就没有什么问题了。 node.js graphql-request的使用这里要配置查询的标签，对着prisma的schema逐个查看，就没有什么问题。 node.js中可能会出现两种错误提示 无法访问服务器， tokent，无效，需要配置，还有现在的endpoint都有/dev后缀， 使用时要留心。 提示查询类型不对， 查询的标签有问题，一定对着查看。 在prisma的版本中，带参数的查询，有点改动，参数之前带了一个data:{}， 使用也要注意检查。 这样基本就没有什么问题了node.js的代码段","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"使用Expo,Apollo-client,graphcool构建Cnode APP","slug":"使用Expo,Apollo-client,graphcool构建Cnode APP","date":"2018-01-26T08:53:28.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2018/01/26/使用Expo,Apollo-client,graphcool构建Cnode APP/","link":"","permalink":"https://React-Apollo.github.io/2018/01/26/使用Expo,Apollo-client,graphcool构建Cnode APP/","excerpt":"","text":"项目起因 技术流程已经建立了，这几天在构建express-mongodb-graqhql的服务器器，花了很长时间，回过头来看又快忘了，感觉到了现在的阶段，人老了，理解能力还是有的，但是记忆力确实不行了。千万要详细记录，要不然就白学很多东西了。 记录越详细越好。 项目缘由主要是三大块，中间始终贯穿函数式编程的想法，但是有些没有实现 Graphcool(Prisma）在Medium网站查找Ramda的文章，结果首页给我推送，apollo,graphcool的文章，graphcool的图标是绿色的，天生有好感，就想看看到是干什么的，因为前面想着手翻译, 这两个技术也很新，所以花了很长时间研究，但是最终没有翻译，感觉到Relay的前景并不是很好，但是最近看Relay还在不断的演化，背靠FB,的确在人才上面和技术上有很大的优势。 但是这个月最终Apollo-Graphcool的构架已经彻底征服了我。 其实选择什么框架并不是什么大问题，没有涉及到核心的问题。这些框架的核心是所有的东西都围绕着GraphQL的Schema来展开。刚开始在使用graphcool的Resolver(解析函数)包装Cnode的api的时候，觉得在定义的时候添加schema一项是多余的。但是随着学习，我发现，GraphQL的威力就在schema上，有了schema，数据的查询就很厉害了。 所有后边的学习重点就围绕schema展开。Graphcool 1.0版本，代号已经改为Prisma.最终要在这里导入CNODE 的API. 根据Graphcool服务器的schema来进行各项操作 ApolloApollo 这个构架是在看meteor的时候就已经知道，所以在Medium网站推送时，相关内容也来来，随便看了一下，没有什么概念， 突然就在SegmentFault网上看到一个系列的文章，突然感觉就入门了，这个系列的文章，提到Apollo的客户端在执行异步请求是，是从网络层抽象的，幸运，CCNA满分，很快理解这个构架的优势。Redux中异步请求时的flag突然就没有了，因为这个flag可以直接从请求的网络状态获得，网络层的请求本来就有几个状态。 这个地方解决的太巧妙。 由此就开始了Apollo构架的学习，这个构架实际也包括server，但是所有的server和graphcool相比都逊色不少，配置graphcool的服务器几乎没有花费任何的学习时间，除了resolver的编程。 后面又看到这篇文章未来的状态管理技术.的确是有未来状态管理的潜力，Redux与之相比有点啰嗦了。其实Redux的技术构架核心，我认为有三个： 单一事实来源(数据单向流动)， Reducer函数(数据Immutable)， Container(数据注入方式) 衍生出的Action和很多中间件都是为之服务的。 所以只要具有核心可以了，在未来状态的管理技术中提到的apollo-link-state这个技术就是依次而生， 本地20%的state和80%的远程数据合二为一，React组件中的所有Action(函数)都依据graphql的shcema干活，如果是本地数据@Client指令就会阻止Action执行远程的请求，只能用于本地的数据访问。 可以简单理解，在Apollo的Store中只加了一个标记就解决了这个问题。 Apollo的技术构架还在不断的演化，前面我的思想中强烈的Redux正统思想和Apollo的进步思想一直打架，毕竟在Redux上花了太多的时间和精力，收获还不大。 要舍弃Reducx太难，没办法技术进步太快，要勇于学习新的知识。 说道这里，看到有的文章简介说什么javascript疲劳，现在来看根本没有这回事情。 应该称之为选择性疲劳，除了为了框架而框架的项目，但凡GitHub评价很高的项目诞生都是有原因的。了解了技术诞生的原因，就学习就比较简单了。比如前面看了一下Eixlir的东西，没什么概念，为什么会有这么一个语言会存活呢？ 原因就是为了处理高并发和稳定性。 这几天突然想，我已经建了好几个graphcool的服务器，那么如果是我想把这几个服务器用在一个项目呢？例如：从一组关键字[‘js’,’ramda’,’redux’,’react’]中查询结果，那么可以不可以用一个总的服务器来接受查询项目，然后下发给子graphcool.这样效果是不是会更好？ 总的服务器用’Express’可以，Eixlir是不是就是为此而生的？ 所以学习Eixlir的缘由和目标就有了。 Expo RN的启动项目RN本机的配置实在是太麻烦，iOS还好一点，直接装Xcode就可以了，安卓的就不好搞，Expo就是为此而生。 直接create-react-naive-app就生成 Expo-RN项目，手机安装Expo软件，扫码就可以进行调试了。实在是简化了操作。 但是Expo也有自己的问题，它打包了一些子代服务，你用不用都有，所以即使hello world项目也有二十多兆，很大。 我的想法是在expo里使用和调试，但是不用expo自己封装到组件，直接自己安装， 需要的时候可以迁移JS文件的正式的RN项目中。 CNODE的这个expo项目已经有了一些内容实现，所以趁还没忘，记录一下流程和代码。 项目流程Graphcool服务构建服务器初始化这个实在是太简单. graphcool init :安装依赖包 graphcool deploy ：部署，本地部署需要docker,mac下的docker用抢先版就可以，远程部署，直接选择就可以了新的版本Prisma命令稍微有点改动 获取数据库endpoint。随时可以在项目文件夹中用graphcool info查看部署信息 创建schemagraphql服务器是以shcema为核心的，schema对于字段类型，和执行方法都有严格的约束，这里严格后面的操作就轻松。参照Graphcool-framework 的做法 定义scheme123456789101112131415161718//对于查询cnode api的信息字段的约束条件type AllCnodePayload &#123; id: String! tab: String title: String! visit: Int! aurl: String! author_id: String!&#125;input QueryInput &#123; page: Int! tab: String!&#125;extend type Query &#123; allCnode(page: Int!, tab: String!): [AllCnodePayload!]!&#125; 在type定义里并没有返回cnode API的 content字段信息。 如果在前端显示列表，content基本是不需要的，或者有需求需要显示摘要， 可以在resolver的时候，做处理。这样做，graphcool 服务器从api获取的数据虽然包含有content,但是我们用schema过滤掉了。 客户端请求时的数据量就减少了。这个地方体现的就是graphql的灵活性。 在Query,中定义了查询时可以传递的参数。这里没有做关联，实际是可以做关联的。在Hotel-GeoData的项目中有数据的关联操作。 tab参数是用于分类查询的，page这个参数用于分页，由于apollo-client做了很多工作，客户端的分页变得很简单，实际只要处理这个一个参数既可以了，返回的数据和原先的数据拼接在一起就可以了。有一点要注意：如果是client,schema和这里的还不太一样，例如 123456789101112131415161718192021222324query getFirstPageInformation&#123; all: allCnode(page:1,tab:\"\")&#123; id, title &#125;, share: allCnode(page:1,tab:\"share\")&#123; id, title &#125;, job: allCnode(page:1,tab:\"job\")&#123; id, title &#125;, dev: allCnode(page:1,tab:\"dev\")&#123; id, title &#125; getWeatherByCity(city:\"Beijing\")&#123; temperature, humidity, &#125; &#125; 上面内容拷贝到下面左侧框中，点击执行就可以看到结果 客户端的schema可以集各家之大成，一次查询获取所有数据，http只需要做一次请求。 Resolver函数对于放在REST API之前的 graphcool 服务器， Resolver是核心， 从API获取的信息，在这里根据shcema做处理， 之后就可以使用graphql的各种优点来进行操作。如果认为Graphcool只是做了REST API的代理，认识是非常肤浅的。从Cnode REST API 获取数据并处理的Resolver函数 1234567891011121314151617181920212223242526272829303132require('isomorphic-fetch');const R = require('ramda');const url = 'https://cnodejs.org/api/v1/topics';module.exports = (event) =&gt; &#123; const &#123; tab, page &#125; = event.data;//这里就是查询的参数， //在graphiql，在查询关键词后添加参数，客户端通过apollo-client传递 urlWithParams = `$&#123;url&#125;?tab=$&#123;tab&#125;&amp;page=$&#123;page&#125;`; let options = &#123; method: 'GET' &#125;; return fetch(urlWithParams, options).then((response) =&gt; response.json()).then((responseData) =&gt; &#123; const NodeList = responseData.data; const allCnode = []; //去毛处理 const selectPropertyX = (x) =&gt; (&#123; id: x.id, tab: x.tab, aurl: 'https://randomuser.me/api/portraits/thumb/men/97.jpg', visit: x.visit_count, title: x.title, author_id: x.author_id &#125;); const allCnode = R.map(selectPropertyX, NodeList); //const getIdcollections=R.curry(R.map(selectPropertyX,data)); //const allCnode=getIdcollections(NodeList); return &#123; data: allCnode &#125;; &#125;);&#125;; graqhiQL测试graphql优点是带有一个GraphiQL的可视化界面，可以在这里测试一下查询，用上面的代码块可以获得数据 1234567891011121314151617181920212223&#123; \"data\": &#123; \"getWeatherByCity\": &#123; \"temperature\": -4.87, \"humidity\": 93 &#125;, \"all\": [ &#123; \"id\": \"5a2403226190c8912ebaceeb\", \"title\": \"企业级 Node.js 框架 Egg 发布 2.0，性能提升 30%，拥抱 Async\" &#125;, &#123; \"id\": \"5a54a8a4afa0a121784a8ab0\", \"title\": \"玉伯《从前端技术到体验科技（附演讲视频）》\" &#125;, &#123; \"id\": \"592917b59e32cc84569a7458\", \"title\": \"测试请发到客户端测试专区，违规影响用户的，直接封号\" &#125;, &#123; \"id\": \"5a6a47119d371d4a059eee66\", \"title\": \"北京求推荐一个好的node线下培训课程\" &#125;, 上面这个的结果实际是来自两个api的，一个是cnode客户端，一个是天气查询的api.一次查询就返回了结果。 这就是graphql的魅力所在。 Expo RN APP 编程使用Create-react-native-app方法构建导入组件有 导航 react-navigation 组件库 react-elements 样式库 styled-components 太牛了，这实际也是函数式编程库 函数式编程库： Ramda, recompose库 主要的思想上的变化是使用函数式编程库。 styled-components的作者问了一个问题，如果函数式编程风格的React组件是无状态组件(函数)，样式也是函数呢？ 由于刚好在学习函数式编程，感觉到黑暗中找到了明灯。 这不就是高阶函数吗？， 样式也可以通过函数传递了。 背后的英雄还是闭包。自从学习了Ramada的规范，即每个函数只解决一个问题， 函数链从右向左，数据从右边开始传递，之后，感觉以前一团乱麻的想法，慢慢清晰了。 在这个地方，思考问题自动分解了，其实从整体看一团乱麻， 单个函数处理问题并不乱。 引入函数式编程的好处真是无可比拟。 在编程中处理的核心数据结构是数组(Ramda叫List)和对象。围绕这个这两个方面，Ramda有一堆的工具可供使用。 R.curry,R.compose,R.reduce是绝对的核心。 思想方法是分解问题，制造和配置生产零件，然后compose成工厂。 在Ramda模式下 compose成的工厂会给在右边留下一个入口，从右边输入猪肉，左边就会后香肠出来。 柯理化和js的闭包在制造和配置生产函数时时直观重要的。我一再的强调配置性 由于高阶函数的特性，函数可以作为参数传递，所以可以传递行使不同功能的函数来配置成执行不同功能的零件，在背后是js函数闭包负责把配置给你保存起来，备用。 js的函数可配置性使得js中可以使用函数组合成各种不同的工厂，只需要传递数据给它即可工作。 APP 中引入Apollo-client数据层入口文件引入apollo-client的包和Graphql的 endpointExpo/app.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import React from 'react'import &#123; StyleSheet &#125; from 'react-native'import &#123;TabNavigator, StackNavigator, DrawerNavigator&#125; from 'react-navigation'import &#123; ApolloProvider &#125; from 'react-apollo'import &#123; ApolloClient, HttpLink, InMemoryCache &#125; from 'apollo-client-preset'import My from './app/My'import Message from './app/Message'import Post from './app/Post'import Editor from './app/Editor'import &#123;MyNotificationsScreen, MyHomeScreen&#125; from './app/Drawer'import Topic from './app/Topic'import Collection from './app/Collection'const Drawer = DrawerNavigator(&#123; Home: &#123; screen: MyHomeScreen , &#125;, Notifications: &#123; screen: MyNotificationsScreen , &#125;,&#125;)const tabNavigator=TabNavigator(&#123; 主题: &#123; screen: Collection, &#125;, Notifications: &#123; screen: Message, &#125;, Add:&#123; screen: Editor, &#125;, My:&#123; screen: My, &#125;, 收藏:&#123; screen :Topic &#125;&#125;, &#123; tabBarPosition: 'bottom', animationEnabled: true, tabBarOptions: &#123; activeTintColor: '#e91e63', &#125;,&#125;)const Navigator = StackNavigator(&#123; Home: &#123; screen: tabNavigator, navigationOptions: &#123; title: 'Info', &#125;, &#125;, Detail: &#123; screen: Post &#125;, //Setting: &#123; sreen: Drawer&#125;, &#125;)//graphcool 服务器的urlconst httpLink = new HttpLink(&#123; uri: 'https://api.graph.cool/simple/v1/cjaxudkum2ugf0127kok921bc' &#125;)//构建client对象const client = new ApolloClient(&#123; link: httpLink, cache: new InMemoryCache(), connectToDevTools: false&#125;)//包装对象注入顶层组件，如果你还要使用Redux,在包装一下，也没有问题。//分别是两个不同的对象而已。export default class App extends React.Component &#123; render() &#123; return ( &lt;ApolloProvider client=&#123;client&#125;&gt; &lt;Navigator /&gt; &lt;/ApolloProvider&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: '#fff', alignItems: 'center', justifyContent: 'center' &#125;&#125;) 配置其实很简单， 在顶层组件注入apollo-client的对象就可以了。redux的其他的文件夹全没有了。apollo-client可以和Redux一起工作， 在顶层组件中再次引入Redux的store,也没有问题。因为这两者是独立的。 像是同一个写字楼里的两家公司，虽然在一起，但是各干个的工作，但是也有使用相同组件的地方，例如两家公司可以同时使用一个卫生间。公家的东西显然大家都不太爱惜，很不好。如果两个公司合二为一呢？ 那就好了。 Apollo的团队想到了这个问题。apollo-link-state就把两拨统一了。 不详细讲，准备翻译apollo的文档了。 组件中的apollo-client的使用cnode列表组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import React, &#123; Component &#125; from 'react';import &#123; View, Text, FlatList,Button&#125; from 'react-native';import &#123; List, ListItem ,Header&#125; from 'react-native-elements';import Dropdown from './Drowdown';//导入graphql组件，具体使用在代码最后import &#123; graphql &#125; from 'react-apollo';//tag 用于拼接graphql的语句import gql from 'graphql-tag';//拼接的语句，这个语句的效果和在graqhiQL中使用效果是一样的//查询所有文章的id,title等，schema定义什么就可以返回什么const allNodesQuery = gql` query($page:Int!,$tab:String!) &#123; allCnode(page:$page,tab:$tab) &#123; id title tab aurl &#125; &#125;`;//文章列表组件 class Topic extends Component &#123; state = &#123; page: 1, tab: \"\", &#125; render() &#123; const &#123;navigate&#125; = this.props.navigation;//react- //navigation的导航对象，其实这个就和Redux的store一样，顶层导入的 //所有的子组件可以使用 console.log(this.props) //props会有需要的数据 //apollo-client神奇的地方， 请求数据的flag借用的是网络层的数据 //由于这里天然就带有各种状态标记，直接使用就可以了 //networkStatus===1表示正在请求数据 if(this.props.networkStatus===1)&#123; return ( &lt;View&gt; &lt;Text&gt;Loading...&lt;/Text&gt;&lt;/View&gt; ) &#125; return ( &lt;View&gt; &lt;Header outerContainerStyles=&#123;&#123;marginTop:0,zIndex:9999&#125;&#125; leftComponent=&#123;&lt;Button title=&#123;'setting'&#125; onPress=&#123;(props)=&gt; this.props.refetch(&#123; page:1, tab:\"job\" &#125;) &#125; /&gt;&#125; centerComponent=&#123;&#123; text: 'MY TITLE', style: &#123; color: '#fff' &#125; &#125;&#125; rightComponent=&#123;&lt;Dropdown refetch=&#123;this.props.refetch&#125;/&gt;&#125; /&gt; &#123;(this.props.networksStatus===2)&amp;&amp;&lt;View style=&#123;&#123;flex:1,alignItems:'center',justifyContent:'center',zIndex:999,opacity:0.8&#125;&#125;&gt; &lt;Text&gt;Loading...&lt;/Text&gt; &lt;/View&gt;&#125; &lt;List containerStyle=&#123;&#123; borderTopWidth: 0, borderBottomWidth: 0,marginTop:0 &#125;&#125;&gt; &lt;FlatList data=&#123;this.props.allCnode&#125; renderItem=&#123;(&#123; item &#125;) =&gt; ( &lt;ListItem roundAvatar refreshing=&#123;this.props.networkStatus === 4&#125; onRefresh=&#123;() =&gt; this.props.refetch()&#125; title=&#123;`$&#123;item.title&#125;`&#125; subtitle=&#123;`$&#123;item.tab&#125;`&#125; avatar=&#123;&#123; uri: item.aurl &#125;&#125; containerStyle=&#123;&#123; borderBottomWidth: 0 &#125;&#125; onPress=&#123;() =&gt; navigate('Detail',&#123;id:`$&#123;item.id&#125;`&#125;)&#125; /&gt; )&#125; keyExtractor=&#123;item =&gt; item.id&#125; onEndReachedThreshold=&#123;0.5&#125; onEndReached=&#123;() =&gt; &#123; // The fetchMore method is used to load new data and add it // to the original query we used to populate the list this.props.fetchMore(&#123; variables: &#123; page: this.props.allCnode.length + 1,tab:\"share\"&#125;, updateQuery: (previousResult, &#123; fetchMoreResult &#125;) =&gt; &#123; // Don't do anything if there weren't any new items //console.log(fetchMoreResult) if (!fetchMoreResult || fetchMoreResult.allCnode.length === 0) &#123; return previousResult; &#125; return &#123; // Concatenate the new feed results after the old ones allCnode: previousResult.allCnode.concat(fetchMoreResult.allCnode), &#125;; &#125;, &#125;); &#125;&#125; /&gt; &lt;/List&gt; &lt;/View&gt; ); &#125; &#125;//这里是graphql注入组件的位置//options就是初始的参数//props可以用map方法进行筛选aooNodesQuery是查询语句export default graphql(allNodesQuery,&#123; options: &#123; variables: &#123; page:1, tab:\"\" &#125;, &#125;, props: (&#123; ownProps, data: &#123; loading, allCnode, refetch,fetchMore,networkStatus,updateQuery&#125; &#125;) =&gt; (&#123; Loading: loading, allCnode: allCnode, refetch: refetch, fetchMore: fetchMore, networkStatus: networkStatus, updateQuer: updateQuery &#125;),&#125; )(Topic); 上面代码的要点是 使用了网络层的状态来表示请求的状态 组件传递了apollo 对象子代的属性方法，refetch用于重新设定 查询的tab. &lt;FlatList data={this.props.allCnode} 列表组件只需要传入这个数据属性 Item组件解析对象属性,点击即可进入下一页。 具体内容的schema和列表是一差不多的 12345678910&lt;ListItem roundAvatar refreshing=&#123;this.props.networkStatus === 4&#125; onRefresh=&#123;() =&gt; this.props.refetch()&#125; title=&#123;`$&#123;item.title&#125;`&#125; subtitle=&#123;`$&#123;item.tab&#125;`&#125; avatar=&#123;&#123; uri: item.aurl &#125;&#125; containerStyle=&#123;&#123; borderBottomWidth: 0 &#125;&#125; onPress=&#123;() =&gt; navigate('Detail',&#123;id:`$&#123;item.id&#125;`&#125;)&#125; /&gt; 如果列表到了末端.page变量加 1 variables: { page: this.props.allCnode.length + 1,tab:&quot;share&quot;} 数据返回以后和之前的数据拼接就可以了 allCnode: previousResult.allCnode.concat(fetchMoreResult.allCnode) 1234567891011121314151617onEndReached=&#123;() =&gt; &#123; // The fetchMore method is used to load new data and add it // to the original query we used to populate the list this.props.fetchMore(&#123; variables: &#123; page: this.props.allCnode.length + 1,tab:\"share\"&#125;, updateQuery: (previousResult, &#123; fetchMoreResult &#125;) =&gt; &#123; // Don't do anything if there weren't any new items //console.log(fetchMoreResult) if (!fetchMoreResult || fetchMoreResult.allCnode.length === 0) &#123; return previousResult; &#125; return &#123; // Concatenate the new feed results after the old ones allCnode: previousResult.allCnode.concat(fetchMoreResult.allCnode), &#125;; &#125;, 整个数据数据流程就建立完成了","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"},{"name":"cnode","slug":"cnode","permalink":"https://React-Apollo.github.io/tags/cnode/"},{"name":"expo","slug":"expo","permalink":"https://React-Apollo.github.io/tags/expo/"},{"name":"graphcool","slug":"graphcool","permalink":"https://React-Apollo.github.io/tags/graphcool/"}]},{"title":"Rename key of Object","slug":"Rename keys of  Obj","date":"2018-01-26T07:25:28.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2018/01/26/Rename keys of  Obj/","link":"","permalink":"https://React-Apollo.github.io/2018/01/26/Rename keys of  Obj/","excerpt":"","text":"函数签名：{a:b}-&gt;{a:*}-&gt;{b:*}关键点是{oldkey: newkey} 步骤是： 使用R.key(obj) 取出对象的键作为数组 使用R.assoc把要转换键名的对象复制空对象中 使用R.reduce函数遍历函数，改变键名 难点： R.assoc可以改变或者添加新属性，第一个参数为要改变或者添加的属性，第二个参数为属性值，第三个为对象 1R.assoc('c', 3, &#123;a: 1, b: 2&#125;); //=&gt; &#123;a: 1, b: 2, c: 3&#125; reduce的使用，reduce是Ramda中应用最广泛的函数 1R.reduce((acc, key) =&gt; R.assoc(keysMap[key] || key, obj[key], acc), &#123;&#125;, R.keys(obj)) R.keys取出对象的键名(属性名)最为遍历的数组，原始对象并没有通过参数传递，通过键名几可以访问属性值 R.reduce函数中的三个位置，一是R.assoc函数,用于转换的函数，{}为初始值，R.key(obj)为原始对象的键名组成的数组 刚开始第一步，对象为空， R.assoc第一个参数为keysMap[key]，keyMap的定义为{oldkey:newkey}，所以keysMap[key]取出的就是新的键名，obj[key]就是原对象中的属性值， 复制到空对象中。key在keyMap中出现，就用旧的键(keyMap[key]||key).第一步可以分解为：1R.assoc(newKey, value, &#123;&#125;) 这样就把第一个对象属性名改变，并存入到新的空对象中接下来的方式就是Reduce的标准模式了。 这个方法有点绕，绕着绕着就明白了。","categories":[{"name":"Ramda-cookbook","slug":"Ramda-cookbook","permalink":"https://React-Apollo.github.io/categories/Ramda-cookbook/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://React-Apollo.github.io/tags/javascript/"},{"name":"Ramda","slug":"Ramda","permalink":"https://React-Apollo.github.io/tags/Ramda/"},{"name":"fp","slug":"fp","permalink":"https://React-Apollo.github.io/tags/fp/"}]},{"title":"从jb51抓取数据并存入mlab数据库","slug":"从jb51抓取数据并存入mlab数据库","date":"2018-01-25T22:18:28.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2018/01/25/从jb51抓取数据并存入mlab数据库/","link":"","permalink":"https://React-Apollo.github.io/2018/01/25/从jb51抓取数据并存入mlab数据库/","excerpt":"","text":"目标从jb51抓取数据，并且存入到mlab数据库。 这里没有经过graphql服务器，后面马上会改进","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"fp","slug":"fp","permalink":"https://React-Apollo.github.io/tags/fp/"},{"name":"Express","slug":"Express","permalink":"https://React-Apollo.github.io/tags/Express/"},{"name":"mongodb","slug":"mongodb","permalink":"https://React-Apollo.github.io/tags/mongodb/"}]},{"title":"使用函数式异步compose方法给graphcool数据库批量导入数据(2)","slug":"使用函数式异步compose方法给graphcool数据库批量导入数据(2)","date":"2018-01-24T17:20:28.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/01/24/使用函数式异步compose方法给graphcool数据库批量导入数据(2)/","link":"","permalink":"https://React-Apollo.github.io/2018/01/24/使用函数式异步compose方法给graphcool数据库批量导入数据(2)/","excerpt":"","text":"异步compose方法批量导入数据流程 解决链式数据流程的异步流程同步化办法 问题在https://react-apollo.github.io/2018/01/24/构建基于MongoDB的%20graphql%20服务器(四)/)已经实现了了数据的流程，但是具体的处理方法上很不Ramda,经过连夜奋战，但是问题存在：对于async/await的基础流程不太清楚，所以绕了弯路，console.log会报错，但是结果是插入数据库了，问题在刚开始console.log，抓取的事件还没有完成在获取函数之后打印是没问题的，但是在获取函数之内就出问题，原因在于远程获取函数之内的打印并没有受到async的控制。 解决办法 终于在网上找到一个异步版本的compose函数，解决了这个问题。comopse函数组合的子函数都要是添加await关键字的，这样做，从流程：远程数据=&gt;数据去毛=&gt;插入数据库的路程才可以顺序执行。正常的流程是这样。因为js的事件轮训机制， 数据去毛的过程可能在数据没有返回(网络请求有延迟)的情况下就会执行，这样就获取不到数据，但是在远程数据回来以后就会有结果了，所以这里的数据去毛，还有数据库插入数据的操作会提示输入参数undefined,但是结果是可以运行的。异步版本的compose函数 12345 // Async composeconst compose = （...functions) =&gt; input =&gt; functions.reduceRight((chain, func) =&gt; chain.then(func), Promise.resolve(input));// Functions fn1, fn2, fn3 can be standard synchronous functions or return a Promisecompose(fn3, fn2, fn1)(input).then(result =&gt; console.log(`Do with the $&#123;result&#125; as you please`)) 异步版本的compose的关键点是使用reduce函数组合子函数时，reduce是异步版本，简单说给就是把每个函数都变为promise对象 直接从json文件获取的数据批量插入现在这个版本是使用了Gdom-基于graphql和python的页面抓取工具 从medium网站获取数据的查询语句(具体细节省略了，不能作为实际的使用，类型大致如此)12345678910111213&#123; page(url: \"https://mediumq=graphcool\") &#123; items: query(selector: \"div\") &#123; title: text(selector: \"div h3\") subTitle: text(selector: \"div h4\") url:attr(selector:\"div a\",name:\"href\") shortPassage: text(selector: \"div p\") avatarImage:attr(selector:\".postMetaInline-avatar img\"name:\"src\") authorName: text(selector: \"postMetaInline:first-child\") clap: text(selector: \"div .js-actionMultirecommendCount \") &#125; &#125;&#125; 异步版本的数据操作流程实际是和前面的版本是相同的，只是compose函数是异步的。第一步从网站抓取数据是异步的，第三步插入graphcool数据库是异步的。所以传统的compose函数就不能使用了。需要使用异步的compose。 获取数据的方法简单讲就是graphql 版本的get和post方法1234567//柯理化版本以便于后面构造composeconst handleGrqphcoolDataTemplate = R.curry((api, template, variables) =&gt; ( request(api, template, variables).then(data =&gt; &#123; //console.log(data.page.items); return data &#125;))) 具体的数据流代码12345678910111213141516171819202122232425262728// #获取数据的方法-简单描述就是graphql版的get和post方法，只要是和const handleGrqphcoolDataTemplate = R.curry((api, template, variables) =&gt; ( request(api, template, variables).then(data =&gt; &#123; //console.log(data.page.items); return data &#125;)))/** ++第一步构建从medium网站通过grapql查询获取方法的工厂++从Medium 网站获取数据的方法是一样的的，柯理化是处理参数不同,抓取变量是网站地址抓取后的数据作为insertDataWaitForData的数据工厂组装完成，只等待传入medium的网址就可以工作了 **/const getDataFromMediumWaitForUrl = handleGrqphcoolDataTemplate(graphqlUrlForRemoteData, schemaForGetDataFromRemote)/* ++第二步构建的工厂专门拔猪毛 毛🐽变光🐷，等待光🐽 */const getArray = (obj) =&gt; obj.page.items// 柯理化 等待抓取的数据const graphqlRequestMethodWaitForData = handleGrqphcoolDataTemplate(api, qu)/*++第三步插入数据的graphcool操作++ 由于是从数组获取的数据，这里就使用map方法进行遍历处理*/const insertDataWaitForData = R.map(graphqlRequestMethodWaitForData)//异步的compose函数const compose = (...functions) =&gt; input =&gt; functions.reduceRight((chain, func) =&gt; chain.then(func), Promise.resolve(input))//构建的整个流程的工厂const insertData = compose(insertDataWaitForData, getArray, getDataFromMediumWaitForUrl)","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"Ramda","slug":"Ramda","permalink":"https://React-Apollo.github.io/tags/Ramda/"}]},{"title":"构建基于MongoDB的 graphql 服务器(四)","slug":"构建基于MongoDB的 graphql 服务器(四)","date":"2018-01-24T04:50:28.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/01/24/构建基于MongoDB的 graphql 服务器(四)/","link":"","permalink":"https://React-Apollo.github.io/2018/01/24/构建基于MongoDB的 graphql 服务器(四)/","excerpt":"","text":"构建基于MongoDB的 graphql 服务器(四) 设想是给graphcool数据库提供一些数据，考虑最近看Medium网站较多，所以抓取这里边的信息. 方法和前面的大同小异， 这里实际算是一个完整的流程了。 使用gDom的grqhql方法选择dom元素。 根据Dom元素来定graphql查询中shcema 数据消毒处理 通过graphcool的方法，插入数据库 难点是schema的建立，和两个主操作的异步处理问题，使用了flow方法，让以异步流程转为类似compose的以异步方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/***************** * 从medium抓取一下感兴趣的内容，放到app中 * *******************/'use strict'import express from 'express'// import bodyParser from 'body-parser'import cors from 'cors'import * as R from 'ramda'import &#123; request &#125; from 'graphql-request'import mediumData from '../dist/mediumData'// 导入的数据// import new_hotel from '../dist/new_hotel'// var fs = require('fs')// var path = require('path')const mediumUrl='https://medium.com/search?q=React-native';const variables = &#123; url: 'https://medium.com/search?q=hoc',&#125;const gDomApi='http://gdom.graphene-python.org/graphql';const URL = 'http://localhost'const PORT = 3001// graphcool endpointconst api = 'https://api.graph.cool/simple/v1/cjcrwz0tg3jyf0153l824cpyh'var _ = require('lodash');var flow=require('nimble');var Promise = require(\"bluebird\");// graphql模板const mu = `mutation getMediumList( $title:String!, $subTitle:String!, $authorName:String!, $avatarImage: String!, $shortPassage:String!, $url: String!, $clap: String!)&#123; createMedium( title:$title, subTitle:$subTitle, authorName:$authorName, avatarImage:$avatarImage, shortPassage:$shortPassage, url: $url, clap:$clap, )&#123; id, title &#125;&#125;`const que =`query getMedium($url:String!)&#123; page(url: $url) &#123; items: query(selector: \"div.js-postListHandle .js-block\")&#123; title: text(selector: \"div h3\") subTitle: text(selector: \"div h4\") url:attr(selector:\"div .postArticle-content a\",name:\"href\") shortPassage: text(selector: \"div p\") avatarImage:attr(selector:\".postMetaInline-avatar img\"name:\"src\") authorName: text(selector: \"div .postMetaInline:first-child\") clap: text(selector: \"div .js-actionMultirecommendCount \") &#125; &#125;&#125;`export const start = async () =&gt; &#123; try &#123; const app = express() app.use(cors()) app.use(express.static(__dirname)) app.listen(PORT, () =&gt; &#123; console.log(`Visit $&#123;URL&#125;:$&#123;PORT&#125;`) &#125;) Promise.try(insertData(variables)).then( console.log(\"done\") ); &#125; catch (e) &#123; console.log(e) &#125;;&#125;// 获取数据的方法const handleGrqphcoolDataTemplate = R.curry((api, template, variables) =&gt; ( request(api, template, variables).then(data =&gt; &#123; //console.log(data.page.items); return data; &#125;)))// 柯理化 等待抓取的数据const graphqlRequestMethodWaitForData = handleGrqphcoolDataTemplate(api, mu);const insertDataWaitForData = R.map(graphqlRequestMethodWaitForData);// 从Medium 网站获取数据的方法是一样的的，柯理化是处理参数不同,抓取是变量是网站地址//抓取后的数据作为insertDataWaitForData的数据const getDataFromMediumWaitForUrl = handleGrqphcoolDataTemplate(gDomApi, que);//const xHeadYLens = R.lensPath(['page', 'items']);//const getArray = R.view(xHeadYLens);// 这是从reddit中找的异步执行的方法const _wrapFlowAsync = (fn) =&gt; (arg) =&gt; Promise .try(() =&gt; arg) .then(fn);const flowAsync = (...fns) =&gt; &#123; const wrappedFns = fns.map(fn =&gt; _wrapFlowAsync(fn)) return _.flow(wrappedFns)&#125;const getArray = (obj) =&gt; obj.page.items;//这里的的流顺序是从左至右const insertData = flowAsync( getDataFromMediumWaitForUrl, getArray , insertDataWaitForData)","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"}]},{"title":"PocketerCRA项目说明","slug":"Pocket CRA ","date":"2018-01-23T20:18:28.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/01/23/Pocket CRA /","link":"","permalink":"https://React-Apollo.github.io/2018/01/23/Pocket CRA /","excerpt":"","text":"Pocketer-CRA项目说明主要技术介绍 使用graphql和mongodb和 create-react-app构建的项目分为三部分: ①.网站内容抓取并存入到mlab数据库 ②.构建graphql-server服务器提供查询服务，后台通过mongoose和mlab交互，获取查询信息。 ③.前端的CRA程序，使用react-apollo-hooks和graphql服务器交互获取查询信息 网站内容抓取程序组成信息通过 http://gdom.graphene-python.org/graphql获取Pocketer的内容信息。 这是request模块需要的graphql服务器地址url地址. Dom结构如下： 123456789101112const getList = `query getList($url:String!)&#123; page(url: $url) &#123; List: query(selector: \"#best_of_list ul li .item_content\") &#123; title: text(selector: \".title a\") source: text(selector: \"cite a\") time: text(selector: \"cite span\") url: attr(selector: \".title a\", name: \"href\") excerpt: text(selector: \".excerpt\") &#125; &#125;&#125;`; 传入要抓取网站的链接，填入要获取信息的dom结构信息。这是request模块需要的的template信息. 代码结构request 函数柯里化 123456789101112//使用Ramda 柯里化 request函数的参数const handleGrqphcoolDataTemplate = R.curry( (api, template, variables) =&gt; ( request(api, template, variables).then(data =&gt; &#123; return data; &#125;) ))//柯理化的函数先传递 graphql服务器的地址和schema,等待 url 变量const queryData = handleGrqphcoolDataTemplate(gDomApi,getList); 传入url地址到获取整个抓取对象的数据流，ramda的compose函数负责从右向左传递数据 1234567891011//1 拼接链接字符串const getUrlStringOfpocket=(str=\"javscript\")=&gt;`&#123;\"url\":\"https://getpocket.com/explore/$&#123;str&#125;?src=search\"&#125;`; // 2 格式化模板json化const JsonFormat = (UrlString) =&gt; JSON.parse(UrlString);//3 查询数据const queryPages = (queryStr) =&gt; queryData(queryStr) //4 数据脱括号的方法,去掉前面的几层花括号的层级 const getArray =async (obj) =&gt; obj.page.List;//然后传入等待链接的graphql查询函数,使用异步compose,从右向左执行流程const getPagesArray = asyncompose(getArray,queryPages,JsonFormat,getUrlStringOfpocket); ‌借助Mongoose插入数据到mlab 数据库config.js 1234567const mongoose = require('mongoose');mongoose.Promise = global.Promise;const MONGO_URL='mongodb://user:user1234@ds048368.mlab.com:48368/pocket-excerpt';mongoose.connect(MONGO_URL, &#123; useNewUrlParser: true &#125;);mongoose.connection.once('open', () =&gt; console.log(`Connected to mongo at $&#123;MONGO_URL&#125;`)); 在config.js文件中配置mlab数据库和mongoose配置,mongoose需要设置schema，mongoose的schema和Graphql的schema很相似，所以一起使用很方便 1234567891011121314151617const mongoose = require('mongoose');const &#123; Schema &#125; = mongoose;const News = new Schema(&#123; cate:String, title: String, source: String, time: String, url:String, excerpt:String,&#125;);const newsModel = mongoose.model('News', News); module.exports = &#123; newsModel&#125;; 创建的额newModel模型性对象就挂在了根据schema操作mongodb的方法。直接执行及㐓了 插入操作 1234const dbForData= async (args)=&gt;&#123; newsModel.create(args); //插入数据 log(chalk.green('insert %s'),args.title); &#125;; 只只要提供的参数和schema的一样，插入就很简单，只要一个model.create(args)就可以了。 模型中定义了cate，用于pocketer的分类， 所以在从网站抓取的信息中添加这个cate字段 123456789101112//获取的数据const Array= await getPagesArray(str); //const db= await dbForData(_) ; //遍历对象添加查询字符串作为分类标记 const addCate= (obj)=&gt;&#123; return Object.assign(&#123;&#125;, obj, &#123; cate: cate, &#125;) &#125;//遍历获取的数组每篇文章的信息，添加cate字段const ArrayaddCate= Array.map(addCate); 遍历数组，执行插入操作 1await R.map(dbForData,ArrayaddCate); 以上代码是单个搜索字符串的插入结果，每个字符串下面可以查到很多文章。 相当于单个售票窗口的队列。 但是我们可以传入多个字符串，这就相当于售票处开了多个窗口。多个窗口之间的操作是并行执行的。 在单个窗口的操作其实也可以是并行操作。这里没有考虑。 执行多个字符串的操作，代码如下： 12345678const insertData= async (items)=&gt; &#123; //items是传入的多个字符串 const promises = items.map((item) =&gt; getData(item)); await Promise.all(promises); log(chalk.yellow('Total Done !')); &#125; await insertData(searchkeywords); 上面代码中items就是传入的多个查询字符串组成的数组， 遍历它，因为数组中每个字符串元素返回的都是promise对象， 使用map方法组成promise数组，然后使用Promise.all方法并行执行操作。 ‌单个字符串的流程还要修改一下，每篇文章的操作仍然是并发的 本地的graphql-server的构建使用了apollo-graphql-express构建 提供 typeDefs和resolvers就可以了。 服务器接受执行指令， 然后在resolvers中执行数据库操作，然后返回Graphql结果 graphql参数定义 1234567891011121314151617181920212223242526272829303132333435363738394041const typeDefs = gql` type News &#123; id: ID! cate:String, title: String, source: String, time: String, url: String , excerpt: String, &#125; type Query &#123; getAllNews: [News] &#125; type Mutation &#123; addOneNews( cate:String, title: String, source: String, time:String, url: String, excerpt: String, ): News &#125;`;const resolvers = &#123; Query: &#123; getAllNews: async () =&gt; await newsModel.find(&#123;&#125;).exec() &#125;, Mutation: &#123; addOneNews: async (_, args) =&gt; &#123; try &#123; console.log(args); let response = await newsModel.create(args); return response; &#125; catch(e) &#123; return e.message; &#125; &#125; &#125;&#125;; graphQL服务器初始化 1234567const server = new ApolloServer(&#123; typeDefs, resolvers &#125;);const app = express();server.applyMiddleware(&#123; app &#125;);app.listen(&#123; port: 4000 &#125;, () =&gt; console.log(`🚀 Server ready at http://localhost:4000$&#123;server.graphqlPath&#125;`)); Create-React-App 构建添加了styled-components,reactstrap,react-apollo-hooks。","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"}]},{"title":"使用函数式方法批量导入数据","slug":"在graqhcool 数据库批量插入数据","date":"2018-01-23T05:24:28.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/01/23/在graqhcool 数据库批量插入数据/","link":"","permalink":"https://React-Apollo.github.io/2018/01/23/在graqhcool 数据库批量插入数据/","excerpt":"","text":"从数据源来的数据，json文件格式，或者是数组， 批量导入到graphcool数据库中。 使用了函数式编程中的ramda.js 和tranducers-js.js的方法， 问题分解 遍历数组，采用map方法 映射单个对象属性到variable 单个对象的变量插入到数据库中 解决办法这里使用函数式编程来处理问题，函数式并不是高深的技术，只是简化了处理问题的流程常规的处理流程transducer的处理流程 数据结构：1234567&#123; ratingStars: 4, name: 'Hotel Europe', streetAddress: 'Dufourstrasse 4', postalCode: '8008', cityLocalized: 'Zürich', geolocation: &#123;latitude: 47.364185, longitude: 8.547145&#125;&#125; 这里有嵌套的结构，在graphql-request要使用扁平的结构，所以需要对数组对象中的的单个对象做映射处理，然后再插入数据库。使用transducer原理，不在先处理映射，然后函子，接着再map方法，插入的数组。 对单个对象的处理可以通过tranducer方式放到一起一并处理。 这里的思想是很精妙的。 具体的操作方法在express服务器上运行 请求函数柯理化1234567//首先传入API，template,等待数据//变量放在最后，有可能用于compose函数const func = R.curry((api, template, variables) =&gt; ( request(api, template, variables).then(data =&gt; &#123; console.log(data) &#125;) )) 扁平化对象数据123456789101112var flattenData = function (n) &#123; return &#123; name: n.name, ratingStars: n.ratingStars, streetAddress: n.streetAddress, postalCode: n.postalCode, cityLocalized: n.cityLocalized, latitude: n.geolocation.latitude, longitude: n.geolocation.longitude, &#125;&#125;; 函数式方法的一些处理过程123456789101112const waitForData = func(api, mu); //柯理化//xf是transducer的过程，对于单个对象的连续处理可以在这里实现// 方向是从左=&gt;右，var xf = t.comp(R.map(flattenData), R.map(waitForData));//这个中间函数有做了柯理化，等待作用的数组数据，这里不是对象了//流程就是接受数组对象，取出`单个对象`，使用tranducer进行处理const mediateFunc=R.curry((xf,data)=&gt;(t.into([], xf, data)));const getFinalRes=mediateFunc(xf);getFinalRes(data); 整个代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102'use strict'// 从hotel 文件获取json数据然后写入到graphcool数据库import express from 'express'import bodyParser from 'body-parser'import cors from 'cors'import * as R from 'ramda'var fs = require('fs')var path = require('path')require('es6-promise').polyfill()require('isomorphic-fetch')import fetch from 'node-fetch'import &#123; request &#125; from 'graphql-request'import hotelData from '../dist/hotelData'//导入的数据const URL = 'http://localhost'const PORT = 3001const api = 'https://api.graph.cool/simple/v1/cjaxudkum2ugf0127kok921bc'; //graphcool API//graphql模板const mu = `mutation createOneHotel( $name:String!, $ratingStars:Int!, $streetAddress:String!, $postalCode: String!, $cityLocalized:String!, $longitude: Float!, $latitude: Float!)&#123;createHotel( name:$name, ratingStars:$ratingStars,streetAddress:$streetAddress, postalCode:$postalCode, cityLocalized:$cityLocalized,geolocation:&#123;latitude:$latitude, longitude: $longitude&#125;)&#123;idgeolocation&#123; longitude latitude&#125;&#125;&#125;`var t = require('transducers-js');//导入transducers-js执行tranducer操作export const start = async () =&gt; &#123; try&#123; const app = express() app.use(cors()) app.use(express.static(__dirname)) app.listen(PORT, () =&gt; &#123; console.log(`Visit $&#123;URL&#125;:$&#123;PORT&#125;`) &#125;); //直接从文件读取，不成功，但是导入是可以的,说明数据的操作是没有问题的，继续再试s // fs.readFile(path.resolve(__dirname,'hotel.json'), function(err,data)&#123; // if(err) throw err; // //console.log(data.toString()); // const hotelData=data.toString(); // //console.log(typeof(data); // //const Data=data.toString(); // //InsertData(Data); // console.log(typeof(hotelData)); // &#125;); InsertData(hotelData); &#125; catch (e) &#123; console.log(e) &#125;;&#125;;var InsertData =(data) =&gt; &#123; // console.log(data); //请求方法的柯理化，首先传入api和template，等待变量 const func = R.curry((api, template, variables) =&gt; ( request(api, template, variables).then(data =&gt; &#123; console.log(data) &#125;) )) var flattenData = function (n) &#123; return &#123; name: n.name, ratingStars: n.ratingStars, streetAddress: n.streetAddress, postalCode: n.postalCode, cityLocalized: n.cityLocalized, latitude: n.geolocation.latitude, longitude: n.geolocation.longitude, &#125;&#125;;const waitForData = func(api, mu);var xf = t.comp(R.map(flattenData), R.map(waitForData)); const mediateFunc=R.curry((xf,data)=&gt;(t.into([], xf, data)));const getFinalRes=mediateFunc(xf);getFinalRes(data);&#125;;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"express","slug":"express","permalink":"https://React-Apollo.github.io/tags/express/"},{"name":"ramda","slug":"ramda","permalink":"https://React-Apollo.github.io/tags/ramda/"},{"name":"tranducer","slug":"tranducer","permalink":"https://React-Apollo.github.io/tags/tranducer/"}]},{"title":"构建基于MongoDB的 graphql 服务器(三)","slug":"构建基于MongoDB的 graphql 服务器(三)","date":"2018-01-22T20:18:28.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/01/22/构建基于MongoDB的 graphql 服务器(三)/","link":"","permalink":"https://React-Apollo.github.io/2018/01/22/构建基于MongoDB的 graphql 服务器(三)/","excerpt":"","text":"graphql-request的使用 graphql是graphcool的的client端，可以用于express服务器中请求数据，在resolver中也可以使用。apollo-client就只能用在在前端。 对于前端使用apollo-client绝对是最好的选择。目前没有对手。 做mutate处理，遇到不少问题，主要函数函数第一次接触，参数没有拼接对。一直以为是js对象转json的问题，早上一直在解决这个问题。结果还是参数的问题，模拟的数据是hotel的数据，其中嵌套有geolocation信息。 为这个嵌套，改了不同的组合，多没有出来， 结果正确拼接好以后，所有问题都没有了，数据是js对象还是json数据都可处理。 接下来要遍历对象数组的时候问题依然是变量的拼接。 代码如下，直接启动文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186//从hotel 文件获取json数据然后写入到graphcool数据库import express from 'express'import bodyParser from 'body-parser'import &#123;graphqlExpress, graphiqlExpress&#125; from 'graphql-server-express'import &#123;makeExecutableSchema&#125; from 'graphql-tools'import cors from 'cors'import * as R from 'ramda'var fs= require('fs');var path=require('path')require('es6-promise').polyfill();require('isomorphic-fetch');import fetch from 'node-fetch';import &#123; request &#125; from 'graphql-request'const URL = 'http://localhost'const PORT = 3001export const start = async () =&gt; &#123; try &#123; const typeDefs = [` type geoData&#123; longitude: Float!, latitude: Float!, &#125; type Hotel&#123; id: ID! ratingStars: Int! name: String! streetAddress: String! postalCode: String!, cityLocalized: String!, geolocation:[geoData!]! &#125; type Mutation &#123; insertData( name: String ): Hotel &#125; type Query&#123; getHotels: [Hotel] geoDatas: geoData &#125; `]; const resolvers =&#123; Mutation: &#123; insertData:async (parent,args,context)=&gt;&#123; const query = `&#123; allHotels(name:$name, streetAddress: $streetAddress, postalCode: $postalCode, cityLocalized: $cityLocalized, geolocation:&#123;$longitude:longitude,$latitude:latitude&#125;)&#123; name, geolocation&#123; longitude, latitude &#125; &#125; &#125;`; const variables=&#123; ratingStars: 8, name: \"vvafo\", streetAddress: \"Hruggerstrasse 56\", postalCode: \"8400\", cityLocalized: \"Paden\", geolocation: &#123;latitude: 47.343960, longitude: 7.304224&#125; &#125;; request('https://api.graph.cool/simple/v1/cjaxudkum2ugf0127kok921bc', query,variables).then(data =&gt; &#123; console.log(data); return data &#125;) &#125; &#125;, Query:&#123; getHotels:async (parent,args,context)=&gt;&#123; const query = `&#123; allHotels&#123; id, name, geolocation&#123; longitude, latitude &#125; &#125; &#125;` request('https://api.graph.cool/simple/v1/cjaxudkum2ugf0127kok921bc', query).then(data =&gt; &#123; console.log(data); return data &#125;) &#125;, &#125;&#125; const schema = makeExecutableSchema(&#123; typeDefs, resolvers &#125;) const app = express() app.use(cors()) app.use(express.static(__dirname)) app.use('/graphql', bodyParser.json(), graphqlExpress(&#123;schema: schema&#125;)) const homePath = '/graphiql' app.use(homePath, graphiqlExpress(&#123; endpointURL: '/graphql' &#125;)) app.listen(PORT, () =&gt; &#123; console.log(`Visit $&#123;URL&#125;:$&#123;PORT&#125;$&#123;homePath&#125;`) &#125;) InsertData(); &#125; catch (e) &#123; console.log(e) &#125;&#125;//使用的是这个函数var InsertData=()=&gt;&#123; const mu= `mutation createOneHotel( $name:String!, $ratingStars:Int!, $streetAddress:String!, $postalCode: String!, $cityLocalized:String!, $longitude: Float!, $latitude: Float! )&#123; createHotel( name:$name, ratingStars:$ratingStars, streetAddress:$streetAddress, postalCode:$postalCode, cityLocalized:$cityLocalized, geolocation:&#123;latitude:$latitude, longitude: $longitude&#125;)&#123; id geolocation&#123; longitude latitude &#125; &#125; &#125;`; const Variables=&#123; name:\"sdfsdlfrererjsldjfsl\", ratingStars:11, streetAddress:\"fdgtetwerwgeg\", postalCode:\"Hakerer ddome\", cityLocalized:\"Lordan\", latitude: 47.343964, longitude: 7.30424, &#125;; request('https://api.graph.cool/simple/v1/cjaxudkum2ugf0127kok921bc', mu,Variables).then(data =&gt; &#123; console.log(data); return data &#125;) &#125;;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"}]},{"title":"构建基于MongoDB的 graphql 服务器(二)。","slug":"构建基于MongoDB的 graphql 服务器(二) ","date":"2018-01-22T11:40:28.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/01/22/构建基于MongoDB的 graphql 服务器(二) /","link":"","permalink":"https://React-Apollo.github.io/2018/01/22/构建基于MongoDB的 graphql 服务器(二) /","excerpt":"","text":"#构建基于MongoDB的 graphql 服务器(二) 项目起因：想包装一下cnode的api,可以使用graphql的mutate方法实现收藏cnode帖子功能，在resolvers中对api包装，用query就可以，因为具体的数据获取并没有使用Graphql的功能。 只不过套用了其中的模式。 但是定义好了mutate或者query在后面比较好理解。这里可以用了，但是不是太规范。项目版本由此 衍生而来 graphql-mongodb-example作者是：”author”: “Nicola Marcacci Rossi &#x6e;&#x69;&#99;&#x6f;&#108;&#97;&#109;&#114;&#64;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109; (http://nmr.io)&quot;这个版本在express-server中对es7的支持很好，语法检查也很完备所以可以作为很好的初始版本。 整理好了之后，考虑向作者提出提交申请。 还有几个类似的服务器也在文件夹中，需要修改index.js的文件名 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import &#123;MongoClient, ObjectId&#125; from 'mongodb'import express from 'express'import bodyParser from 'body-parser'import &#123;graphqlExpress, graphiqlExpress&#125; from 'graphql-server-express'import &#123;makeExecutableSchema&#125; from 'graphql-tools'import cors from 'cors'import fetch from 'node-fetch'require('es6-promise').polyfill()require('isomorphic-fetch')const URL = 'http://localhost'const PORT = 3001const MONGO_URL = 'mongodb://php-smarter:&lt;password,去掉尖括号&gt;@ds239097.mlab.com:39097/recompose'const api = 'https://cnodejs.org/api/v1/topic_collect/collect'// const request = require('superagent');export const start = async () =&gt; &#123; try &#123; const typeDefs = [` type collectTopic &#123; topic_id: String accesstoken: String success: Boolean &#125; type Query &#123; getCollectionTopic(topic_id: String!, accesstoken: String!): collectTopic, createCollectionTopic(topic_id: String!, accesstoken: String!): collectTopic &#125;, schema &#123; query: Query &#125; `] const resolvers = &#123; Query: &#123; createCollectionTopic: async (parent, args, context) =&gt; &#123; const &#123;accesstoken, topic_id&#125; = args const body = &#123;accesstoken: accesstoken, topic_id: topic_id&#125; const ress = await fetch(api, &#123; method: 'POST', body: JSON.stringify(body), headers: &#123; 'Content-Type': 'application/json' &#125; &#125;) .then(res =&gt; res.json()) .then(json =&gt; json) console.log(ress) const success = &#123;'success': ress.success&#125; return success &#125; &#125; &#125; const schema = makeExecutableSchema(&#123; typeDefs, resolvers &#125;) const app = express() app.use(cors()) app.use('/graphql', bodyParser.json(), graphqlExpress(&#123;schema: schema&#125;)) const homePath = '/graphiql' app.use(homePath, graphiqlExpress(&#123; endpointURL: '/graphql' &#125;)) app.listen(PORT, () =&gt; &#123; console.log(`Visit $&#123;URL&#125;:$&#123;PORT&#125;$&#123;homePath&#125;`) &#125;) &#125; catch (e) &#123; console.log(e) &#125;&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://React-Apollo.github.io/tags/MongoDB/"}]},{"title":"构建基于MongoDB的 graphql 服务器(一)。","slug":"构建基于MongoDB的 graphql 服务器(一)","date":"2018-01-22T11:18:28.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/01/22/构建基于MongoDB的 graphql 服务器(一)/","link":"","permalink":"https://React-Apollo.github.io/2018/01/22/构建基于MongoDB的 graphql 服务器(一)/","excerpt":"","text":"#构建基于MongoDB的 graphql 服务器(一) 项目起因：本来想在后端使用graphcool服务器，在后端定义好了schema之后，其他的工作就由graphcool 自动生成了CURD的各种方法，很好用，因为graphql的自省功能，可以在graphiql查询时根据定义好的schma给你提供很好的提示但是如果要批量导入数据，就比较麻烦。所以尝试使用mongodb+graphql的方法自建一个服务器，根据下面版本建立了一个服务器。项目版本由此 衍生而来 graphql-mongodb-example作者是：”author”: “Nicola Marcacci Rossi &#x6e;&#105;&#99;&#x6f;&#108;&#97;&#109;&#114;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#109; (http://nmr.io)&quot;这个版本在express-server中对es7的支持很好，语法检查也很完备所以可以作为很好的初始版本。 整理好了之后，考虑向作者提出提交申请。 ####步骤： 构建express服务器 连接mongodb 构建graphql的schema 查询数据 这里做了一个很傻的决定，要在resolver中再从graphcool服务器取数据，取出来是没有问题，问题是数据 js对象和Json对象转换，很麻烦，取出的数据的转化在graphcool-framework 的rest-wrapper中 cnode API的数据获取中有模板文件遇到嵌套数据比较难处理。还有几个类似的服务器也在文件夹中，需要修改index.js的文件名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import &#123;MongoClient, ObjectId&#125; from 'mongodb'import express from 'express'import bodyParser from 'body-parser'import &#123;graphqlExpress, graphiqlExpress&#125; from 'graphql-server-express'import &#123;makeExecutableSchema&#125; from 'graphql-tools'import cors from 'cors'const URL = 'http://localhost'const PORT = 3001const MONGO_URL = 'mongodb://php-smarter:&lt;password&gt;@ds239097.mlab.com:39097/recompose'const prepare = (o) =&gt; &#123; o._id = o._id.toString() return o&#125;function fromMongo(item) &#123; item.id=(item._id).toString(); return item &#125;export const start = async () =&gt; &#123; try &#123; const db = await MongoClient.connect(MONGO_URL) //const context=await db.collection('books') //console.log(context); const typeDefs = [` type Book &#123; id: ID! isbn: String! title: String! author: Author! &#125; type Author &#123; id: ID! name: String! &#125; type Query &#123; books(keyword:String): [Book] book(id: ID!): Book &#125; schema &#123; query: Query &#125; `]; const resolvers = &#123; Query: &#123; books: async (root,args, context) =&gt; &#123; let findParams = &#123;&#125;; console.log(args); if (args.keyword) &#123; findParams.title = new RegExp(args.keyword, 'i') &#125; //console.log('2:',db); const res=await context.db.collection('books').find(findParams).map(fromMongo).toArray(); //console.log(context); return res; &#125;, book: async (root,&#123;id, title&#125;, context) =&gt; &#123; //console.log(id); const result = await context.db.collection('books') .findOne(&#123;_id: new ObjectId(id) &#125;) return fromMongo(result) &#125; &#125; &#125; const schema = makeExecutableSchema(&#123; typeDefs, resolvers &#125;) const app = express() app.use(cors()) app.use('/graphql', bodyParser.json(), graphqlExpress(&#123;schema: schema, context: &#123; db: db &#125;&#125;)) const homePath = '/graphiql' app.use(homePath, graphiqlExpress(&#123; endpointURL: '/graphql' &#125;)) app.listen(PORT, () =&gt; &#123; console.log(`Visit $&#123;URL&#125;:$&#123;PORT&#125;$&#123;homePath&#125;`) &#125;) &#125; catch (e) &#123; console.log(e) &#125;&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://React-Apollo.github.io/tags/MongoDB/"}]},{"title":"Apollo-github第三方登录的实现","slug":"Apollo-github第三方登录的实现","date":"2018-01-21T22:30:28.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/01/21/Apollo-github第三方登录的实现/","link":"","permalink":"https://React-Apollo.github.io/2018/01/21/Apollo-github第三方登录的实现/","excerpt":"","text":"graphcool-github第三方登录的实现 OAuth 协议的认证和授权的过程如下： 1.用户打开我的博客后，我想要通过GitHub获取改用户的基本信息2.在转跳到GitHub的授权页面后，用户同意我获取他的基本信息3.博客获得GitHub提供的授权码，使用该授权码向GitHub申请一个令牌4.GitHub对博客提供的授权码进行验证，验证无误后，发放一个 令牌给博客端5.博客端使用令牌，向GitHub获取用户信息6.GitHub 确认令牌无误，返回给我基本的用户信息 基本的流程就是如此。在Graphcool的官方路程中跑不通这个过程，好像是fetch的异步操作有问题。所我用了单独的graphql服务器来实现，官方流程中需要把数据存到graphcool的库中，这一步没有做。 获得授权码这要用一个登陆页面，有github的脚本，和你我申请的ID。共同去服务端获得一个githubUserCode,这个就是要使用的查询参数。 html网页通过http-server本地服务器加载，主要的是这个服务的的端口要和github申请时的回调地址和端口一致。光放文档是使用的是python的http服务，我没用，端口可能是8000.用http-server时端口是8080，和文档描述不一致的时候，要知道为什么。官方的文件为template仓库html文件12345678910111213141516171819202122&lt;html&gt;&lt;body&gt; &lt;script&gt; // Github client id const client_id = '842e83a0329b156b0a5b' // Will extract code from current url const githubCode = window.location.search.substring(1).split('&amp;')[0].split('code=')[1] if (githubCode) &#123; // call Graphcool authenticateGithubUser mutation console.log(githubCode) &#125; function getgithubCode() &#123; window.location = `https://github.com/login/oauth/authorize?client_id=$&#123;client_id&#125;&amp;scope=user` &#125; &lt;/script&gt; &lt;button onclick=\"getgithubCode();\"&gt;Authenticate with Github&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 这里是一个静态的html页面，如果是webapp或者APP的话，这里点击后，从github网站请求到githubUserCode，以后可以执行换取用户信息的工作了。这里为了方便，通过console.log的方式在终端中打印出gitHubUser的值，然后我在graqhiql界面执行一个查询操作，如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import express from 'express'import bodyParser from 'body-parser'import &#123;graphqlExpress, graphiqlExpress&#125; from 'graphql-server-express'import &#123;makeExecutableSchema&#125; from 'graphql-tools'import cors from 'cors'require('es6-promise').polyfill();require('isomorphic-fetch');import fetch from 'node-fetch';const URL = 'http://localhost'const PORT = 3001export const start = async () =&gt; &#123; try &#123; const typeDefs = [` type AuthenticateUserPayload &#123; id: ID! token: String! &#125; type Query &#123; getGithubToken(githubCode: String!): AuthenticateUserPayload &#125; schema &#123; query: Query &#125; `]; const resolvers =&#123; Query :&#123; /*test start area*/ getGithubToken:async (parent,args,context)=&gt;&#123; console.log(args); const endpoint = 'https://github.com/login/oauth/access_token' const &#123;githubCode&#125; =args; const client_id= '842e83a0329b156b0a5b' const client_secret = '0a25a9f3c5cb3d47eece0b54e58163a188834bf9' const data = await fetch(endpoint, &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json', 'Accept': 'application/json' &#125;, body: JSON.stringify(&#123; client_id, client_secret, code: githubCode, &#125;) &#125;) .then(response =&gt; response.json()) if (data.error) &#123; throw new Error(JSON.stringify(data.error)) &#125; console.log(\"data,\",data); const res=await getGithubUser(data.access_token) console.log(res); return &#123;token:data.access_token,id:res.id&#125;; &#125; /*test end area*/ &#125; &#125; const getGithubUser=async (githubToken)=&gt;&#123; const endpoint = `https://api.github.com/user?access_token=$&#123;githubToken&#125;` const data = await fetch(endpoint).then(response =&gt; response.json()) if (data.error) &#123; throw new Error(JSON.stringify(data.error)) &#125; return data &#125; const schema = makeExecutableSchema(&#123; typeDefs, resolvers &#125;) const app = express() //app.use(cors()) app.use('/graphql', bodyParser.json(), graphqlExpress(&#123;schema: schema&#125;)) const homePath = '/graphiql' app.use(homePath, graphiqlExpress(&#123; endpointURL: '/graphql' &#125;)) app.listen(PORT, () =&gt; &#123; console.log(`Visit $&#123;URL&#125;:$&#123;PORT&#125;$&#123;homePath&#125;`) &#125;) &#125; catch (e) &#123; console.log(e) &#125;&#125; 在这个服务器的resolver中post请求发送githubUser信息到github.实际的代码是很简单的。 注意异步操作的问题，在这个问题上绕了很久，才摸索出上面的方法。 ResT-Wrapper中的实现在Graphcool rest-wrapper实例代码中也实现了这个操作。 graphcool的起始配置很复杂，但是实际使用时很方便的。rest-wrapper的库提交到bitbucket上.文件目录 src/github/ 文件结构已经重新整理过resolver’的代码如下：建了两个数据模型但是没有使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import &#123;fromEvent, FunctionEvent&#125; from 'graphcool-lib'import &#123;GraphQLClient&#125; from 'graphql-request'import * as fetch from 'isomorphic-fetch'interface User &#123; id : string&#125;interface GithubUser &#123; id : string html_url: string gists_url: string avatar_url: string&#125;interface EventData &#123; githubCode : string&#125;// read Github credentials from environment variablesexport default async(event : FunctionEvent &lt; EventData &gt;) =&gt; &#123; console.log(event) // if (!process.env.GITHUB_CLIENT_ID || !process.env.GITHUB_CLIENT_SECRET) &#123; // console.log('Please provide a valid client id and secret!') return &#123; error: // 'Github Authentication not configured correctly.' &#125; &#125; try &#123; const &#123;githubCode&#125; = event.data // get github token const githubToken : string = await getGithubToken(githubCode) // call github API to obtain user data const githubUser: any= await getGithubUser(githubToken) // get graphcool user by github id return &#123; data: &#123; id: githubUser.id.toString(), token: githubToken, html_url: githubUser.html_url, avatar_url: githubUser.avatar_url, gists_url: githubUser.gists_url &#125; &#125; &#125; catch (e) &#123; console.log(e) return &#123;error: 'An unexpected error occured during authentication.'&#125; &#125;&#125;async function getGithubToken(githubCode) &#123; const client_id = '842e83a0329b156b0a5b' const client_secret = '0a25a9f3c5cb3d47eece0b54e58163a188834bf9' const endpoint = 'https://github.com/login/oauth/access_token' const data = await fetch(endpoint, &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json', 'Accept': 'application/json' &#125;, body: JSON.stringify(&#123;client_id, client_secret, code: githubCode&#125;) &#125;).then(response =&gt; response.json()) if (data.error) &#123; throw new Error(JSON.stringify(data.error)) &#125; return data.access_token //const res=await getGithubUser(data.access_token) //console.log(res); //return &#123;token:data.access_token,id:res.id&#125;;&#125;async function getGithubUser(githubToken : string) : Promise &lt; GithubUser &gt; &#123; const endpoint = `https://api.github.com/user?access_token=$&#123;githubToken&#125;` const data = await fetch(endpoint).then(response =&gt; response.json())if (data.error) &#123; throw new Error(JSON.stringify(data.error)) &#125; return data&#125; 方法和流程其实是一样的。 如果在node.js下要想执行grapql操作，最好是使用graph-lib库来实现。方法和客户端一样， 都是执行异步操作。","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Apollo-client","slug":"Apollo-client","permalink":"https://React-Apollo.github.io/tags/Apollo-client/"},{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"}]},{"title":"GraphQL Playground 列表","slug":"GraphQL Playground List","date":"2018-01-21T13:55:28.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2018/01/21/GraphQL Playground List/","link":"","permalink":"https://React-Apollo.github.io/2018/01/21/GraphQL Playground List/","excerpt":"","text":"#GraphQL playground graphql-api地址 Gdom 通过grphql爬取dom元素 Mongodb_todo demotodo 更据查询要求来绘图 电影数据库查询","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"Github","slug":"Github","permalink":"https://React-Apollo.github.io/tags/Github/"}]},{"title":"SNACK  playground","slug":"xde-snack 2","date":"2018-01-21T11:18:28.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2018/01/21/xde-snack 2/","link":"","permalink":"https://React-Apollo.github.io/2018/01/21/xde-snack 2/","excerpt":"","text":"","categories":[{"name":"工具","slug":"工具","permalink":"https://React-Apollo.github.io/categories/工具/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://React-Apollo.github.io/tags/javascript/"},{"name":"RN","slug":"RN","permalink":"https://React-Apollo.github.io/tags/RN/"}]},{"title":"SNACK  playground","slug":"xde-snack","date":"2018-01-21T11:18:28.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2018/01/21/xde-snack/","link":"","permalink":"https://React-Apollo.github.io/2018/01/21/xde-snack/","excerpt":"","text":"","categories":[{"name":"工具","slug":"工具","permalink":"https://React-Apollo.github.io/categories/工具/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://React-Apollo.github.io/tags/javascript/"},{"name":"RN","slug":"RN","permalink":"https://React-Apollo.github.io/tags/RN/"}]},{"title":"create-react-app,Apollo-client,graphcool的模板","slug":"create-react-app,Apollo-client,graphcool的模板","date":"2018-01-20T16:18:28.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2018/01/20/create-react-app,Apollo-client,graphcool的模板/","link":"","permalink":"https://React-Apollo.github.io/2018/01/20/create-react-app,Apollo-client,graphcool的模板/","excerpt":"","text":"create-react-app,Apollo-client,graphcool的模板初步的使用方法，很简单，组要是打通数据线路 代码：index.js中的标准配置123456789101112131415161718192021import React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';import registerServiceWorker from './registerServiceWorker';import &#123; ApolloClient &#125; from 'apollo-client';import &#123; HttpLink &#125; from 'apollo-link-http';import &#123; InMemoryCache &#125; from 'apollo-cache-inmemory';import &#123; ApolloProvider &#125; from 'react-apollo';const client = new ApolloClient(&#123; link: new HttpLink(&#123; uri: 'https://api.graph.cool/simple/v1/cjaxudkum2ugf0127kok921bc' &#125;), cache: new InMemoryCache(), connectToDevTools: true&#125;);ReactDOM.render( &lt;ApolloProvider client=&#123;client&#125;&gt; &lt;App /&gt; &lt;/ApolloProvider&gt;, document.getElementById('root'),); React-Native中配置和这个是一样的， 添加了react-navigation时候，完全一样， 所有的路由包装完以后，在用apollo的client包装。Apollo使用时的好处是，虽然数据是单一来源，但是每个容器包装的组件都有查询方法为属性的属性值。 这个很好，相当于有了命名空间， 每个从endpoint获取数据的组件，就等于隔离开了。如果是本地数据考霸是app-link-state的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; graphql&#125; from 'react-apollo';import gql from 'graphql-tag';const getOneNode = gql` query ($id: String!)&#123; OneNode(id:$id) &#123; id, tab, content, &#125; &#125;`;class App extends Component &#123; render() &#123; console.log(this.props.data); if(!this.props.data.loading)&#123; var content=this.props.data.OneNode.content; console.log(typeof(content)) &#125;else&#123; var content = \"\"; &#125; return ( &lt;div className=\"App\"&gt; &lt;div className=\"App-intro\"&gt; &lt;div&gt;&#123;ReactHtmlParser(content)&#125;&lt;/div&gt;; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default graphql(getOneNode, &#123;options: () =&gt; &#123; return (&#123; variables: &#123; id: '5433d5e4e737cbe96dcef312', &#125; &#125;);&#125;&#125;)(App) 定要好schema,这个刚开始觉得很难，其实打开graphiql，对着来写是很简单，直观的的 ，可以在graphiql中先获取想要的结果，然后就获得查询的方法了。 剩下就是获取数据了。 这一步已经在Rn-cnode的项目中实现了。 mutate的方法完全相同。","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"},{"name":"cra","slug":"cra","permalink":"https://React-Apollo.github.io/tags/cra/"},{"name":"graphcool","slug":"graphcool","permalink":"https://React-Apollo.github.io/tags/graphcool/"}]},{"title":"翻译计划列表","slug":"翻译文章计划列表","date":"2018-01-20T13:18:28.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2018/01/20/翻译文章计划列表/","link":"","permalink":"https://React-Apollo.github.io/2018/01/20/翻译文章计划列表/","excerpt":"","text":"styles-components 1.Writing Scalable React Apps with the Component Folder Pattern 2.how to build a simple HackerNews feed with styled-componentes React&amp;RN FP&amp;Ramda Apollo&amp;Graphcool javascript Basic","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"Ramda","slug":"Ramda","permalink":"https://React-Apollo.github.io/tags/Ramda/"},{"name":"RN","slug":"RN","permalink":"https://React-Apollo.github.io/tags/RN/"},{"name":"styles-components","slug":"styles-components","permalink":"https://React-Apollo.github.io/tags/styles-components/"}]},{"title":"Prisma简介(翻译)","slug":"Prisma介绍","date":"2018-01-20T13:18:28.000Z","updated":"2019-04-28T05:52:57.892Z","comments":true,"path":"2018/01/20/Prisma介绍/","link":"","permalink":"https://React-Apollo.github.io/2018/01/20/Prisma介绍/","excerpt":"","text":"Prima简介 用于数据库的开源GraphQL API抽象层.本来准备翻译 medium上面的简介,但是最后感觉也太简单了,说明不了太多问题. 总体上, Prisma 是位于 grpqh-client 和传统数据库或者 REST API 之间的应用层, 利用了 graphQL的强类型和 schema 的优点.在这个系统中, 核心是围绕Schema展开. 最终构建了灵活可用数据的CRUD 方法. Prisma是GraphQL 数据库的代理，它可以把你的数据库转化为GraphQL API. 你可以使用 基础构架 客户端作为数据的消费者, 可以使用 apollo-client 或者 relay Graphql sever 是基于 graphql-yoga 的 webserver, 内核是 express Prisma &amp; Prisma bindings Database","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"}]},{"title":"TodoList-graphql-model","slug":"TodoList-graphql-schema-method","date":"2018-01-20T06:30:28.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2018/01/20/TodoList-graphql-schema-method/","link":"","permalink":"https://React-Apollo.github.io/2018/01/20/TodoList-graphql-schema-method/","excerpt":"","text":"基础的graphql数据模型网址是：grapiql ### 数据模型123id: IDtitle: Stringcompleted: Boolean query :todos{id, title, complete} mutation:123456- add(title: String!): todo- toggle(id: String!): todo- toggleAll(checked: Boolean!): [todo]- destroy(id: String!): todo- clearCompleted: [todo]- save(id: String!title: String!): todoTodoList DemoTodoList Demo runkit graphql playground","categories":[{"name":"Data Model","slug":"Data-Model","permalink":"https://React-Apollo.github.io/categories/Data-Model/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"data-Model","slug":"data-Model","permalink":"https://React-Apollo.github.io/tags/data-Model/"}]},{"title":"Public GraphQL APIs","slug":"Public GraphQL APIs","date":"2018-01-20T05:18:28.000Z","updated":"2019-04-28T05:52:57.892Z","comments":true,"path":"2018/01/20/Public GraphQL APIs/","link":"","permalink":"https://React-Apollo.github.io/2018/01/20/Public GraphQL APIs/","excerpt":"","text":"Public GraphQL APIs graphql-apis/README.md at master · APIs-guru/graphql-apisA collective list of public GraphQL APIs. PRs are welcome :smile:If you are interested in GraphQL in general, check out awesome-graphql. Official APIs API Description GraphiQL Docs/Repo Brandfolder Digital asset management platform Try it! Repo Buildkite Continuous integration and deployments Try it! Docs Deutsche Bahn Infrastructure Data, like realtime facility status, stations, timetables and more Try it! DocsRepo Digitransit HSL Transit routes and realtime schedules from Helsinki Regional Transport Authority, Finland Try it! Docs EHRI Holocaust-related archival materials Try it! Docs EtMDB Ethopian Movie Database Try it!%20%7B%0A%20%20%20%20edges%20%7B%0A%20%20%20%20%20%20node%20%7B%0A%20%20%20%20%20%20%20%20slug%0A%20%20%20%20%20%20%20%20hallName%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A) Docs Gdom DOM Traversing and Scraping using GraphQL Try it! Repo GitHub Web-based Git repository hosting service Try it! Docs GraphLoc Find a geolocation of an IP address including latitude, longitude, city, country, time zone and area code. Free to use, SSL supported Try it! Docs GraphQL Community Graph This is an Graph Database full of activity of the GraphQL community, including Twitter, StackOverflow, GitHub, Meetups, Slack. Try it! Repo GraphQL Europe Europe’s first GraphQL conference Try it! GraphQL Fake Fake is a tool for generating fake data using GraphQL queries. Try it! GraphQL World The fastest growing community of GraphQL developers Try it! DocsSite HIVDB A curated database to represent, store and analyze HIV drug resistance data Try it! Docs Hollowverse The religions and political views of the influentials. Try it! DocsRepo melodyRepo Fast and reliable dependency manager for Go Try it! Docs Microsoft Graph (DEMO) Connect to the data that drives productivity – mail, calendar, contacts, documents, directory, devices, and more. Try it! Repo Shopify Storefront The Storefront API gives you full creative control to build customized purchasing experiences for your customers. Try it! DocsExamples SuperChargers Locations of Tesla Stores, Superchargers, Destination Chargers and Service centers Try it! DocsRepo Universe Check what your friends are doing &amp; find unique events near you using our filter. Try it! Docs Yelp User Reviews and Recommendations of Top Restaurants, Shopping, Nightlife, Entertainment, Services and More Try it! Docs Unofficial API proxies API Description GraphiQL Docs/Repo Contentful “CMS as a Service”. GraphiQL demo allows to query a simple blog, but the library itself generates a schema automatically for any content model you store in Contentful. Try it! Repo Hacker NewsRedditTwitterGiphy GraphQL Hub Try HN!Try Reddit!Try Twitter!Try Giphy! DocsRepo MusicBrainz Open music encyclopedia that collects music metadata Try it!%20%7B%0A%20%20%20%20%20%20name%0A%20%20%20%20%20%20releaseGroups(type%3A%20ALBUM)%20%7B%0A%20%20%20%20%20%20%20%20edges%20%7B%0A%20%20%20%20%20%20%20%20%20%20node%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20title%0A%20%20%20%20%20%20%20%20%20%20%20%20firstReleaseDate%0A%20%20%20%20%20%20%20%20%20%20%20%20relationships%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20releaseGroups(type%3A%20%22single%20from%22)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20edges%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20node%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20target%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20…%20on%20ReleaseGroup%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20title%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20firstReleaseDate%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A&amp;operationName=NirvanaAlbumSingles) Repo NYC Restaurant Grades NYC Restaurant Inspection Results data (letter ratings for restaurants) Try it! Docs PokeAPI Pokémon Data API Try it! Repo Spotify Spotify gives you instant access to millions of songs - from old favorites to the latest hits. Try it! RepoExamples SWAPI Star Wars API Try it! Repo Demonstration-only APIs API Description GraphiQL Docs/Repo GraphQL Pokémon Get information of a Pokémon with GraphQL or Demo App! Try it!%20%7B%0A%20%20%20%20id%0A%20%20%20%20number%0A%20%20%20%20name%0A%20%20%20%20attacks%20%7B%0A%20%20%20%20%20%20special%20%7B%0A%20%20%20%20%20%20%20%20name%0A%20%20%20%20%20%20%20%20type%0A%20%20%20%20%20%20%20%20damage%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20evolutions%20%7B%0A%20%20%20%20%20%20id%0A%20%20%20%20%20%20number%0A%20%20%20%20%20%20name%0A%20%20%20%20%20%20weight%20%7B%0A%20%20%20%20%20%20%20%20minimum%0A%20%20%20%20%20%20%20%20maximum%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20attacks%20%7B%0A%20%20%20%20%20%20%20%20fast%20%7B%0A%20%20%20%20%20%20%20%20%20%20name%0A%20%20%20%20%20%20%20%20%20%20type%0A%20%20%20%20%20%20%20%20%20%20damage%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D) RepoClientRepo MongoDB Northwind demo Demo App build on top of graphql-compose and mongoose Try it!Try Relay version! DocsServerRepoClientRepo MongoDB TODO-List TODO List using GraphQL and MongoDb Try it! DocsRepo Scaphold Slackr Real-time API to power Scaphold Slackr Try it! DocsRepo Spotify GraphQL Server This demonstrates how to build a GraphQL server which fetches data from an external API (Spotify) Try it!%20%7B%0A%20%20%20%20name%0A%20%20%20%20id%0A%20%20%20%20image%0A%20%20%7D%0A%7D%0A) Docs Repo Three.js demo Declare a Three.js program with GraphQL Try it! Repo UFC GraphQL Server Public UFC API turned into a GraphQL server. It’s hosted by now.sh then, sometimes, it gets freeze. Try it! Repo","categories":[{"name":"source","slug":"source","permalink":"https://React-Apollo.github.io/categories/source/"}],"tags":[{"name":"Graphql","slug":"Graphql","permalink":"https://React-Apollo.github.io/tags/Graphql/"},{"name":"Github","slug":"Github","permalink":"https://React-Apollo.github.io/tags/Github/"},{"name":"API","slug":"API","permalink":"https://React-Apollo.github.io/tags/API/"}]},{"title":"未来的状态管理技术","slug":"the future of state mangement","date":"2018-01-04T04:01:45.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2018/01/04/the future of state mangement/","link":"","permalink":"https://React-Apollo.github.io/2018/01/04/the future of state mangement/","excerpt":"","text":"未来的状态管理技术使用apollo-link-state在Apollo client管理本地状态**随着应用规模的增长，它的状态也日趋复杂化。作为一个开发者我们的任务不仅要从多个远程服务器获取五花八门的数据，同时还要处理与UI交互有关的本地数据。最糟糕的是，我们不得不考略怎么存储这些数据，以便于应用中的组件可以轻松访问数据。很多的开发者的诉求是Apollo client在远程数据的管理上非常优秀，远程数据大概占据了他们80%的数据需求。但是本地数据(例如：全局标记，设备API反馈结果)怎么才能满足剩下的20%需求？在以前(其实也不算久)，Apollo用户在独立的Redux或者Mobx store(两种数据构架存储数据的对象)中管理20%的本地数据需求。对于apollo client 1.0这么做是可行的解决办法，但是Apollo client 2.0已经完全从Redux构建中迁移出来，结果是在如果要在Apollo的store和本地管理构建的store之间同步本地，远程数据会变得非常棘手。最终用户的诉求是希望能在Apollo client中封装本地和远程数据，保持单一数据来源(one source of truth)。 依靠坚实的基础Apollo开发者知道，必须要解决这个迫在眉睫的问题，所谓我们提出了问题：在Apollo client中管理状态到底应该是什么样子？刚开始，我们认为应该具有类似Redux的特征，例如Redux的dev tools以及通过connect函数把state注入到组件中。但是我们也考虑到了Redux自身的缺陷，例如模板的问题，还有DIY的问题，核心的特性，例如异步action creator(asyncchronous action creator,Redux执行异步操作时的action的函数一般都有三个)，缓存(caching),以及optimistic UI。 为了创建理想的state管理方案，我们想依据Redux构建，但是又避免它的备受批评的方面。同时还要使用GraphQL的强大的能力：也就是一次查询，从多个数据源返回数据。 一次学习，到处编写GraphQL查询对于GraphQL的一个常见误解是：它和特定的服务器实现耦合在一起。实际上，GraphQL非常灵活。不管你是从gRPC,REST或者客户端缓存查询数据都可以实现-GraphQL就是数据通用查询语言，操作与数据来源无关。这就是GraphQL查询和突变(query,mutation)完美契合应用状态改变需求的原因。不再使用Redux的分发动作(dispatching action，Redux中触发状态改变的函数),我们使用GraphQL mutation来表现状态的改变。可以通过GraphQL的query来表明组件的数据需求，从而可以访问到相应的数据。GraphQL的最大优点是它可以聚合来自多个数据来源的数据，不管是本地还是远程数据，只要在一个查询里通过指令(directive,graphQL里的语法，可以灵活的构建查询).定制需要的字段。 🎉好吧！来看看怎么实现 通过Apollo Client管理状态在Apollo Ｃlient中管理本地数据通过Apollo Link实现，Apollo Link是client中的网络技术栈，可以让你在任何地点接入到GraphQL的请求周期中。为了从GraphQL服务器请求远程数据，我们可以使用HttpLink,但是为了从缓存中请求本地数据，我们需要安装新的link:apollo-link-state。 12345678910111213141516import &#123; ApolloClient &#125; from 'apollo-client';import &#123; InMemoryCache &#125; from 'apollo-cache-inmemory';import &#123; ApolloLink &#125; from 'apollo-link';import &#123; withClientState &#125; from 'apollo-link-state';import &#123; HttpLink &#125; from 'apollo-link-http';import &#123; defaults, resolvers &#125; from './resolvers/todos';const cache = new InMemoryCache();const stateLink = withClientState(&#123; resolvers, cache, defaults &#125;);const client = new ApolloClient(&#123; cache, link: ApolloLink.from([stateLink, new HttpLink()]),&#125;); 使用apollo-link-state初始化Apollo Client为了创建state link,可以使用withClientState函数，传递的具有resolvers,defaults和Apollocache属性的对象。接着拼接本地sate link到整个link链中。state link应该在HttpLink之前出现，因此本地查询和突变到达网络成之前就会被拦截。 ####默认配置(Defaults)defaults对象代表着写入缓存时创建的state link的初始状态。在没有需求时，传递defaults对象给cache热个身是非常重要的，这样做组件在查询状态数据时才不会出错(译注：这里和Redux的reducer中返回默认的initailState是一个意思，可以返回空对象，但是不能undefined)。定义的defaults对象外观应该可以反映出在应用中计划实现的查询方案。 1234export const defaults = &#123; visibilityFilter: 'SHOW_ALL', todos: [],&#125;; 默认对象代表着想读写cache的初始化状态 Resolvers(查询解析函数)如果使用Apollo Client来管理state,Apollo cache就称为应用中所有远程数据和本地数据的单一来源。怎么访问和更新cache中的数据？resolvers应运而生。如果你在服务器端使用过graph-tools，client端的resolver类型签名与之相同： 1fieldName: (obj, args, context, info) =&gt; result; 如果不熟悉resolvers，也不用担心，这里要注意的两个重点是查询或者突变的变量在第二个参数中传递，cache会在context中自动添加(在服务端，需要在context中手动指定查询的配置，可以是rest地址，也可以是数据库配置)。 123456789101112131415161718192021222324252627282930313233export const defaults = &#123; // same as before &#125; export const resolvers = &#123; Mutation: &#123; visibilityFilter: (_, &#123; filter &#125;, &#123; cache &#125;) =&gt; &#123; cache.writeData(&#123; data: &#123; visibilityFilter: filter &#125; &#125;); return null; &#125;, addTodo: (_, &#123; text &#125;, &#123; cache &#125;) =&gt; &#123; const query = gql` query GetTodos &#123; todos @client &#123; id text completed &#125; &#125; `; const previous = cache.readQuery(&#123; query &#125;); const newTodo = &#123; id: nextTodoId++, text, completed: false, __typename: 'TodoItem', &#125;; const data = &#123; todos: previous.todos.concat([newTodo]), &#125;; cache.writeData(&#123; data &#125;); return newTodo; &#125;, &#125;&#125; Resolvers是访问和更新cache中数据的函数 为了把数据写到cache的根下，调用cache.writeData函数，并传递自己的数据。有时候，我们写入到cache的数据是和之前的数据有关的，例如上面实例中的mutation操作addTodo。在这种情况下，需要在执行写操作之前使用cache.readQuery函数从cache中读取之前的数据，如果你只是对cache中已经存在的对象写入部分数据，可以选择性传入一个id，这个id代表着相应对象在cache中的key.因为我们在apollo client store中使用的是InMemoryCache，key是_.typename:id. @client directive(@client指令)如果我们从UI中触发一个mutation.Apollo client需要知道这个动作到底是要更新服务器的数据，还是客户端本地数据。apollo-link-state使用@client指令来界定只能用于客户端数据的操作。接着apollo-link-state调用resolvser来处理相关字段。 1234567891011const SET_VISIBILITY = gql` mutation SetFilter($filter: String!) &#123; visibilityFilter(filter: $filter) @client &#125;`;const setVisibilityFilter = graphql(SET_VISIBILITY, &#123; props: (&#123; mutate, ownProps &#125;) =&gt; (&#123; onClick: () =&gt; mutate(&#123; variables: &#123; filter: ownProps.filter &#125; &#125;), &#125;),&#125;); 通过@client指令针对本地数据执行mutation操作 query操作和mutation操作类似。如果你在查询中正在执行异步操作，Apollo Client将会为你跟踪loading和error状态。对React而言，你可以在this.props.data中找到这些状态，其中还包括很多的助手函数，包括refetching(刷新)，pagination(分页)和polling(轮询)。 最令人心动的特性是你可以在一次查询中从多个数据源请求数据！😍在这个例子中，我们可以从GraphQL服务器远程请求user信息，同时从Apollo cache中请求本地的visiblityFilter数据。 12345678910111213141516const GET_USERS_ACTIVE_TODOS = gql` &#123; visibilityFilter @client user(id: 1) &#123; name address &#125; &#125;`;const withActiveState = graphql(GET_USERS_ACTIVE_TODOS, &#123; props: (&#123; ownProps, data &#125;) =&gt; (&#123; active: ownProps.filter === data.visibilityFilter, data, &#125;),&#125;); 通过@client指令请求本地数据，user没有@client指令，是远程请求数据。更多有关在应用中整合apollo-link-state的示例和技巧，请关注我们的文档更新页面 到1.0版本的技术路线现在，尽管apollo-link-state已经足够稳定，可以在应用使用了，但是还有几个特性，我们很快会解决： Client-side schema(客户端图式)：现在，客户端还不支持根据客户端schema所做的类型验证。这是因为在运行时包含用于构建和验证schema会显著的增加打包文件的大小。替换方案是，我们希望把schema构建转移到构建阶段，通过对GraphQL内省(introspection)的支持，你可以获取GraphiQL中所有很酷的特征。 Helper组件：我们的目标是尽可能的使apollo中的状态管理无差别。我们编写一些React组件，从而减少执行普通任务时的多余代码，例如在执行mutation时，在幕后传递参数，需用考虑细节配置。 如果你你对这些问题感兴趣，可以加入github 或者是 Apollo Slack的#local-state频道。我们很感激你可以帮助塑造下一代的状态管理方案！🚀 React,GraphQL,JavaScript,Redux,API","categories":[],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"},{"name":"Apollo-Client","slug":"Apollo-Client","permalink":"https://React-Apollo.github.io/tags/Apollo-Client/"},{"name":"javacript","slug":"javacript","permalink":"https://React-Apollo.github.io/tags/javacript/"},{"name":"app-link","slug":"app-link","permalink":"https://React-Apollo.github.io/tags/app-link/"},{"name":"app-link-state","slug":"app-link-state","permalink":"https://React-Apollo.github.io/tags/app-link-state/"}]},{"title":"Javascript Reducer函数实战","slug":"Disssection-Twitter-s-Redux-Store","date":"2017-06-09T04:01:45.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2017/06/09/Disssection-Twitter-s-Redux-Store/","link":"","permalink":"https://React-Apollo.github.io/2017/06/09/Disssection-Twitter-s-Redux-Store/","excerpt":"","text":"javascript Reduce函数是比较强大的一个函数,在简书上看到有个作者写了这个函数的文章,也是看到有个问题就向他请教,大神很忙,但是仍然在github上做了答复,我对那个问题搞明白了,所以写了下面这个文章,但是没有写完,现在陪老娘在医院,又把这个问题翻出来看,又不懂了,还是拉锯战啊. javascript的编程中,我开始感到看别人的源码最难的地方实际还是两个,一个是数组方法的灵活应用,另一个是对象的浅拷贝和深拷贝的问题.这两个问题要是有深刻的体会,看源码的难度会降低很多.reduce,slice,splice,concat函数是明星.遇到这几个函数的时候就有些看不懂,所以掌握这几个函数是非常重要的. 深拷贝和浅拷贝的问题其实和javascript的对象和函数都是传引用赋值息息相关,一句话解决对象的共享还是独享的问题.javascript的设计模式很多都是利用对象很函数的传引用赋值的特点来完成的.所以这儿地方也是非常的重要.javascript的数组元素也可以是对象的引用. 本人是新手,最大的体会是学到的两个简单原则:1 对象是用来组织数据和相关方法的,所以组织方式越简单,越灵活越好,由于js的对象和函数都可以传引用赋值,所以在js中,以对象字面量和数组的组织方式真的是非常的强大,之所以这么讲,就是要把学习数组的方法提到新的高度.2 编程到底是在干什么？ 我逐渐体会到编程也就是解决信息的传递，存储和处理的问题. 所以很多问题其实稍微抽象一下,问题可能会简单一点. 我简单的写了一个东西,在学习React/Redux的时候,总是掌握不了实质,就是Redux中的state的实质是什么.前面学习的时候,总是言必称state,想了各种办法去了解什么是state，为什么要这样设计.其实再抽象一下,这不就是一个小型的数据库吗？可以这样说吗？当然可以了,我看了一本介绍React的书,有点确认了,当我这几天再读F8 app的代码官方文档的时候,facebook直接就是把Redux称为数据层.我还想了一些办法来理解Redux，比如说借用中介者模式,MVC解耦和模式,但是如果抽象为数据层,那么还有什么问题解决不了的吗？ 如果接触过任何一种web框架语言,例如php/mysql,node/mongodb.每种都是解耦和,每种都是中介者模式.所以在理解这些概念的时候最基础的内容可能是最解决问题的条件.你可以梳理一下这些框架中与数据库操作都有哪些? 连接数据库,数据库操作语句,数据库文件,返回值等等.这些东西在react/redux中都能找到一摸一样的内容.web框架里的数据库操作和redux的操作是完全一样的,有什么奇怪的吗？都是数据库. Redux的文档中有个redo,undo的例子,我最近又重新看redux文档的时候，感觉这一部分讲的真是好,以前怎么没有理解呢？ 有三个缺陷一个是对于state的数据结构的理解,一个是堆栈方法使用理解,另一个就是js的浅拷贝的问题。前面看那本数据结构的书,也不得法,但是硬着头皮把几种数据结构拿下以后,突然觉得好多问题都找到了解决办法,计算机中对于数据结构和算法的重视不是白来的.state如果作为一个简单数据库,他里面就是一些键值对. 由于js中对象可以传引用,所以可以很容易的建立一个类数据库的结构.其他语言可以吗？ #####下面我们就贯彻以上的理念,来研究一些基础的内容。第一个就是Reducer函数,参考 MDN 文档 直接看代码例子 1234//accumulator是累加值,currentValue是当前遍历的值[0,1,2,3,4].reduce( (accumulator, currentValue, currentIndex, array) =&gt; &#123; return accumulator + currentValue;&#125;, 10); callback accumulate currentValue currentIndex array return 第一次调用 10 0 0 [0,1,2,3,4] 10 第二次调用 10 1 1 [0,1,2,3,4] 11 第三次调用 11 2 2 [0,1,2,3,4] 13 第四次调用 13 3 3 [0,1,2,3,4] 16 第五次调用 16 4 4 [0,1,2,3,4] 20 第一个遍历，accumulate等于10.遍历的数组元素是0，index是0.这是巧合。数组还是[0,1,2,3,4]。返回的值是初始值加当前的数组元素值，也就是返回accumulate+array[currentIndex]。return的就是 10+array[0]=10. 第二个遍历，accumulate就是10，遍历的数组元素是1，index是1.这也是巧合。数组还是[0,1,2,3,4]。返回的值是accumulate加当前的数组值，accumulate+array[currentIndex]。也就是返回 10+array[1]=11. 第二个遍历和第一个遍历的区别就是初始值来源不同。第一个遍历的是reduce带进来的数据。第二个遍历使用的是第一个遍历返回的值。后面的几个遍历就和第二个遍历一样了。 数组扁平化12345var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) &#123; return a.concat(b); //要了解concat的使用,返回的是 //数组合并的返回对象&#125;, []); //起始是空数组// flattened is [0, 1, 2, 3, 4, 5] 就这么简单,但是灵活变动起来也不是太好理解啊看这个计算器的React-Native的代码,在UI组件中渲染出计算器的几个按键的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 var Types = &#123; //类型 NUMBER: 'NUMBER', DECIMAL: 'DECIMAL', SIGN: 'SIGN'&#125;;var inputs = [ &#123;value: 1, type: Types.NUMBER&#125;, &#123;value: 2, type: Types.NUMBER&#125;, &#123;value: 3, type: Types.NUMBER&#125;, &#123;value: 4, type: Types.NUMBER&#125;, &#123;value: 5, type: Types.NUMBER&#125;, &#123;value: 6, type: Types.NUMBER&#125;, &#123;value: 7, type: Types.NUMBER&#125;, &#123;value: 8, type: Types.NUMBER&#125;, &#123;value: 9, type: Types.NUMBER&#125;, &#123;value: '+/-', type: Types.SIGN&#125;, &#123;value: 0, type: Types.NUMBER&#125;, &#123;value: '.', type: Types.DECIMAL&#125;,];//操作符的配置var operations = [ &#123;value: '/', color: '#c77ccc', altColor: '#b16eb7', operation: OPERATION_DIVIDE&#125;, &#123;value: '-', color: '#f8b055', altColor: '#dc9c4c', operation: OPERATION_SUBTRACT&#125;, &#123;value: '+', color: '#f796d2', altColor: '#e088be', operation: OPERATION_ADD&#125;, &#123;value: 'x', color: '#6fcdf4', altColor: '#65badd', operation: OPERATION_MULTIPLY&#125;];renderInputRows() &#123; var &#123;inputNumber, inputSigned, inputDecimal&#125; = this.props;//注意在redux中那个地方返回了这三个函数的名字 return inputs.reduce((collection, input) =&gt; &#123;//这里的reduce是怎么用的呢？ if (collection[collection.length - 1].length === 3) &#123;//为什么等于3 collection.push([]); &#125; collection[collection.length-1].push(input); return collection; &#125;, [[]]).map((group, rowIndex) =&gt; &#123; var columns = group.map((item, columnIndex) =&gt; &#123;//看看map的方法 return ( &lt;TouchableHighlight key=&#123;'inputRow_' + rowIndex + '_inputCol_' + columnIndex&#125; underlayColor=\"#ededed\" style=&#123;styles.input&#125; onPress=&#123;() =&gt; &#123; //dispatch方法 if (item.type === Types.NUMBER) &#123; inputNumber(item.value); &#125; else if (item.type === Types.DECIMAL) &#123; inputDecimal(); &#125; else if (item.type === Types.SIGN) &#123; inputSigned(); &#125; &#125;&#125;&gt; &lt;Text style=&#123;styles.inputText&#125;&gt;&#123;item.value&#125;&lt;/Text&gt; &lt;/TouchableHighlight&gt; ); &#125;); 看看这个数组的reducer方法的使用.源代码在这里 这个我稍后再补充,会补充大神给我的解答. 1234567891011121314151617181920212223242526272829303132 var Types = &#123; NUMBER: 'NUMBER', DECIMAL: 'DECIMAL', SIGN: 'SIGN'&#125;var inputs = [ &#123;value: 1, type: Types.NUMBER&#125;, &#123;value: 2, type: Types.NUMBER&#125;, &#123;value: 3, type: Types.NUMBER&#125;, &#123;value: 4, type: Types.NUMBER&#125;, &#123;value: 5, type: Types.NUMBER&#125;, &#123;value: 6, type: Types.NUMBER&#125;, &#123;value: 7, type: Types.NUMBER&#125;, &#123;value: 8, type: Types.NUMBER&#125;, &#123;value: 9, type: Types.NUMBER&#125;, &#123;value: '+/-', type: Types.SIGN&#125;, &#123;value: 0, type: Types.NUMBER&#125;, &#123;value: '.', type: Types.DECIMAL&#125;,];//这里其实是有一维数组转为二维数组，打印结构可以看到.//注意reduce的起始值就是一个二维数组.var result = inputs.reduce((collection, input) =&gt; &#123; if (collection[collection.length - 1].length === 3) &#123; collection.push([]); &#125; collection[collection.length-1].push(input); return collection; &#125;, [[]])console.log(result)console.table(result) 再看看下面这里两段代码12345678let str = `name, age, hair\\nMerble, 35, red\\nBob, 64, blonde`;function lameCSV(str) &#123; return str.split('\\n').reduce(function(table, row)&#123; table.push(row.split(',').map(function(c) &#123;return c.trim();&#125;)); return table &#125;, [[]]);&#125;;lameCSV(str); 123456789var arr=[0,1,2,3,4,5,6,7,8]; var result = arr.reduce((collection, input) =&gt; &#123; if (collection[collection.length - 1].length === 3) &#123; collection.push([]); &#125; collection[collection.length-1].push(input); console.log(collection); return collection; &#125;, [[]]); 感谢大神的帮助,大神的githubreduce这个方法还能演变出什么花样来呢？数组的操作真的是一个需要好好学习的内容.","categories":[],"tags":[{"name":"javacript","slug":"javacript","permalink":"https://React-Apollo.github.io/tags/javacript/"},{"name":"array","slug":"array","permalink":"https://React-Apollo.github.io/tags/array/"}]},{"title":"Dissecting Twitter's Redux Store","slug":"JavaScript  Reducer  practice","date":"2017-06-04T04:01:45.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2017/06/04/JavaScript  Reducer  practice/","link":"","permalink":"https://React-Apollo.github.io/2017/06/04/JavaScript  Reducer  practice/","excerpt":"","text":"摘编|Dissecting Twitter’s Redux Store原文请见 剖析mobile.twitter.com的store结构.大公司的移动网站,可以借鉴的东西很多,twitter的mobile已经使用了React/Redux技术,所以如果你的web网站也想要采用React/Redux构架,这篇文章要好好看看. 原文我现在不想翻译.列出来可能遇到的问题和需要用到的技术 可能要自己翻墙 记住是Twitter’s mobile website移动网站,不是pc端网站,网址是mobileTwitter 要使用chrome浏览器打开 申请一个twitter账号，登录,否则store中的信息很少 需要在chrome安装 React Developer Tools (RDT) 工具. chrome的调试界面下可以看到点击，打开console. 输入 $r.store.getState(); twitter在你应用中store的 state结构就展现出来了. 现在你可以看看大公司的应用是怎么来设计state的结构的. 由于人家的网站很复杂，所以state很像一个数据库，可以先看看数据库的范式化和 React/Redux中的实现方案 normalizr.了解如何减少巢状结构和冗余数据. 其他有兴趣的再深挖吧.总之一句话,当React应用中引入了Redux以后,应用的控制权就交到了Redux的手中,所以不要局限于React组件和页面的,需要更过的考虑数据的组织问题. 这一篇算是工具篇。 相关的开发工具后redux-logger, dev-tools, React-native Debugger ,Reactotron工具.好像还有一个可视化的工具","categories":[],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"}]},{"title":"CRA项目部署到ghpage的方法","slug":"CRA项目的Github-Page部署","date":"2017-04-04T13:18:28.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2017/04/04/CRA项目的Github-Page部署/","link":"","permalink":"https://React-Apollo.github.io/2017/04/04/CRA项目的Github-Page部署/","excerpt":"","text":"GitHub Pages Note: this feature is available with `react-scripts@0.2.0` and higher. Step 1: Add homepage to package.jsonThe step below is important!If you skip it, your app will not deploy correctly. Open your package.json and add a homepage field for your project: 1\"homepage\": \"https://myusername.github.io/my-app\", or for a GitHub user page: 1\"homepage\": \"https://myusername.github.io\", Create React App uses the homepage field to determine the root URL in the built HTML file. Step 2: Install gh-pages and add deploy to scripts in package.jsonNow, whenever you run npm run build, you will see a cheat sheet with instructions on how to deploy to GitHub Pages. To publish it at https://myusername.github.io/my-app, run: 1npm install --save gh-pages Alternatively you may use yarn: 1yarn add gh-pages Add the following scripts in your package.json: 12345 \"scripts\": &#123;+ \"predeploy\": \"npm run build\",+ \"deploy\": \"gh-pages -d build\", \"start\": \"react-scripts start\", \"build\": \"react-scripts build\", The predeploy script will run automatically before deploy is run. If you are deploying to a GitHub user page instead of a project page you&#39;ll need to make two additional modifications: First, change your repository’s source branch to be any branch other than master. Additionally, tweak your package.json scripts to push deployments to master:1234 \"scripts\": &#123; \"predeploy\": \"npm run build\",- \"deploy\": \"gh-pages -d build\",+ \"deploy\": \"gh-pages -b master -d build\", Step 3: Deploy the site by running npm run deployThen run: 1npm run deploy Step 4: Ensure your project’s settings use gh-pagesFinally, make sure GitHub Pages option in your GitHub project settings is set to use the gh-pages branch: Step 5: Optionally, configure the domainYou can configure a custom domain with GitHub Pages by adding a CNAME file to the public/ folder. Notes on client-side routingGitHub Pages doesn’t support routers that use the HTML5 pushState history API under the hood (for example, React Router using browserHistory). This is because when there is a fresh page load for a url like http://user.github.io/todomvc/todos/42, where /todos/42 is a frontend route, the GitHub Pages server returns 404 because it knows nothing of /todos/42. If you want to add a router to a project hosted on GitHub Pages, here are a couple of solutions: You could switch from using HTML5 history API to routing with hashes. If you use React Router, you can switch to hashHistory for this effect, but the URL will be longer and more verbose (for example, http://user.github.io/todomvc/#/todos/42?_k=yknaj). Read more about different history implementations in React Router. Alternatively, you can use a trick to teach GitHub Pages to handle 404 by redirecting to your index.html page with a special redirect parameter. You would need to add a 404.html file with the redirection code to the build folder before deploying your project, and you’ll need to add code handling the redirect parameter to index.html. You can find a detailed explanation of this technique in this guide.","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[{"name":"CRA","slug":"CRA","permalink":"https://React-Apollo.github.io/tags/CRA/"},{"name":"ghpage","slug":"ghpage","permalink":"https://React-Apollo.github.io/tags/ghpage/"}]},{"title":"使用React,Redux,redux-sage构建图片库(翻译)","slug":"使用React-Redux-redux-sage构建图片库-翻译","date":"2017-04-04T13:18:28.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2017/04/04/使用React-Redux-redux-sage构建图片库-翻译/","link":"","permalink":"https://React-Apollo.github.io/2017/04/04/使用React-Redux-redux-sage构建图片库-翻译/","excerpt":"","text":"看到这篇文章build an image gallery using redux saga，觉得写的不错，长短也适中. 文后有注释版的github代码库,请使用comment分枝. Flickr API可能需要有fQ的基本能力.可以使用google的翻译作为参考，这篇文章google翻译版的中文水平让我吃了一惊.翻译已经完成. 使用React,Redux和reudx-saga构建一个图像浏览程序(翻译)Joel Hooks ,2016年3月 构建一个图片长廊图像长廊是一个简单的程序，从Flicker API 加载图片URLs,允许用户查看图片详情。 后续我们会使用React,Redux和redux-saga.React作为核心框架，优势是虚拟dom(virtual-dom)的实现。Redux在程序内负责state的管理。最后，我们会使用redux-saga来执行javascript的异步操作步骤。 我们会使用ES6(箭头函数，模块，和模板字符串)，所以我们首先需要做一些项目的配置工作。 #####项目配置和自动化 如果要开始一个React项目，须有有一系列的配置选项。对于一个简单的项目，我想把配置选项尽可能缩减。考虑到浏览器的版本问题，使用Babel把ES6编译为ES5。 首先使用npm init 创建一个package.json文件 package.json 123456789101112131415161718192021222324252627282930313233343536 &#123; \"name\": \"egghead-react-redux-image-gallery\", \"version\": \"0.0.1\", \"description\": \"Redux Saga beginner tutorial\", \"main\": \"src/main.js\", \"scripts\": &#123; \"test\": \"babel-node ./src/saga.spec.js | tap-spec\", \"start\": \"budo ./src/main.js:build.js --dir ./src --verbose --live -- -t babelify\" &#125;, \"repository\": &#123; \"type\": \"git\", \"url\": \"git+https://github.com/joelhooks/egghead-react-redux-image-gallery.git\" &#125;, \"author\": \"Joel Hooks &lt;joelhooks@gmail.com&gt;\", \"license\": \"MIT\", \"dependencies\": &#123; \"babel-polyfill\": \"6.3.14\", \"react\": \"^0.14.3\", \"react-dom\": \"^0.14.3\", \"react-redux\": \"^4.4.1\", \"redux\": \"^3.3.1\", \"redux-saga\": \"^0.8.0\" &#125;, \"devDependencies\": &#123; \"babel-cli\": \"^6.1.18\", \"babel-core\": \"6.4.0\", \"babel-preset-es2015\": \"^6.1.18\", \"babel-preset-react\": \"^6.1.18\", \"babel-preset-stage-2\": \"^6.1.18\", \"babelify\": \"^7.2.0\", \"browserify\": \"^13.0.0\", \"budo\": \"^8.0.4\", \"tap-spec\": \"^4.1.1\", \"tape\": \"^4.2.2\" &#125;&#125; 有了package.json, 可以在项目文件夹命令行运行 npm install 安装程序需要的依赖项。 .babelrc 123&#123; \"presets\": [\"es2015\", \"react\", \"stage-2\"] &#125; 这个文件告诉babel,我们将会使用ES2015(ES6),React以及ES2106的stage-2的一些特征。 package.json有两个标准的script脚本配置：start和test.现在我们想通过start脚本加载程序，start会使用src目录的一些文件，所以西药先创建src文件夹.在src文件夹添加下面的一些文： index.html 12345678910111213141516171819 &lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;egghead: React Redux Image Gallery&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"styles.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"title\"&gt; ![](http://cloud.egghead.io/2G021h3t2K10/download/egghead-logo-head-only.svg) &lt;h3&gt;Egghead Image Gallery&lt;/h3&gt;&lt;/div&gt;&lt;div id=\"root\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"build.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; main.js 123456789import \"babel-polyfill\"import React from 'react'import ReactDOM from 'react-dom'ReactDOM.render( &lt;h1&gt;Hello React!&lt;/h1&gt;, document.getElementById('root')); style.css 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 body &#123; font-family: Helvetica, Arial, Sans-Serif, sans-serif; background: white;&#125;.title &#123; display: flex; padding: 2px;&#125;.egghead &#123; width: 30px; padding: 5px;&#125;.image-gallery &#123; width: 300px; display: flex; flex-direction: column; border: 1px solid darkgray;&#125;.gallery-image &#123; height: 250px; display: flex; align-items: center; justify-content: center;&#125;.gallery-image img &#123; width: 100%; max-height: 250px;&#125;.image-scroller &#123; display: flex; justify-content: space-around; overflow: auto; overflow-y: hidden;&#125;.image-scroller img &#123; width: 50px; height: 50px; padding: 1px; border: 1px solid black;&#125; index.html文件加载style.css文件提供一些基本的布局样式，同时也加载build.js文件，这是一个生成出来的文件.main.js是一个最基础的React程序，他在index.html的#root元素中渲染一个h1元素。创建这些文件以后，在项目文件夹中命令行运行npm start。在浏览器打开http://10.11.12.1:9966.就可以看到index.html中渲染的页面 现在我们来构建基础的Gallery React 组件 在Gallery中显示一些图片 首先我们需要尽可能快的获得一个可以显示的图片素材.在项目文件夹中创建一个文件Gallery.js Gallery.js 1234567891011121314151617181920212223242526272829303132333435363738 import React, &#123;Component&#125; from 'react'const flickrImages = [ \"https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg\", \"https://farm2.staticflickr.com/1581/25283151224_50f8da511e.jpg\", \"https://farm2.staticflickr.com/1653/25265109363_f204ea7b54.jpg\", \"https://farm2.staticflickr.com/1571/25911417225_a74c8041b0.jpg\", \"https://farm2.staticflickr.com/1450/25888412766_44745cbca3.jpg\"];export default class Gallery extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; images: flickrImages, selectedImage: flickrImages[0] &#125; &#125; render() &#123; const &#123;images, selectedImage&#125; = this.state; return ( &lt;div className=\"image-gallery\"&gt; &lt;div className=\"gallery-image\"&gt; &lt;div&gt; &lt;img src=&#123;selectedImage&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"image-scroller\"&gt; &#123;images.map((image, index) =&gt; ( &lt;div key=&#123;index&#125;&gt; &lt;img src=&#123;image&#125;/&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 我们直接在组件中硬编码了一个提供数据的数组，让项目尽快的工作起来.Gallery组件继承Component组件,在构造函数中创建一些组件的出事状态.最后我们利用一些样式标记渲染一下文件。image-scroller元素遍历(map方法)图片数组,生成摘要小图片。 123456789101112 import \"babel-polyfill\"import React from 'react'import ReactDOM from 'react-dom'+ import Gallery from './Gallery'ReactDOM.render(- &lt;h1&gt;Hello React!&lt;/h1&gt;,+ &lt;Gallery /&gt;, document.getElementById('root')); 到现在，我们使用硬编码的图片URLs(通过fickrImages)数组,第一张图片作为selectedImage.这些属性在Gallery组件的构造函数缺省配置中，通过初始状态(initial)来设定. 接下来在组件中添加一个和组件进行交互操作的方法，方法具体内容是操做setSate. Gallery.js 12345678910111213141516171819202122232425262728293031323334export default class Gallery extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; images: flickrImages, selectedImage: flickrImages[0] &#125; &#125;+ handleThumbClick(selectedImage) &#123;+ this.setState(&#123;+ selectedImage+ &#125;)+ &#125; render() &#123; const &#123;images, selectedImage&#125; = this.state; return ( &lt;div className=\"image-gallery\"&gt; &lt;div className=\"gallery-image\"&gt; &lt;div&gt; &lt;img src=&#123;selectedImage&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"image-scroller\"&gt; &#123;images.map((image, index) =&gt; (- &lt;div key=&#123;index&#125;&gt;+ &lt;div key=&#123;index&#125; onClick=&#123;this.handleThumbClick.bind(this,image)&#125;&gt; &lt;img src=&#123;image&#125;/&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 在Gallery组件添加handleThumbClick方法,任何元素都可用通过onClick属性调用这个方法.image作为第二个参数传递，元素自身作为第一个参数传递.bind方法传递javascript函数调用上下文对象是非常便捷。 看起来不错!现在我们有了一些交互操作的方法，有点“APP”的意思了。截止目前，我们已经让app运行起来了，接下来要考虑怎么加载远程数据。最容易加载远程数据的地方是一个React组件生命周期方法,我们使用componentDidMount方法,通过他从Flikr API请求并加载一些图片. Gallery.js 1234567891011121314151617181920212223 export default class Gallery extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; images: flickrImages, selectedImage: flickrImages[0] &#125; &#125;+ componentDidMount() &#123;+ const API_KEY = 'a46a979f39c49975dbdd23b378e6d3d5';+ const API_ENDPOINT = `https://api.flickr.com/services/rest/?method=flickr.interestingness.+getList&amp;api_key=$&#123;API_KEY&#125;&amp;format=json&amp;nojsoncallback=1&amp;per_page=5`;+++ fetch(API_ENDPOINT).then((response) =&gt; &#123;+ return response.json().then((json) =&gt; &#123;+ const images = json.photos.photo.map((&#123;farm, server, id, secret&#125;) =&gt; &#123; + return `https://farm$&#123;farm&#125;.staticflickr.com/$&#123;server&#125;/$&#123;id&#125;_$&#123;secret&#125;.jpg`+ &#125;);++ this.setState(&#123;images, selectedImage: images[0]&#125;);+ &#125;)+ &#125;)+ &#125;[...] 我们在Gallery类中添加了一个新的方法,通过React的componentDidMount生命周期方法触发Flickr图片数据的获取。 在React组件运行的不同时间点，组件会调用不同的生命周期函数。在这段代码中，当组件被渲染到DOM中的时间点,componentDidMount函数就会被调用。需要注意的是:Gallery组件只有一次渲染到DOM的机会，所以这个函数可以提供一些初始化图片.考虑到在APP的整个生命周期中,有更多的动态组件的加载和卸载,这可能会造成一些多余的调用和无法考虑到的结果。 我们使用浏览器接口(browser API)的fetch方法执行请求.Fetch返回一个promise对象解析response对象.调用response.json()方法,返回另一个promise对象，这就是我们实际需要的json格式的数据.遍历这个对象以后就可以获取图片的url地址. 坦白讲，这个应用目前还很简单.我们还需要在这里花费更多的时间，还有一些基础的需求需要完成.或许我们应该在promise处理流程中添加错误处理方法,如果图片数据获取成功也需要一些处理逻辑.在这个地方，你需要发挥一些想象力考虑一下更多的逻辑.在生产实践中简单的需求是很少见的.很快,应用中就会添加更多的需求。认证,滚动橱窗,加载不同图片库的能力和图片的设置等等.仅仅这些还远远不够. 我们已经使用React构建了一个加载图片库的程序。接下来我们需要考虑到随着程序功能的添加，到底需要哪些基础的模式.首先考虑到的一个问题就是要把应用的状态(state)控制从Gallery组件中分离出来. 我们通过引入Redux来完成应用的状态管理工作。 使用Redux来管理状态在你的应用中只要使用了setState方法都会让一个组件从无状态变为有状态的组件.糟糕的是这个方法会导致应用中出现一些令人困惑的代码,这些代码会在应用中到处蔓延。 Flux构架来减轻这个问题.Flux把逻辑(logic)和状态(state)迁移到Store中.应用中的动作(Actions)被Dispatch的时候,Stores会做相应的更新.Stores的更新会触发View根据新状态的渲染. 那么我们为什么要舍弃Flux?他竟然还是“官方”构建的.好吧！Redux是基于Flux构架的,但是他有一些独特的优势.下面是Dan Abramov(Redux创建者)的一些话： Redux和Flux没有什么不同.总体来讲他们是相同的构架,但是Redux通过功能组合把Flux使用回调注册的复杂点给屏蔽掉了.两个构架从更本上讲没有什么不同，但是我发现Redux使一些在Flux比较难实现的逻辑更容易实现. Redux文档非常棒.如果你还没有读过代码的卡通教程或者Dan的系列文章.赶快去看看吧！ 启动Redux第一件需要做的事事初始化Redux,让他在我们的程序中运行起来.现在不需要做安装工作，刚开始运行npm install的时候已经安装好了依赖项，我们需要做一些导入和配置工作.reducer函数是Redux的大脑. 每当应用分发(或派遣,dispatch)一个操作(action)的时候,reducer函数会接受操作(action)并且依据这个动作(action)创建reducer自己的state.因为reducers是纯函数，他们可以组合到一起，创建应用的一个完整state.让我们在src中创建一个简单的reducer: reducer.js 1234export default function images(state, action) &#123; console.log(state, action) return state;&#125; 一个reducer函数接受两个参数(arguments). [x] state-这个数据代表应用的状态(state).reducer函数使用这个状态来构建一个reducer自己可以管理的状态.如果状态没有发生改变,reducer会返回输入的状态. [x] action-这是触发reducer的事件.Actions通过store派发(dispatch),由reducer处理.action需要一个type属性来告诉reducer怎么处理state. 目前,images reuducer在终端中打印出日志记录，表明工作流程是正常的，可以做接下来的工作了.为了使用reducer，需要在main.js中做一些配置工作: main.js 123456789101112131415161718192021import \"babel-polyfill\";import React from 'react';import ReactDOM from 'react-dom';import Gallery from './Gallery';+ import &#123; createStore &#125; from 'redux'+ import reducer from './reducer'+ const store = createStore(reducer);+ import &#123;Provider&#125; from 'react-redux';ReactDOM.render(+ &lt;Provider store=&#123;store&#125;&gt; &lt;Gallery /&gt;+ &lt;/Provider&gt;, document.getElementById('root'));&#125; 我们从Redux库中导入createStore组件.creatStore用来创建Redux的store.大多数情况下,我们不会和store直接交互,store在Redux中做幕后管理工作. 也需要导入刚才创建的reducer函数,以便于他可以被发送到store. 我们将通过createStore(reducer)操作，利用reducer来配置应用的store.这个示例仅仅只有一个reducer,但是createStore可以接收多个reducer作为参数.稍后我们会看到这一点. 最后我们导入高度集成化的组件Provider,这个组件用来包装Gallery,以便于我们在应用中使用Redux.我们需要把刚刚创建的store传递给Provider.你也可以不使用Provider,实际上Redux可以不需要React.但是我们将会使用Provider,因为他非常便于使用. 这张图可能有点古怪，但是展示了Redux的一个有意思的地方.所有的reducers接收在应用中的全部actions(动作或操作).在这个例子中我们可以看到Redux自己派发的一个action. 连接Gallery组件 借助Redux,我们将使用”connected”和“un-connected”组件.一个connected组件被连线到store.connected组件使控制动作事件(controls action event)和store协作起来.通常,一个connected组件有子组件,子组件具有单纯的接收输入和渲染功能，当数据更新时执行调用.这个子组件就是unconnected组件. 提示:当Rect和Redux配合是工作的非常好,但是Redux不是非要和React在一起才能工作.没有React,Redux其实可以和其他框架配合使用. 在应用中需要关联React组件和Redux Store 的时候，react-redux提供了便捷的包装器.我们把react-redux添加进Gallery中,从而使Gallery成为首要的关联组件. Gallery.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 import React, &#123;Component&#125; from 'react'+import &#123;connect&#125; from 'react-redux';-export default class Gallery extends Component &#123;+export class Gallery extends Component &#123; constructor(props) &#123; super(props);+ console.log(props); this.state = &#123; images: [] &#125; &#125; componentDidMount() &#123; const API_KEY = 'a46a979f39c49975dbdd23b378e6d3d5'; const API_ENDPOINT = `https://api.flickr.com/services/rest/?method=flickr.interestingness.getList&amp;api_key=$&#123;API_KEY&#125;&amp;format=json&amp;nojsoncallback=1&amp;per_page=5`; fetch(API_ENDPOINT).then((response) =&gt; &#123; return response.json().then((json) =&gt; &#123; const images = json.photos.photo.map((&#123;farm, server, id, secret&#125;) =&gt; &#123; return `https://farm$&#123;farm&#125;.staticflickr.com/$&#123;server&#125;/$&#123;id&#125;_$&#123;secret&#125;.jpg` &#125;); this.setState(&#123;images, selectedImage: images[0]&#125;); &#125;) &#125;) &#125; handleThumbClick(selectedImage) &#123; this.setState(&#123; selectedImage &#125;) &#125; render() &#123; const &#123;images, selectedImage&#125; = this.state; return ( &lt;div className=\"image-gallery\"&gt; &lt;div className=\"gallery-image\"&gt; &lt;div&gt; &lt;img src=&#123;selectedImage&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"image-scroller\"&gt; &#123;images.map((image, index) =&gt; ( &lt;div key=&#123;index&#125; onClick=&#123;this.handleThumbClick.bind(this,image)&#125;&gt; &lt;img src=&#123;image&#125;/&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;+export default connect()(Gallery) 从react-redux导入connect函数,可以在导出组件的时候把他变为链接组件(connected component).请注意,connect()(Gallery)代码把Gallery组件放在第二个形参中,这是因为connect()返回一个函数，这个函数接受一个React组件作为参数(argument).调用connect()函数时需要配置项.后面我们将会传递配置我们应用的actions和state参数.我们也把connect作为默认配置到处模块.这一点非常重要！现在当我们import Gallery的时候,就不是一个单纯的React组件了,而是一个和Redux关联的组件了. 如果你观察我们添加进构造器的console.log的输出,就可以看到Gallery组件的属性现在包括了一个dispatch函数.这个地方是connect为我们的应用修改的,这个改动赋予了组件把自己的动作对象(action objects)派发到reducers的能力. 123456789 export class Gallery extends Component &#123; constructor(props) &#123; super(props);+ this.props.dispatch(&#123;type: 'TEST'&#125;); this.state = &#123; images: [] &#125; &#125;[...] 我们可以在组件的构造器中调用派发功能.你可以在开发者的终端中看到来自reducer的日志声明.看到声明表示我们已经派发了第一个action!.Actions是一个单一的javascript对象,必需有type属性.Actions可以拥有任意数量和种类的其他属性.但是type可以让reducers理解这些动作到底是做什么用的(意译，意思是只有拥有type属性，reducers才知道对state做什么样的修改). 12345678export default function images(state, action) &#123;- console.log(state, action)+ switch(action.type) &#123;+ case 'TEST':+ console.log('THIS IS ONLY A TEST')+ &#125; return state;&#125; 总的reducers使用switch代码块过滤有关的消息,Switch语句使用actions的type属性,当一个action和case分支吻合以后,相应的单个reducer就会执行他的具体工作. 我们的应用现在关联到接收的动作.现在我们需要把Redux-Store提供的state关联到应用中. 默认的应用状态(state) reducer.js123456789101112131415 const defaultState = &#123; images: []&#125;export default function images(state = defaultState, action) &#123; switch(action.type) &#123; case 'TEST':- console.log('THIS IS ONLY A TEST')+ console.log(state, action)+ return state;+ default:+ return state; &#125;- return state;&#125; 我们创建一个defaultState对象,这个对象返回一个空数组作为images的属性.我们把images函数的参数state设置为默认.如果在test分支中输出日志,将会看到state不是undefined(空数组不是undefined)!reducer需要返回应用的当前state.这点很重要!现在我们没有做任何改变,所以仅仅返回state.注意我们在case中添加了default分支,reducer必须要返回一个state. 在Gallery组件中，我们也可以把state做一定的映射(map)以后再连接到应用. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 import React, &#123;Component&#125; from 'react'import &#123;connect&#125; from 'react-redux';export class Gallery extends Component &#123; constructor(props) &#123; super(props); this.props.dispatch(&#123;type: 'TEST'&#125;);+ console.log(props);- this.state = &#123;- images: []- &#125; &#125;- componentDidMount() &#123;- const API_KEY = 'a46a979f39c49975dbdd23b378e6d3d5';- const API_ENDPOINT = `https://api.flickr.com/services/rest/?method=flickr.interestingness.-getList&amp;api_key=$&#123;API_KEY&#125;&amp;format=json&amp;nojsoncallback=1&amp;per_page=5`;--- fetch(API_ENDPOINT).then((response) =&gt; &#123;- return response.json().then((json) =&gt; &#123;- const images = json.photos.photo.map((&#123;farm, server, id, secret&#125;) =&gt; &#123; - return `https://farm$&#123;farm&#125;.staticflickr.com/$&#123;server&#125;/$&#123;id&#125;_$&#123;secret&#125;.jpg`- &#125;);-- this.setState(&#123;images, selectedImage: images[0]&#125;);- &#125;)- &#125;)- &#125;- handleThumbClick(selectedImage) &#123;- this.setState(&#123;- selectedImage- &#125;)- &#125; render() &#123;- const &#123;images, selectedImage&#125; = this.state;+ const &#123;images, selectedImage&#125; = this.props; return ( &lt;div className=\"image-gallery\"&gt; &lt;div className=\"gallery-image\"&gt; &lt;div&gt; &lt;img src=&#123;selectedImage&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"image-scroller\"&gt; &#123;images.map((image, index) =&gt; (- &lt;div key=&#123;index&#125; onClick=&#123;this.handleThumbClick.bind(this,image)&#125;&gt;+ &lt;div key=&#123;index&#125;&gt; &lt;img src=&#123;image&#125;/&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;+function mapStateToProps(state) &#123;+ return &#123;+ images: state.images+ selectedImage: state.selectedImage+ &#125;+&#125;-export default connect()(Gallery)+export default connect(mapStateToProps)(Gallery)``` 我们将移除连接组件中的所有图片加载和交互逻辑代码,如果你注意看`Gallery`组件的底部代码,你会注意到，我们创建了一个`mapStateToProps`函数,接收一个`state`作为参数,返回一个对象,把`state.images`映射为`images`属性.`mapStateToProps`做为参数传递给`connect`. 正如名字暗示的一样,`mapStateToProps`函数接收当前应用的state,然后把state转变为组件的属性(propertys).如果在构造器中输出props,将会看到images数组是`reducer`返回的默认state. const defaultState = { images: [] images: [ “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg&quot;, “https://farm2.staticflickr.com/1581/25283151224_50f8da511e.jpg&quot;, “https://farm2.staticflickr.com/1653/25265109363_f204ea7b54.jpg&quot;, “https://farm2.staticflickr.com/1571/25911417225_a74c8041b0.jpg&quot;, “https://farm2.staticflickr.com/1450/25888412766_44745cbca3.jpg&quot; ], selectedImage: “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg&quot;} export default function images(state = defaultState, action) { switch(action.type) { case ‘TEST’: console.log(state, action) return state; default: return state; }}1234567 如果在`defaultState`中更新images数组,你将可以看到一些图片重新出现在gallery中!现在当用户点击缩略图的时候,我们可以反馈选择动作,返回对应的大图. #### 更新state 怎么操作才能根据新选择的图片更新state? 需要配置reducer监听`IMAGE_SELECTED`动作,借助action携带的信息(payload,有的文章翻译为载荷,载荷怎么理解？手机载荷就是声音，短信和流量数据。如果是卡车就是拉的货物,如果是客车就乘载的乘客,action的载荷就是要让reducer明白你要干什么，需要什么)来更新state. const defaultState = { images: [ “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg&quot;, “https://farm2.staticflickr.com/1581/25283151224_50f8da511e.jpg&quot;, “https://farm2.staticflickr.com/1653/25265109363_f204ea7b54.jpg&quot;, “https://farm2.staticflickr.com/1571/25911417225_a74c8041b0.jpg&quot;, “https://farm2.staticflickr.com/1450/25888412766_44745cbca3.jpg&quot; ], selectedImage: “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg&quot;} export default function images(state = defaultState, action) { switch(action.type) { case ‘TEST’:case ‘IMAGE_SELECTED’: return state; return {…state, selectedImage: action.image};default:return state;}} 12现在reducer已经准备接收`IMAGE_SELECTED` action了.在`IMAGE_SELECTED`分支选项内,我们在展开(spreading,ES6的对象操作方法),并重写`selectedImage`属性后,返回一个新state对象.了解更多的`...state`对象操作可以看`ruanyifeng`的书. import React, {Component} from ‘react’import {connect} from ‘react-redux’; export class Gallery extends Component { constructor(props) { super(props); this.props.dispatch({type: ‘TEST’}); console.log(props); }render() { const {images, selectedImage} = this.props; const {images, selectedImage, dispatch} = this.props; return ( &lt;div&gt; &lt;img src={selectedImage} /&gt; &lt;/div&gt; {images.map((image, index) =&gt; ( dispatch({type:’IMAGE_SELECTED’, image})}&gt; ))})}} function mapStateToProps(state) { return { images: state.images, selectedImage: state.selectedImage }} export default connect(mapStateToProps)(Gallery)12345678 在`Gallery`组件中,我们将会在组件的属性中定义`dispatch`在`onClick`函数体中调用他,现在我们从便利角度考虑把他们放在一起,但是两者功能是一样的.一旦我们点击了缩略图,他将会通过reducer更新大图. 使用dispatch可以很方便的创建通用actions,但是很快我们会需要重用命名好的actions.为了这样做,可以使用”action creators”. #### Action Creators Action creators函数返回配置好的action对象.我们在`action.js`中添加第一个action creator. `action.js` export const IMAGE_SELECTED = ‘IMAGE_SELECTED’; export function selectImage(image) { return { type: IMAGE_SELECTED, image }}1234这个方法经过export以后,可以直接在任何需要创建`selectImage` action地方导入!`selectImage`是纯函数，只能返回数据.他接收一个image作为参数,把image添加到action对象中，并返回.&gt;注意:我们正在返回一个单纯的javascript object,但是`image`的属性可能很古怪，如果你以前没有碰到这样的样式.从ES6的角度出发,如果你给一个对象传递一个类似这样的属性,隐含的意思是把`image:'任何image包含的值'`添加到最终返回的对象.超级好用! import * as GalleryActions from ‘./actions.js’;[…]onClick={() =&gt; dispatch(GalleryActions.selectImage(image))}1234this isn’t much than just using `dispatch` though.幸运的是,这个模式很普遍,Redux在`bindActionCreators`函数里提供了一个更好的办法来完成这个功能. import React, {Component} from ‘react’import {connect} from ‘react-redux’; import {bindActionCreators} from ‘redux’; import * as GalleryActions from ‘./actions.js’; export class Gallery extends Component { constructor(props) { super(props); this.props.dispatch({type: ‘TEST’}); console.log(props); } handleThumbClick(selectedImage) { this.setState({ selectedImage }) } render() { const {images, selectedImage, dispatch} = this.props; const {images, selectedImage, selectImage} = this.props;return ( &lt;div&gt; &lt;img src={selectedImage} /&gt; &lt;/div&gt; {images.map((image, index) =&gt; ( dispatch({type:’IMAGE_SELECTED’, image})}&gt; selectImage(image)}&gt; ))})}} function mapStateToProps(state) { return { images: state.images, selectedImage: state.selectedImage }} +function mapActionCreatorsToProps(dispatch) { return bindActionCreators(GalleryActions, dispatch);+} -export default connect(mapStateToProps)(Gallery)+export default connect(mapStateToProps, mapActionCreatorsToProps)(Gallery)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 我们已经添加了`mapActionCreatorsToProps`函数,他接收`dispatch`函数作为参数.返回`bindActionCreators`的调用结果,`GalleryActions`作为`bindActionCreators`的参数.现在如果你输出属性日志,就看不到`dispatch`作为参数,`selectImage`直接可以使用了.(这里相当于对dispatch和action进行了包装). 现在回顾一下,我们做了几件事: - 创建了一个reducer包含应用的默认初始状态(initial state),并且监听actions的执行. - 创建了一个store,把reducer具体化,提供一个分发器(dispatcher)可以分发action. - 把我们的Gallery组件关联到store的state. - 把store的state映射为属性(property)，传递给Gallery. - 映射一个动作创建器,Gallery可以简单的调用`selectImage(image)`,分发动作,应用状态将会更新.那么，我们怎么才能使用这些模式从远程资源加载数据呢？这个过程将会非常有趣!#### 异步活动？你可能在参加函数式编程的时候听说过”副作用”(side effects)这个名词,side effects是发生在应用的范围之外的东西.在我们舒适的肥皂泡里,side effect根本不是问题,但是当我们要到达一个远程资源,肥皂泡就被穿透了.有些事情我们就控制不了了,我们必须接受这个事实.(根据这段话，side effect 翻译为意想不到的事情，出乎意料的不受控制的事情更好)在Redux里,reducer没有Side effects.这意味着reducers不处理我们应用中的异步活动.我们不能使用reducers加载远程数据,因为reducers是纯函数,没有side effects.Redux很棒,如果你的应用里没有任何异步活动，你可以停下来,不用再往下看了.如果你创建的应用比较大,可能你会从服务端加载数据,这时,当然要使用异步方式.&gt;**注意**： Redux其中一个最酷的地方是他非常小巧.他试图解决有限范围内的问题.大多数的应用需要解决很多问题!万幸,Reduc提供中间件概念,中间件存在于action-&gt;reducer-&gt;store的三角关系中,通过中间件的方式,可以导入诸如远程数据异步加载类似的功能.其中一个方法是使用`thunks`对象,在Redux中有 redux-thunk 中间件.Thunks非常厉害，但是可能会导致actions的序列很复杂,测试起来也是很大的挑战.考虑到我们的 图片浏览程序.当应用加载是,需要做:- 从服务器请求图片数组- 当图片加载完毕,显示提示消息- 当远程数据返回以后,选择初始图片显示- 处理可能出现的错误这些事件都要在用户点击应用里的任何元素之前完成!我们该怎么做呢？redux-saga就是为此而诞生,为我们的应用提供绝佳的服务.redux-sageredux-sage可以在Redux应用中操作异步actions.他提供中间件和趁手的方法使构建复杂的异步操作流程轻而易举.一个saga是一个Generator(生成器),Generator函数是ES2015新添加的特性.可能是你第一次遇到Generator函数,这样你会觉得有点古怪,可以参考(ruanyifeng文章).不要苦恼，如果你对此仍然很抓耳挠腮.使用redux-sage你不需要javascript异步编程的博士学位.因为使用了generators的缘故,我们能创建一个顺序执行的命令序列，用来描述复杂的异步操作流程(workflows).整个图片的加载流程序列如下： export function* loadImages() { try { const images = yield call(fetchImages); yield put({type: ‘IMAGES_LOADED’, images}) yield put({type: ‘IMAGE_SELECTED’, image: images[0]}) } catch(error) { yield put({type: ‘IMAGE_LOAD_FAILURE’, error}) }} export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield call(loadImages); }}123456 #### 第一个saga我们将开始一个简单的saga实例,然后配置他连接到我们的应用.在`src`创建一个文件`saga.js` export function* sayHello() { console.log(‘hello’);} 1234___我们的saga是一个简单的generator函数.函数后面的`*`作为标志,他也被叫做”super star”.现在在`main.js`文件中导入新函数,并且执行他. import “babel-polyfill”; import React from ‘react’;import ReactDOM from ‘react-dom’; import Gallery from ‘./Gallery’; import { createStore } from ‘redux’import {Provider} from ‘react-redux’;import reducer from ‘./reducer’ +import {sayHello} from ‘./sagas’;+sayHello(); const store = createStore(reducer); ReactDOM.render( , document.getElementById(‘root’));12345不管你盯住终端多长时间,“hello”永远不会出现.这是因为`sayHello`是一个generator！Generator 不会立即执行.如果你把代码该为`sayHello().next();`你的“hello”就出现了.不用担心,我们不会总是调用`next`.正如Redux,redux-saga用来消除应用开发中的痛苦.配置 redux-sage import “babel-polyfill”; import React from ‘react’;import ReactDOM from ‘react-dom’; import Gallery from ‘./Gallery’; -import { createStore } from ‘redux’+import { createStore, applyMiddleware } from ‘redux’+import createSagaMiddleware from ‘redux-saga’import {Provider} from ‘react-redux’;import reducer from ‘./reducer’ import {sayHello} from ‘./sagas’;-sayHello() -const store = createStore(reducer);+const store = createStore( reducer, applyMiddleware(createSagaMiddleware(sayHello))+); ReactDOM.render( , document.getElementById(‘root’));123456789 我们已从Redux导入了`applyMiddleware`函数.从redux-saga导入`createSagaMiddleware`函数.当我们创建store的时候,我们需要通过中间件提供Redux需要的功能.在这个实例中,我们会调用`applyMiddleware`函数,这个函数返回`createSagaMiddleware(sayHello)`的结果.在幕后,redux-saga加载`sayHello`函数,仪式性的调用`next`函数. 应该可以在终端中看到提示消息了. 现在让我们构建加载图片的saga #### 通过Saga加载图片数据我们将删除出sayHello saga,使用`loadImages` saga -export function* sayHello() { console.log(‘hello’);-} +export function* loadImages() { console.log(‘load some images please’)+}12不要忘了更新`main.js` import “babel-polyfill”; import React from ‘react’;import ReactDOM from ‘react-dom’; import Gallery from ‘./Gallery’; import { createStore, applyMiddleware } from ‘redux’import {Provider} from ‘react-redux’;import createSagaMiddleware from ‘redux-saga’import reducer from ‘./reducer’ -import {sayHello} from ‘./sagas’;+import {loadImages} from ‘./sagas’; const store = createStore( reducer, applyMiddleware(createSagaMiddleware(sayHello)) applyMiddleware(createSagaMiddleware(loadImages))); ReactDOM.render( , document.getElementById(‘root’));12现在saga已经加载,在`saga.js`中添加`fetchImages`方法 const API_KEY = &apos;a46a979f39c49975dbdd23b378e6d3d5&apos;; const API_ENDPOINT = https://api.flickr.com/services/rest/?method=flickr.interestingness.getList&amp;api_key=${API_KEY}&amp;format=json&amp;nojsoncallback=1&amp;per_page=5; const fetchImages = () =&gt; { return fetch(API_ENDPOINT).then(function (response) { return response.json().then(function (json) { return json.photos.photo.map( ({farm, server, id, secret}) =&gt; https://farm${farm}.staticflickr.com/${server}/${id}_${secret}.jpg ); }) })}; export function* loadImages() { const images = yield fetchImages(); console.log(images)}12345678 `fetchImages`方法返回一个promise对象.我们将调用`fetchImages`,但是现在我们要使用`yield`关键字.通过黑暗艺术和巫术,generators理解Promise对象,正如终端输出的日志显示,我们已经收获了一个图片URLs的数组.看看`loadImages`的代码,他看起来像是典型的同步操作代码.`yield`关键字是秘制调味酱,让我们的代码用同步格式执行异步操作活动. #### 封装我们的异步API请求. 首先来定义一下需要使用的api.他没有什么特殊的地方,实际上他和早先加载Flickr images的代码是相同的.我们创建`flickr.js`文件 const API_KEY = ‘a46a979f39c49975dbdd23b378e6d3d5’;const API_ENDPOINT = https://api.flickr.com/services/rest/?method=flickr.interestingness.getList&amp;api_key=${API_KEY}&amp;format=json&amp;nojsoncallback=1&amp;per_page=5; export const fetchImages = () =&gt; { return fetch(API_ENDPOINT).then(function (response) { return response.json().then(function (json) { return json.photos.photo.map( ({farm, server, id, secret}) =&gt; https://farm${farm}.staticflickr.com/${server}/${id}_${secret}.jpg ); }) })};123456 严格意义上来说,不需要这么做,但是这会带来一定的好处.我们处在应用的边缘(boundaries of our application,意思是说在这里的代码可能是很多和远程服务器交互的代码，可能逻辑会很复杂),事情都有点乱.通过封装和远程API交互的逻辑,我们的代码将会很整洁,很容易更新.如果需要抹掉图片服务也会出奇的简单.我们的`saga.js`看起来是这个样子： import {fetchImages} from ‘./flickr’; export function* loadImages() { const images = yield fetchImages(); console.log(images)}1234567我们仍然需要在saga外获取数据,并且进入应用的state(使用异步获取的远程数据更新state).为了处理这个问题,我们将使用”effects”.#### 从saga来更新应用我们可以通过`dispatch`或者store作为参数来调用saga,但是这个方法时间一长就会给人造成些许的困扰.我们选择采用redux-saga提供的`put`方法.首先我们更新`reducer.js`操作一个新的action类型`IMAGES_LOADED`. const defaultState = { images: []} export default function images(state = defaultState, action) { switch(action.type) { case ‘IMAGE_SELECTED’: return {…state, selectedImage: action.image}; case ‘IMAGES_LOADED’: return {…state, images: action.images};default:return state;}} 1234我们添加了新的分支,并从`defaultState`中删除了硬编码的URLs数据.`IMAGES_LOADED`分支现在返回一个更新的state,包含action的image数据.下一步我们更新saga: import {fetchImages} from ‘./flickr’;+import {put} from ‘redux-saga/effects’; export function* loadImages() { const images = yield fetchImages(); yield put({type: ‘IMAGES_LOADED’, images})}1234567导入`put`以后,我们在`loadImages`添加另外一行.他`yield` `put`函数调用的返回结果.在幕后,redux-saga 分发这些动作,reducer接收到了消息! 怎样才能使用特定类型的action来触发一个saga? #### 使用actions来触发saga工作流Sagas变得越来越有用,因为我们有能力使用redux actions来触发工作流.当我们这样做,saga会在我们的应用中表现出更大的能力.首先我们创建一个新的saga.`watchForLoadImages`. import {fetchImages} from ‘./flickr’;-import {put} from ‘redux-saga/effects’;+import {put, take} from ‘redux-saga/effects’; export function* loadImages() { const images = yield fetchImages(); yield put({type: ‘IMAGES_LOADED’, images})} +export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield loadImages(); }+}12新的saga使用的是while来保持一直激活和等待调用状态.在循环的内部,我们生成(yield)一个redux-sage调用方法:`take`.Take方法监听任何类型的actions,他也会使saga接受下一个yield.在上面的例子中我们调用了一个方法`loadImages`,初始化图片加载. import “babel-polyfill”; import React from ‘react’;import ReactDOM from ‘react-dom’; import Gallery from ‘./Gallery’; import { createStore, applyMiddleware } from ‘redux’import {Provider} from ‘react-redux’;import createSagaMiddleware from ‘redux-saga’import reducer from ‘./reducer’ -import {loadImages} from ‘./sagas’;+import {loadImages} from ‘./watchForLoadImages’; const store = createStore( reducer, applyMiddleware(createSagaMiddleware(loadImages)) applyMiddleware(createSagaMiddleware(watchForLoadImages))); ReactDOM.render( , document.getElementById(‘root’));12更新了`main.js`以后,应用不再加载图片,我们需要在action creators中添加`loadImages`的`action`. export const IMAGE_SELECTED = ‘IMAGE_SELECTED’;+const LOAD_IMAGES = ‘LOAD_IMAGES’; export function selectImage(image) { return { type: IMAGE_SELECTED, image }} +export function loadImages() { return { type: LOAD_IMAGES }+}1234567因为我们已经绑定了action creators(Action创建器),我们只需要在`Gallery`组件中调用这个action就可以了.#### block(阻塞)和no-blocking(非阻塞)效应现在我们的引用工作的足够好了,但是可能还有更多的问题需要考虑.`watchForLoadImages` saga包含 block effects.那么这到底是什么意思呢？这意味着在工作流中我们只能执行一次`LOAD_IMAGES`!在诸如我们现在构建的小型应用一样,这一点不太明显,实际上我们也仅仅加载了一次图片集.实际上，普遍的做法是使用`fork` effect 代替 `yield` 来加载图片. export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield loadImages(); yield fork(loadImages); //be sure to import it!}}12345使用`fork`助手(helper)函数,`watchForLoadImages`就变成了非阻塞saga了,再也不用考虑他是不是以前掉用过.redux-sagas 提供两个helpers,`takeEvery`和`takeLastest`（takeEvery监听多次action，不考虑是不是同一种action type,takeLatest只处理同一种action type的最后一次调用）.####选择默认的图片Sagas按照队列来执行acitons,所以添加更多的saga也很容易. import {fetchImages} from ‘./flickr’;import {put, take, fork} from ‘redux-saga/effects’; export function* loadImages() { const images = yield fetchImages(); yield put({type: ‘IMAGES_LOADED’, images}) yield put({type: ‘IMAGE_SELECTED’, image: images[0]})} export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield fork(loadImages); }}1234在 `loadImages`工作流上,我们可以yield put函数调用,action type是`IMAGE_SELECTED`.发送我们选择的图片(在这个例子中，发送的仅仅是图片的url的字符串).#### 错误处理如果在saga循环内部出现错误,我们要考虑提醒应用做出合理的回应.所有流程包装到try/catch语句块里就可以实现,捕获错误以后`put`一个提示信息作为`IMAGE_LOAD_FAILURE` action的内容. import {fetchImages} from ‘./flickr’;import {put, take, fork} from ‘redux-saga/effects’; export function* loadImages() { try { const images = yield fetchImages(); yield put({type: ‘IMAGES_LOADED’, images}) yield put({type: ‘IMAGE_SELECTED’, image: images[0]}) } catch(error) { yield put({type: ‘IMAGE_LOAD_FAILURE’, error}) }} export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield fork(loadImages); }}123456#### Sagas的测试在应用中使用Redux,测试变得相当的舒服. 看看我们的[鹅蛋头系列课程](https://egghead.io/series/react-testing-cookbook),可以了解到很多React的测试技术.使用Redux-saga在棒的一个方面就是异步代码测试很容易.测试javascript异步代码真是一件苦差事.有了saga,我们不需要跳出引用的核心代码.Saga把javascript的痛点都抹掉了.是不是意味着我们要写更多的测试?对的.我们会使用`tape`组件,首先做一些配置工作. import test from ‘tape’;import {put, take} from ‘redux-saga/effects’import {watchForLoadImages, loadImages} from ‘./sagas’;import {fetchImages} from ‘./flickr’; test(‘watchForLoadImages’, assert =&gt; { const generator = watchForLoadImages(); assert.end();});12添加所有需要的组件,现在我们添加一个测试.这个测试接收一个名称和一个函数作为形参.在测试的函数体内部代码块,我们创建了一个saga生成器代码实例.在这个实例里面我们尅是测试saga的每一个动作. import test from ‘tape’;import {put, take} from ‘redux-saga/effects’import {watchForLoadImages, loadImages} from ‘./sagas’;import {fetchImages} from ‘./flickr’; test(‘watchForLoadImages’, assert =&gt; { const generator = watchForLoadImages(); assert.deepEqual( generator.next().value, false, ‘watchForLoadImages should be waiting for LOAD_IMAGES action’ ); assert.end();}); 123`assert.deepEqual`方法接收两个值,检查一下他们是不是深度相同(js对象的概念).第一行代码是`generator.next().value`的调用,这个调用使生成器从暂停中恢复,得到值.下一个值单单是一个`false`.我想看到他失败,最后一个参数描述了测试期待的行为.在项目文件夹中命令行运行`npm test`看看结果: import test from ‘tape’;import {put, take} from ‘redux-saga/effects’import {watchForLoadImages, loadImages} from ‘./sagas’;import {fetchImages} from ‘./flickr’; test(‘watchForLoadImages’, assert =&gt; { const generator = watchForLoadImages(); assert.deepEqual( generator.next().value, false, ‘watchForLoadImages should be waiting for LOAD_IMAGES action’ ); assert.end();}); 12测试结果和预期的一样失败,结果有点意思.实际的结论是`&#123;TAKE:'LOAD_IMAGES'&#125;`,这是我们调用`take('LOAD_IMAGES')`受到的结果.实际上,我们的saga’可以yield一个对象来代替调用`take`.但是`take`添加了一些代码,让我们少敲些代码. import test from ‘tape’;import {put, take} from ‘redux-saga/effects’import {watchForLoadImages, loadImages} from ‘./sagas’;import {fetchImages} from ‘./flickr’; test(‘watchForLoadImages’, assert =&gt; { const generator = watchForLoadImages(); assert.deepEqual( generator.next().value, false take(‘LOAD_IMAGES’),‘watchForLoadImages should be waiting for LOAD_IMAGES action’); assert.end();}); 12我们简单的调用`take`函数,就可以得到期待的结果了. import test from ‘tape’;import {put, take} from ‘redux-saga/effects’import {watchForLoadImages, loadImages} from ‘./sagas’;import {fetchImages} from ‘./flickr’; test(‘watchForLoadImages’, assert =&gt; { const generator = watchForLoadImages(); assert.deepEqual( generator.next().value, take(‘LOAD_IMAGES’), ‘watchForLoadImages should be waiting for LOAD_IMAGES action’ ); assert.deepEqual( gen.next().value, false, ‘watchForLoadImages should call loadImages after LOAD_IMAGES action is received’ ); assert.end();}); 1234下一个测试使我们确信`loadImages`saga在流程的下一个阶段会被自动调用.我们需要一个 false来检查结果.更新一下saga代码,yield一个`loadImages` saga: export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield loadImages(); yield fork(loadImages); //be sure to import it!}}12现在运行测试,将会看到下面结果： ✖ watchForLoadImages should call loadImages after LOAD_IMAGES action is received operator: deepEqual expected: |- false actual: |- { _invoke: [Function: invoke] }1234哼！`&#123; _invoke: [Function: invoke] &#125;`绝对不是我们yield take想要的结果.有问题.幸运的是redux-saga可以使用诸如`fork`一样的`effects`来解决这个问题.`fork`,`take`和其他的effect方法返容易满足测试要求的简单对象.这些effects返回的对象是一个指导redux-saga进行任务执行的集合.这一点对于测试来说非常的优雅,因为我们不用担心类似远程服务请求的副作用.有了redux-saga,我们把注意点放到请求执行的命令上.下面让我们更新一下saga,再一次使用`fork`. export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield loadImages(); yield fork(loadImages); }} 1234这里使用`yield fork(loadImages)`直接代替`loadImages`.需要注意的是我们还没有执行`loadImages`,而是作为参数传递给`fork`.再次运行`npm test`. ✖ watchForLoadImages should call loadImages after LOAD_IMAGES action is received operator: deepEqual expected: |- false actual: |- { FORK: { args: [], context: null, fn: [Function: loadImages] } }12结果得到了一个单纯对象而不是一个函数调用.函数在浏览器端也同时加载了,但是我们现在可以轻松的在saga 工作流里测试这个步骤. import test from ‘tape’;import {put, take} from ‘redux-saga/effects’import {watchForLoadImages, loadImages} from ‘./sagas’;import {fetchImages} from ‘./flickr’; test(‘watchForLoadImages’, assert =&gt; { const generator = watchForLoadImages(); assert.deepEqual( generator.next().value, take(‘LOAD_IMAGES’), ‘watchForLoadImages should be waiting for LOAD_IMAGES action’ ); assert.deepEqual( generator.next().value, false, yield fork(loadImages),‘watchForLoadImages should call loadImages after LOAD_IMAGES action is received’); assert.end();}); 12测试`loadImages`saga是一样的,只需要把`yield fetchImages`更新为`yield fork(fetchImages)`. test(‘loadImages’, assert =&gt; { const gen = loadImages(); assert.deepEqual( gen.next().value, call(fetchImages), ‘loadImages should call the fetchImages api’ ); const images = [0]; assert.deepEqual( gen.next(images).value, put({type: ‘IMAGES_LOADED’, images}), ‘loadImages should dispatch an IMAGES_LOADED action with the images’ ); assert.deepEqual( gen.next(images).value, put({type: ‘IMAGE_SELECTED’, image: images[0]}), ‘loadImages should dispatch an IMAGE_SELECTED action with the first image’ ); const error = ‘error’; assert.deepEqual( gen.throw(error).value, put({type: ‘IMAGE_LOAD_FAILURE’, error}), ‘loadImages should dispatch an IMAGE_LOAD_FAILURE if an error is thrown’ ); assert.end();});` 特别注意最后一个assert.这个断言测试使用异常捕获代替生成器函数的next方法.另一个非常酷的地方是：可以传值.注意看代码,我们创建了images常量,并且传递到next函数.saga可以在接下来的任务序列中使用传递的值. 太棒了,这种方法是测试异步编程的程序员梦寐以求的技术. 接下来做什么？ 你可以fork一下这个例子的代码. 如果你想扩充这个应用,可以做一下几个方面的工作. 做一个幻灯显示下一张要显示的图片 允许使用者搜索Flickr图片 添加其他提供图片的API 允许用户选择喜欢的API进行搜索. 我们仅仅和生成器碰了一下面,但是即便如此,希望在联合使用redux-saga library,Redux和React的时候给你一些帮助.","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"saga","slug":"saga","permalink":"https://React-Apollo.github.io/tags/saga/"}]},{"title":"翻译|redux undo/redo  reducer增强组件","slug":"翻译-redux-undo-redo-reducer增强组件","date":"2017-04-04T13:18:28.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2017/04/04/翻译-redux-undo-redo-reducer增强组件/","link":"","permalink":"https://React-Apollo.github.io/2017/04/04/翻译-redux-undo-redo-reducer增强组件/","excerpt":"","text":"Redux的文档中提供一个可以做undo/redo的解决办法,实际是有previous,current,prew的对象,围绕这数据的压入和弹出来实现操作步骤的记忆,结合persist就可以实现更强大的记忆功能.今天的这个增强组件实际把这个功能给包装了一下,内部实现细节仍然没有变.只需要把reducer用这个增强组件包装一下就可以用了. redux undo/redo 提示:你可以使用redux-undo-boilerplate来开始项目. Installation1npm install --save redux-undo API123import undoable from 'redux-undo';undoable(reducer)undoable(reducer, config) 让你的reducers变得可以重做redux-undo是一个reducer增强组件,它提供了undoable函数,这个函数接收已经存在的reducer和配置对象,使用undo函数增强已经存在的reducer. 注意：如果在state.counter之前接入,你必须要在包装reducer之后接入state.coutner.present. 首先导入redux-undo1234 // Redux utility functions import &#123; combineReducers &#125; from 'redux';// redux-undo higher-order reducer import undoable from 'redux-undo'; 接着,添加undoable到你的reducer123combineReducers(&#123; counter: undoable(counter)&#125;) 配置项想这样传递12345combineReducers(&#123; counter: undoable(counter, &#123; limit: 10 // set a limit for the history &#125;)&#125;) 历史API使用reducer包装你的reducer想这样12345 &#123; past: [...pastStatesHere...], present: &#123;...currentStateHere...&#125;, future: [...futureStatesHere...]&#125; 现在你可以使用state.present获取当前的state获取所有过去的state使用state.past. Undo/Redo Actions首先导入undo/redo action creators1import &#123; ActionCreators &#125; from 'redux-undo'; 然后就可以使用store.dispatch()和undo/redo action creators来执行undo/redo操作.12345store.dispatch(ActionCreators.undo()) // undo the last action store.dispatch(ActionCreators.redo()) // redo the last action store.dispatch(ActionCreators.jumpToPast(index)) // jump to requested index in the past[] array store.dispatch(ActionCreators.jumpToFuture(index)) // jump to requested index in the future[] array 配置配置对象传递给undoable()(值是默认值) 123456789101112131415161718192021undoable(reducer, &#123; limit: false, // set to a number to turn on a limit for the history filter: () =&gt; true, // see `Filtering Actions` section undoType: ActionTypes.UNDO, // define a custom action type for this undo action redoType: ActionTypes.REDO, // define a custom action type for this redo action jumpToPastType: ActionTypes.JUMP_TO_PAST, // define custom action type for this jumpToPast action jumpToFutureType: ActionTypes.JUMP_TO_FUTURE, // define custom action type for this jumpToFuture action initialState: undefined, // initial state (e.g. for loading) initTypes: ['@@redux/INIT', '@@INIT'] // history will be (re)set upon init action type initialHistory: &#123; // initial history (e.g. for loading) past: [], present: config.initialState, future: [] &#125;, debug: false, // set to `true` to turn on debugging &#125;) 过滤Actions如果你不想包含每一步的action,可以传递一个函数到undoable123456789undoable(reducer, function filterActions(action, currentState, previousState) &#123; return action.type === SOME_ACTION; // only add to history if action is SOME_ACTION只有some_action的action才能记录 &#125;) // or you could do... undoable(reducer, function filterState(action, currentState, previousState) &#123; return currentState !== previousState; // only add to history if state changed只有state变化的才能记录重做 &#125;) 或者你可以使用distinctState,includeAction,excludeAction助手函数1import undoable, &#123; distinctState, includeAction, excludeAction &#125; from 'redux-undo'; 现在你可以使用助手函数了,相当简单123456undoable(reducer, &#123; filter: includeAction(SOME_ACTION) &#125;)undoable(reducer, &#123; filter: excludeAction(SOME_ACTION) &#125;) // or you could do... undoable(reducer, &#123; filter: distinctState() &#125;) 甚至还支持数组12 undoable(reducer, &#123; filter: includeAction([SOME_ACTION, SOME_OTHER_ACTION]) &#125;)undoable(reducer, &#123; filter: excludeAction([SOME_ACTION, SOME_OTHER_ACTION]) &#125;) 有什么魔法？怎么工作的Redux文档中的实现Undo历史的方案解释了redux-undo工作的具体细节.","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"}]},{"title":"翻译|使用React,Redux和reudx-saga构建一个图像浏览程序","slug":"using react redux and redux-saga building a app","date":"2017-03-28T08:17:07.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2017/03/28/using react redux and redux-saga building a app/","link":"","permalink":"https://React-Apollo.github.io/2017/03/28/using react redux and redux-saga building a app/","excerpt":"","text":"###使用React,Redux和reudx-saga构建一个图像浏览程序(翻译)Joel Hooks ,2016年3月 #####构建一个图片长廊 图像长廊是一个简单的程序，从Flicker API 加载图片urls,允许用户查看图片详情。 图片1 后续会使用React,Redux和redux-saga.React作为核心框架，优势是虚拟dom(virtual-dom)的实现。Redux在程序内负责state的管理。最后，我们会使用redux-saga来操作javascript的异步操作步骤。 我会是用ES6(箭头函数，模块，和模板字符串)，所以我们首先需要做一些项目的配置工作。 项目配置和自动化 如果要开始一个React项目，须有有一系列的配置选项。对于一个简单的项目，我想把配置选项尽可能缩减。考虑到浏览器的版本问题，我会使用Babel把ES6编译为ES5。后面这一句不懂 首先使用npm init 创建一个package.json文件 package.json 123456789101112131415161718192021222324252627282930313233343536 &#123; \"name\": \"egghead-react-redux-image-gallery\", \"version\": \"0.0.1\", \"description\": \"Redux Saga beginner tutorial\", \"main\": \"src/main.js\", \"scripts\": &#123; \"test\": \"babel-node ./src/saga.spec.js | tap-spec\", \"start\": \"budo ./src/main.js:build.js --dir ./src --verbose --live -- -t babelify\" &#125;, \"repository\": &#123; \"type\": \"git\", \"url\": \"git+https://github.com/joelhooks/egghead-react-redux-image-gallery.git\" &#125;, \"author\": \"Joel Hooks &lt;joelhooks@gmail.com&gt;\", \"license\": \"MIT\", \"dependencies\": &#123; \"babel-polyfill\": \"6.3.14\", \"react\": \"^0.14.3\", \"react-dom\": \"^0.14.3\", \"react-redux\": \"^4.4.1\", \"redux\": \"^3.3.1\", \"redux-saga\": \"^0.8.0\" &#125;, \"devDependencies\": &#123; \"babel-cli\": \"^6.1.18\", \"babel-core\": \"6.4.0\", \"babel-preset-es2015\": \"^6.1.18\", \"babel-preset-react\": \"^6.1.18\", \"babel-preset-stage-2\": \"^6.1.18\", \"babelify\": \"^7.2.0\", \"browserify\": \"^13.0.0\", \"budo\": \"^8.0.4\", \"tap-spec\": \"^4.1.1\", \"tape\": \"^4.2.2\" &#125;&#125; 有了package.json, 可以在项目文件夹命令行运行 npm install 安装程序需要的依赖项。 .babelrc 12345678910&#123; \"presets\": [\"es2015\", \"react\", \"stage-2\"] &#125; ``` 这个文件告诉babel,我们将会使用ES2015(ES6),React以及ES2106的stage-2的一些特征。`package.json`有两个标准的script脚本配置：`start`和`test`.现在我们想通过start脚本加载程序，start会使用`src`目录的一些文件，所以西药先创建`src`文件夹.在`src`文件夹添加下面的一些文：`index.html` &lt;!doctype html&gt; egghead: React Redux Image Gallery Egghead Image Gallery 1234___`main.js` import &quot;babel-polyfill&quot; import React from ‘react’import ReactDOM from ‘react-dom’ ReactDOM.render( Hello React!, document.getElementById(‘root’));12`style.css` body { font-family: Helvetica, Arial, Sans-Serif, sans-serif; background: white; } .title { display: flex; padding: 2px;} .egghead { width: 30px; padding: 5px;} .image-gallery { width: 300px; display: flex; flex-direction: column; border: 1px solid darkgray;} .gallery-image { height: 250px; display: flex; align-items: center; justify-content: center;} .gallery-image img { width: 100%; max-height: 250px;} .image-scroller { display: flex; justify-content: space-around; overflow: auto; overflow-y: hidden;} .image-scroller img { width: 50px; height: 50px; padding: 1px; border: 1px solid black;} 12345678910111213`index.html`文件加载`style.css`文件提供一些基本的布局样式，同时也加载`build.js`文件，这是一个生成出来的文件.`main.js`是一个最基础的React程序，他在`index.html`的`#root`元素中渲染一个`h1`元素。创建这些文件以后，在项目文件夹中命令行运行`npm start`。在浏览器打开`http://10.11.12.1:9966`.就可以看到`index.html`中渲染的页面图2现在我们来构建基础的`Gallery` React 组件#####在Gallery中显示一些图片___ 首先我们需要尽可能快的获得一个可以显示的图片素材.在项目文件夹中创建一个文件`Gallery.js``Gallery.js` import React, {Component} from &apos;react&apos; const flickrImages = [ “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg&quot;, “https://farm2.staticflickr.com/1581/25283151224_50f8da511e.jpg&quot;, “https://farm2.staticflickr.com/1653/25265109363_f204ea7b54.jpg&quot;, “https://farm2.staticflickr.com/1571/25911417225_a74c8041b0.jpg&quot;, “https://farm2.staticflickr.com/1450/25888412766_44745cbca3.jpg&quot;]; export default class Gallery extends Component { constructor(props) { super(props); this.state = { images: flickrImages, selectedImage: flickrImages[0] } } render() { const {images, selectedImage} = this.state; return ( {images.map((image, index) =&gt; ( ))} ) }}123我们直接在组件中硬编码了一个提供数据的数组，能让项目尽快的工作起来.`Gallery组件`继承`Component组件`,在构造函数中创建一些组件的出事状态.最后我们利用一些样式标记渲染一下文件。`image-scroller`元素遍历(`map`方法)图片数组,生成摘要图片。 import &quot;babel-polyfill&quot; import React from ‘react’import ReactDOM from ‘react-dom’ import Gallery from ‘./Gallery’ ReactDOM.render( Hello React!, ,document.getElementById(‘root’));12345678910111213141516171819202122232425262728293031323334353637383940414243 到现在，我们使用硬编码的图片URLs(通过fickrImages)数组,第一张图片作为`selectedImage`.这些属性在`Gallery`组件的构造函数缺省配置中，通过初始状态(initial)来设定. 图片3 接下来在组件中添加一个和组件进行交互操作的方法，方法具体内容是操做`setSate`. `Gallery.js` ```js export default class Gallery extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; images: flickrImages, selectedImage: flickrImages[0] &#125; &#125;+ handleThumbClick(selectedImage) &#123;+ this.setState(&#123;+ selectedImage+ &#125;)+ &#125; render() &#123; const &#123;images, selectedImage&#125; = this.state; return ( &lt;div className=\"image-gallery\"&gt; &lt;div className=\"gallery-image\"&gt; &lt;div&gt; &lt;img src=&#123;selectedImage&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"image-scroller\"&gt; &#123;images.map((image, index) =&gt; (- &lt;div key=&#123;index&#125;&gt;+ &lt;div key=&#123;index&#125; onClick=&#123;this.handleThumbClick.bind(this,image)&#125;&gt; &lt;img src=&#123;image&#125;/&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 在Gallery组件添加handleThumbClick方法,任何元素都可用通过onClick属性调用这个方法.image作为第二个参数传递，元素自身作为第一个参数传递.bind方法传递javascript函数调用上下文对象是非常便捷。 看起来错!现在我们有了一些交互操作，有点“APP”的意思了。截止目前，我们已经让app运行起来了，接下来要考虑加载远程数据。最容易加载远程数据的地方是一个React组件生命周期方法,我们使用componentDidMount方法,通过他从Flikr API请求并加载一些图片. Gallery.js 1234567891011121314151617181920212223 export default class Gallery extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; images: flickrImages, selectedImage: flickrImages[0] &#125; &#125;+ componentDidMount() &#123;+ const API_KEY = 'a46a979f39c49975dbdd23b378e6d3d5';+ const API_ENDPOINT = `https://api.flickr.com/services/rest/?method=flickr.interestingness.+getList&amp;api_key=$&#123;API_KEY&#125;&amp;format=json&amp;nojsoncallback=1&amp;per_page=5`;+++ fetch(API_ENDPOINT).then((response) =&gt; &#123;+ return response.json().then((json) =&gt; &#123;+ const images = json.photos.photo.map((&#123;farm, server, id, secret&#125;) =&gt; &#123; + return `https://farm$&#123;farm&#125;.staticflickr.com/$&#123;server&#125;/$&#123;id&#125;_$&#123;secret&#125;.jpg`+ &#125;);++ this.setState(&#123;images, selectedImage: images[0]&#125;);+ &#125;)+ &#125;)+ &#125;[...] 我们在Gallery类中添加了一个新的方法,通过React的componentDidMount生命周期方法触发Flickr图片数据的获取。 在React组件运行的不同时间点，组件会调用不同的生命周期函数。在这段代码中，当组件被渲染到DOM中的时间点,componentDidMount函数就会被调用。需要注意的是:Gallery组件只有一次渲染到DOM的机会，所以这个函数可以提供一些初始化图片.考虑到在APP的整个生命周期中,有更多的动态组件的加载和卸载,这可能会造成一些多余的调用和无法考虑到的结果。 我们使用浏览器接口(browser API)的fetch方法执行请求.Fetch返回一个promise对象解析response对象.调用response.json()方法,返回另一个promise对象，这就是我们实际需要的json格式的数据.遍历这个对象以后就可以获取图片的url地址. 坦白讲，这个应用很简单.我们还需要在这里花费更多的时间，还有一些基础的需求需要完成.或许我们应该在promise处理流程中添加错误处理方法,如果图片数据获取成功也需要一些处理逻辑.在这个地方，你需要发挥一些想象力.在生产实践中简单的需求是很少见的.很快,应用中就会添加更多的需求。认证,滚动橱窗,加载不同图片库的能力和图片的设置等等.仅仅这些还还不够. 我们已经使用React构建了一个加载图片库的程序。接下来我们需要考虑到随着程序功能的添加，到底需要哪些基础的模式.首先考虑到的一个问题就是要把应用的状态(state)控制从Gallery组件中分离出来. 我们通过引入Redux来完成应用的状态管理工作。 使用Redux来管理状态在你的应用中只要使用了setState方法都会让一个组件从无状态变为有状态的组件.糟糕的是这个方法会导致应用中出现一些令人困惑的代码,这些代码会在应用中到处蔓延。 Flux构架来减轻这个问题.Flux把逻辑(logic)和状态(state)迁移到Store中.应用中的动作(Actions)被Dispatch的时候,Stores会做相应的更新.Stores的更新会触发View根据新状态的渲染. 那么我们为什么要舍弃Flux?他竟然还是“官方”构建的.好吧！Redux是基于Flux构架的,但是他有一些独特的优势.下面是Dan Abramov(Redux创建者)的一些话： Redux和Flux没有什么不同.总体来讲他们是相同的构架,但是Redux通过功能组合把Flux使用回调注册的复杂点给屏蔽掉了.两个构架从更本上讲没有什么不同，但是我发现Redux使一些在Flux比较难实现的逻辑更容易实现. Redux文档非常棒.Dan(这句话不知道怎么翻译了)如果你还没有读过代码的卡通教程或者Dan的系列文章.赶快去看看吧！ ###启动Redux 第一件需要做的事事初始化Redux,让他在我们的程序中运行起来.现在不需要做安装工作，刚开始运行npm install的时候已经安装好了依赖项，我们需要做一些导入和配置工作.reducer函数是Redux的大脑. 每当应用分发(或派遣,dispatch)一个操作(action)的时候,reducer函数会接受操作(action)并且依据这个动作(action)创建reducer自己的state.因为reducers是纯函数，他们可以组合到一起，创建应用的一个完整state.让我们在src中创建一个简单的reducer: reducer.js 1234export default function images(state, action) &#123; console.log(state, action) return state;&#125; 一个reducer函数接受两个参数(arguments). [x] state-这个数据代表应用的状态(state).reducer函数使用这个状态来构建一个reducer自己可以管理的状态.如果状态没有发生改变,reducer会返回输入的状态. [x] action-这是触发reducer的事件.Actions通过store派发(dispatch),由reducer处理.action需要一个type属性来告诉reducer怎么处理state. 目前,images reuducer在终端中打印出日志记录，表明工作流程是正常的，可以做接下来的工作了.为了使用reducer，需要在main.js中做一些配置工作:main.js 123456789101112131415161718192021import \"babel-polyfill\";import React from 'react';import ReactDOM from 'react-dom';import Gallery from './Gallery';+ import &#123; createStore &#125; from 'redux'+ import reducer from './reducer'+ const store = createStore(reducer);+ import &#123;Provider&#125; from 'react-redux';ReactDOM.render(+ &lt;Provider store=&#123;store&#125;&gt; &lt;Gallery /&gt;+ &lt;/Provider&gt;, document.getElementById('root'));&#125; 我们从Redux库中导入createStore组件.creatStore用来创建Redux的store.大多数情况下,我们不会和store直接交互,store在Redux中做幕后管理工作. 也需要导入刚才创建的reducer函数,以便于他可以被发送到store. 我们将通过createStore(reducer)操作，利用reducer来配置应用的store.这个示例仅仅只有一个reducer,但是createStore可以接收多个reducer作为参数.稍后我们会看到这一点. 最后我们导入高度集成化的组件Provider,这个组件用来包装Gallery,以便于我们在应用中使用Redux.我们需要把刚刚创建的store传递给Provider.你也可以不使用Provider,实际上Redux可以不需要React.但是我们将会使用Provider,因为他非常便于使用. 图3 这张图可能有点古怪，但是展示了Redux的一个有意思的地方.所有的reducers接收在应用中的全部actions(动作或操作).在这个例子中我们可以看到Redux自己派发的一个action. 连接Gallery组件 借助Redux,我们将使用”connected”和“un-connected”组件.一个connected组件被连线到store.connected组件使控制动作事件(controls action event)和store协作起来.通常,一个connected组件有子组件,子组件具有单纯的接收输入和渲染功能，当数据更新时执行调用.这个子组件就是unconnected组件. 提示:当Rect和Redux配合是工作的非常好,但是Redux不是非要和React在一起才能工作.没有React,Redux其实可以和其他框架配合使用. 在应用中需要关联React组件和Redux Store 的时候，react-redux提供了便捷的包装器.我们把react-redux添加进Gallery中,从而使Gallery成为首要的关联组件. Gallery.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 import React, &#123;Component&#125; from 'react'+import &#123;connect&#125; from 'react-redux';-export default class Gallery extends Component &#123;+export class Gallery extends Component &#123; constructor(props) &#123; super(props);+ console.log(props); this.state = &#123; images: [] &#125; &#125; componentDidMount() &#123; const API_KEY = 'a46a979f39c49975dbdd23b378e6d3d5'; const API_ENDPOINT = `https://api.flickr.com/services/rest/?method=flickr.interestingness.getList&amp;api_key=$&#123;API_KEY&#125;&amp;format=json&amp;nojsoncallback=1&amp;per_page=5`; fetch(API_ENDPOINT).then((response) =&gt; &#123; return response.json().then((json) =&gt; &#123; const images = json.photos.photo.map((&#123;farm, server, id, secret&#125;) =&gt; &#123; return `https://farm$&#123;farm&#125;.staticflickr.com/$&#123;server&#125;/$&#123;id&#125;_$&#123;secret&#125;.jpg` &#125;); this.setState(&#123;images, selectedImage: images[0]&#125;); &#125;) &#125;) &#125; handleThumbClick(selectedImage) &#123; this.setState(&#123; selectedImage &#125;) &#125; render() &#123; const &#123;images, selectedImage&#125; = this.state; return ( &lt;div className=\"image-gallery\"&gt; &lt;div className=\"gallery-image\"&gt; &lt;div&gt; &lt;img src=&#123;selectedImage&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"image-scroller\"&gt; &#123;images.map((image, index) =&gt; ( &lt;div key=&#123;index&#125; onClick=&#123;this.handleThumbClick.bind(this,image)&#125;&gt; &lt;img src=&#123;image&#125;/&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;+export default connect()(Gallery) 从react-redux导入connect函数,可以在导出组件的时候把他变为链接组件(connected component).请注意,connect()(Gallery)代码把Gallery组件放在第二个形参中,这是因为connect()返回一个函数，这个函数接受一个React组件作为参数(argument).调用connect()函数时需要配置项.后面我们将会传递配置我们应用的actions和state参数.我们也把connect作为默认配置到处模块.这一点非常重要！现在当我们import Gallery的时候,就不是一个单纯的React组件了,而是一个和Redux关联的组件了. 图4 如果你观察我们添加进构造器的console.log的输出,就可以看到Gallery组件的属性现在包括了一个dispatch函数.这个地方是connect为我们的应用修改的,这个改动赋予了组件把自己的动作对象(action objects)派发到reducers的能力. 123456789 export class Gallery extends Component &#123; constructor(props) &#123; super(props);+ this.props.dispatch(&#123;type: 'TEST'&#125;); this.state = &#123; images: [] &#125; &#125;[...] 我们可以在组件的构造器中调用派发功能.你可以在开发者的终端中看到来自reducer的日志声明.看到声明表示我们已经派发了第一个action!.Actions是一个单一的javascript对象,必需有type属性.Actions可以拥有任意数量和种类的其他属性.但是type可以让reducers理解这些动作到底是做什么用的(意译，意思是只有拥有type属性，reducers才知道对state做什么样的修改). 12345678export default function images(state, action) &#123;- console.log(state, action)+ switch(action.type) &#123;+ case 'TEST':+ console.log('THIS IS ONLY A TEST')+ &#125; return state;&#125; 总的reducers使用switch代码块过滤有关的消息,Switch语句使用actions的type属性,当一个action和case分支吻合以后,相应的单个reducer就会执行他的具体工作. 我们的应用现在关联到接收的动作.现在我们需要把Redux-Store提供的state关联到应用中. 默认的应用状态(state)reducer.js 123456789101112131415 const defaultState = &#123; images: []&#125;export default function images(state = defaultState, action) &#123; switch(action.type) &#123; case 'TEST':- console.log('THIS IS ONLY A TEST')+ console.log(state, action)+ return state;+ default:+ return state; &#125;- return state;&#125; 我们创建一个defaultState对象,这个对象返回一个空数组作为images的属性.我们把images函数的参数state设置为默认.如果在test分支中输出日志,将会看到state不是undefined(空数组不是undefined)!reducer需要返回应用的当前state.这点很重要!现在我们没有做任何改变,所以仅仅返回state.注意我们在case中添加了default分支,reducer必须要返回一个state. 在Gallery组件中，我们也可以把state做一定的映射(map)以后再连接到应用. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 import React, &#123;Component&#125; from 'react'import &#123;connect&#125; from 'react-redux';export class Gallery extends Component &#123; constructor(props) &#123; super(props); this.props.dispatch(&#123;type: 'TEST'&#125;);+ console.log(props);- this.state = &#123;- images: []- &#125; &#125;- componentDidMount() &#123;- const API_KEY = 'a46a979f39c49975dbdd23b378e6d3d5';- const API_ENDPOINT = `https://api.flickr.com/services/rest/?method=flickr.interestingness.-getList&amp;api_key=$&#123;API_KEY&#125;&amp;format=json&amp;nojsoncallback=1&amp;per_page=5`;--- fetch(API_ENDPOINT).then((response) =&gt; &#123;- return response.json().then((json) =&gt; &#123;- const images = json.photos.photo.map((&#123;farm, server, id, secret&#125;) =&gt; &#123; - return `https://farm$&#123;farm&#125;.staticflickr.com/$&#123;server&#125;/$&#123;id&#125;_$&#123;secret&#125;.jpg`- &#125;);-- this.setState(&#123;images, selectedImage: images[0]&#125;);- &#125;)- &#125;)- &#125;- handleThumbClick(selectedImage) &#123;- this.setState(&#123;- selectedImage- &#125;)- &#125; render() &#123;- const &#123;images, selectedImage&#125; = this.state;+ const &#123;images, selectedImage&#125; = this.props; return ( &lt;div className=\"image-gallery\"&gt; &lt;div className=\"gallery-image\"&gt; &lt;div&gt; &lt;img src=&#123;selectedImage&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"image-scroller\"&gt; &#123;images.map((image, index) =&gt; (- &lt;div key=&#123;index&#125; onClick=&#123;this.handleThumbClick.bind(this,image)&#125;&gt;+ &lt;div key=&#123;index&#125;&gt; &lt;img src=&#123;image&#125;/&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;+function mapStateToProps(state) &#123;+ return &#123;+ images: state.images+ selectedImage: state.selectedImage+ &#125;+&#125;-export default connect()(Gallery)+export default connect(mapStateToProps)(Gallery)``` 我们将移除连接组件中的所有图片加载和交互逻辑代码,如果你注意看`Gallery`组件的底部代码,你会注意到，我们创建了一个`mapStateToProps`函数,接收一个`state`作为参数,返回一个对象,把`state.images`映射为`images`属性.`mapStateToProps`做为参数传递给`connect`. 正如名字暗示的一样,`mapStateToProps`函数接收当前应用的state,然后把state转变为组件的属性(propertys).如果在构造器中输出props,将会看到images数组是`reducer`返回的默认state. const defaultState = { images: [] images: [ “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg&quot;, “https://farm2.staticflickr.com/1581/25283151224_50f8da511e.jpg&quot;, “https://farm2.staticflickr.com/1653/25265109363_f204ea7b54.jpg&quot;, “https://farm2.staticflickr.com/1571/25911417225_a74c8041b0.jpg&quot;, “https://farm2.staticflickr.com/1450/25888412766_44745cbca3.jpg&quot; ], selectedImage: “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg&quot;} export default function images(state = defaultState, action) { switch(action.type) { case ‘TEST’: console.log(state, action) return state; default: return state; }}1234567 如果在`defaultState`中更新images数组,你将可以看到一些图片重新出现在gallery中!现在当用户点击缩略图的时候,我们可以反馈选择动作,返回对应的大图. #### 更新state 怎么操作才能根据新选择的图片更新state? 需要配置reducer监听`IMAGE_SELECTED`动作,借助action携带的信息(payload,有的文章翻译为载荷,载荷怎么理解？手机载荷就是声音，短信和流量数据。如果是卡车就是拉的货物,如果是客车就乘载的乘客,action的载荷就是要让reducer明白你要干什么，需要什么)来更新state. const defaultState = { images: [ “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg&quot;, “https://farm2.staticflickr.com/1581/25283151224_50f8da511e.jpg&quot;, “https://farm2.staticflickr.com/1653/25265109363_f204ea7b54.jpg&quot;, “https://farm2.staticflickr.com/1571/25911417225_a74c8041b0.jpg&quot;, “https://farm2.staticflickr.com/1450/25888412766_44745cbca3.jpg&quot; ], selectedImage: “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg&quot;} export default function images(state = defaultState, action) { switch(action.type) { case ‘TEST’:case ‘IMAGE_SELECTED’: return state; return {…state, selectedImage: action.image};default:return state;}} 12现在reducer已经准备接收`IMAGE_SELECTED` action了.在`IMAGE_SELECTED`分支选项内,我们在展开(spreading,ES6的对象操作方法),并重写`selectedImage`属性后,返回一个新state对象.了解更多的`...state`对象操作可以看`ruanyifeng`的书. import React, {Component} from ‘react’import {connect} from ‘react-redux’; export class Gallery extends Component { constructor(props) { super(props); this.props.dispatch({type: ‘TEST’}); console.log(props); }render() { const {images, selectedImage} = this.props; const {images, selectedImage, dispatch} = this.props; return ( &lt;div&gt; &lt;img src={selectedImage} /&gt; &lt;/div&gt; {images.map((image, index) =&gt; ( dispatch({type:’IMAGE_SELECTED’, image})}&gt; ))})}} function mapStateToProps(state) { return { images: state.images, selectedImage: state.selectedImage }} export default connect(mapStateToProps)(Gallery)12345678 在`Gallery`组件中,我们将会在组件的属性中定义`dispatch`在`onClick`函数体中调用他,现在我们从便利角度考虑把他们放在一起,但是两者功能是一样的.一旦我们点击了缩略图,他将会通过reducer更新大图. 使用dispatch可以很方便的创建通用actions,但是很快我们会需要重用命名好的actions.为了这样做,可以使用”action creators”. #### Action Creators Action creators函数返回配置好的action对象.我们在`action.js`中添加第一个action creator. `action.js` export const IMAGE_SELECTED = ‘IMAGE_SELECTED’; export function selectImage(image) { return { type: IMAGE_SELECTED, image }}1234这个方法经过export以后,可以直接在任何需要创建`selectImage` action地方导入!`selectImage`是纯函数，只能返回数据.他接收一个image作为参数,把image添加到action对象中，并返回.&gt;注意:我们正在返回一个单纯的javascript object,但是`image`的属性可能很古怪，如果你以前没有碰到这样的样式.从ES6的角度出发,如果你给一个对象传递一个类似这样的属性,隐含的意思是把`image:'任何image包含的值'`添加到最终返回的对象.超级好用! import * as GalleryActions from ‘./actions.js’;[…]onClick={() =&gt; dispatch(GalleryActions.selectImage(image))}1234this isn’t much than just using `dispatchti` though.幸运的是,这个模式很普遍,Redux在`bindActionCreators`函数里提供了一个更好的办法来完成这个功能. import React, {Component} from ‘react’import {connect} from ‘react-redux’; import {bindActionCreators} from ‘redux’; import * as GalleryActions from ‘./actions.js’; export class Gallery extends Component { constructor(props) { super(props); this.props.dispatch({type: ‘TEST’}); console.log(props); } handleThumbClick(selectedImage) { this.setState({ selectedImage }) } render() { const {images, selectedImage, dispatch} = this.props; const {images, selectedImage, selectImage} = this.props;return ( &lt;div&gt; &lt;img src={selectedImage} /&gt; &lt;/div&gt; {images.map((image, index) =&gt; ( dispatch({type:’IMAGE_SELECTED’, image})}&gt; selectImage(image)}&gt; ))})}} function mapStateToProps(state) { return { images: state.images, selectedImage: state.selectedImage }} +function mapActionCreatorsToProps(dispatch) { return bindActionCreators(GalleryActions, dispatch);+} -export default connect(mapStateToProps)(Gallery)+export default connect(mapStateToProps, mapActionCreatorsToProps)(Gallery)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 我们已经添加了`mapActionCreatorsToProps`函数,他接收`dispatch`函数作为参数.返回`bindActionCreators`的调用结果,`GalleryActions`作为`bindActionCreators`的参数.现在如果你输出属性日志,就看不到`dispatch`作为参数,`selectImage`直接可以使用了.(这里相当于对dispatch和action进行了包装). 现在回顾一下,我们做了几件事: - 创建了一个reducer包含应用的默认初始状态(initial state),并且监听actions的执行. - 创建了一个store,把reducer具体化,提供一个分发器(dispatcher)可以分发action. - 把我们的Gallery组件关联到store的state. - 把store的state映射为属性(property)，传递给Gallery. - 映射一个动作创建器,Gallery可以简单的调用`selectImage(image)`,分发动作,应用状态将会更新.那么，我们怎么才能使用这些模式从远程资源加载数据呢？这个过程将会非常有趣!#### 异步活动？你可能在参加函数式编程的时候听说过”副作用”(side effects)这个名词,side effects是发生在应用的范围之外的东西.在我们舒适的肥皂泡里,side effect根本不是问题,但是当我们要到达一个远程资源,肥皂泡就被穿透了.有些事情我们就控制不了了,我们必须接受这个事实.(根据这段话，side effect 翻译为意想不到的事情，出乎意料的不受控制的事情更好)在Redux里,reducer没有Side effects.这意味着reducers不处理我们应用中的异步活动.我们不能使用reducers加载远程数据,因为reducers是纯函数,没有side effects.Redux很棒,如果你的应用里没有任何异步活动，你可以停下来,不用再往下看了.如果你创建的应用比较大,可能你会从服务端加载数据,这时,当然要使用异步方式.&gt;**注意**： Redux其中一个最酷的地方是他非常小巧.他试图解决有限范围内的问题.大多数的应用需要解决很多问题!万幸,Reduc提供中间件概念,中间件存在于action-&gt;reducer-&gt;store的三角关系中,通过中间件的方式,可以导入诸如远程数据异步加载类似的功能.其中一个方法是使用`thunks`对象,在Redux中有 redux-thunk 中间件.Thunks非常厉害，但是可能会导致actions的序列很复杂,测试起来也是很大的挑战.考虑到我们的 图片浏览程序.当应用加载是,需要做:- 从服务器请求图片数组- 当图片加载完毕,显示提示消息- 当远程数据返回以后,选择初始图片显示- 处理可能出现的错误这些事件都要在用户点击应用里的任何元素之前完成!我们该怎么做呢？redux-saga就是为此而诞生,为我们的应用提供绝佳的服务.`redux-sage`redux-sage可以在Redux应用中操作异步actions.他提供中间件和趁手的方法使构建复杂的异步操作流程轻而易举.一个saga是一个Generator(生成器),Generator函数是ES2015新添加的特性.可能是你第一次遇到Generator函数,这样你会觉得有点古怪,可以参考(ruanyifeng文章).不要苦恼，如果你对此仍然很抓耳挠腮.使用redux-sage你不需要javascript异步编程的博士学位.因为使用了generators的缘故,我们能创建一个顺序执行的命令序列，用来描述复杂的异步操作流程(workflows).整个图片的加载流程序列如下： export function* loadImages() { try { const images = yield call(fetchImages); yield put({type: ‘IMAGES_LOADED’, images}) yield put({type: ‘IMAGE_SELECTED’, image: images[0]}) } catch(error) { yield put({type: ‘IMAGE_LOAD_FAILURE’, error}) }} export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield call(loadImages); }}12345 #### 第一个saga我们将开始一个简单的saga实例,然后配置他连接到我们的应用.在`src`创建一个文件`saga.js` export function* sayHello() { console.log(‘hello’);}1234 我们的saga是一个简单的generator函数.函数后面的`*`作为标志,他也被叫做”super star”.现在在`main.js`文件中导入新函数,并且执行他. import “babel-polyfill”; import React from ‘react’;import ReactDOM from ‘react-dom’; import Gallery from ‘./Gallery’; import { createStore } from ‘redux’import {Provider} from ‘react-redux’;import reducer from ‘./reducer’ +import {sayHello} from ‘./sagas’;+sayHello(); const store = createStore(reducer); ReactDOM.render( , document.getElementById(‘root’));123456不管你盯住终端多长时间,“hello”永远不会出现.这是因为`sayHello`是一个generator！Generator 不会立即执行.如果你把代码该为`sayHello().next();`你的“hello”就出现了.不用担心,我们不会总是调用`next`.正如Redux,redux-saga用来消除应用开发中的痛苦.配置 redux-sage import “babel-polyfill”; import React from ‘react’;import ReactDOM from ‘react-dom’; import Gallery from ‘./Gallery’; -import { createStore } from ‘redux’+import { createStore, applyMiddleware } from ‘redux’+import createSagaMiddleware from ‘redux-saga’import {Provider} from ‘react-redux’;import reducer from ‘./reducer’ import {sayHello} from ‘./sagas’;-sayHello() -const store = createStore(reducer);+const store = createStore( reducer, applyMiddleware(createSagaMiddleware(sayHello))+); ReactDOM.render( , document.getElementById(‘root’));123456789 我们已从Redux导入了`applyMiddleware`函数.从redux-saga导入`createSagaMiddleware`函数.当我们创建store的时候,我们需要通过中间件提供Redux需要的功能.在这个实例中,我们会调用`applyMiddleware`函数,这个函数返回`createSagaMiddleware(sayHello)`的结果.在幕后,redux-saga加载`sayHello`函数,仪式性的调用`next`函数. 应该可以在终端中看到提示消息了. 现在让我们构建加载图片的saga #### 通过Saga加载图片数据我们将删除出sayHello saga,使用`loadImages` saga -export function* sayHello() { console.log(‘hello’);-} +export function* loadImages() { console.log(‘load some images please’)+}12不要忘了更新`main.js` import “babel-polyfill”; import React from ‘react’;import ReactDOM from ‘react-dom’; import Gallery from ‘./Gallery’; import { createStore, applyMiddleware } from ‘redux’import {Provider} from ‘react-redux’;import createSagaMiddleware from ‘redux-saga’import reducer from ‘./reducer’ -import {sayHello} from ‘./sagas’;+import {loadImages} from ‘./sagas’; const store = createStore( reducer, applyMiddleware(createSagaMiddleware(sayHello)) applyMiddleware(createSagaMiddleware(loadImages))); ReactDOM.render( , document.getElementById(‘root’));12 现在saga已经加载,在`saga.js`中添加`fetchImages`方法 const API_KEY = &apos;a46a979f39c49975dbdd23b378e6d3d5&apos;; const API_ENDPOINT = https://api.flickr.com/services/rest/?method=flickr.interestingness.getList&amp;api_key=${API_KEY}&amp;format=json&amp;nojsoncallback=1&amp;per_page=5; const fetchImages = () =&gt; { return fetch(API_ENDPOINT).then(function (response) { return response.json().then(function (json) { return json.photos.photo.map( ({farm, server, id, secret}) =&gt; https://farm${farm}.staticflickr.com/${server}/${id}_${secret}.jpg ); }) })}; export function* loadImages() { const images = yield fetchImages(); console.log(images)}123456789 `fetchImages`方法返回一个promise对象.我们将调用`fetchImages`,但是现在我们要使用`yield`关键字.通过黑暗艺术和巫术,generators理解Promise对象,正如终端输出的日志显示,我们已经收获了一个图片URLs的数组.看看`loadImages`的代码,他看起来像是典型的同步操作代码.`yield`关键字是秘制调味酱,让我们的代码用同步格式执行异步操作活动. #### 封装我们的异步API请求. 首先来定义一下需要使用的api.他没有什么特殊的地方,实际上他和早先加载Flickr images的代码是相同的.我们创建`flickr.js`文件 const API_KEY = ‘a46a979f39c49975dbdd23b378e6d3d5’;const API_ENDPOINT = https://api.flickr.com/services/rest/?method=flickr.interestingness.getList&amp;api_key=${API_KEY}&amp;format=json&amp;nojsoncallback=1&amp;per_page=5; export const fetchImages = () =&gt; { return fetch(API_ENDPOINT).then(function (response) { return response.json().then(function (json) { return json.photos.photo.map( ({farm, server, id, secret}) =&gt; https://farm${farm}.staticflickr.com/${server}/${id}_${secret}.jpg ); }) })};123456 严格意义上来说,不需要这么做,但是这会带来一定的好处.我们处在应用的边缘(boundaries of our application,意思是说在这里的代码可能是很多和远程服务器交互的代码，可能逻辑会很复杂),事情都有点乱.通过封装和远程API交互的逻辑,我们的代码将会很整洁,很容易更新.如果需要抹掉图片服务也会出奇的简单.我们的`saga.js`看起来是这个样子： import {fetchImages} from ‘./flickr’; export function* loadImages() { const images = yield fetchImages(); console.log(images)}1234567我们仍然需要在saga外获取数据,并且进入应用的state(使用异步获取的远程数据更新state).为了处理这个问题,我们将使用”effects”.#### 从saga来更新应用我们可以通过`dispatch`或者store作为参数来调用saga,但是这个方法时间一长就会给人造成些许的困扰.我们选择采用redux-saga提供的`put`方法.首先我们更新`reducer.js`操作一个新的action类型`IMAGES_LOADED`. const defaultState = { images: []} export default function images(state = defaultState, action) { switch(action.type) { case ‘IMAGE_SELECTED’: return {…state, selectedImage: action.image}; case ‘IMAGES_LOADED’: return {…state, images: action.images};default:return state;}} 1234我们添加了新的分支,并从`defaultState`中删除了硬编码的URLs数据.`IMAGES_LOADED`分支现在返回一个更新的state,包含action的image数据.下一步我们更新saga: import {fetchImages} from ‘./flickr’;+import {put} from ‘redux-saga/effects’; export function* loadImages() { const images = yield fetchImages(); yield put({type: ‘IMAGES_LOADED’, images})} 1234567 导入`put`以后,我们在`loadImages`添加另外一行.他`yield` `put`函数调用的返回结果.在幕后,redux-saga 分发这些动作,reducer接收到了消息! 怎样才能使用特定类型的action来触发一个saga? #### 使用actions来触发saga工作流 Sagas变得越来越有用,因为我们有能力使用redux actions来触发工作流.当我们这样做,saga会在我们的应用中表现出更大的能力.首先我们创建一个新的saga.`watchForLoadImages`. import {fetchImages} from ‘./flickr’;-import {put} from ‘redux-saga/effects’;+import {put, take} from ‘redux-saga/effects’; export function* loadImages() { const images = yield fetchImages(); yield put({type: ‘IMAGES_LOADED’, images})} +export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield loadImages(); }+}` 这个新saga使用while循环,因此他总是处于激活和等待状态.","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"Redux-Saga","slug":"Redux-Saga","permalink":"https://React-Apollo.github.io/tags/Redux-Saga/"}]},{"title":"翻译|Getting Started with React, Redux and Immutable a Test-Driven Tutorial (Part 2)","slug":"翻译|Getting Started with React, Redux and Immutable- a Test-Driven","date":"2017-03-26T15:01:24.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2017/03/26/翻译|Getting Started with React, Redux and Immutable- a Test-Driven/","link":"","permalink":"https://React-Apollo.github.io/2017/03/26/翻译|Getting Started with React, Redux and Immutable- a Test-Driven/","excerpt":"","text":"翻译版本,原文请见 这是第二部分的内容. 在第一部分,我们罗列了app的UI,开发和单元测试的基础. 我们看到了app的state通过React的props向下传递到单个的组件,用户的actions声明为回调函数,因此app的逻辑和UI分离开来了. Redux的工作流介绍在这一点上,我们的UI是没有交互操作的:尽管我们已经测试了如果一个item如果被设定为completed,它将给文本划线,但是这里还没有方法邀请用户来完成它: state tree通过props定义了UI和action回调函数. 用户的actions,例如点击,被发送到action creator,action被它范式化. redux action被传递到reducer实现实际的app逻辑 reducer更新state tree,dispatch state到store. UI根据store里的新state tree来更新UI 设定初始化state这部分的代码提交在这里 我们的第一个action将会允许我们在Redux store里正确的设置初始化state,我们将会创建store. Redux中的action是一个信息的载体(payload).action由一个JSON对象有一个type属性,描述action到底是做什么的,还有一部分是app需要的信息.在我们的实例中,type被设定为SET_STATE,我们可以添加一个state对象包含需要的state:1234567891011&#123; type: 'SET_STATE', state: &#123; todos: [ &#123;id: 1, text: 'React', status: 'active', editing: false&#125;, &#123;id: 2, text: 'Redux', status: 'active', editing: false&#125;, &#123;id: 3, text: 'Immutable', status: 'active', editing: false&#125;, ], filter: 'all' &#125;&#125; 这个action会被dispatch到一个reducer,reducer角色的是识别和实施和action对应的逻辑代码. 让我们为reducer来写单元测试代码test/reducer_spec.js1234567891011121314151617181920212223242526272829303132 import &#123;List, Map, fromJS&#125; from 'immutable';import &#123;expect&#125; from 'chai';import reducer from '../src/reducer';describe('reducer', () =&gt; &#123; it('handles SET_STATE', () =&gt; &#123; const initialState = Map(); const action = &#123; type: 'SET_STATE', state: Map(&#123; todos: List.of( Map(&#123;id: 1, text: 'React', status: 'active'&#125;), Map(&#123;id: 2, text: 'Redux', status: 'active'&#125;), Map(&#123;id: 3, text: 'Immutable', status: 'completed'&#125;) ) &#125;) &#125;; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'active'&#125;, &#123;id: 3, text: 'Immutable', status: 'completed'&#125; ] &#125;)); &#125;);&#125;); 为了方便一点,state使用单纯JS对象,而不是使用Immutable数据结构.让我们的reducer来处理转变.最后,reducer将会优雅的处理undefined初始化state:test/reducer_spec.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546 // ...describe('reducer', () =&gt; &#123; // ... it('handles SET_STATE with plain JS payload', () =&gt; &#123; const initialState = Map(); const action = &#123; type: 'SET_STATE', state: &#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'active'&#125;, &#123;id: 3, text: 'Immutable', status: 'completed'&#125; ] &#125; &#125;; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'active'&#125;, &#123;id: 3, text: 'Immutable', status: 'completed'&#125; ] &#125;)); &#125;); it('handles SET_STATE without initial state', () =&gt; &#123; const action = &#123; type: 'SET_STATE', state: &#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'active'&#125;, &#123;id: 3, text: 'Immutable', status: 'completed'&#125; ] &#125; &#125;; const nextState = reducer(undefined, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'active'&#125;, &#123;id: 3, text: 'Immutable', status: 'completed'&#125; ] &#125;)); &#125;);&#125;); 我们的reducer将会匹配接收的actions的type,如果type是SET_STATE,当前的state和action运载的state融合在一起:src/reducer.js12345678910111213import &#123;Map&#125; from 'immutable';function setState(state, newState) &#123; return state.merge(newState);&#125;export default function(state = Map(), action) &#123; switch (action.type) &#123; case 'SET_STATE': return setState(state, action.state); &#125; return state;&#125; 现在我们不得不把reducer连接到我们的app,所以当app启动初始化state.这里实际是第一次使用Redux库,安装一下npm install —save redux@3.3.1 react-redux@4.4.1 src/index.jsx1234567891011121314151617181920212223242526272829303132 import React from 'react';import ReactDOM from 'react-dom';import &#123;List, Map&#125; from 'immutable';import &#123;createStore&#125; from 'redux';import &#123;Provider&#125; from 'react-redux';import reducer from './reducer';import &#123;TodoAppContainer&#125; from './components/TodoApp';// We instantiate a new Redux storeconst store = createStore(reducer);// We dispatch the SET_STATE action holding the desired statestore.dispatch(&#123; type: 'SET_STATE', state: &#123; todos: [ &#123;id: 1, text: 'React', status: 'active', editing: false&#125;, &#123;id: 2, text: 'Redux', status: 'active', editing: false&#125;, &#123;id: 3, text: 'Immutable', status: 'active', editing: false&#125;, ], filter: 'all' &#125;&#125;);require('../node_modules/todomvc-app-css/index.css');ReactDOM.render( // We wrap our app in a Provider component to pass the store down to the components &lt;Provider store=&#123;store&#125;&gt; &lt;TodoAppContainer /&gt; &lt;/Provider&gt;, document.getElementById('app')); 如果你看看上面的代码段,你可以注意到我们的TodoApp组件实际是被TodoAppContainer代替.在Redux里,有两种类型的组件:展示组件和容器.我推荐你阅读一下由Dan Abramov(Redux的作者)写作的高信息量的文章,强调了展示组件和容器的差异性. 如果我想总结得快一点,我将引用Redux 文档的内容： “展示组件是关于事件的样子(模板和样式),容器组件是关于事情是怎么工作的(数据获取,state更新)”. 所以我们创建store,传递给TodoAppContainer.然而为了子组件可以使用store,我们把state映射成为React组件TodoApp的props.src/components/TodoApp.jsx1234567891011121314 // ...import &#123;connect&#125; from 'react-redux';export class TodoApp extends React.Component &#123;// ...&#125;function mapStateToProps(state) &#123; return &#123; todos: state.get('todos'), filter: state.get('filter') &#125;;&#125;export const TodoAppContainer = connect(mapStateToProps)(TodoApp); 如果你在浏览器中重新加载app,你应该可以看到它初始化和之前一样,不过现在使用Redux tools. Redux dev 工具这一部分的提交代码 现在我们已经配置了redux store和reducer.我们可以配置Redux dev tools来展现数据流开发. 首先,获取Redux dev tools Chrome extension dev tools可以在Store创建的时候可以加载. src/index.jsx12345678 // ...import &#123;compose, createStore&#125; from 'redux';const createStoreDevTools = compose( window.devToolsExtension ? window.devToolsExtension() : f =&gt; f)(createStore);const store = createStoreDevTools(reducer);// ... 重新加载app,点击Redux图标,有了. 有三个不同的监视器可以使用:Diff监视器,日志监视器,Slider监视器. 使用Action Creators配置我们的actions切换item的不同状态. 这部分的提交代码在这里 下一步是允许用户在active和completed之前切换状态：test/reducer_spec.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 import &#123;List, Map, fromJS&#125; from 'immutable';import &#123;expect&#125; from 'chai';import reducer from '../src/reducer';describe('reducer', () =&gt; &#123;// ... it('handles TOGGLE_COMPLETE by changing the status from active to completed', () =&gt; &#123; const initialState = fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'active'&#125;, &#123;id: 3, text: 'Immutable', status: 'completed'&#125; ] &#125;); const action = &#123; type: 'TOGGLE_COMPLETE', itemId: 1 &#125; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'completed'&#125;, &#123;id: 2, text: 'Redux', status: 'active'&#125;, &#123;id: 3, text: 'Immutable', status: 'completed'&#125; ] &#125;)); &#125;); it('handles TOGGLE_COMPLETE by changing the status from completed to active', () =&gt; &#123; const initialState = fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'active'&#125;, &#123;id: 3, text: 'Immutable', status: 'completed'&#125; ] &#125;); const action = &#123; type: 'TOGGLE_COMPLETE', itemId: 3 &#125; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'active'&#125;, &#123;id: 3, text: 'Immutable', status: 'active'&#125; ] &#125;)); &#125;);&#125;); 为了通过这些测试,我们更新reducer:src/reducer.js123456789101112131415161718192021222324// ...function toggleComplete(state, itemId) &#123; // We find the index associated with the itemId const itemIndex = state.get('todos').findIndex( (item) =&gt; item.get('id') === itemId ); // We update the todo at this index const updatedItem = state.get('todos') .get(itemIndex) .update('status', status =&gt; status === 'active' ? 'completed' : 'active'); // We update the state to account for the modified todo return state.update('todos', todos =&gt; todos.set(itemIndex, updatedItem));&#125;export default function(state = Map(), action) &#123; switch (action.type) &#123; case 'SET_STATE': return setState(state, action.state); case 'TOGGLE_COMPLETE': return toggleComplete(state, action.itemId); &#125; return state;&#125; 和SET_STATE的action同一个地方,我们需要让TodoAppContainer组件感知到action,所以toggleComplete回调函数会被传递到TodoItem组件(实际调用函数的地方). 在Redux中,有标准的方法来做这件事：Action Creators. action creators是简单的函数,返回合适的action，这些韩式是React的props的一些映射之一.让我们创建第一个action creator:src/action_creators.js 123456export function toggleComplete(itemId) &#123; return &#123; type: 'TOGGLE_COMPLETE', itemId &#125;&#125; 现在,尽管TodoAppcontainer组件中的connect函数的调用可以用来获取store,我们告诉组件使用映射props的回调函数:src/components/TodoApp.jsx123456789101112131415// ...import * as actionCreators from '../action_creators';export class TodoApp extends React.Component &#123; // ... render() &#123; return &lt;div&gt; // ... // We use the spread operator for better lisibility &lt;TodoList &#123;...this.props&#125; /&gt; // ... &lt;/div&gt; &#125;&#125;;export const TodoAppContainer = connect(mapStateToProps, actionCreators)(TodoApp); 重启你的webserver,刷新一下你的浏览器:当当.在条目上点击现在可以切换它的状态.如果你查看Redux dev tools,你可以看到触发的action和后继的更新. 改变目前的过滤器相关代码在在这里 现在每件事情都已经配置完毕,写其他的action是件小事.我们继续创建你希望的CHANGE_FILTERaction,改变当前state的filter,由此仅仅显示过滤过的条目.开始创建action creator：src/action_creators.js1234567 // ...export function changeFilter(filter) &#123; return &#123; type: 'CHANGE_FILTER', filter &#125;&#125; 现在写reducer的单元测试:test/reducer_spec.js1234567891011121314151617181920212223// ...describe('reducer', () =&gt; &#123; // ... it('handles CHANGE_FILTER by changing the filter', () =&gt; &#123; const initialState = fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, ], filter: 'all' &#125;); const action = &#123; type: 'CHANGE_FILTER', filter: 'active' &#125; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, ], filter: 'active' &#125;)); &#125;);&#125;); 关联的reducer函数:src/reducer.js12345678910111213141516 // ...function changeFilter(state, filter) &#123; return state.set('filter', filter);&#125;export default function(state = Map(), action) &#123; switch (action.type) &#123; case 'SET_STATE': return setState(state, action.state); case 'TOGGLE_COMPLETE': return toggleComplete(state, action.itemId); case 'CHANGE_FILTER': return changeFilter(state, action.filter); &#125; return state;&#125; 最后我们把changeFilter回调函数传递给TodoTools组件:TodoApp.jsx123456789101112131415// ...export class TodoApp extends React.Component &#123; // ... render() &#123; return &lt;div&gt; &lt;section className=\"todoapp\"&gt; // ... &lt;TodoTools changeFilter=&#123;this.props.changeFilter&#125; filter=&#123;this.props.filter&#125; nbActiveItems=&#123;this.getNbActiveItems()&#125; /&gt; &lt;/section&gt; &lt;Footer /&gt; &lt;/div&gt; &#125;&#125;; 完成了,第一个filter selector工作完美 Item编辑代码在这里 当用户编辑一个条目,实际上是两个actions触发的三个可能性: 用户输入编辑模式:EDIT_ITEM 用户退出编辑模式(不保存变化):CANCEL_EDITING 用户验证他的编辑(保存变化):DONE_EDITING 我们可以为三个actions编写action creators：src/action_creators.js12345678910111213141516171819202122// ...export function editItem(itemId) &#123; return &#123; type: 'EDIT_ITEM', itemId &#125;&#125;export function cancelEditing(itemId) &#123; return &#123; type: 'CANCEL_EDITING', itemId &#125;&#125;export function doneEditing(itemId, newText) &#123; return &#123; type: 'DONE_EDITING', itemId, newText &#125;&#125; 现在为这些actions编写单元测试:test/reducer_spec.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// ...describe('reducer', () =&gt; &#123; // ... it('handles EDIT_ITEM by setting editing to true', () =&gt; &#123; const initialState = fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active', editing: false&#125;, ] &#125;); const action = &#123; type: 'EDIT_ITEM', itemId: 1 &#125; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active', editing: true&#125;, ] &#125;)); &#125;); it('handles CANCEL_EDITING by setting editing to false', () =&gt; &#123; const initialState = fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active', editing: true&#125;, ] &#125;); const action = &#123; type: 'CANCEL_EDITING', itemId: 1 &#125; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active', editing: false&#125;, ] &#125;)); &#125;); it('handles DONE_EDITING by setting by updating the text', () =&gt; &#123; const initialState = fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active', editing: true&#125;, ] &#125;); const action = &#123; type: 'DONE_EDITING', itemId: 1, newText: 'Redux', &#125; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'Redux', status: 'active', editing: false&#125;, ] &#125;)); &#125;);&#125;); 现在我们可以开发reducer函数,实际操作三个actions:src/reducer.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function findItemIndex(state, itemId) &#123; return state.get('todos').findIndex( (item) =&gt; item.get('id') === itemId );&#125;// We can refactor the toggleComplete function to use findItemIndexfunction toggleComplete(state, itemId) &#123; const itemIndex = findItemIndex(state, itemId); const updatedItem = state.get('todos') .get(itemIndex) .update('status', status =&gt; status === 'active' ? 'completed' : 'active'); return state.update('todos', todos =&gt; todos.set(itemIndex, updatedItem));&#125;function editItem(state, itemId) &#123; const itemIndex = findItemIndex(state, itemId); const updatedItem = state.get('todos') .get(itemIndex) .set('editing', true); return state.update('todos', todos =&gt; todos.set(itemIndex, updatedItem));&#125;function cancelEditing(state, itemId) &#123; const itemIndex = findItemIndex(state, itemId); const updatedItem = state.get('todos') .get(itemIndex) .set('editing', false); return state.update('todos', todos =&gt; todos.set(itemIndex, updatedItem));&#125;function doneEditing(state, itemId, newText) &#123; const itemIndex = findItemIndex(state, itemId); const updatedItem = state.get('todos') .get(itemIndex) .set('editing', false) .set('text', newText); return state.update('todos', todos =&gt; todos.set(itemIndex, updatedItem));&#125;export default function(state = Map(), action) &#123; switch (action.type) &#123; // ... case 'EDIT_ITEM': return editItem(state, action.itemId); case 'CANCEL_EDITING': return cancelEditing(state, action.itemId); case 'DONE_EDITING': return doneEditing(state, action.itemId, action.newText); &#125; return state;&#125; 清除完成,添加和删除条目代码在这里 三个剩下的action是: CLEAR_COMPLETED,在TodoTools组件中触发,从列表中清除完成的条目 ADD_ITEM,在TodoHeader中触发,根据用户的的输入文本来添加条目 DELETE_ITEM,相似TodoItem中调用,删除一个条目 我们现在使用的工作流是:添加action creators,单元测试reducer和代码逻辑,最终通过props传递回调函数:src/action_creators.js 1234567891011121314151617181920// ...export function clearCompleted() &#123; return &#123; type: 'CLEAR_COMPLETED' &#125;&#125;export function addItem(text) &#123; return &#123; type: 'ADD_ITEM', text &#125;&#125;export function deleteItem(itemId) &#123; return &#123; type: 'DELETE_ITEM', itemId &#125;&#125; test/reducer_spec.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 // ...describe('reducer', () =&gt; &#123; // ... it('handles CLEAR_COMPLETED by removing all the completed items', () =&gt; &#123; const initialState = fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'completed'&#125;, ] &#125;); const action = &#123; type: 'CLEAR_COMPLETED' &#125; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, ] &#125;)); &#125;); it('handles ADD_ITEM by adding the item', () =&gt; &#123; const initialState = fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125; ] &#125;); const action = &#123; type: 'ADD_ITEM', text: 'Redux' &#125; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'active'&#125;, ] &#125;)); &#125;); it('handles DELETE_ITEM by removing the item', () =&gt; &#123; const initialState = fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'completed'&#125;, ] &#125;); const action = &#123; type: 'DELETE_ITEM', itemId: 2 &#125; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, ] &#125;)); &#125;);&#125;); src/reducer.js12345678910111213141516171819202122232425262728293031323334function clearCompleted(state) &#123; return state.update('todos', (todos) =&gt; todos.filterNot( (item) =&gt; item.get('status') === 'completed' ) );&#125;function addItem(state, text) &#123; const itemId = state.get('todos').reduce((maxId, item) =&gt; Math.max(maxId,item.get('id')), 0) + 1; const newItem = Map(&#123;id: itemId, text: text, status: 'active'&#125;); return state.update('todos', (todos) =&gt; todos.push(newItem));&#125;function deleteItem(state, itemId) &#123; return state.update('todos', (todos) =&gt; todos.filterNot( (item) =&gt; item.get('id') === itemId ) );&#125;export default function(state = Map(), action) &#123; switch (action.type) &#123; // ... case 'CLEAR_COMPLETED': return clearCompleted(state); case 'ADD_ITEM': return addItem(state, action.text); case 'DELETE_ITEM': return deleteItem(state, action.itemId); &#125; return state;&#125; src/components/TodoApp.jsx12345678910111213141516171819 // ...export class TodoApp extends React.Component &#123; // ... render() &#123; return &lt;div&gt; &lt;section className=\"todoapp\"&gt; // We pass down the addItem callback &lt;TodoHeader addItem=&#123;this.props.addItem&#125;/&gt; &lt;TodoList &#123;...this.props&#125; /&gt; // We pass down the clearCompleted callback &lt;TodoTools changeFilter=&#123;this.props.changeFilter&#125; filter=&#123;this.props.filter&#125; nbActiveItems=&#123;this.getNbActiveItems()&#125; clearCompleted=&#123;this.props.clearCompleted&#125;/&gt; &lt;/section&gt; &lt;Footer /&gt; &lt;/div&gt; &#125;&#125;; 我们的TodoMVC app现在完成了. 包装起来这我们的测试驱动的React,Redux&amp;Immutable 技术栈 如果你想了解更多内容,有更多的事情等着你去挖掘例如: React Redux router创建完全的单页面应用 是由Redux在后台同构Redux,看这1教程,2教程 Gambie,简单的包装器简化到API的连接 系列视频,作者是Dan Abramov(Redux的创建者) Redux 网站上更多的内容!","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"redux","slug":"redux","permalink":"https://React-Apollo.github.io/tags/redux/"},{"name":"Immutable.js","slug":"Immutable-js","permalink":"https://React-Apollo.github.io/tags/Immutable-js/"}]},{"title":"翻译|在 react-redux 中使用中间件","slug":"翻译|中间件和React Redux 生命周期","date":"2017-03-25T15:30:43.000Z","updated":"2019-04-28T05:52:57.900Z","comments":true,"path":"2017/03/25/翻译|中间件和React Redux 生命周期/","link":"","permalink":"https://React-Apollo.github.io/2017/03/25/翻译|中间件和React Redux 生命周期/","excerpt":"","text":"原文请参看. 如果你使用过类似Express.js框架构建Node.js程序,你就可能在使用中间件,并且知道他们怎么工作.Redux给前端引入同样的概念. 什么是中间件？中间件是可以被框架自动调用的函数,在框架中数据流结束之前,在数据流中加强或者改变输出.例如:如果框架里面没有中间件是这个样子的: funcA — calls→ funcB — calls→ funcC 添加了中间件以后,控制流就变为:funcA — calls→ funcB — calls→ funcMiddleWare1 — back to →funcB. funcB → then calls→ funcMiddleWare2 — back to→ funcB. funcB — finally calls→ funcC 注意：funcB最终调用funcC但是在调用funcC之前要调用两个中间件. 没有中间件的Redux生命周期让我们想看看Redux app生命周期,来更好的理解它. 场景:点击”Click Me”按钮,更新”Clicked xyz times” 文本. 场景：现在,当用户点击按钮的时候,我们想把点击的数目保存到服务器,并且在debugg中展示state的变化日志.让我们看看现在的控制流. 在Redux中,中间件函数一个接一个的被调用,直到所有的中间件被调用,然后“Action”对象呗发送到“Reducer”. 注意:这就允许中间件有修改Action对象的潜力,在最终调用Reducers之前,解析AJAX调用,还可以做其他事情比如日志.Reeucers将会更新state,在app需要的时候渲染组件. 使用中间件Redux有个巨大的社区,已经构建了大量可以完成各种任务的中间件. 所有你需要做的就是: 通过npm 安装 配置或者添加到Redux 例如：在我前面的blog：创建React Redux CRUD程序指南,app为CRUD操作做AJAX请求.在里面,我使用AXios的库来做AJAX调用.但是Axios返回一个Promise对象.但是Actions需要传递给Reducers的是一个纯粹的JSON对象.所以在在数据到达Reducers之前使用redux-promise解析Action中的Promise对象. 为了使用,首先安装. npm install — save redux-promise 再做一点配置工作: 123456789101112 import React from ‘react’;...import &#123; createStore, applyMiddleware &#125; from ‘redux’;import rp from ‘redux-promise’; // &lt;------------ MIDDLEWARE...//add middlewaresconst createStoreWithMiddleware = applyMiddleware(rp)(createStore);ReactDOM.render( &lt;Provider store=&#123;createStoreWithMiddleware(reducers)&#125;&gt; &lt;Router history=&#123;browserHistory&#125; routes=&#123;routes&#125; /&gt; &lt;/Provider&gt; , document.getElementById(‘body’)); 中间件是怎么工作的？如果你看了redux-promise,你就可以看到他是怎么工作的. 这里是伪代码: Redux调用中间件,“dispatch(函数)”,“next(函数)”和”action“JSON对象. 中间件检查”action”对象,看看是否有Promise对象 如果没有Promise对象,调用”next“函数返回到Redux. 如果这样做,他会附加上成功或者失败的回调函数,等待服务器的响应. 1234567891011121314151617181920212223//redux-promise middleware source codeimport &#123; isFSA &#125; from 'flux-standard-action';function isPromise(val) &#123; return val &amp;&amp; typeof val.then === 'function';&#125;export default function promiseMiddleware(&#123; dispatch &#125;) &#123; return next =&gt; action =&gt; &#123; if (!isFSA(action)) &#123; return isPromise(action) ? action.then(dispatch) : next(action); &#125; return isPromise(action.payload) ? action.payload.then( result =&gt; dispatch(&#123; ...action, payload: result &#125;), error =&gt; dispatch(&#123; ...action, payload: error, error: true &#125;) ) : next(action); &#125;;&#125; 更多内容请看: 官方Redux 中间件文档 中间件列表 到A Guide For Building A React Redux CRUD APP. 结束","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"redux","slug":"redux","permalink":"https://React-Apollo.github.io/tags/redux/"}]},{"title":"Immutable-collections","slug":"Immutable collections for JavaScript copy","date":"2017-03-22T00:04:10.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2017/03/22/Immutable collections for JavaScript copy/","link":"","permalink":"https://React-Apollo.github.io/2017/03/22/Immutable collections for JavaScript copy/","excerpt":"","text":"Immutable collections for JavaScript Immutable data cannot be changed once created, leading to much simplerapplication development, no defensive copying, and enabling advanced memoizationand change detection techniques with simple logic. Persistent data presentsa mutative API which does not update the data in-place, but instead alwaysyields new updated data. Immutable.js provides many Persistent Immutable data structures including:List, Stack, Map, OrderedMap, Set, OrderedSet and Record. These data structures are highly efficient on modern JavaScript VMs by usingstructural sharing via hash maps tries and vector tries as popularizedby Clojure and Scala, minimizing the need to copy or cache data. Immutable also provides a lazy Seq, allowing efficientchaining of collection methods like map and filter without creatingintermediate representations. Create some Seq with Range and Repeat. Want to hear more? Watch the presentation about Immutable.js: Getting startedInstall immutable using npm. 1npm install immutable Then require it into any module. 12345var Immutable = require('immutable');var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var map2 = map1.set('b', 50);map1.get('b'); // 2map2.get('b'); // 50 BrowserTo use immutable from a browser, download dist/immutable.min.jsor use a CDN such as CDNJSor jsDelivr. Then, add it as a script tag to your page: 1234567&lt;script src=\"immutable.min.js\"&gt;&lt;/script&gt;&lt;script&gt; var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;); var map2 = map1.set('b', 50); map1.get('b'); // 2 map2.get('b'); // 50&lt;/script&gt; Or use an AMD loader (such as RequireJS): 123456require(['./immutable.min.js'], function (Immutable) &#123; var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;); var map2 = map1.set('b', 50); map1.get('b'); // 2 map2.get('b'); // 50&#125;); If you’re using browserify, the immutable npm modulealso works from the browser. TypeScriptUse these Immutable collections and sequences as you would use nativecollections in your TypeScript programs while still takingadvantage of type generics, error detection, and auto-complete in your IDE. Just add a reference with a relative path to the type declarations at the topof your file. 1234567///&lt;reference path='./node_modules/immutable/dist/immutable.d.ts'/&gt;import Immutable = require('immutable');var map1: Immutable.Map&lt;string, number&gt;;map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var map2 = map1.set('b', 50);map1.get('b'); // 2map2.get('b'); // 50 The case for ImmutabilityMuch of what makes application development difficult is tracking mutation andmaintaining state. Developing with immutable data encourages you to thinkdifferently about how data flows through your application. Subscribing to data events throughout your application creates a huge overhead ofbook-keeping which can hurt performance, sometimes dramatically, and createsopportunities for areas of your application to get out of sync with each otherdue to easy to make programmer error. Since immutable data never changes,subscribing to changes throughout the model is a dead-end and new data can onlyever be passed from above. This model of data flow aligns well with the architecture of Reactand especially well with an application designed using the ideas of Flux. When data is passed from above rather than being subscribed to, and you’re onlyinterested in doing work when something has changed, you can use equality. Immutable collections should be treated as values rather than objects. Whileobjects represent some thing which could change over time, a value representsthe state of that thing at a particular instance of time. This principle is mostimportant to understanding the appropriate use of immutable data. In order totreat Immutable.js collections as values, it’s important to use theImmutable.is() function or .equals() method to determine value equalityinstead of the === operator which determines object reference identity. 12345var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var map2 = map1.set('b', 2);assert(map1.equals(map2) === true);var map3 = map1.set('b', 50);assert(map1.equals(map3) === false); Note: As a performance optimization Immutable attempts to return the existingcollection when an operation would result in an identical collection, allowingfor using === reference equality to determine if something definitely has notchanged. This can be extremely useful when used within a memoization functionwhich would prefer to re-run the function if a deeper equality check couldpotentially be more costly. The === equality check is also used internally byImmutable.is and .equals() as a performance optimization. If an object is immutable, it can be “copied” simply by making another referenceto it instead of copying the entire object. Because a reference is much smallerthan the object itself, this results in memory savings and a potential boost inexecution speed for programs which rely on copies (such as an undo-stack). 12var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var clone = map1; JavaScript-first APIWhile immutable is inspired by Clojure, Scala, Haskell and other functionalprogramming environments, it’s designed to bring these powerful concepts toJavaScript, and therefore has an Object-Oriented API that closely mirrors thatof ES6 Array, Map, and Set. The difference for the immutable collections is that methods which would mutatethe collection, like push, set, unshift or splice instead return a newimmutable collection. Methods which return new arrays like slice or concatinstead return new immutable collections. 123456789var list1 = Immutable.List.of(1, 2);var list2 = list1.push(3, 4, 5);var list3 = list2.unshift(0);var list4 = list1.concat(list2, list3);assert(list1.size === 2);assert(list2.size === 5);assert(list3.size === 6);assert(list4.size === 13);assert(list4.get(0) === 1); Almost all of the methods on Array will be found in similar form onImmutable.List, those of Map found on Immutable.Map, and those of Setfound on Immutable.Set, including collection operations like forEach()and map(). 123var alpha = Immutable.Map(&#123;a:1, b:2, c:3, d:4&#125;);alpha.map((v, k) =&gt; k.toUpperCase()).join();// 'A,B,C,D' Accepts raw JavaScript objects.Designed to inter-operate with your existing JavaScript, immutableaccepts plain JavaScript Arrays and Objects anywhere a method expects anIterable with no performance penalty. 12345var map1 = Immutable.Map(&#123;a:1, b:2, c:3, d:4&#125;);var map2 = Immutable.Map(&#123;c:10, a:20, t:30&#125;);var obj = &#123;d:100, o:200, g:300&#125;;var map3 = map1.merge(map2, obj);// Map &#123; a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 &#125; This is possible because immutable can treat any JavaScript Array or Objectas an Iterable. You can take advantage of this in order to get sophisticatedcollection methods on JavaScript Objects, which otherwise have a very sparsenative API. Because Seq evaluates lazily and does not cache intermediateresults, these operations can be extremely efficient. 123var myObject = &#123;a:1,b:2,c:3&#125;;Immutable.Seq(myObject).map(x =&gt; x * x).toObject();// &#123; a: 1, b: 4, c: 9 &#125; Keep in mind, when using JS objects to construct Immutable Maps, thatJavaScript Object properties are always strings, even if written in a quote-lessshorthand, while Immutable Maps accept keys of any type. 12345678var obj = &#123; 1: \"one\" &#125;;Object.keys(obj); // [ \"1\" ]obj[\"1\"]; // \"one\"obj[1]; // \"one\"var map = Immutable.fromJS(obj);map.get(\"1\"); // \"one\"map.get(1); // undefined Property access for JavaScript Objects first converts the key to a string, butsince Immutable Map keys can be of any type the argument to get() isnot altered. Converts back to raw JavaScript objects.All immutable Iterables can be converted to plain JavaScript Arrays andObjects shallowly with toArray() and toObject() or deeply with toJS().All Immutable Iterables also implement toJSON() allowing them to be passed toJSON.stringify directly. 12345var deep = Immutable.Map(&#123; a: 1, b: 2, c: Immutable.List.of(3, 4, 5) &#125;);deep.toObject() // &#123; a: 1, b: 2, c: List [ 3, 4, 5 ] &#125;deep.toArray() // [ 1, 2, List [ 3, 4, 5 ] ]deep.toJS() // &#123; a: 1, b: 2, c: [ 3, 4, 5 ] &#125;JSON.stringify(deep) // '&#123;\"a\":1,\"b\":2,\"c\":[3,4,5]&#125;' Embraces ES6Immutable takes advantage of features added to JavaScript in ES6,the latest standard version of ECMAScript (JavaScript), including Iterators,Arrow Functions, Classes, and Modules. It’s also inspired by theMap and Set collections added to ES6. The library is “transpiled” to ES3in order to support all modern browsers. All examples are presented in ES6. To run in all browsers, they need to betranslated to ES3. 1234// ES6foo.map(x =&gt; x * x);// ES3foo.map(function (x) &#123; return x * x; &#125;); Nested StructuresThe collections in immutable are intended to be nested, allowing for deeptrees of data, similar to JSON. 12var nested = Immutable.fromJS(&#123;a:&#123;b:&#123;c:[3,4,5]&#125;&#125;&#125;);// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5 ] &#125; &#125; &#125; A few power-tools allow for reading and operating on nested data. Themost useful are mergeDeep, getIn, setIn, and updateIn, found on List,Map and OrderedMap. 12345678910var nested2 = nested.mergeDeep(&#123;a:&#123;b:&#123;d:6&#125;&#125;&#125;);// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5 ], d: 6 &#125; &#125; &#125;nested2.getIn(['a', 'b', 'd']); // 6var nested3 = nested2.updateIn(['a', 'b', 'd'], value =&gt; value + 1);// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5 ], d: 7 &#125; &#125; &#125;var nested4 = nested3.updateIn(['a', 'b', 'c'], list =&gt; list.push(6));// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5, 6 ], d: 7 &#125; &#125; &#125; Lazy SeqSeq describes a lazy operation, allowing them to efficiently chainuse of all the Iterable methods (such as map and filter). Seq is immutable — Once a Seq is created, it cannot bechanged, appended to, rearranged or otherwise modified. Instead, any mutativemethod called on a Seq will return a new Seq. Seq is lazy — Seq does as little work as necessary to respond to anymethod call. For example, the following does not perform any work, because the resultingSeq is never used: var oddSquares = Immutable.Seq.of(1,2,3,4,5,6,7,8) .filter(x =&gt; x % 2).map(x =&gt; x * x); Once the Seq is used, it performs only the work necessary. In thisexample, no intermediate arrays are ever created, filter is called three times,and map is only called once: console.log(oddSquares.get(1)); // 9 Any collection can be converted to a lazy Seq with .toSeq(). var seq = Immutable.Map({a:1, b:1, c:1}).toSeq(); Seq allows for the efficient chaining of sequence operations, especially whenconverting to a different concrete type (such as to a JS object): seq.flip().map(key =&gt; key.toUpperCase()).flip().toObject(); // { A: 1, B: 1, C: 1 } As well as expressing logic that would otherwise seem memory-limited: Immutable.Range(1, Infinity) .skip(1000) .map(n =&gt; -n) .filter(n =&gt; n % 2 === 0) .take(2) .reduce((r, n) =&gt; r * n, 1); // 1006008 Note: An iterable is always iterated in the same order, however that order maynot always be well defined, as is the case for the Map. Equality treats Collections as DataImmutable provides equality which treats immutable data structures as puredata, performing a deep equality check if necessary. 12345var map1 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);var map2 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);assert(map1 !== map2); // two different instancesassert(Immutable.is(map1, map2)); // have equivalent valuesassert(map1.equals(map2)); // alternatively use the equals method Immutable.is() uses the same measure of equality as Object.isincluding if both are immutable and all keys and values are equalusing the same measure of equality. Batching Mutations If a tree falls in the woods, does it make a sound? If a pure function mutates some local data in order to produce an immutablereturn value, is that ok? — Rich Hickey, Clojure Applying a mutation to create a new immutable object results in some overhead,which can add up to a minor performance penalty. If you need to apply a seriesof mutations locally before returning, Immutable gives you the ability tocreate a temporary mutable (transient) copy of a collection and apply a batch ofmutations in a performant manner by using withMutations. In fact, this isexactly how Immutable applies complex mutations itself. As an example, building list2 results in the creation of 1, not 3, newimmutable Lists. 123456var list1 = Immutable.List.of(1,2,3);var list2 = list1.withMutations(function (list) &#123; list.push(4).push(5).push(6);&#125;);assert(list1.size === 3);assert(list2.size === 6); Note: immutable also provides asMutable and asImmutable, but onlyencourages their use when withMutations will not suffice. Use caution to notreturn a mutable copy, which could result in undesired behavior. Important!: Only a select few methods can be used in withMutations includingset, push and pop. These methods can be applied directly against apersistent data-structure where other methods like map, filter, sort,and splice will always return new immutable data-structures and never mutatea mutable collection. DocumentationRead the docs and eat your vegetables. Docs are automatically generated from Immutable.d.ts.Please contribute! Also, don’t miss the Wiki whichcontains articles on specific topics. Can’t find something? Open an issue. TestingIf you are using the Chai Assertion Library, Chai Immutable provides a set of assertions to use against Immutable collections. ContributionUse Github issues for requests. We actively welcome pull requests, learn how to contribute. ChangelogChanges are tracked as Github releases. ThanksPhil Bagwell, for his inspirationand research in persistent data structures. Hugh Jackson, for providing the npm packagename. If you’re looking for his unsupported package, see this repository. LicenseImmutable is BSD-licensed. We also provide an additional patent grant.","categories":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/categories/Redux/"}],"tags":[{"name":"react","slug":"react","permalink":"https://React-Apollo.github.io/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"https://React-Apollo.github.io/tags/javascript/"}]},{"title":"Immutable-collections","slug":"Immutable collections for JavaScript","date":"2017-03-22T00:04:10.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2017/03/22/Immutable collections for JavaScript/","link":"","permalink":"https://React-Apollo.github.io/2017/03/22/Immutable collections for JavaScript/","excerpt":"","text":"Immutable collections for JavaScript Immutable data cannot be changed once created, leading to much simplerapplication development, no defensive copying, and enabling advanced memoizationand change detection techniques with simple logic. Persistent data presentsa mutative API which does not update the data in-place, but instead alwaysyields new updated data. Immutable.js provides many Persistent Immutable data structures including:List, Stack, Map, OrderedMap, Set, OrderedSet and Record. These data structures are highly efficient on modern JavaScript VMs by usingstructural sharing via hash maps tries and vector tries as popularizedby Clojure and Scala, minimizing the need to copy or cache data. Immutable also provides a lazy Seq, allowing efficientchaining of collection methods like map and filter without creatingintermediate representations. Create some Seq with Range and Repeat. Want to hear more? Watch the presentation about Immutable.js: Getting startedInstall immutable using npm. 1npm install immutable Then require it into any module. 12345var Immutable = require('immutable');var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var map2 = map1.set('b', 50);map1.get('b'); // 2map2.get('b'); // 50 BrowserTo use immutable from a browser, download dist/immutable.min.jsor use a CDN such as CDNJSor jsDelivr. Then, add it as a script tag to your page: 1234567&lt;script src=\"immutable.min.js\"&gt;&lt;/script&gt;&lt;script&gt; var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;); var map2 = map1.set('b', 50); map1.get('b'); // 2 map2.get('b'); // 50&lt;/script&gt; Or use an AMD loader (such as RequireJS): 123456require(['./immutable.min.js'], function (Immutable) &#123; var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;); var map2 = map1.set('b', 50); map1.get('b'); // 2 map2.get('b'); // 50&#125;); If you’re using browserify, the immutable npm modulealso works from the browser. TypeScriptUse these Immutable collections and sequences as you would use nativecollections in your TypeScript programs while still takingadvantage of type generics, error detection, and auto-complete in your IDE. Just add a reference with a relative path to the type declarations at the topof your file. 1234567///&lt;reference path='./node_modules/immutable/dist/immutable.d.ts'/&gt;import Immutable = require('immutable');var map1: Immutable.Map&lt;string, number&gt;;map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var map2 = map1.set('b', 50);map1.get('b'); // 2map2.get('b'); // 50 The case for ImmutabilityMuch of what makes application development difficult is tracking mutation andmaintaining state. Developing with immutable data encourages you to thinkdifferently about how data flows through your application. Subscribing to data events throughout your application creates a huge overhead ofbook-keeping which can hurt performance, sometimes dramatically, and createsopportunities for areas of your application to get out of sync with each otherdue to easy to make programmer error. Since immutable data never changes,subscribing to changes throughout the model is a dead-end and new data can onlyever be passed from above. This model of data flow aligns well with the architecture of Reactand especially well with an application designed using the ideas of Flux. When data is passed from above rather than being subscribed to, and you’re onlyinterested in doing work when something has changed, you can use equality. Immutable collections should be treated as values rather than objects. Whileobjects represent some thing which could change over time, a value representsthe state of that thing at a particular instance of time. This principle is mostimportant to understanding the appropriate use of immutable data. In order totreat Immutable.js collections as values, it’s important to use theImmutable.is() function or .equals() method to determine value equalityinstead of the === operator which determines object reference identity. 12345var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var map2 = map1.set('b', 2);assert(map1.equals(map2) === true);var map3 = map1.set('b', 50);assert(map1.equals(map3) === false); Note: As a performance optimization Immutable attempts to return the existingcollection when an operation would result in an identical collection, allowingfor using === reference equality to determine if something definitely has notchanged. This can be extremely useful when used within a memoization functionwhich would prefer to re-run the function if a deeper equality check couldpotentially be more costly. The === equality check is also used internally byImmutable.is and .equals() as a performance optimization. If an object is immutable, it can be “copied” simply by making another referenceto it instead of copying the entire object. Because a reference is much smallerthan the object itself, this results in memory savings and a potential boost inexecution speed for programs which rely on copies (such as an undo-stack). 12var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var clone = map1; JavaScript-first APIWhile immutable is inspired by Clojure, Scala, Haskell and other functionalprogramming environments, it’s designed to bring these powerful concepts toJavaScript, and therefore has an Object-Oriented API that closely mirrors thatof ES6 Array, Map, and Set. The difference for the immutable collections is that methods which would mutatethe collection, like push, set, unshift or splice instead return a newimmutable collection. Methods which return new arrays like slice or concatinstead return new immutable collections. 123456789var list1 = Immutable.List.of(1, 2);var list2 = list1.push(3, 4, 5);var list3 = list2.unshift(0);var list4 = list1.concat(list2, list3);assert(list1.size === 2);assert(list2.size === 5);assert(list3.size === 6);assert(list4.size === 13);assert(list4.get(0) === 1); Almost all of the methods on Array will be found in similar form onImmutable.List, those of Map found on Immutable.Map, and those of Setfound on Immutable.Set, including collection operations like forEach()and map(). 123var alpha = Immutable.Map(&#123;a:1, b:2, c:3, d:4&#125;);alpha.map((v, k) =&gt; k.toUpperCase()).join();// 'A,B,C,D' Accepts raw JavaScript objects.Designed to inter-operate with your existing JavaScript, immutableaccepts plain JavaScript Arrays and Objects anywhere a method expects anIterable with no performance penalty. 12345var map1 = Immutable.Map(&#123;a:1, b:2, c:3, d:4&#125;);var map2 = Immutable.Map(&#123;c:10, a:20, t:30&#125;);var obj = &#123;d:100, o:200, g:300&#125;;var map3 = map1.merge(map2, obj);// Map &#123; a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 &#125; This is possible because immutable can treat any JavaScript Array or Objectas an Iterable. You can take advantage of this in order to get sophisticatedcollection methods on JavaScript Objects, which otherwise have a very sparsenative API. Because Seq evaluates lazily and does not cache intermediateresults, these operations can be extremely efficient. 123var myObject = &#123;a:1,b:2,c:3&#125;;Immutable.Seq(myObject).map(x =&gt; x * x).toObject();// &#123; a: 1, b: 4, c: 9 &#125; Keep in mind, when using JS objects to construct Immutable Maps, thatJavaScript Object properties are always strings, even if written in a quote-lessshorthand, while Immutable Maps accept keys of any type. 12345678var obj = &#123; 1: \"one\" &#125;;Object.keys(obj); // [ \"1\" ]obj[\"1\"]; // \"one\"obj[1]; // \"one\"var map = Immutable.fromJS(obj);map.get(\"1\"); // \"one\"map.get(1); // undefined Property access for JavaScript Objects first converts the key to a string, butsince Immutable Map keys can be of any type the argument to get() isnot altered. Converts back to raw JavaScript objects.All immutable Iterables can be converted to plain JavaScript Arrays andObjects shallowly with toArray() and toObject() or deeply with toJS().All Immutable Iterables also implement toJSON() allowing them to be passed toJSON.stringify directly. 12345var deep = Immutable.Map(&#123; a: 1, b: 2, c: Immutable.List.of(3, 4, 5) &#125;);deep.toObject() // &#123; a: 1, b: 2, c: List [ 3, 4, 5 ] &#125;deep.toArray() // [ 1, 2, List [ 3, 4, 5 ] ]deep.toJS() // &#123; a: 1, b: 2, c: [ 3, 4, 5 ] &#125;JSON.stringify(deep) // '&#123;\"a\":1,\"b\":2,\"c\":[3,4,5]&#125;' Embraces ES6Immutable takes advantage of features added to JavaScript in ES6,the latest standard version of ECMAScript (JavaScript), including Iterators,Arrow Functions, Classes, and Modules. It’s also inspired by theMap and Set collections added to ES6. The library is “transpiled” to ES3in order to support all modern browsers. All examples are presented in ES6. To run in all browsers, they need to betranslated to ES3. 1234// ES6foo.map(x =&gt; x * x);// ES3foo.map(function (x) &#123; return x * x; &#125;); Nested StructuresThe collections in immutable are intended to be nested, allowing for deeptrees of data, similar to JSON. 12var nested = Immutable.fromJS(&#123;a:&#123;b:&#123;c:[3,4,5]&#125;&#125;&#125;);// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5 ] &#125; &#125; &#125; A few power-tools allow for reading and operating on nested data. Themost useful are mergeDeep, getIn, setIn, and updateIn, found on List,Map and OrderedMap. 12345678910var nested2 = nested.mergeDeep(&#123;a:&#123;b:&#123;d:6&#125;&#125;&#125;);// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5 ], d: 6 &#125; &#125; &#125;nested2.getIn(['a', 'b', 'd']); // 6var nested3 = nested2.updateIn(['a', 'b', 'd'], value =&gt; value + 1);// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5 ], d: 7 &#125; &#125; &#125;var nested4 = nested3.updateIn(['a', 'b', 'c'], list =&gt; list.push(6));// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5, 6 ], d: 7 &#125; &#125; &#125; Lazy SeqSeq describes a lazy operation, allowing them to efficiently chainuse of all the Iterable methods (such as map and filter). Seq is immutable — Once a Seq is created, it cannot bechanged, appended to, rearranged or otherwise modified. Instead, any mutativemethod called on a Seq will return a new Seq. Seq is lazy — Seq does as little work as necessary to respond to anymethod call. For example, the following does not perform any work, because the resultingSeq is never used: var oddSquares = Immutable.Seq.of(1,2,3,4,5,6,7,8) .filter(x =&gt; x % 2).map(x =&gt; x * x); Once the Seq is used, it performs only the work necessary. In thisexample, no intermediate arrays are ever created, filter is called three times,and map is only called once: console.log(oddSquares.get(1)); // 9 Any collection can be converted to a lazy Seq with .toSeq(). var seq = Immutable.Map({a:1, b:1, c:1}).toSeq(); Seq allows for the efficient chaining of sequence operations, especially whenconverting to a different concrete type (such as to a JS object): seq.flip().map(key =&gt; key.toUpperCase()).flip().toObject(); // { A: 1, B: 1, C: 1 } As well as expressing logic that would otherwise seem memory-limited: Immutable.Range(1, Infinity) .skip(1000) .map(n =&gt; -n) .filter(n =&gt; n % 2 === 0) .take(2) .reduce((r, n) =&gt; r * n, 1); // 1006008 Note: An iterable is always iterated in the same order, however that order maynot always be well defined, as is the case for the Map. Equality treats Collections as DataImmutable provides equality which treats immutable data structures as puredata, performing a deep equality check if necessary. 12345var map1 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);var map2 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);assert(map1 !== map2); // two different instancesassert(Immutable.is(map1, map2)); // have equivalent valuesassert(map1.equals(map2)); // alternatively use the equals method Immutable.is() uses the same measure of equality as Object.isincluding if both are immutable and all keys and values are equalusing the same measure of equality. Batching Mutations If a tree falls in the woods, does it make a sound? If a pure function mutates some local data in order to produce an immutablereturn value, is that ok? — Rich Hickey, Clojure Applying a mutation to create a new immutable object results in some overhead,which can add up to a minor performance penalty. If you need to apply a seriesof mutations locally before returning, Immutable gives you the ability tocreate a temporary mutable (transient) copy of a collection and apply a batch ofmutations in a performant manner by using withMutations. In fact, this isexactly how Immutable applies complex mutations itself. As an example, building list2 results in the creation of 1, not 3, newimmutable Lists. 123456var list1 = Immutable.List.of(1,2,3);var list2 = list1.withMutations(function (list) &#123; list.push(4).push(5).push(6);&#125;);assert(list1.size === 3);assert(list2.size === 6); Note: immutable also provides asMutable and asImmutable, but onlyencourages their use when withMutations will not suffice. Use caution to notreturn a mutable copy, which could result in undesired behavior. Important!: Only a select few methods can be used in withMutations includingset, push and pop. These methods can be applied directly against apersistent data-structure where other methods like map, filter, sort,and splice will always return new immutable data-structures and never mutatea mutable collection. DocumentationRead the docs and eat your vegetables. Docs are automatically generated from Immutable.d.ts.Please contribute! Also, don’t miss the Wiki whichcontains articles on specific topics. Can’t find something? Open an issue. TestingIf you are using the Chai Assertion Library, Chai Immutable provides a set of assertions to use against Immutable collections. ContributionUse Github issues for requests. We actively welcome pull requests, learn how to contribute. ChangelogChanges are tracked as Github releases. ThanksPhil Bagwell, for his inspirationand research in persistent data structures. Hugh Jackson, for providing the npm packagename. If you’re looking for his unsupported package, see this repository. LicenseImmutable is BSD-licensed. We also provide an additional patent grant.","categories":[{"name":"Readme","slug":"Readme","permalink":"https://React-Apollo.github.io/categories/Readme/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://React-Apollo.github.io/tags/javascript/"}]},{"title":"翻译|开启React,Redux和Immutable之旅:测试驱动教程(part1)","slug":"Translation|Getting Started with React, Redux and Immutable- a Test-Driven Tutorial (Part 1)","date":"2017-03-15T14:59:17.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2017/03/15/Translation|Getting Started with React, Redux and Immutable- a Test-Driven Tutorial (Part 1)/","link":"","permalink":"https://React-Apollo.github.io/2017/03/15/Translation|Getting Started with React, Redux and Immutable- a Test-Driven Tutorial (Part 1)/","excerpt":"","text":"翻译版本,原文请见,第一部分,第二部分 几周以前,我正在漫无目的的浏览Hacker News,读到一篇关于Redux的头条新闻,Redux的内容我是了解,但是另一个谈到的问题javascript fatigue(JavaScript 疲劳)已经困扰我了,所以我没有太关心,知道读到Redux的几个特征. 强化了函数式编程,确保app行为的可预测性 允许app的同构,客户端和服务端的大多数逻辑都可以共享 时间旅行的debugger?有可能吗？ Redux似乎是React程序state管理的优雅方法,再者谁说的时间旅行不可能？所以我读了文档和一篇非常精彩的教程@teropa:A Comprehensive Guide to Test-First Development with Redux,React,and Immutable(这一篇也是我写作的主要灵感来源). 我喜欢Redux,代码非常优雅,debugger令人疯狂的伟大.我的意思是-看看这个 接下来的教程第一部分希望引导你理解Redux运行的原则.教程的目的仅限于(客户端,没有同构,是比较简单的app)保持教程的简明扼要.如果你想发掘的更深一点,我仅建议你阅读上面提高的那个教程.对比版的Github repo在这里,共享代码贴合教程的步骤.如果你对代码或者教程有任何问题和建议,最好能留下留言. 编辑按:文章已经更新为ES2015版的句法. APP为了符合教程的目的,我们将建一个经典的TodoMVC,为了记录需要,需求如下： 每一个todo可以激活或者完成 可以添加,编辑,删除一个todo 可以根据它的status来过滤筛选todos 激活的todos的数目显示在底部 完成的Todo理解可以删除 Reudux和Immutable：使用函数编程去营救回到几个月前,我正在开发一个webapp包含仪表板. 随着app的成长,我们注意到越来越多的有害的bugs,藏在代码角落里,很难发现.类似:“如果你要导航到这一页,点击按钮,然后回到主页,喝一杯咖啡,回到这一页然后点击两次,奇怪的事情发生了.”这些bug的来源要么是异步操作(side effects)或者逻辑:一个action可能在app中有意想不到的影响,这个有时候我们还发现不了. 这就是Redux之所以存在的威力:整个app的state是一个单一的数据结构,state tree.这一点意思是说：在任何时刻,展示给用户的内容仅仅是state tree结果,这就是单一来源的真相(用户界面的显示内容是由state tree来决定的).每一个action接收state,应用相应的修改(例如,添加一个todo),输出更新的state tree.更新的结果渲染展示给用户.里面没有模糊的异步操作,没有变量的引用引起的不经意的修改.这个步骤使得app有了更好的结构,分离关注点,dubugging也更好用了. Immutable是有Facebook开发的助手函数库,提供一些工具去创建和操作immutable数据结构.尽管在Redux也不是一定要使用它,但是它通过禁止对象的修改,强化了函数式编程方法.有了immutable,当我们想更新一个对象,实际上我们修改的是一个新创建的的对象,原先的对象保持不变. 这里是“Immutable文档”里面的例子: 12345 var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var map2 = map1.set('b', 2);assert(map1 === map2); // no changevar map3 = map1.set('b', 50);assert(map1 !== map3); // change 我们更新了map1的一个值,map1对象保持不变,一个新的对象map3被创建了. Immutable在store中被用来储存我们的app的state tree.很快我们会看到Immutable提供了一下操作对象的简单和有效的方法. 配置项目声明:一些配置有@terops的教程启发. 注意事项:推荐使用Node.js&gt;=4.0.0.你可以使用nvm(node version manager)来切换不同的node.js的版本. 这里是比较版本的提交 开始配置项目: 123mkdir redux-todomvccd redux-todomvcnpm init -y 项目的目录结构如下: 12345678├── dist│ ├── bundle.js│ └── index.html├── node_modules├── package.json├── src├── test└── webpack.config.js 首先创建一个简单的HTML页面,用来运行我们的appdist/index.html1234567891011 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;React TodoMVC&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 有了这个文件,我们写一个简单的脚本文件看看包安装的情况src/index.js 1console.log('Hello world !'); 我们将会使用[Webpack]来打包成为bundle.js文件.Webpack的特性是速度,容易配置,大部分是热更新的.代码的更新不需要重新加载,意味着app的state保持热加载. 让我们安装webpack: npm install —save-dev webpack@1.12.14 webpack-dev-server@1.14.1 app使用ES2015的语法,带来一些优异的特性和一些语法糖.如果你想了解更多的ES2015内容,这个recap是一个不错的资源. Babel用来把ES2015的语法改变为普通的JS语法:npm install —save-dev babel-core@6.5.2 babel-loader@6.2.4 babel-preset-es2015@6.5.0 我们将使用JSX语法编写React组件,所以让我们安装Babel React package：npm install —save-dev babel-preset-react@6.5.0 配置webpack输出源文件:package.json123 \"babel\": &#123; \"presets\": [\"es2015\", \"react\"]&#125; webpack.config.js 1234567891011121314151617181920212223 module.exports = &#123; entry: [ './src/index.js' ], module: &#123; loaders: [&#123; test: /\\.jsx?$/, exclude: /node_modules/, loader: 'babel' &#125;] &#125;, resolve: &#123; extensions: ['', '.js', '.jsx'] &#125;, output: &#123; path: __dirname + '/dist', publicPath: '/', filename: 'bundle.js' &#125;, devServer: &#123; contentBase: './dist' &#125;&#125;; 现在添加React和React热加载组件到项目中:12npm install --save react@0.14.7 react-dom@0.14.7npm install --save-dev react-hot-loader@1.3.0 为了让热加载能运行,webpack.config.js文件中要做一些修改. webpack.config.js12345678910111213141516171819202122232425262728293031 var webpack = require('webpack'); // Requiring the webpack libmodule.exports = &#123; entry: [ 'webpack-dev-server/client?http://localhost:8080', // Setting the URL for the hot reload 'webpack/hot/only-dev-server', // Reload only the dev server './src/index.js' ], module: &#123; loaders: [&#123; test: /\\.jsx?$/, exclude: /node_modules/, loader: 'react-hot!babel' // Include the react-hot loader &#125;] &#125;, resolve: &#123; extensions: ['', '.js', '.jsx'] &#125;, output: &#123; path: __dirname + '/dist', publicPath: '/', filename: 'bundle.js' &#125;, devServer: &#123; contentBase: './dist', hot: true // Activate hot loading &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() // Wire in the hot loading plugin ]&#125;; 配置单元测试框架我们将使用Mocha和Chai来进行测试工作.这两个工具广泛的被使用,他们的输出内容对于测试驱动开发非常的好.Chai-immutable是一个chai插件,用来处理immutable数据结构. 12npm install --save immutable@3.7.6npm install --save-dev mocha@2.4.5 chai@3.5.0 chai-immutable@1.5.3 在我们的例子中,我们不会依赖浏览器为基础的测试运行器例如Karma-替代方案是我们使用jsdom库,它将会使用纯javascirpt创建一个假DOM,这样做让我们的测试更加快速. npm install —save-dev jsdom@8.0.4 我们也需要为测试写一个启动脚本,要考虑到下面的内容. 模拟document和window对象,通常是由浏览器提供 通过chia-immutable告诉chai组件我们要使用immutable数据结构 test/setup.js 1234567891011121314151617 import jsdom from 'jsdom';import chai from 'chai';import chaiImmutable from 'chai-immutable';const doc = jsdom.jsdom('&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;');const win = doc.defaultView;global.document = doc;global.window = win;Object.keys(window).forEach((key) =&gt; &#123; if (!(key in global)) &#123; global[key] = window[key]; &#125;&#125;);chai.use(chaiImmutable); 更新一下npm test脚本package.json1234 \"scripts\": &#123; \"test\": \"mocha --compilers js:babel-core/register --require ./test/setup.js 'test/**/*.@(js|jsx)'\", \"test:watch\": \"npm run test -- --watch --watch-extensions jsx\"&#125;, npm run test:watch命令在windows操作系统下似乎不能工作. 现在,如果我们运行npm run test:watch,所有test目录里的.js,.jsx文件在更新自身或者源文件的时候,将会运行mocha测试. 配置完成了：我们可以在终端中运行webpack-dev-server,打开另一个终端,npm run test:watch.在浏览器中打开localhost:8080.检查hello world!是否出现在终端中. 构建state tree之前提到过,state tree是能提供app所有信息的数据结构.这个结构需要在实际开发之前经过深思熟虑,因为它将影响一些代码的结构和交互作用. 作为示例,我们app是一个TODO list由几个条目组合而成 每一个条目有一个文本,为了便于操作,设一个id,此外每个item有两个状态之一:活动或者完成：最后一个条目需要一个可编辑的状态(当用户想编辑的文本的时候),所以我们需要保持下面的数据结构: 也有可能基于他们的状态进行筛选,所以我们天剑filter条目来获取最终的state tree: 创建UI首先我们把app分解为下面的组件: TodoHeader组件是创建新todo的输入组件 TodoList组件是todo的列表 todoItem是一个todo todoInput是编辑todo的输入框 TodoTools是显示未完成的条目数量,过滤器和清除完成的按钮 footer是显示信息的,没有具体的逻辑 我们也创建TodoApp组件组织所有的其他组件. 首次运行我们的组件 提示:运行这个版本 正如我们所见的,我们将会把所有组件放到合并成一个TodoApp组件.所以让我们添加组件到index.html文件的#appDIV中:src/index.jsx 12345678910111213141516import React from 'react';import ReactDOM from 'react-dom';import &#123;List, Map&#125; from 'immutable';import TodoApp from './components/TodoApp';const todos = List.of( Map(&#123;id: 1, text: 'React', status: 'active', editing: false&#125;), Map(&#123;id: 2, text: 'Redux', status: 'active', editing: false&#125;), Map(&#123;id: 3, text: 'Immutable', status: 'completed', editing: false&#125;));ReactDOM.render( &lt;TodoApp todos=&#123;todos&#125; /&gt;, document.getElementById('app')); 因为我们在index.jsx文件中使用JSX语法,需要在wabpack中扩展.jsx.修改如下:webpack.config.js12345 entry: [ 'webpack-dev-server/client?http://localhost:8080', 'webpack/hot/only-dev-server', './src/index.jsx' // Change the index file extension], 编写todo list UI现在我们编写第一版本的TodoApp组件,用来显示todo项目列表:src/components/TodoApp.jsx1234567891011121314151617181920212223242526272829 import React from 'react';export default class TodoApp extends React.Component &#123; getItems() &#123; return this.props.todos || []; &#125; render() &#123; return &lt;div&gt; &lt;section className=\"todoapp\"&gt; &lt;section className=\"main\"&gt; &lt;ul className=\"todo-list\"&gt; &#123;this.getItems().map(item =&gt; &lt;li className=\"active\" key=&#123;item.get('text')&#125;&gt; &lt;div className=\"view\"&gt; &lt;input type=\"checkbox\" className=\"toggle\" /&gt; &lt;label htmlFor=\"todo\"&gt; &#123;item.get('text')&#125; &lt;/label&gt; &lt;button className=\"destroy\"&gt;&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; )&#125; &lt;/ul&gt; &lt;/section&gt; &lt;/section&gt; &lt;/div&gt; &#125;&#125;; 要记住两件事情:第一个,如果你看到的结果不太好,修复它,我们将会使用todomvc-app-css包来补充一些需要的样式12npm install --save todomvc-app-css@2.0.4npm install style-loader@0.13.0 css-loader@0.23.1 --save-dev 我们需要告诉webpack去加载css 样式文件:webpack.config.js123456789101112// ...module: &#123; loaders: [&#123; test: /\\.jsx?$/, exclude: /node_modules/, loader: 'react-hot!babel' &#125;, &#123; test: /\\.css$/, loader: 'style!css' // We add the css loader &#125;]&#125;,//... 然后在inde.jsx文件中添加样式:src/index.jsx1234567 // ...require('../node_modules/todomvc-app-css/index.css');ReactDOM.render( &lt;TodoApp todos=&#123;todos&#125; /&gt;, document.getElementById('app')); 第二件事是:代码似乎很复杂,这就是我们为什么要创建两个或者多个组件的原因:TodoList和TodoItem将会分别关注条目列表和单个的条目. 这一部分的提交代码 src/components/TodoApp.jsx123456789101112 import React from 'react';import TodoList from './TodoList'export default class TodoApp extends React.Component &#123; render() &#123; return &lt;div&gt; &lt;section className=\"todoapp\"&gt; &lt;TodoList todos=&#123;this.props.todos&#125; /&gt; &lt;/section&gt; &lt;/div&gt; &#125;&#125;; 在TodoList组件中根据获取的props为每一个条目显示一个TodoItem组件. src/components/TodoList.jsx123456789101112131415 import React from 'react';import TodoItem from './TodoItem';export default class TodoList extends React.Component &#123; render() &#123; return &lt;section className=\"main\"&gt; &lt;ul className=\"todo-list\"&gt; &#123;this.props.todos.map(item =&gt; &lt;TodoItem key=&#123;item.get('text')&#125; text=&#123;item.get('text')&#125; /&gt; )&#125; &lt;/ul&gt; &lt;/section&gt; &#125;&#125;; src/components/TodoItem.jsx12345678910111213141516 import React from 'react';export default class TodoItem extends React.Component &#123; render() &#123; return &lt;li className=\"todo\"&gt; &lt;div className=\"view\"&gt; &lt;input type=\"checkbox\" className=\"toggle\" /&gt; &lt;label htmlFor=\"todo\"&gt; &#123;this.props.text&#125; &lt;/label&gt; &lt;button className=\"destroy\"&gt;&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &#125;&#125;; 在我们深入用户的交互操作之前,我们先在组件TodoItem中添加一个input用于编辑src/componensts/TodoItem.jsx1234567891011121314151617181920 import React from 'react';import TextInput from './TextInput';export default class TodoItem extends React.Component &#123; render() &#123; return &lt;li className=\"todo\"&gt; &lt;div className=\"view\"&gt; &lt;input type=\"checkbox\" className=\"toggle\" /&gt; &lt;label htmlFor=\"todo\"&gt; &#123;this.props.text&#125; &lt;/label&gt; &lt;button className=\"destroy\"&gt;&lt;/button&gt; &lt;/div&gt; &lt;TextInput /&gt; // We add the TextInput component &lt;/li&gt; &#125;&#125;; TextInput组件如下src/compoents/TextInput.jsx123456789import React from 'react';export default class TextInput extends React.Component &#123; render() &#123; return &lt;input className=\"edit\" autoFocus=&#123;true&#125; type=\"text\" /&gt; &#125;&#125;; ”纯“组件的好处：PureRenderMixin这部分的提交代码 除了允许函数式编程的样式,我们的UI是单纯的,可以使用PureRenderMixin来提升速度,正如React 文档:如果你的React的组件渲染函数是”纯“(换句话就是,如果使用相同的porps和state,总是会渲染出同样的结果),你可以使用mixin在同一个案例转给你来提升性能. 正如React文档(我们也会在第二部分看到TodoApp组件有额外的角色会阻止PureRenderMixin的使用)展示的mixin也非常容易的添加到我们的子组件中:npm install --save react-addons-pure-render-mixin@0.14.7src/components/TodoList.jsc 12345678910111213 import React from 'react';import PureRenderMixin from 'react-addons-pure-render-mixin'import TodoItem from './TodoItem';export default class TodoList extends React.Component &#123; constructor(props) &#123; super(props); this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this); &#125; render() &#123; // ... &#125;&#125;; src/components/TodoItem/jsx12345678910111213import React from 'react';import PureRenderMixin from 'react-addons-pure-render-mixin'import TextInput from './TextInput';export default class TodoItem extends React.Component &#123; constructor(props) &#123; super(props); this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this); &#125; render() &#123; // ... &#125;&#125;; src/components/TextInput.jsx123456789101112import React from 'react';import PureRenderMixin from 'react-addons-pure-render-mixin'export default class TextInput extends React.Component &#123; constructor(props) &#123; super(props); this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this); &#125; render() &#123; // ... &#125;&#125;; 在list组件中处理用户的actions好了,现在我们配置好了list组件.然而我们没有考虑添加用户的actions和怎么添加进去组件. props的力量在React中,props对象是当我们实例化一个容器(container)的时候,通过设定的attributes来设定.例如,如果我们实例化一个TodoItem元素:1&lt;TodoItem text=&#123;'Text of the item'&#125; /&gt; 然后我们在TodoItem组件中获取this.props.text变量:123 // in TodoItem.jsxconsole.log(this.props.text);// outputs 'Text of the item' Redux构架中强化使用props.基础的原理是state几乎都存在于他的props里面.换一种说法：对于同样一组props,两个元素的实例应该输出完全一样的结果.正如之前我们看到的,整个app的state都包含在一个state tree中:意思是说,state tree 如果通过props的方式传递到组件,将会完整和可预期的决定app的视觉输出. TodoList组件这一部分的代码修改 在这一部分和接下来的一部分,我们将会了解一个测试优先的方法. 为了帮助我们测试组件,React库提供了TestUtils工具插件,有一下方法: renderIntoDocument,渲染组件到附加的DOM节点 scryRenderDOMComponentsWIthTag,使用提供的标签(例如li,input)在DOM中找到所有的组件实例. scryRederDOMComponentsWithClass,同上使用的是类 Simulate,模拟用户的actions(例如 点击,按键,文本输入…) TestUtils插件没有包含在react包中,所以需要单独安装npm install --save-dev react-addons-test-utils@0.14.7 我们的第一个测试将确保Todolist组件中,如果filterprops被设置为active,将会展示所有的活动条目: test/components/TodoList_spec.jsx 123456789101112131415161718192021222324252627 import React from 'react';import TestUtils from 'react-addons-test-utils';import TodoList from '../../src/components/TodoList';import &#123;expect&#125; from 'chai';import &#123;List, Map&#125; from 'immutable';const &#123;renderIntoDocument, scryRenderedDOMComponentsWithTag&#125; = TestUtils;describe('TodoList', () =&gt; &#123; it('renders a list with only the active items if the filter is active', () =&gt; &#123; const todos = List.of( Map(&#123;id: 1, text: 'React', status: 'active'&#125;), Map(&#123;id: 2, text: 'Redux', status: 'active'&#125;), Map(&#123;id: 3, text: 'Immutable', status: 'completed'&#125;) ); const filter = 'active'; const component = renderIntoDocument( &lt;TodoList filter=&#123;filter&#125; todos=&#123;todos&#125; /&gt; ); const items = scryRenderedDOMComponentsWithTag(component, 'li'); expect(items.length).to.equal(2); expect(items[0].textContent).to.contain('React'); expect(items[1].textContent).to.contain('Redux'); &#125;);&#125;); 我们可以看到测试失败了,期待的是两个活动条目,但是实际上是三个.这是再正常不过的了,因为我们没有编写实际筛选的逻辑:src/components/TodoList.jsx1234567891011121314151617181920212223// ...export default class TodoList extends React.Component &#123; // Filters the items according to their status getItems() &#123; if (this.props.todos) &#123; return this.props.todos.filter( (item) =&gt; item.get('status') === this.props.filter ); &#125; return []; &#125; render() &#123; return &lt;section className=\"main\"&gt; &lt;ul className=\"todo-list\"&gt; // Only the filtered items are displayed &#123;this.getItems().map(item =&gt; &lt;TodoItem key=&#123;item.get('text')&#125; text=&#123;item.get('text')&#125; /&gt; )&#125; &lt;/ul&gt; &lt;/section&gt; &#125;&#125;; 第一个测试通过了.别停下来,让我们添加筛选器:all和completed: test/components/TodoList_spec.js 12345678910111213141516171819202122232425262728293031323334353637 // ...describe('TodoList', () =&gt; &#123; // ... it('renders a list with only completed items if the filter is completed', () =&gt; &#123; const todos = List.of( Map(&#123;id: 1, text: 'React', status: 'active'&#125;), Map(&#123;id: 2, text: 'Redux', status: 'active'&#125;), Map(&#123;id: 3, text: 'Immutable', status: 'completed'&#125;) ); const filter = 'completed'; const component = renderIntoDocument( &lt;TodoList filter=&#123;filter&#125; todos=&#123;todos&#125; /&gt; ); const items = scryRenderedDOMComponentsWithTag(component, 'li'); expect(items.length).to.equal(1); expect(items[0].textContent).to.contain('Immutable'); &#125;); it('renders a list with all the items', () =&gt; &#123; const todos = List.of( Map(&#123;id: 1, text: 'React', status: 'active'&#125;), Map(&#123;id: 2, text: 'Redux', status: 'active'&#125;), Map(&#123;id: 3, text: 'Immutable', status: 'completed'&#125;) ); const filter = 'all'; const component = renderIntoDocument( &lt;TodoList filter=&#123;filter&#125; todos=&#123;todos&#125; /&gt; ); const items = scryRenderedDOMComponentsWithTag(component, 'li'); expect(items.length).to.equal(3); expect(items[0].textContent).to.contain('React'); expect(items[1].textContent).to.contain('Redux'); expect(items[2].textContent).to.contain('Immutable'); &#125;);&#125;); 第三个测试失败了,因为all筛选器更新组件的逻辑稍稍有点不同 src/components/TodoList.jsx 12345678910111213 // ...export default React.Component &#123; // Filters the items according to their status getItems() &#123; if (this.props.todos) &#123; return this.props.todos.filter( (item) =&gt; this.props.filter === 'all' || item.get('status') === this.props.filter ); &#125; return []; &#125; // ...&#125;); 在这一点上,我们知道显示在app中的条目都是经过filter属性过滤的.如果在浏览器中看看结果,没有显示任何条目,因为我们还没有设置：src/index.jsx123456789101112131415 // ...const todos = List.of( Map(&#123;id: 1, text: 'React', status: 'active', editing: false&#125;), Map(&#123;id: 2, text: 'Redux', status: 'active', editing: false&#125;), Map(&#123;id: 3, text: 'Immutable', status: 'completed', editing: false&#125;));const filter = 'all';require('../node_modules/todomvc-app-css/index.css')ReactDOM.render( &lt;TodoApp todos=&#123;todos&#125; filter = &#123;filter&#125;/&gt;, document.getElementById('app')); src/components/TodoApp.jsx 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// ...export default class TodoApp extends React.Component &#123; render() &#123; return &lt;div&gt; &lt;section className=\"todoapp\"&gt; // We pass the filter props down to the TodoList component &lt;TodoList todos=&#123;this.props.todos&#125; filter=&#123;this.props.filter&#125;/&gt; &lt;/section&gt; &lt;/div&gt; &#125;&#125;;``` 使用在`index.jsc`文件中声明的`filter`常量过滤以后,我们的条目重新出现了.### TodoItem component[这部分的代码修改](https://github.com/phacks/redux-todomvc/commit/71d2835620f4ba6f3fc3665327f13ec4fba62eee)现在,让我们关注一下`TodoItem`组件.首先,我们想确信`TodoItem`组件真正渲染一个条目.我们也想测试一下还没有测试的特性,就是当一个条目完成的时候,他的文本中间有一条线`test/components/TodoItem_spec.js` ```js import React from 'react';import TestUtils from 'react-addons-test-utils';import TodoItem from '../../src/components/TodoItem';import &#123;expect&#125; from 'chai';const &#123;renderIntoDocument, scryRenderedDOMComponentsWithTag&#125; = TestUtils;describe('TodoItem', () =&gt; &#123; it('renders an item', () =&gt; &#123; const text = 'React'; const component = renderIntoDocument( &lt;TodoItem text=&#123;text&#125; /&gt; ); const todo = scryRenderedDOMComponentsWithTag(component, 'li'); expect(todo.length).to.equal(1); expect(todo[0].textContent).to.contain('React'); &#125;); it('strikes through the item if it is completed', () =&gt; &#123; const text = 'React'; const component = renderIntoDocument( &lt;TodoItem text=&#123;text&#125; isCompleted=&#123;true&#125;/&gt; ); const todo = scryRenderedDOMComponentsWithTag(component, 'li'); expect(todo[0].classList.contains('completed')).to.equal(true); &#125;);&#125;); 为了使第二个测试通过,如果条目的状态是complete我们使用了类complete,它将会通过props传递向下传递.我们将会使用classnames包来操作我们的DOM类. npm install —save classnames src/components/TodoItem.jsx 1234567891011121314151617 import React from 'react';// We need to import the classNames objectimport classNames from 'classnames';import TextInput from './TextInput';export default class TodoItem extends React.Component &#123; render() &#123; var itemClass = classNames(&#123; 'todo': true, 'completed': this.props.isCompleted &#125;); return &lt;li className=&#123;itemClass&#125;&gt; // ... &lt;/li&gt; &#125;&#125;; 一个item在编辑的时候外观应该看起来不一样,由isEditingprops来包裹.test/components/TodoItem_spec.js 1234567891011121314 // ...describe('TodoItem', () =&gt; &#123; //... it('should look different when editing', () =&gt; &#123; const text = 'React'; const component = renderIntoDocument( &lt;TodoItem text=&#123;text&#125; isEditing=&#123;true&#125;/&gt; ); const todo = scryRenderedDOMComponentsWithTag(component, 'li'); expect(todo[0].classList.contains('editing')).to.equal(true); &#125;);&#125;); 为了使测试通过,我们仅仅需要更新itemClass对象: src/components/TodoItem.jsx 12345678910111213 // ...export default class TodoItem extends React.Component &#123; render() &#123; var itemClass = classNames(&#123; 'todo': true, 'completed': this.props.isCompleted, 'editing': this.props.isEditing &#125;); return &lt;li className=&#123;itemClass&#125;&gt; // ... &lt;/li&gt; &#125;&#125;; 条目左侧的checkbox如果条目完成,应该标记位checked: test/components/TodoItem_spec.js 12345678910111213141516 // ...describe('TodoItem', () =&gt; &#123; //... it('should be checked if the item is completed', () =&gt; &#123; const text = 'React'; const text2 = 'Redux'; const component = renderIntoDocument( &lt;TodoItem text=&#123;text&#125; isCompleted=&#123;true&#125;/&gt;, &lt;TodoItem text=&#123;text2&#125; isCompleted=&#123;false&#125;/&gt; ); const input = scryRenderedDOMComponentsWithTag(component, 'input'); expect(input[0].checked).to.equal(true); expect(input[1].checked).to.equal(false); &#125;);&#125;); React有个设定checkbox输入state的方法:defaultChecked. src/components/TodoItem.jsx 1234567891011121314 // ...export default class TodoItem extends React.Component &#123; render() &#123; // ... return &lt;li className=&#123;itemClass&#125;&gt; &lt;div className=\"view\"&gt; &lt;input type=\"checkbox\" className=\"toggle\" defaultChecked=&#123;this.props.isCompleted&#125;/&gt; // ... &lt;/div&gt; &lt;/li&gt; &#125;&#125;; 我们也从TodoList组件向下传递isCompleted和isEditingprops. src/components/TodoList.jsx 123456789101112131415161718192021 // ...export default class TodoList extends React.Component &#123; // ... // This function checks whether an item is completed isCompleted(item) &#123; return item.get('status') === 'completed'; &#125; render() &#123; return &lt;section className=\"main\"&gt; &lt;ul className=\"todo-list\"&gt; &#123;this.getItems().map(item =&gt; &lt;TodoItem key=&#123;item.get('text')&#125; text=&#123;item.get('text')&#125; // We pass down the info on completion and editing isCompleted=&#123;this.isCompleted(item)&#125; isEditing=&#123;item.get('editing')&#125; /&gt; )&#125; &lt;/ul&gt; &lt;/section&gt; &#125;&#125;; 截止目前,我们已经能够在组件中反映出state：例如,完成的条目将会被划线.然而一个webapp将会处理诸如点击按钮的操作.在Redux的模式中,这个操作也通过porps来执行,稍稍特殊的是通过在props中传递回调函数来完成.通过这种方式,我们再次把UI和App的逻辑处理分离开:组件根本不需要知道按钮点击的操作具体是什么,仅仅是点击触发了一些事情. 为了描述这个原理,我们将会测试如果用户点击了delete按钮(红色X),delteItem函数将会被调用. 这部分的代码修改 test/components/TodoItem_spec.jsx 1234567891011121314151617181920212223 / ...// The Simulate helper allows us to simulate a user clickingconst &#123;renderIntoDocument, scryRenderedDOMComponentsWithTag, Simulate&#125; = TestUtils;describe('TodoItem', () =&gt; &#123; // ... it('invokes callback when the delete button is clicked', () =&gt; &#123; const text = 'React'; var deleted = false; // We define a mock deleteItem function const deleteItem = () =&gt; deleted = true; const component = renderIntoDocument( &lt;TodoItem text=&#123;text&#125; deleteItem=&#123;deleteItem&#125;/&gt; ); const buttons = scryRenderedDOMComponentsWithTag(component, 'button'); Simulate.click(buttons[0]); // We verify that the deleteItem function has been called expect(deleted).to.equal(true); &#125;);&#125;); 为了是这个测试通过,我们必须在delete按钮声明一个onClick句柄,他将会调用经过props传递的deleteItem函数. src/components/TodoItem.jsx 123456789101112131415 // ...export default class TodoItem extends React.Component &#123; render() &#123; // ... return &lt;li className=&#123;itemClass&#125;&gt; &lt;div className=\"view\"&gt; // ... // The onClick handler will call the deleteItem function given in the props &lt;button className=\"destroy\" onClick=&#123;() =&gt; this.props.deleteItem(this.props.id)&#125;&gt;&lt;/button&gt; &lt;/div&gt; &lt;TextInput /&gt; &lt;/li&gt; &#125;&#125;; 重要的一点:实际删除的逻辑还没有实施,这个将是Redux的主要作用. 在同一个model,我们可以测试和实施下面的特性: 点击checkbox将会调用toggleComplete函数 双击条目标签,将会调用editItem函数 test/components/TodoItem_spec.js 12345678910111213141516171819202122232425262728 // ...describe('TodoItem', () =&gt; &#123; // ... it('invokes callback when checkbox is clicked', () =&gt; &#123; const text = 'React'; var isChecked = false; const toggleComplete = () =&gt; isChecked = true; const component = renderIntoDocument( &lt;TodoItem text=&#123;text&#125; toggleComplete=&#123;toggleComplete&#125;/&gt; ); const checkboxes = scryRenderedDOMComponentsWithTag(component, 'input'); Simulate.click(checkboxes[0]); expect(isChecked).to.equal(true); &#125;); it('calls a callback when text is double clicked', () =&gt; &#123; var text = 'React'; const editItem = () =&gt; text = 'Redux'; const component = renderIntoDocument( &lt;TodoItem text=&#123;text&#125; editItem=&#123;editItem&#125;/&gt; ); const label = component.refs.text Simulate.doubleClick(label); expect(text).to.equal('Redux'); &#125;);&#125;); src/compoents/TodoItem.jsx 12345678910111213141516171819202122 // ...render() &#123; // ... return &lt;li className=&#123;itemClass&#125;&gt; &lt;div className=\"view\"&gt; // We add an onClick handler on the checkbox &lt;input type=\"checkbox\" className=\"toggle\" defaultChecked=&#123;this.props.isCompleted&#125; onClick=&#123;() =&gt; this.props.toggleComplete(this.props.id)&#125;/&gt; // We add a ref attribute to the label to facilitate the testing // The onDoubleClick handler is unsurprisingly called on double clicks &lt;label htmlFor=\"todo\" ref=\"text\" onDoubleClick=&#123;() =&gt; this.props.editItem(this.props.id)&#125;&gt; &#123;this.props.text&#125; &lt;/label&gt; &lt;button className=\"destroy\" onClick=&#123;() =&gt; this.props.deleteItem(this.props.id)&#125;&gt;&lt;/button&gt; &lt;/div&gt; &lt;TextInput /&gt; &lt;/li&gt; 我们也从TodoList组件借助props向下传递editItem,deleteItem和toggleComplete函数. src/components/TodoList.jsx 1234567891011121314151617181920 // ...export default class TodoList extends React.Component &#123; // ... render() &#123; return &lt;section className=\"main\"&gt; &lt;ul className=\"todo-list\"&gt; &#123;this.getItems().map(item =&gt; &lt;TodoItem key=&#123;item.get('text')&#125; text=&#123;item.get('text')&#125; isCompleted=&#123;this.isCompleted(item)&#125; isEditing=&#123;item.get('editing')&#125; // We pass down the callback functions toggleComplete=&#123;this.props.toggleComplete&#125; deleteItem=&#123;this.props.deleteItem&#125; editItem=&#123;this.props.editItem&#125;/&gt; )&#125; &lt;/ul&gt; &lt;/section&gt; &#125;&#125;; 配置其他组件现在,你可能对流程有些熟悉了.为了让本文不要太长,我邀请你看看组件的代码,TextInput(相关提交),TodoHeader(相关提交),Todotools和Footer(相关提交)组件.如果你有任何问题，请留下评论,或着在repo的issue中留下评论. 你可能主要到一些函数,例如editItem,toggleComplete诸如此类的,还没有被定义.这些内容将会在教程的下一部分作为Redux actions的组成来定义,所以如果遇到错误,不要担心. 包装起来 在这篇文章中,我已经演示了我的第一个React,Redux和Immutable webapp.我们的UI是模块化的.完全通过测试,准备和实际的app逻辑联系起来.怎么来连接？这些傻瓜组件什么都不知道,怎么让我们可以写出时间旅行的app? 教程的第二部分在这里.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"react","slug":"react","permalink":"https://React-Apollo.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"https://React-Apollo.github.io/tags/redux/"},{"name":"Immutable.js","slug":"Immutable-js","permalink":"https://React-Apollo.github.io/tags/Immutable-js/"}]},{"title":"Redux-reselect","slug":"Reselect","date":"2017-03-08T00:04:10.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2017/03/08/Reselect/","link":"","permalink":"https://React-Apollo.github.io/2017/03/08/Reselect/","excerpt":"","text":"Simple “selector” library for Redux inspired by getters in NuclearJS, subscriptions in re-frame and this proposal from speedskater. Selectors can compute derived data, allowing Redux to store the minimal possible state. Selectors are efficient. A selector is not recomputed unless one of its arguments change. Selectors are composable. They can be used as input to other selectors. 1234567891011121314151617181920212223242526272829303132333435import &#123; createSelector &#125; from 'reselect'const shopItemsSelector = state =&gt; state.shop.itemsconst taxPercentSelector = state =&gt; state.shop.taxPercentconst subtotalSelector = createSelector( shopItemsSelector, items =&gt; items.reduce((acc, item) =&gt; acc + item.value, 0))const taxSelector = createSelector( subtotalSelector, taxPercentSelector, (subtotal, taxPercent) =&gt; subtotal * (taxPercent / 100))export const totalSelector = createSelector( subtotalSelector, taxSelector, (subtotal, tax) =&gt; (&#123; total: subtotal + tax &#125;))let exampleState = &#123; shop: &#123; taxPercent: 8, items: [ &#123; name: 'apple', value: 1.20 &#125;, &#123; name: 'orange', value: 0.95 &#125;, ] &#125;&#125;console.log(subtotalSelector(exampleState)) // 2.15console.log(taxSelector(exampleState)) // 0.172console.log(totalSelector(exampleState)) // &#123; total: 2.322 &#125; Table of Contents Installation Example Motivation for Memoized Selectors Creating a Memoized Selector Composing Selectors Connecting a Selector to the Redux Store Accessing React Props in Selectors Sharing Selectors with Props Across Multiple Components API createSelector defaultMemoize createSelectorCreator createStructuredSelector FAQ Why isn’t my selector recomputing when the input state changes? Why is my selector recomputing when the input state stays the same? Can I use Reselect without Redux? The default memoization function is no good, can I use a different one? How do I test a selector? How do I create a selector that takes an argument? How do I use Reselect with Immutable.js? Can I share a selector across multiple components? Are there TypeScript typings? How can I make a curried selector? Related Projects License Installationnpm install reselect ExampleMotivation for Memoized Selectors The examples in this section are based on the Redux Todos List example. containers/VisibleTodoList.js1234567891011121314151617181920212223242526272829303132333435import &#123; connect &#125; from 'react-redux'import &#123; toggleTodo &#125; from '../actions'import TodoList from '../components/TodoList'const getVisibleTodos = (todos, filter) =&gt; &#123; switch (filter) &#123; case 'SHOW_ALL': return todos case 'SHOW_COMPLETED': return todos.filter(t =&gt; t.completed) case 'SHOW_ACTIVE': return todos.filter(t =&gt; !t.completed) &#125;&#125;const mapStateToProps = (state) =&gt; &#123; return &#123; todos: getVisibleTodos(state.todos, state.visibilityFilter) &#125;&#125;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; onTodoClick: (id) =&gt; &#123; dispatch(toggleTodo(id)) &#125; &#125;&#125;const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList)export default VisibleTodoList In the above example, mapStateToProps calls getVisibleTodos to calculate todos. This works great, but there is a drawback: todos is calculated every time the component is updated. If the state tree is large, or the calculation expensive, repeating the calculation on every update may cause performance problems. Reselect can help to avoid these unnecessary recalculations. Creating a Memoized SelectorWe would like to replace getVisibleTodos with a memoized selector that recalculates todos when the value of state.todos or state.visibilityFilter changes, but not when changes occur in other (unrelated) parts of the state tree. Reselect provides a function createSelector for creating memoized selectors. createSelector takes an array of input-selectors and a transform function as its arguments. If the Redux state tree is mutated in a way that causes the value of an input-selector to change, the selector will call its transform function with the values of the input-selectors as arguments and return the result. If the values of the input-selectors are the same as the previous call to the selector, it will return the previously computed value instead of calling the transform function. Let’s define a memoized selector named getVisibleTodos to replace the non-memoized version above: selectors/index.js123456789101112131415161718import &#123; createSelector &#125; from 'reselect'const getVisibilityFilter = (state) =&gt; state.visibilityFilterconst getTodos = (state) =&gt; state.todosexport const getVisibleTodos = createSelector( [ getVisibilityFilter, getTodos ], (visibilityFilter, todos) =&gt; &#123; switch (visibilityFilter) &#123; case 'SHOW_ALL': return todos case 'SHOW_COMPLETED': return todos.filter(t =&gt; t.completed) case 'SHOW_ACTIVE': return todos.filter(t =&gt; !t.completed) &#125; &#125;) In the example above, getVisibilityFilter and getTodos are input-selectors. They are created as ordinary non-memoized selector functions because they do not transform the data they select. getVisibleTodos on the other hand is a memoized selector. It takes getVisibilityFilter and getTodos as input-selectors, and a transform function that calculates the filtered todos list. Composing SelectorsA memoized selector can itself be an input-selector to another memoized selector. Here is getVisibleTodos being used as an input-selector to a selector that further filters the todos by keyword: 12345678const getKeyword = (state) =&gt; state.keywordconst getVisibleTodosFilteredByKeyword = createSelector( [ getVisibleTodos, getKeyword ], (visibleTodos, keyword) =&gt; visibleTodos.filter( todo =&gt; todo.text.indexOf(keyword) &gt; -1 )) Connecting a Selector to the Redux StoreIf you are using React Redux, you can call selectors as regular functions inside mapStateToProps(): containers/VisibleTodoList.js12345678910111213141516171819202122232425import &#123; connect &#125; from 'react-redux'import &#123; toggleTodo &#125; from '../actions'import TodoList from '../components/TodoList'import &#123; getVisibleTodos &#125; from '../selectors'const mapStateToProps = (state) =&gt; &#123; return &#123; todos: getVisibleTodos(state) &#125;&#125;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; onTodoClick: (id) =&gt; &#123; dispatch(toggleTodo(id)) &#125; &#125;&#125;const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList)export default VisibleTodoList Accessing React Props in Selectors This section introduces a hypothetical extension to our app that allows it to support multiple Todo Lists. Please note that a full implementation of this extension requires changes to the reducers, components, actions etc. that aren’t directly relevant to the topics discussed and have been omitted for brevity. So far we have only seen selectors receive the Redux store state as an argument, but a selector can receive props too. Here is an App component that renders three VisibleTodoList components, each of which has a listId prop: components/App.js123456789101112import React from 'react'import Footer from './Footer'import AddTodo from '../containers/AddTodo'import VisibleTodoList from '../containers/VisibleTodoList'const App = () =&gt; ( &lt;div&gt; &lt;VisibleTodoList listId=\"1\" /&gt; &lt;VisibleTodoList listId=\"2\" /&gt; &lt;VisibleTodoList listId=\"3\" /&gt; &lt;/div&gt;) Each VisibleTodoList container should select a different slice of the state depending on the value of the listId prop, so let’s modify getVisibilityFilter and getTodos to accept a props argument: selectors/todoSelectors.js1234567891011121314151617181920212223import &#123; createSelector &#125; from 'reselect'const getVisibilityFilter = (state, props) =&gt; state.todoLists[props.listId].visibilityFilterconst getTodos = (state, props) =&gt; state.todoLists[props.listId].todosconst getVisibleTodos = createSelector( [ getVisibilityFilter, getTodos ], (visibilityFilter, todos) =&gt; &#123; switch (visibilityFilter) &#123; case 'SHOW_COMPLETED': return todos.filter(todo =&gt; todo.completed) case 'SHOW_ACTIVE': return todos.filter(todo =&gt; !todo.completed) default: return todos &#125; &#125;)export default getVisibleTodos props can be passed to getVisibleTodos from mapStateToProps: 12345const mapStateToProps = (state, props) =&gt; &#123; return &#123; todos: getVisibleTodos(state, props) &#125;&#125; So now getVisibleTodos has access to props, and everything seems to be working fine. But there is a problem! Using the getVisibleTodos selector with multiple instances of the VisibleTodoList container will not correctly memoize: containers/VisibleTodoList.js1234567891011121314151617181920212223242526import &#123; connect &#125; from 'react-redux'import &#123; toggleTodo &#125; from '../actions'import TodoList from '../components/TodoList'import &#123; getVisibleTodos &#125; from '../selectors'const mapStateToProps = (state, props) =&gt; &#123; return &#123; // WARNING: THE FOLLOWING SELECTOR DOES NOT CORRECTLY MEMOIZE todos: getVisibleTodos(state, props) &#125;&#125;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; onTodoClick: (id) =&gt; &#123; dispatch(toggleTodo(id)) &#125; &#125;&#125;const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList)export default VisibleTodoList A selector created with createSelector only returns the cached value when its set of arguments is the same as its previous set of arguments. If we alternate between rendering &lt;VisibleTodoList listId=&quot;1&quot; /&gt; and &lt;VisibleTodoList listId=&quot;2&quot; /&gt;, the shared selector will alternate between receiving {listId: 1} and {listId: 2} as its props argument. This will cause the arguments to be different on each call, so the selector will always recompute instead of returning the cached value. We’ll see how to overcome this limitation in the next section. Sharing Selectors with Props Across Multiple Components The examples in this section require React Redux v4.3.0 or greater To share a selector across multiple VisibleTodoList components while passing in props and retaining memoization, each instance of the component needs its own private copy of the selector. Let’s create a function named makeGetVisibleTodos that returns a new copy of the getVisibleTodos selector each time it is called: selectors/todoSelectors.js12345678910111213141516171819202122232425import &#123; createSelector &#125; from 'reselect'const getVisibilityFilter = (state, props) =&gt; state.todoLists[props.listId].visibilityFilterconst getTodos = (state, props) =&gt; state.todoLists[props.listId].todosconst makeGetVisibleTodos = () =&gt; &#123; return createSelector( [ getVisibilityFilter, getTodos ], (visibilityFilter, todos) =&gt; &#123; switch (visibilityFilter) &#123; case 'SHOW_COMPLETED': return todos.filter(todo =&gt; todo.completed) case 'SHOW_ACTIVE': return todos.filter(todo =&gt; !todo.completed) default: return todos &#125; &#125; )&#125;export default makeGetVisibleTodos We also need a way to give each instance of a container access to its own private selector. The mapStateToProps argument of connect can help with this. If the mapStateToProps argument supplied to connect returns a function instead of an object, it will be used to create an individual mapStateToProps function for each instance of the container. In the example below makeMapStateToProps creates a new getVisibleTodos selector, and returns a mapStateToProps function that has exclusive access to the new selector: 123456789const makeMapStateToProps = () =&gt; &#123; const getVisibleTodos = makeGetVisibleTodos() const mapStateToProps = (state, props) =&gt; &#123; return &#123; todos: getVisibleTodos(state, props) &#125; &#125; return mapStateToProps&#125; If we pass makeMapStateToProps to connect, each instance of the VisibleTodosList container will get its own mapStateToProps function with a private getVisibleTodos selector. Memoization will now work correctly regardless of the render order of the VisibleTodoList containers. containers/VisibleTodoList.js1234567891011121314151617181920212223242526272829import &#123; connect &#125; from 'react-redux'import &#123; toggleTodo &#125; from '../actions'import TodoList from '../components/TodoList'import &#123; makeGetVisibleTodos &#125; from '../selectors'const makeMapStateToProps = () =&gt; &#123; const getVisibleTodos = makeGetVisibleTodos() const mapStateToProps = (state, props) =&gt; &#123; return &#123; todos: getVisibleTodos(state, props) &#125; &#125; return mapStateToProps&#125;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; onTodoClick: (id) =&gt; &#123; dispatch(toggleTodo(id)) &#125; &#125;&#125;const VisibleTodoList = connect( makeMapStateToProps, mapDispatchToProps)(TodoList)export default VisibleTodoList APIcreateSelector(…inputSelectors | [inputSelectors], resultFunc)Takes one or more selectors, or an array of selectors, computes their values and passes them as arguments to resultFunc. createSelector determines if the value returned by an input-selector has changed between calls using reference equality (===). Inputs to selectors created with createSelector should be immutable. Selectors created with createSelector have a cache size of 1. This means they always recalculate when the value of an input-selector changes, as a selector only stores the preceding value of each input-selector. 1234567891011121314const mySelector = createSelector( state =&gt; state.values.value1, state =&gt; state.values.value2, (value1, value2) =&gt; value1 + value2)// You can also pass an array of selectorsconst totalSelector = createSelector( [ state =&gt; state.values.value1, state =&gt; state.values.value2 ], (value1, value2) =&gt; value1 + value2) It can be useful to access the props of a component from within a selector. When a selector is connected to a component with connect, the component props are passed as the second argument to the selector: 12345678910111213141516const abSelector = (state, props) =&gt; state.a * props.b// props only (ignoring state argument)const cSelector = (_, props) =&gt; props.c// state only (props argument omitted as not required)const dSelector = state =&gt; state.dconst totalSelector = createSelector( abSelector, cSelector, dSelector, (ab, c, d) =&gt; (&#123; total: ab + c + d &#125;)) defaultMemoize(func, equalityCheck = defaultEqualityCheck)defaultMemoize memoizes the function passed in the func parameter. It is the memoize function used by createSelector. defaultMemoize has a cache size of 1. This means it always recalculates when the value of an argument changes. defaultMemoize determines if an argument has changed by calling the equalityCheck function. As defaultMemoize is designed to be used with immutable data, the default equalityCheck function checks for changes using reference equality: 123function defaultEqualityCheck(currentVal, previousVal) &#123; return currentVal === previousVal&#125; defaultMemoize can be used with createSelectorCreator to customize the equalityCheck function. createSelectorCreator(memoize, …memoizeOptions)createSelectorCreator can be used to make a customized version of createSelector. The memoize argument is a memoization function to replace defaultMemoize. The ...memoizeOptions rest parameters are zero or more configuration options to be passed to memoizeFunc. The selectors resultFunc is passed as the first argument to memoize and the memoizeOptions are passed as the second argument onwards: 123456789101112const customSelectorCreator = createSelectorCreator( customMemoize, // function to be used to memoize resultFunc option1, // option1 will be passed as second argument to customMemoize option2, // option2 will be passed as third argument to customMemoize option3 // option3 will be passed as fourth argument to customMemoize)const customSelector = customSelectorCreator( input1, input2, resultFunc // resultFunc will be passed as first argument to customMemoize) Internally customSelector calls the memoize function as follows: 1customMemoize(resultFunc, option1, option2, option3) Here are some examples of how you might use createSelectorCreator: Customize equalityCheck for defaultMemoize1234567891011121314import &#123; createSelectorCreator, defaultMemoize &#125; from 'reselect'import isEqual from 'lodash.isEqual'// create a \"selector creator\" that uses lodash.isEqual instead of ===const createDeepEqualSelector = createSelectorCreator( defaultMemoize, isEqual)// use the new \"selector creator\" to create a selectorconst mySelector = createDeepEqualSelector( state =&gt; state.values.filter(val =&gt; val &lt; 5), values =&gt; values.reduce((acc, val) =&gt; acc + val, 0)) Use memoize function from lodash for an unbounded cache1234567891011121314151617import &#123; createSelectorCreator &#125; from 'reselect'import memoize from 'lodash.memoize'let called = 0const hashFn = (...args) =&gt; args.reduce( (acc, val) =&gt; acc + '-' + JSON.stringify(val), '')const customSelectorCreator = createSelectorCreator(memoize, hashFn)const selector = customSelectorCreator( state =&gt; state.a, state =&gt; state.b, (a, b) =&gt; &#123; called++ return a + b &#125;) createStructuredSelector({inputSelectors}, selectorCreator = createSelector)createStructuredSelector is a convenience function for a common pattern that arises when using Reselect. The selector passed to a connect decorator often just takes the values of its input-selectors and maps them to keys in an object: 123456789101112131415const mySelectorA = state =&gt; state.aconst mySelectorB = state =&gt; state.b// The result function in the following selector// is simply building an object from the input selectorsconst structuredSelector = createSelector( mySelectorA, mySelectorB, mySelectorC, (a, b, c) =&gt; (&#123; a, b, c &#125;)) createStructuredSelector takes an object whose properties are input-selectors and returns a structured selector. The structured selector returns an object with the same keys as the inputSelectors argument, but with the selectors replaced with their values. 123456789const mySelectorA = state =&gt; state.aconst mySelectorB = state =&gt; state.bconst structuredSelector = createStructuredSelector(&#123; x: mySelectorA, y: mySelectorB&#125;)const result = structuredSelector(&#123; a: 1, b: 2 &#125;) // will produce &#123; x: 1, y: 2 &#125; Structured selectors can be nested: 12345678910const nestedSelector = createStructuredSelector(&#123; subA: createStructuredSelector(&#123; selectorA, selectorB &#125;), subB: createStructuredSelector(&#123; selectorC, selectorD &#125;)&#125;) FAQQ: Why isn’t my selector recomputing when the input state changes?A: Check that your memoization function is compatible with your state update function (i.e. the reducer if you are using Redux). For example, a selector created with createSelector will not work with a state update function that mutates an existing object instead of creating a new one each time. createSelector uses an identity check (===) to detect that an input has changed, so mutating an existing object will not trigger the selector to recompute because mutating an object does not change its identity. Note that if you are using Redux, mutating the state object is almost certainly a mistake. The following example defines a simple selector that determines if the first todo item in an array of todos has been completed: 1234const isFirstTodoCompleteSelector = createSelector( state =&gt; state.todos[0], todo =&gt; todo &amp;&amp; todo.completed) The following state update function will not work with isFirstTodoCompleteSelector: 1234567891011121314export default function todos(state = initialState, action) &#123; switch (action.type) &#123; case COMPLETE_ALL: const areAllMarked = state.every(todo =&gt; todo.completed) // BAD: mutating an existing object return state.map(todo =&gt; &#123; todo.completed = !areAllMarked return todo &#125;) default: return state &#125;&#125; The following state update function will work with isFirstTodoCompleteSelector: 12345678910111213export default function todos(state = initialState, action) &#123; switch (action.type) &#123; case COMPLETE_ALL: const areAllMarked = state.every(todo =&gt; todo.completed) // GOOD: returning a new object each time with Object.assign return state.map(todo =&gt; Object.assign(&#123;&#125;, todo, &#123; completed: !areAllMarked &#125;)) default: return state &#125;&#125; If you are not using Redux and have a requirement to work with mutable data, you can use createSelectorCreator to replace the default memoization function and/or use a different equality check function. See here and here for examples. Q: Why is my selector recomputing when the input state stays the same?A: Check that your memoization function is compatible with your state update function (i.e. the reducer if you are using Redux). For example, a selector created with createSelector that recomputes unexpectedly may be receiving a new object on each update whether the values it contains have changed or not. createSelector uses an identity check (===) to detect that an input has changed, so returning a new object on each update means that the selector will recompute on each update. 123456789101112131415161718192021import &#123; REMOVE_OLD &#125; from '../constants/ActionTypes'const initialState = [ &#123; text: 'Use Redux', completed: false, id: 0, timestamp: Date.now() &#125;]export default function todos(state = initialState, action) &#123; switch (action.type) &#123; case REMOVE_OLD: return state.filter(todo =&gt; &#123; return todo.timestamp + 30 * 24 * 60 * 60 * 1000 &gt; Date.now() &#125;) default: return state &#125;&#125; The following selector is going to recompute every time REMOVE_OLD is invoked because Array.filter always returns a new object. However, in the majority of cases the REMOVE_OLD action will not change the list of todos so the recomputation is unnecessary. 12345678910import &#123; createSelector &#125; from 'reselect'const todosSelector = state =&gt; state.todosexport const visibleTodosSelector = createSelector( todosSelector, (todos) =&gt; &#123; ... &#125;) You can eliminate unnecessary recomputations by returning a new object from the state update function only when a deep equality check has found that the list of todos has actually changed: 1234567891011121314151617181920212223import &#123; REMOVE_OLD &#125; from '../constants/ActionTypes'import isEqual from 'lodash.isEqual'const initialState = [ &#123; text: 'Use Redux', completed: false, id: 0, timestamp: Date.now() &#125;]export default function todos(state = initialState, action) &#123; switch (action.type) &#123; case REMOVE_OLD: const updatedState = state.filter(todo =&gt; &#123; return todo.timestamp + 30 * 24 * 60 * 60 * 1000 &gt; Date.now() &#125;) return isEqual(updatedState, state) ? state : updatedState default: return state &#125;&#125; Alternatively, the default equalityCheck function in the selector can be replaced by a deep equality check: 123456789101112131415161718import &#123; createSelectorCreator, defaultMemoize &#125; from 'reselect'import isEqual from 'lodash.isEqual'const todosSelector = state =&gt; state.todos// create a \"selector creator\" that uses lodash.isEqual instead of ===const createDeepEqualSelector = createSelectorCreator( defaultMemoize, isEqual)// use the new \"selector creator\" to create a selectorconst mySelector = createDeepEqualSelector( todosSelector, (todos) =&gt; &#123; ... &#125;) Always check that the cost of an alternative equalityCheck function or deep equality check in the state update function is not greater than the cost of recomputing every time. If recomputing every time does work out to be the cheaper option, it may be that for this case Reselect is not giving you any benefit over passing a plain mapStateToProps function to connect. Q: Can I use Reselect without Redux?A: Yes. Reselect has no dependencies on any other package, so although it was designed to be used with Redux it can be used independently. It is currently being used successfully in traditional Flux apps. If you create selectors using createSelector make sure its arguments are immutable.See here Q: How do I create a selector that takes an argument?A: Reselect doesn’t have built-in support for creating selectors that accepts arguments, but here are some suggestions for implementing similar functionality… If the argument is not dynamic you can use a factory function: 1234567891011const expensiveItemSelectorFactory = minValue =&gt; &#123; return createSelector( shopItemsSelector, items =&gt; items.filter(item =&gt; item.value &gt; minValue) )&#125;const subtotalSelector = createSelector( expensiveItemSelectorFactory(200), items =&gt; items.reduce((acc, item) =&gt; acc + item.value, 0)) The general consensus here and over at nuclear-js is that if a selector needs a dynamic argument, then that argument should probably be state in the store. If you decide that you do require a selector with a dynamic argument, then a selector that returns a memoized function may be suitable: 1234567891011121314import &#123; createSelector &#125; from 'reselect'import memoize from 'lodash.memoize'const expensiveSelector = createSelector( state =&gt; state.items, items =&gt; memoize( minValue =&gt; items.filter(item =&gt; item.value &gt; minValue) ))const expensiveFilter = expensiveSelector(state)const slightlyExpensive = expensiveFilter(100)const veryExpensive = expensiveFilter(1000000) Q: The default memoization function is no good, can I use a different one?A: We think it works great for a lot of use cases, but sure. See these examples. Q: How do I test a selector?A: For a given input, a selector should always produce the same output. For this reason they are simple to unit test. 12345678910111213const selector = createSelector( state =&gt; state.a, state =&gt; state.b, (a, b) =&gt; (&#123; c: a * 2, d: b * 3 &#125;))test(\"selector unit test\", () =&gt; &#123; assert.deepEqual(selector(&#123; a: 1, b: 2 &#125;), &#123; c: 2, d: 6 &#125;) assert.deepEqual(selector(&#123; a: 2, b: 3 &#125;), &#123; c: 4, d: 9 &#125;)&#125;) It may also be useful to check that the memoization function for a selector works correctly with the state update function (i.e. the reducer if you are using Redux). Each selector has a recomputations method that will return the number of times it has been recomputed: 123456789101112131415161718192021222324252627282930313233suite('selector', () =&gt; &#123; let state = &#123; a: 1, b: 2 &#125; const reducer = (state, action) =&gt; ( &#123; a: action(state.a), b: action(state.b) &#125; ) const selector = createSelector( state =&gt; state.a, state =&gt; state.b, (a, b) =&gt; (&#123; c: a * 2, d: b * 3 &#125;) ) const plusOne = x =&gt; x + 1 const id = x =&gt; x test(\"selector unit test\", () =&gt; &#123; state = reducer(state, plusOne) assert.deepEqual(selector(state), &#123; c: 4, d: 9 &#125;) state = reducer(state, id) assert.deepEqual(selector(state), &#123; c: 4, d: 9 &#125;) assert.equal(selector.recomputations(), 1) state = reducer(state, plusOne) assert.deepEqual(selector(state), &#123; c: 6, d: 12 &#125;) assert.equal(selector.recomputations(), 2) &#125;)&#125;) Additionally, selectors keep a reference to the last result function as .resultFunc. If you have selectors composed of many other selectors this can help you test each selector without coupling all of your tests to the shape of your state. For example if you have a set of selectors like this: selectors.js12345678910export const firstSelector = createSelector( ... )export const secondSelector = createSelector( ... )export const thirdSelector = createSelector( ... )export const myComposedSelector = createSelector( firstSelector, secondSelector, thirdSelector, (first, second, third) =&gt; first * second &lt; third) And then a set of unit tests like this: test/selectors.js 1234567891011121314// tests for the first three selectors...test(\"firstSelector unit test\", () =&gt; &#123; ... &#125;)test(\"secondSelector unit test\", () =&gt; &#123; ... &#125;)test(\"thirdSelector unit test\", () =&gt; &#123; ... &#125;)// We have already tested the previous// three selector outputs so we can just call `.resultFunc`// with the values we want to test directly:test(\"myComposedSelector unit test\", () =&gt; &#123; // here instead of calling selector() // we just call selector.resultFunc() assert(selector.resultFunc(1, 2, 3), true) assert(selector.resultFunc(2, 2, 1), false)&#125;) Finally, each selector has a resetRecomputations method that setsrecomputations back to 0. The intended use is for a complex selector that mayhave many independent tests and you don’t want to manually manage thecomputation count or create a “dummy” selector for each test. Q: How do I use Reselect with Immutable.js?A: Selectors created with createSelector should work just fine with Immutable.js data structures. If your selector is recomputing and you don’t think the state has changed, make sure you are aware of which Immutable.js update methods always return a new object and which update methods only return a new object when the collection actually changes. 12345678910111213141516import Immutable from 'immutable'let myMap = Immutable.Map(&#123; a: 1, b: 2, c: 3&#125;) // set, merge and others only return a new obj when update changes collectionlet newMap = myMap.set('a', 1)assert.equal(myMap, newMap)newMap = myMap.merge(&#123; 'a', 1 &#125;)assert.equal(myMap, newMap)// map, reduce, filter and others always return a new objnewMap = myMap.map(a =&gt; a * 1)assert.notEqual(myMap, newMap) If a selector’s input is updated by an operation that always returns a new object, it may be performing unnecessary recomputations. See here for a discussion on the pros and cons of using a deep equality check like Immutable.is to eliminate unnecessary recomputations. Q: Can I share a selector across multiple components?A: Selectors created using createSelector only have a cache size of one. This can make them unsuitable for sharing across multiple components if the arguments to the selector are different for each instance of the component. There are a couple of ways to get around this: Create a factory function which returns a new selector for each instance of the component. There is built-in support for factory functions in React Redux v4.3 or higher. See here for an example. Create a custom selector with a cache size greater than one. Q: Are there TypeScript Typings?A: Yes! They are included and referenced in package.json. They should Just Work™. Q: How can I make a curried selector?A: Try these helper functions courtesy of MattSPalmer Related Projects###reselect-map Can be useful when doing very expensive computations on elements of a collection because Reselect might not give you the granularity of caching that you need. Check out the reselect-maps README for examples. The optimizations in reselect-map only apply in a small number of cases. If you are unsure whether you need it, you don’t! LicenseMIT","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[]},{"title":"Readme|Redux-awesome","slug":"Awesome Redux","date":"2017-03-08T00:04:10.000Z","updated":"2019-04-28T05:52:57.888Z","comments":true,"path":"2017/03/08/Awesome Redux/","link":"","permalink":"https://React-Apollo.github.io/2017/03/08/Awesome Redux/","excerpt":"","text":"Awesome Redux List of repositories which use Redux ReduxDocumentation of ReduxDocumentation of Redux(Simple Chinese version)Documentation of Redux(Russian version) (Work in progress)Documentation of Redux(Traditional Chinese version)Documentation of Redux(Japanese version) (Work in progress)Documentation of Redux(Portuguese version) (Work in progress)Documentation of Redux(Spanish version) (Work in progress)Documentation of Redux(Korean version)Documentation of Redux(Sinhala|සිංහල version) (Work in progress) Predictable state container for JavaScript apps Marks Universal (Isomorphic) - :metal: Hot Reload - :fire: Presentations Let’s learn React and Redux with Javascript’s new ES6 syntax, from Beginner to Intermediate to Advanced. A introduction about Redux Real World Redux The power of higher-order reducers Reactive Architecture with Redux and Angular Redux Internals Replacing Angular 1 with React and Redux A tour on the React ecosystem Redux from Twitter hype to production Resources Many tools and middlewares Redux offline docs Flux challenge Sound Redux - a simple Soundcloud client Favesound Redux - SoundCloud Client for Artists Structor - a user interface builder for React generator-redux - CLI tools for Redux: next-gen functional Flux/React with devtools generator-reactapp - Yeoman generator for react app with redux Rekit - Toolkit for building scalable web apps with React, Redux and React-router Spectacle - ReactJS based Presentation Library Notes (and partial transcription) of Dan Abramov’s Redux course videos on http://egghead.io Comprehensive Notes for Learning (how to use) Redux to manage state in your Web/Mobile Apps React Redux [RU tutorial] Redux without profanity React and Redux Single Page Applications Resources A categorized list of Redux-related addons, libraries, and utilities Building the F8 2016 App (Redux, GraphQL, React Native) The Elm Architecture in JavaScript Articles And Tutorials Building Applications with React and Redux in ES6 on Pluralsight Writing a Basic App in Redux Learn how to use Redux step by step Tutorial: Handcrafting an Isomorphic Redux Application (With Love) 0 to 1 : Getting started with Redux Redux Chinese Document Redux Document (Traditional Chinese) Relay and Routing Understanding Redux Middleware Several videos about Redux + Falcor and Example code Redux Middleware: Behind the Scenes A proposal for bundling reducers, action types and actions when using Redux Full-Stack Redux Tutorial - A Comprehensive Guide to Test-First Development with Redux, React, and Immutable Source Server + Client Redux best practices The 3REE Stack: React + Redux + RethinkDB + Express.js React Tutorial - Converting Reflux to Redux Redux example using 500px API (with ES6) Building a boilerplate for a Koa, Redux, React application including Webpack, Mocha and SASS - This article explains in detail how this koa-redux-react-boilerplate was built and the technologies it uses. Typed React and Redux A cartoon intro to Redux Join The Dark Side Of The Flux: Responding to Actions with Actors Can I dispatch multiple actions from Redux action creators? Understanding Redux (or, How I Fell in Love with a JavaScript State Container) Your First Immutable React &amp; Redux App Getting Started with Redux - Egghead’s video lessons from Dan Abramov Redux Testing Video Lessons - a few short Egghead video lessons (some free, some require a subscription) Implementing a smart Login Modal with Redux, reselect and ReactJS How to Build a Todo App Using React, Redux, and Immutable.js Rethinking Redux Managing Side Effects In React + Redux Using Sagas Secure Your React and Redux App with JWT Authentication Getting started with Redux and GraphQL Data Flows with Angular 2 and Redux Simple Routing with Redux and React Redux nowadays : From actions creators to sagas Master Complex Redux Workflows with Sagas Angular 2 Application Architecture - Building Flux Apps with Redux and Immutable.js React, Redux and Immutable.js: Ingredients for Efficient Web Applications An Introduction to React Redux (Part 1) An Introduction to React Redux (Part 2) Rules For Structuring (Redux) Applications Redux for the very beginner Redux - Calling web service asynchronously Animating with React, Redux, and d3 Build an Image Gallery Using React, Redux and redux-saga Introducing redux-operations Solving Redux’s shortcoming in 150 LOCs The Anatomy Of A React Redux App Getting Started with React, Redux and Immutable: a Test-Driven Tutorial (Part 2) Leveling Up with React: Redux Complete intro to react Recreating Redux — Behind the magic curtain Let’s Build a Redux Powered React Application Deep Introduction to Redux - Seriese 1/3 Universal Rendering with Redux and React-Router - Seriese 2/3 Unit Testing Redux Apps - Seriese 3/3 Using Aurelia and Redux together for good times all around Comparing Redux and Relay Building React Applications with Idiomatic Redux The SoundCloud Client in React + Redux 深入浅出 Redux Building Angular 2 applications with Immutable.js and Redux Tutorial: Building Redux in TypeScript with Angular 2 Improving React and Redux performance with Reselect Recipes for Redux Getting Started with Redux &amp; Angular 2 Universal/Isomorphic React+Redux on a Swift Web Backend Creating Reusable React-Redux Components Through Scoping React+Redux系列教程 书籍：《React 与 Redux 开发实例精解》 Boilerplate redux-minimal - Minimalist react-redux starter kit which let’s you build rich real world apps Modern and Scalable React/Redux Boilerplate - Flexible starter kit using Webpack 2 (tree-shaking) / React Hot Loader v3 / Code Splitting for React Router / PostCSS / CSS Modules / custom Ducks pattern app architecture / best practices / Sentry error tracking / Enzyme test environment :rocket: react-production-starter - React boilerplate with isomorphic rendering, async react-router routes, async redux reducers, async data fetching, and code-splitting. :metal: :fire: mern.io - Simple full-stack boilerplate to get started with building isomorphic/universal apps, handles api part and also offers a cli to generate the boilerplate :metal: :fire: universal-react-redux - Opinionated Universal React/Redux/Webpack with HMR. Continually updated. :metal: :fire: react-slingshot - React Redux Starter Kit with hot reloading, tests and example app react-redux-boilerplate - React Redux Boilerplate react-boilerplate - React + Typescript + Sass boilerplate react-redux-scaffold - Combination of redux, react-router and ES6+ support simple-redux-boilerplate - Simple and guided React, Redux boilerplate w/ Transform HMR! :fire: reactv - React Redux example redux-boilerplate - Boilerplate for Redux react-redux-starter-kit - Get started with React, Redux, and React-Router. simplest-redux-example - Simplest Redux + React example for beginners redux-easy-boilerplate - React Redux easy boilerplate dicty-redux - Starter kit to bootstrap React and Redux (Flux) based web application 3ree - Boilerplate &amp; Demo for Universal Realtime Apps built with React + Redux + RethinkDB + Express react_scaffolding - React + React Router 1.0 + Redux + Webpack &amp; Hot Module Replacement express-redux-sample - Express-Redux-PassportJs-MySQL Boilerplate redux-blog-example - Redux-Webpack-Babel Blog Platform boilerplate redux-undo-boilerplate - a magical boilerplate with hot reloading and awesome error handling redux500 - The Redux version of isomorphic500 redux-demo - Redux port of SurviveJS - Webpack and React Kanban app react-redux-universal-hot-example - A starter boilerplate for a universal webapp using express, react, redux, webpack, and react-hot-loader :metal: rde - Reactive Live Programming Environment React Redux Starter Kit - Yet another React and Redux based web application starter kit skeleton - A simple project-stub to show the basic ideas. Also serves you as a quick start for your project (Mori + Redux) browser-redux - Building Chrome apps and cross-browser extensions with Redux and Webpack react-for-hipsters-boilerplate - Fresh boilerplate with brand new hot reloading confing and other hipster stuff Documented Koa Redux React Webpack boilerplate- The building process of this boilerplate is deeply documented from 0 for learning purposes. You can find the docs here. err - Electron, React, Redux-devtools boilerplate for building cross-platform apps. friends-app-redux - React Redux Universal Hot Example isomorphic-redux-app - Redux Isomorphic App (with async content) starter-kit - Project boilerplate using React, Redux and Uniloc http://unicornstandard.com/packages/boilerplate.html loopback-redux-react-boilerplate - A boilerplate for a Redux-React application using LoopBack breko-hub - Babel React Koa Hot Universal Boilerplate – A simple, clean and consistent boilerplate for creating universal webapps with universal data fetching and SocketIO integration React Redux Cordova Boilerplate react-boilerplate - Performance orientated, offline-first boilerplate feat. hot-reloading, PostCSS and the best developer experience. react-webpack-node - Boilerplate for an universal React + Redux/alt Flux application using Webpack running on a node express server [Hapi React Starter Kit - Universal, Redux, Redis, Socket.io, Intl] (https://github.com/Dindaleon/hapi-react-starter-kit) [Universal Redux Template - A clean, extensible react + redux boilerplate with universal rendering, testing and more] (https://github.com/mz026/universal-redux-template) universal-js - A universal Javascript starter kit inc. React, Redux, Redux Dev Tools, Universal Redux Router, CSS Modules, hot module reloading, Babel for ES2015+ and ESLint redux-react-material-boilerplate - Simple boilerplate inc. React, Redux, Hot reload and Material-ui react-redux-starter - React Redux Starter Reduxible - The Fast and Easy way to make a React + Redux apps react-workflow - A large SPA boilerplate for web development built on top of Facebook’s React library,use redux architecture ReacToGo - A simple ES6 boilerplate with Redux architecture and ImmutableJS: Hot Reload, React UI Comp, Firebase, Router React/Redux simple CRUD with persistent state and local async actions (add a manifest file and you get an offline webapp) StarHackIt - An React/Redux Node full-stack starter kit with authentication and authorization code React Seed - A barebones scalable directory structure and package.json for facilitating new React + Redux projects. No fat to trim here! [React/Redux with Auth boilerplate - Very simple boilerplate, good for fast creating admin panels / dashboard. Included: React, Redux, ReduxForm, React-Router, Simple Authenticate, Hot Reload and Webpack (with babel) :fire:] (https://github.com/WapGeaR/react-redux-boilerplate-auth) Docker + React/Redux + Node + PostgreSQL - full stack boilerplate with fully dockerized workflows for development, deployment, testing Redux universal boilerplate - boilerplate for react universal application building on flux architecture based on redux implementation. React Redux Universal Boilerplate - An Universal ReactJS/Redux Boilerplate. react-hot-redux-firebase-starter - Starter boilerplate for using React/Redux with Firebase 3.0 API, include the new React Hot Loader 3.0 :fire: React Redux Firebase Boilerplate - Designed for quickly spin up your apps with Firebase, using bunch of awesome new front-end technologies includes webpack build system, hot reloading, routing &amp; sass support. :fire: React Universal Saga - Universal React Starter Kit ft. Redux Saga React Redux SoundCloud Client - Seed Project for a SoundCloud Client with working Login + Extension Seed Projects vortigern - A universal boilerplate for building web applications w/ TypeScript, React, Redux and more. angular2-redux-contact-list - Simple contact list built with Angular 2, Immutable.js and Redux react-redux-seed - 使用 React 与 Redux 实现 Universal 渲染的种子工程 ARc - A progressive React starter kit based on Atomic Design with redux, redux-saga and redux-form edux - fast Redux without constants and switches. Actions and reducers are generated from single source. React Native - A framework for building native apps using React Examples CarteJaune - An open source Redux/ExponentJS (React Native) app leveraging redux-saga to keep track of your vaccinations noder-react-native - The mobile app of cnodejs.org written in React Native react-native-redux-counter react-native-counter-ios-android react-native-redux-groceries - An example app using React Native, Redux, Firebase, and AsyncStorage for offline data react-native-sound-cloud snowflake - mobile app starter: Login, Logout, Reset Password, Update Profile, Hot Reload uestc-bbs-react-native - An iOS client for http://bbs.uestc.edu.cn/ written in React Native with Redux movies-redux - redux implementation of react-native movies example that is included in react-native source react-native-redux-todo-list - A sample todo list app developed by using react-native and redux React - A JavaScript library for building user interfaces Containers reapop - A React &amp; Redux notifications system Middlewares redux-cheerio - Make HTTP requests and then parse the responses with jQuery selectors using Cheerio redux-reporter - Report actions &amp; metadata to 3rd party providers, extremely useful for analytics and error handling (New Relic, Sentry, Adobe DTM, Keen, etc.) redux-transduce - Transducer utilities for Redux redux-actions - Flux Standard Action utilities for Redux redux-promise - FSA-compliant promise middleware for Redux redux-sync-promise - Middleware for writing asynchronous actions in synchronous style redux-simple-promise - FSA-compliant promise middleware for Redux with simple behaviour with minimal boilerplate declarations redux-async - FSA-compliant promise property middleware for Redux redux-async-queue - Manage queues of thunk actions redux-async-initial-state - Set initial Redux state asynchronously redux-await - Manage async redux actions sanely redux-rx - RxJS utilities for Redux reselect - Selector library for Redux like in NuclearJS react-redux - React bindings for Redux redux-react-router - Redux bindings for React Router – keep your router state inside your Redux store redux-promise-middleware - Redux middleware for resolving and rejecting promises redux-thunk - Thunk middleware for Redux redux-batched-updates - Batch React updates that occur as a result of Redux dispatches, to prevent cascading renders. redux-combine-actions - Redux middleware that allows you to easy combine actions and dispatch them sequentially redux-catch-promise - Extended replacement of redux-thunk middleware to supporting async-await functions and implement server-side rendering for React components with async state redux-delegator - Compose redux reducers in a structured way routex - Simple router for Redux universal applications. Can be used with React too redux-persist-store - Persist and rehydrate a redux store adrenaline - React bindings for Redux with Relay in mind redux-localstorage - Store enhancer that syncs (a subset) of your Redux store state to localstorage. redux-storage - Persistence layer for redux with flexible backends redux-pouchdb - sync store state to pouchdb redux-vstack-router - Helpers to bind vstack-router to redux redux-create-store redux-batched-subscribe - Batch calls to subscribe handlers with a custom function, including debouncing or React batched updates. redux-logger - Logger middleware for Redux redux-node-logger - A Redux Logger for Node Environments redux-diff-logger - Diff logger between states for Redux redux-debug - debug(…) middleware for Redux redux-requests - Avoid issuing duplicate HTTP requests redux-owl - Redux One Way Linking redux-act - An opinionated lib to create actions and reducers for Redux redux-act-async - Reducing boilerplate when creating asynchronous actions in Redux redux-raven-middleware - Redux middleware for sending error reports to Sentry through raven-js redux-routing - Universal routing built on top of redux redux-undo - Simple undo/redo functionality for redux state containers rn-redux-mixpanel - Configurable Redux middleware that sends your actions &amp; user profile data to Mixpanel redux-falcor - Connect your redux front-end to your falcor back-end redux-analytics - Trigger analytics events based on your event metadata redux-ignore - Ignore redux actions by array or filter function redux-recycle - Reset the redux state on certain actions re-notif A notification center based on React &amp; Redux. redux-lunr - Make your redux store searchable with Lunr.js redux-ensure-fsa - Development middleware to check for FSA-compliant actions redux-pagan - internationalization via redux redux-debounce - Debounce your actions! redux-future - FSA-compliant future monad middleware for redux redux-io - FSA-compliant io monad middleware for redux redux-either - FSA-compliant either monad middleware for redux redux-timeout - Trigger actions based on timeouts redux-observable-middleware - Redux middleware for subscribing to observables redux-observable - RxJS 5-based middleware for Redux. Compose and cancel actions as epics. redux-deferred - Redux middleware for jQuery Deferred Object redux-task - A simple Side Effects manager for redux redux-gen - Generator based middleware for redux redux-authentication - Authentication component for Redux socket.io-redux - Redux middleware to emit action via socket.io redux-catch - Error catcher middleware for Redux reducers and middlewares redux-elm-middleware - Elm middleware for redux redux-api-middleware - Redux API middleware based on the real-world example redux-mediaquery - Redux ActionCreator to put responsive-design breakpoints in your store redux-amrc - Redux async middleware and reducer creator redux-fetch-middleware - Redux middleware that help user to treat simple request via fetch api Tools reactotron - Control, monitor, and instrument your React Native apps from the comfort of your TTY redux-test-recorder - Redux test recorder is a redux middleware + included component for automagically generating tests for your reducers based on the actions in your app redux-devtools - DevTools for Redux with hot reloading, action replay, and customizable UI react-router-redux - Ruthlessly simple bindings to keep react-router and redux in sync redux-tiny-router - A Router made for Redux, stop using the router as a controller it’s just state! redux-devtools-gentest-plugin - Generate mocha like tests from redux-devtools session generator-redux - CLI tools for Redux: next-gen functional Flux/React with devtools generator-reactapp - Yeoman generator for react app with redux generator-redux-app - Scaffold out a redux app with counter example and react-router redux-loader - A high order component for Redux. This components loads resources and passes them to the child components via props redux-rest - Automatically create Flux action constants, action creators and Redux reducers for your REST API react-reach - A library to communicate with Graphql through Redux redux-api - Flux REST API for redux infrastructure redux-store-validator - Add validation to your Redux reducers firedux - Firebase + Redux for ReactJS vstack-router - Universal router redux-ecommerce - E-commerce flux with redux redux-form - An ES7 decorator for forms using Redux and React redux-form-validation - Form validation for controlled &amp; uncontrolled inputs simple-redux-form - A tiny redux-form alternative Higher Order Component for forms. redux-slider-monitor - A custom monitor for Redux DevTools to replay recorded Redux actions updeep - Easily update nested frozen objects and arrays in a declarative and immutable manner redux-immutable - Streamlines use of Immutable.js with Redux reducers. redux-import-export-monitor - A monitor for copying your serialized action log to the clipboard, as well as pasting it in from somewhere else icedam - Just-in-time immutability: freezes data sent to views. react-inline-grid - Predictable flexbox based grid for React using Redux and Immutable-js. redux-easy-actions - Sugar library for creating Redux or Flux actions redux-mount - Mount state data and change its state values on the fly redux-multi - Dispatch multiple actions from one action creator immu - A tiny, fail-fast, lazy, immutable Javascript objects library Generate standard action creators and reducers for CRUD applications Redux &amp; ImmutableJs - Integration of Redux &amp; ImmutableJs that 100% conforms Redux standards redux-tcomb - Immutable and type-checked state and actions for Redux redux-react-router-transitions - Attach react-router transitions to arbitrary actions redux-optimist - Optimistically apply actions that can be later commited or reverted. redux-devtools-diff-monitor - Redux DevTools – Diff Monitor redux-store-visualizer - Visualize Redux store in real time generator-redux - CLI tools for Redux: next-gen functional Flux/React with devtools generator-reactapp - Yeoman generator for react app with redux redux-viewmodel - ViewModel wrapping for Redux &amp; React redux-utils - Utility functions for Redux multireducer - A utility to wrap many copies of a single Redux reducer into a single key-based reducer subdivide - User defined UI layout: Every pane can be subdivided and any widget assigned to any pane replux - Self contained components and enhancements for Redux redux-immutable-utils - Utilities for using Immutable with Redux recompose - A microcomponentization toolkit for React redux-lift - Lifting for Redux redux-router5 - router5 integration with Redux redux-devtools-extension - Redux DevTools Extension universal-redux-router - A very simple router for Redux and React that works on both server and client redux-watch - Watch/monitor for state changes on an object path redux-devtools-filterable-log-monitor - Filterable tree view monitor for Redux DevTools redux-flash-notification - A flash notification component for Redux redux-saga - An alternative side effect model for Redux apps remote-redux-devtools - Use Redux DevTools remotely for React Native, hybrid, desktop and server side Redux apps redux-devtools-dispatch - Dispatch your actions manually to test if your app reacts well redux-loop - Sequence your effects naturally and purely by returning them from your reducers redux-orm - A small, simple and immutable ORM to manage data in your Redux store redux-bacon - Utilities for attaching Bacon.js to Redux rereduce - Reducer library for Redux redux-decorators - A ridiculously good syntax for working with Redux and TypeScript. Currently limited to Angular 2 but could potentially be used elsewhere redux-test-reducer - Simple and clean testing mechanism for Redux reducers redux-devtools-inspector - Another Redux DevTools Monitor redux-ava - Helpers for writing Redux tests in AVA redux-cli - An opinionated CLI for building redux/react apps quicker redux-saga-rxjs - RxJS implementation of Saga pattern for redux redux-actions-assertions - Assertions for redux actions testing redux-duck - Helper function to create Redux modules using the ducks-modular-redux proposal redux-dispatch-cli - A CLI tool for Redux remote dispatch. Used in remote-redux-devtools redux-immutable-reducer - Immutable reducer states with Redux redux-bootstrap - configure React + React-Router + Redux + Immutable.js with one function! redux-director - Redux bindings to director router redux-q - Provides a way to queue callbacks until an action is dispatched redux-apist - Creator API actions for redux-thunk reswitch — Write reducers with less boilerplate redux-autoform - Create Redux-Forms dynamically out of metadata redux-ship - Composable, testable and typable side effects Frameworks Jumpsuit - A powerful &amp; efficient React framework. Jump in. Zip up. Build great apps. Jumpstate - Simple and powerful state management for Redux dva - Front-end framework based on react, redux, react-redux, react-router and redux-saga. Vdux - World’s smallest framework. Stateless Virtual DOM Redux Esex - Full-stack Universal JavaScript Framework (Redux+RxJs) Ripster Este - The most complete minimal dev stack / boilerplate for React &amp; Redux universal web apps stardux - Functional DOM containers based on starplate, IncrementalDOM, and redux nux - A Push-Based Functional Reactive Web Application Framework Keo - Plain functions for a more functional Deku approach to creating React components, with functional goodies such as compose, memoize, etc… for free plait - A minimal JavaScript framework for building reactive web components reactuate — A React/Redux stack (not a boilerplate!) with a focus on Domain-Driven Design meatier - Like meteor, but meatier relax - New generation CMS on top of React, Redux and GraphQL lovli.js - A boilerplate for developing react+redux applications with rethinkdb/horizon as realtime database and express for the server kea - Well-readable, self-documenting and easily refactorable framework that brings your data to life! Comes with scaffolding tools :bird: Feeble - A framework built on top of React/Redux/redux-saga which aims to make building React/Redux applications easier and better. Conventional-Redux - A wrapper for react-redux which provides API based on convention over configuration pattern. redux-react-i18n - An i18n solution for redux/react✌🏿✊🏽🤘🏻 Examples Similar libraries flux-ts - A small flux implementation heavily inspired by redux chopped-redux - A very small Flux implementation based on Redux fluxette - Minimalist, functional, and concise Flux rx-redux - A reimplementation of redux using RxJS understate - A simple state manager refer - Redux-like library for handling global state on functional style bobflux - Bobflux is pure functional implementation of FLUX pattern and is fitted to Bobril mobx - Simple, scalable state management Deku - Functional view library for building UI components as an alternative to React Examples Deku + Express + Redux + Crossroads Router deku-redux - Bindings for redux in deku (Standalone plugin)) Incremental DOM - Incremental DOM is a library for building up DOM trees and updating them in-place when data changes Examples Incremental DOM + Redux Flux = Todo App WinJS - Windows Library for JavaScript Examples react-redux-winjs-example Angular - HTML enhanced for web apps Examples Angular + Typescript + Redux ng-redux - Standalone plugin redux-ui-router - ngRedux middleware for Angular UI Router Todo app with ng-redux • ES6 • Webpack https://github.com/InfomediaLtd/angular2-redux-example https://github.com/tomusdrw/angular2-redux-example Angular 2 - One framework. Mobile and desktop Examples angular2-redux-example - Example project for using pure Redux with Angular 2 and TypeScript @angular-redux/store - Angular 2 bindings for Redux angular2-redux - Wrapper components for using Redux in an Angular2 application ng2redux - Angular 2 bindings for Redux implemented with TypeScript and decorators Vue - A library for building modern web interfaces Examples Revue - Redux binding for Vue Vue + Redux Meteor + Vue + Redux Polymer - Build modern apps using web components Examples polymer-redux redux-store-element Ember - A framework for creating ambitious web applications Examples Meteor - Build apps that are a delight to use, faster than you ever thought possible Examples meteor-react-redux-example meteor-flux-leaderboard Mithril - A Javascript Framework for Building Brilliant Applications Examples mithril-redux-starter-hmr Backbone - Give your JS App some Backbone with Models, Views, Collections, and Events Tools backbone-redux — The easy way to keep your backbone collections and redux store in sync Aurelia - is a next gen JavaScript client framework for mobile, desktop and web that leverages simple conventions to empower your creativity Examples aurelia-redux-todo - An implementation of the Redux todo demo app using Aurelia Managing State in Aurelia: How to Use Aurelia with Redux Riot - A React-like user interface micro-library Examples riotredux-budget app-skeleton Electron - Build cross platform desktop apps with web technologies electron-react-boilerplate (Electron + Redux + Hot Reload) A-Frame - A web framework for building VR experiences aframe-redux-component Chrome Extensions Redux Chrome Extension React Chrome Extension Boilerplate (Webpack + Redux + Babel and etc Examples Pumgrana Plugin Ruby on Rails Resources React Webpack Rails Tutorial Using Redux react_on_rails gem Other languages .NET https://github.com/GuillaumeSalles/redux.NET https://github.com/pshomov/reducto Java https://github.com/glung/redux-java https://github.com/trikita/jedux https://github.com/izumin5210/Droidux Swift https://github.com/ReSwift/reduxSwift https://github.com/Swift-Flow/Swift-Flow https://github.com/ReSwift/ReSwift and docs Purescript https://github.com/brakmic/purescript-redux https://github.com/faber/purescript-purdux","categories":[{"name":"Readme","slug":"Readme","permalink":"https://React-Apollo.github.io/categories/Readme/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"react","slug":"react","permalink":"https://React-Apollo.github.io/tags/react/"}]},{"title":"redux-logic","slug":"redux-logic","date":"2017-03-08T00:04:10.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2017/03/08/redux-logic/","link":"","permalink":"https://React-Apollo.github.io/2017/03/08/redux-logic/","excerpt":"","text":"redux-logic “One place for all your business logic and action side effects” Redux middleware that can: intercept (validate/transform/augment) actions AND perform async processing (fetching, I/O, side effects) tl;drWith redux-logic, you have the freedom to write your logic in your favorite JS style: plain callback code - dispatch(resultAction) promises - return axios.get(url).then(...) async/await - result = await fetch(url) observables - ob$.next(action1) Use the type of code you and your team are comfortable and experienced with. Leverage powerful declarative features by simply setting properties: filtering for action type(s) or with regular expression(s) cancellation on receiving action type(s) use only response for the latest request debouncing throttling dispatch actions - auto decoration of payloads Testing your logic is straight forward and simple. With simple code your logic can: intercept actions before they hit the reducer validate, verify, auth check actions and allow/reject or modify actions transform - augment/enhance/modify actions process - async processing and dispatching, orchestration, I/O (ajax, REST, subscriptions, GraphQL, web sockets, …) Redux-logic makes it easy to use code that is split into bundles, so you can dynamically load logic right along with your split UI. Server rendering is simplified with redux-logic since it lets you know when all your async fetching is complete without manual tracking. Inspired by redux-observable epics, redux-saga, and custom redux middleware, redux-logic combines ideas of each into a simple easy to use API. Quick ExampleThis is an example of logic which will listen for actions of type FETCH_POLLS and it will perform ajax request to fetch data for which it dispatches the results (or error) on completion. It supports cancellation by allowing anything to send an action of type CANCEL_FETCH_POLLS. It also uses take latest feature that if additional FETCH_POLLS actions come in before this completes, it will ignore the outdated requests. The developer can just declare the type filtering, cancellation, and take latest behavior, no code needs to be written for that. That leaves the developer to focus on the real business requirements which are invoked in the process hook. 12345678910111213141516171819202122const fetchPollsLogic = createLogic(&#123; // declarative built-in functionality wraps your code type: FETCH_POLLS, // only apply this logic to this type cancelType: CANCEL_FETCH_POLLS, // cancel on this type latest: true, // only take latest // your code here, hook into one or more of these execution // phases: validate, transform, and/or process process(&#123; getState, action &#125;, dispatch, done) &#123; axios.get('https://survey.codewinds.com/polls') .then(resp =&gt; resp.data.polls) .then(polls =&gt; dispatch(&#123; type: FETCH_POLLS_SUCCESS, payload: polls &#125;)) .catch(err =&gt; &#123; console.error(err); // log since could be render err dispatch(&#123; type: FETCH_POLLS_FAILED, payload: err, error: true &#125;) &#125;) .then(() =&gt; done()); // call done when finished dispatching &#125;&#125;); Since redux-logic gives you the freedom to use your favorite style of JS code (callbacks, promises, async/await, observables), it supports many features to make that easier, explained in more detail. Table of contents Goals Usage Full API Examples - JSFiddle and full examples Comparison summaries to fat action creators, thunks, redux-observable, redux-saga, custom middleware SAM/PAL pattern Other - todo, inspiration, license Goals organize business logic keeping action creators and reducers clean action creators are light and just post action objects reducers just focus on updating state intercept and perform validations, verifications, authentication intercept and transform actions perform async processing, orchestration, dispatch actions wrap your core business logic code with declarative behavior filtered - apply to one or many action types or even all actions cancellable - async work can be cancelled limiting (like taking only the latest, throttling, and debouncing) features to support business logic and large apps have access to full state to make decisions easily composable to support large applications inject dependencies into your logic, so you have everything needed in your logic code dynamic loading of logic for splitting bundles in your app your core logic code stays focussed and simple, don’t use generators or observables unless you want to. create subscriptions - streaming updates easy testing - since your code is just a function it’s easy to isolate and test Usage12npm install rxjs --savenpm install redux-logic --save 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// in configureStore.jsimport &#123; createLogic, createLogicMiddleware &#125; from 'redux-logic';import rootReducer from './rootReducer';import arrLogic from './logic';const deps = &#123; // optional injected dependencies for logic // anything you need to have available in your logic A_SECRET_KEY: 'dsfjsdkfjsdlfjls', firebase: firebaseInstance&#125;;const logicMiddleware = createLogicMiddleware(arrLogic, deps);const middleware = applyMiddleware( logicMiddleware);const enhancer = middleware; // could compose in dev tools tooexport default function configureStore() &#123; const store = createStore(rootReducer, enhancer); return store;&#125;// in logic.js - combines logic from across many files, just// a simple array of logic to be used for this appexport default [ ...todoLogic, ...pollsLogic];// in polls/logic.jsconst validationLogic = createLogic(&#123; type: ADD_USER, validate(&#123; getState, action &#125;, allow, reject) &#123; const user = action.payload; if (!getState().users[user.id]) &#123; // can also hit server to check allow(action); &#125; else &#123; reject(&#123; type: USER_EXISTS_ERROR, payload: user, error: true &#125;) &#125; &#125;&#125;);const addUniqueId = createLogic(&#123; type: '*', transform(&#123; getState, action &#125;, next) &#123; // add unique tid to action.meta of every action const existingMeta = action.meta || &#123;&#125;; const meta = &#123; ...existingMeta, tid: shortid.generate() &#125;, next(&#123; ...action, meta &#125;); &#125;&#125;);const fetchPollsLogic = createLogic(&#123; type: FETCH_POLLS, // only apply this logic to this type cancelType: CANCEL_FETCH_POLLS, // cancel on this type latest: true, // only take latest process(&#123; getState, action &#125;, dispatch, done) &#123; axios.get('https://survey.codewinds.com/polls') .then(resp =&gt; resp.data.polls) .then(polls =&gt; dispatch(&#123; type: FETCH_POLLS_SUCCESS, payload: polls &#125;)) .catch(err =&gt; &#123; console.error(err); // log since could be render err dispatch(&#123; type: FETCH_POLLS_FAILED, payload: err, error: true &#125;) &#125;) .then(() =&gt; done()); &#125;&#125;);// pollsLogicexport default [ validationLogic, addUniqueId, fetchPollsLogic]; processOptions introduced for redux-logic@0.8.2 allowing for even more streamlined codeprocessOptions has these new properties which affect the process hook behavior: dispatchReturn - the returned value of the process function will be dispatched or if it is a promise or observable then the resolve, reject, or observable values will be dispatched applying any successType or failType logic if defined. Default is determined by arity of process fn, true if dispatch not provided, false otherwise. Details successType - dispatch this action type using contents of dispatch as the payload (also would work with with promise or observable). You may alternatively provide an action creator function to use instead and it will receive the value as only parameter. Default: undefined. if successType is a string action type create action using successType and provide value as payload. ex: with successType:&#39;FOO&#39;, result would be { type: &#39;FOO&#39;, payload: value } if successType is an action creator fn receiving the value as only parameter use the return value from the action creator fn for dispatching ex: successType: x =&gt; ({ type: &#39;FOO&#39;, payload: x }) if the action creator fn returns a falsey value like undefined then nothing will be dispatched. This allows your action creator to control whether something is actually dispatched based on the value provided to it. failType - dispatch this action type using contents of error as the payload, sets error: true (would also work for rejects of promises or error from observable). You may alternatively provide an action creator function to use instead which will receive the error as the only parameter. Default: undefined. if failType is a string action type create action using failType, provide value as the payload, and set error to true. ex: with failType:&#39;BAR&#39;, result would be { type: &#39;BAR&#39;, payload: errorValue, error: true } if failType is an action creator function receiving the error value as its only parameter use the return value from the action creator fn for dispatching. ex: failType: x =&gt; ({ type: &#39;BAR&#39;, payload: x, error: true }) if the action creator fn returns a falsey value like undefined then nothing will be dispatched. This allows your action creator to control whether something is actually dispatched based on teh value provided to it. The successType and failType would enable clean code, where you can simply return a promise or observable that resolves to the payload and rejects on error. The resulting code doesn’t have to deal with dispatch and actions directly. 12345678910111213141516171819202122232425const fetchPollsLogic = createLogic(&#123; // declarative built-in functionality wraps your code type: FETCH_POLLS, // only apply this logic to this type cancelType: CANCEL_FETCH_POLLS, // cancel on this type latest: true, // only take latest processOptions: &#123; // optional since the default is true when dispatch is omitted from // the process fn signature dispatchReturn: true, // use returned/resolved value(s) for dispatching // provide action types or action creator functions to be used // with the resolved/rejected values from promise/observable returned successType: FETCH_POLLS_SUCCESS, // dispatch this success act type failType: FETCH_POLLS_FAILED, // dispatch this failed action type &#125;, // Omitting dispatch from the signature below makes the default for // dispatchReturn true allowing you to simply return obj, promise, obs // not needing to use dispatch directly process(&#123; getState, action &#125;) &#123; return axios.get('https://survey.codewinds.com/polls') .then(resp =&gt; resp.data.polls); &#125;&#125;); This is pretty nice leaving us with mainly our business logic code that could be easily extracted and called from here. Full APISee the docs for the full api ExamplesJSFiddle live examples search async axios fetch - live search using debounce and take latest functionality with axios fetch search rxjs ajax fetch - live search using debounce and take latest functionality with rxjs ajax fetch search rxjs ajax fetch - using processOptions - live search using debounce and take latest with rxjs ajax fetch using processOptions to streamline the code async axios fetch - single page - displayed using React async rxjs-ajax fetch - async fetching using RxJS ajax which supports XHR abort for cancels async axios fetch - single page redux only - just the redux and redux-logic code async axios fetch - using processOptions - using processOptions to streamline your code further with React async rxjs-ajax fetch - using processOptions - async fetch using RxJS ajax (supporting XHR abort on cancel) and processOptions for clean code. async await - react - using ES7 async functions (async/await) displaying with React async await - redux only - using ES7 async functions (async/await) - just redux and redux-logic code async await - react processOptions - using ES7 async functions (async/await) with processOptions, displayed with React Full examples search-async-fetch - search async fetch example using axios uses debouncing and take latest features async-fetch-vanilla - async fetch example using axios async-rxjs-ajax-fetch - async fetch example using RxJS ajax (supporting XHR abort on cancel) and redux-actions async-fetch-proc-options - async fetch example using axios and the new processOptions feature async-rxjs-ajax-proc-options - async RxJS ajax (with XHR abort on cancel) fetch example using axios and the new processOptions feature async-await - ES7 async functions - async fetch example using axios and ES7 async functions (async/await) async-await - ES7 async functions with processOptions - async fetch example using axios and ES7 async functions (async/await) and using the new processOptions feature countdown - a countdown timer implemented with setInterval countdown-obs - a countdown timer implemented with Rx.Observable.interval form-validation - form validation and async post to server using axios, displays updated user list notification - notification message example showing at most N messages for X amount of time, rotating queued messages in as others expire search-single-file - search async fetch example with all code in a single file and displayed with React single-file-redux - async fetch example with all code in a single file and appended to the container div. Only redux and redux-logic code. Comparison summariesFollowing are just short summaries to compare redux-logic to other approaches. For a more detailed comparison with examples, see by article in docs, Where do I put my business logic in a React-Redux application?. Compared to fat action creators no easy way to cancel or do limiting like take latest with fat action creators action creators would not have access to the full global state so you might have to pass down lots of extra data that isn’t needed for rendering. Every time business logic changes might require new data to be made available no global interception using just action creators - applying logic or transformations across all or many actions Testing components and fat action creators may require running the code (possibly mocked API calls). Compared to redux-thunk With thunks business logic is spread over action creators With thunks there is not an easy way to cancel async work nor to perform (take latest) limiting no global interception with thunks - applying logic or transformations across all or many actions Testing components and thunked action creators may require running the code (possibly mocked API calls). When you have a thunk (function or promise) you don’t know what it does unless you execute it. Compared to redux-observable redux-logic doesn’t require the developer to use rxjs observables. It uses observables under the covers to provide cancellation, throttling, etc. You simply configure these parameters to get this functionality. You can still use rxjs in your code if you want, but not a requirement. redux-logic hooks in before the reducer stack like middleware allowing validation, verification, auth, tranformations. Allow, reject, tranform actions before they hit your reducers to update your state as well as accessing state after reducers have run. redux-observable hooks in after the reducers have updated state so they have no opportuntity to prevent the updates. Compared to redux-saga redux-logic doesn’t require you to code with generators redux-saga relies on pulling data (usually in a never ending loop) while redux-logic and logic are reactive, responding to data as it is available redux-saga runs after reducers have been run, redux-logic can intercept and allow/reject/modify before reducers run also as well as after Compared to custom redux middleware Both are fully featured to do any type of business logic (validations, tranformations, processing) redux-logic already has built-in capabilities for some of the hard stuff like cancellation, limiting, dynamic loading of code. With custom middleware you have to implement all functionality. No safety net, if things break it could stop all of your future actions Testing requires some mocking or setup Implementing SAM/PAL PatternThe SAM (State-Action-Model) pattern is a pattern introduced by Jean-Jacques Dubray. Also known as the PAL (proposer, acceptor, learner) pattern based on Paxos terminology. A few of the challenging parts of implementing this with a React-Redux application are: where to perform the accept (interception) of the proposed action performing validation, verification, authentication against the current model state. Based on the current state, it might be appropriate to modify the action, dispatch a different action, or simply suppress the action. how to trigger actions based on the state after the model has finished updating, referred to as the NAP (next-action-predicate). Custom Redux middleware can be introduced to perform this logic, but you’ll be implementing most everything on your own. With redux-logic you can implement the SAM / PAL pattern easily in your React/Redux apps. Namely you can separate out your business logic from your action creators and reducers keeping them thin. redux-logic provides a nice place to accept, reject, and transform actions before your reducers are run. You have access to the full state to make decisions and you can trigger actions based on the updated state as well. Solving those SAM challenges previously identified using redux-logic: perform acceptance in redux-logic validate hooks, you have access to the full state (model) of the app to make decisions. You can perform synchronous or asynchronous logic to determine whether to accept the action and you may augment, modify, substitute actions, or suppress as desired. Perform NAP processing in redux-logic process hooks. The process hook runs after the actions have been sent down to the reducers so you have access to the full model (state) after the updates where you can make decisions and dispatch additional actions based on the updated state. Inspirationredux-logic was inspired from these projects: redux-observable epics redux-saga redux middleware Minimized/gzipped size with all deps(redux-logic only includes the modules of RxJS 5 that it uses)1redux-logic.min.js.gz 11KB Note: If you are already including RxJS 5 into your project then the resulting delta will be much smaller. TODO add typescript support more docs more examples evaulate additional features as outlined above Get involvedIf you have input or ideas or would like to get involved, you may: contact me via twitter @jeffbski - http://twitter.com/jeffbski open an issue on github to begin a discussion - https://github.com/jeffbski/redux-logic/issues fork the repo and send a pull request (ideally with tests) - https://github.com/jeffbski/redux-logic See the contributing guide SupportersThis project is supported by CodeWinds Training License - MIT MIT license","categories":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/categories/Redux/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"}]},{"title":"CheatSheet|React Native Styling Cheat Sheet","slug":"React Native Styling Cheat Sheet","date":"2017-01-28T08:17:07.000Z","updated":"2019-04-28T05:52:57.892Z","comments":true,"path":"2017/01/28/React Native Styling Cheat Sheet/","link":"","permalink":"https://React-Apollo.github.io/2017/01/28/React Native Styling Cheat Sheet/","excerpt":"","text":"React Native Styling Cheat SheetMost of the React Native styling material in one page. Imported from the official docs. ContentsGeneral Flexbox ShadowPropTypesIOS Transforms Components Image ScrollView Text View Flexbox Name Type Description alignItems oneOf flex-start, flex-end, center, stretch alignItems aligns children in the cross direction. For example, if children are flowing vertically, alignItems controls how they align horizontally. It works like align-items in CSS, except the default value is stretch instead of flex-start. See https://css-tricks.com/almanac/properties/a/align-items/ for more detail. alignSelf oneOf auto, flex-start, flex-end, center, stretch controls how a child aligns in the cross direction, overriding the alignItems of the parent. It works like align-self in CSS. See https://css-tricks.com/almanac/properties/a/align-self/ for more detail. borderBottomWidth number borderBottomWidth works like border-bottom-width in CSS. See http://www.w3schools.com/cssref/pr_border-bottom_width.asp for more details. borderLeftWidth number borderLeftWidth works like border-left-width in CSS. See http://www.w3schools.com/cssref/pr_border-bottom_width.asp for more details. borderRightWidth number borderRightWidth works like border-right-width in CSS. See http://www.w3schools.com/cssref/pr_border-right_width.asp for more details. borderTopWidth number borderTopWidth works like border-top-width in CSS. See http://www.w3schools.com/cssref/pr_border-top_width.asp for more details. borderWidth number borderWidth works like border-width in CSS. See http://www.w3schools.com/cssref/pr_border-width.asp for more details. bottom number bottom is the number of logical pixels to offset the bottom edge of this component. It works similarly to bottom in CSS, but in React Native you must use logical pixel units, rather than percents, ems, or any of that. See https://developer.mozilla.org/en-US/docs/Web/CSS/bottom for more details of how top affects layout. flex number In React Native flex does not work the same way that it does in CSS. flex is a number rather than a string, and it works according to the css-layout library at https://github.com/facebook/css-layout . When flex is a positive number, it makes the component flexible and it will be sized proportional to its flex value. So a component with flex set to 2 will take twice the space as a component with flex set to 1. When flex is 0, the component is sized according to width and height and it is inflexible. When flex is -1, the component is normally sized according width and height. However, if there’s not enough space, the component will shrink to its minWidth and minHeight. flexDirection oneOf row, row-reverse, column, column-reverse flexDirection controls which directions children of a container go. row goes left to right, column goes top to bottom, and you may be able to guess what the other two do. It works like flex-direction in CSS, except the default is column. See https://css-tricks.com/almanac/properties/f/flex-direction/ for more detail. flexWrap oneOf wrap, nowrap flexWrap controls whether children can wrap around after they hit the end of a flex container. It works like flex-wrap in CSS. See https://css-tricks.com/almanac/properties/f/flex-wrap/ for more detail. height number height sets the height of this component. It works similarly to height in CSS, but in React Native you must use logical pixel units, rather than percents, ems, or any of that. See http://www.w3schools.com/cssref/pr_dim_width.asp for more details. justifyContent oneOf flex-start, flex-end, center, space-between, space-around justifyContent aligns children in the main direction. For example, if children are flowing vertically, justifyContent controls how they align vertically. It works like justify-content in CSS. See https://css-tricks.com/almanac/properties/j/justify-content/ for more detail. left number left is the number of logical pixels to offset the left edge of this component. It works similarly to left in CSS, but in React Native you must use logical pixel units, rather than percents, ems, or any of that. See https://developer.mozilla.org/en-US/docs/Web/CSS/left for more details of how left affects layout. margin number Setting margin has the same effect as setting each of marginTop, marginLeft, marginBottom, and marginRight. marginBottom number marginBottom works like margin-bottom in CSS. See http://www.w3schools.com/cssref/pr_margin-bottom.asp for more details. marginHorizontal number Setting marginHorizontal has the same effect as setting both marginLeft and marginRight. marginLeft number marginLeft works like margin-left in CSS. See http://www.w3schools.com/cssref/pr_margin-left.asp for more details. marginRight number marginRight works like margin-right in CSS. See http://www.w3schools.com/cssref/pr_margin-right.asp for more details. marginTop number marginTop works like margin-top in CSS. See http://www.w3schools.com/cssref/pr_margin-top.asp for more details. marginVertical number Setting marginVertical has the same effect as setting both marginTop and marginBottom. maxHeight number maxHeight is the maximum height for this component, in logical pixels. It works similarly to max-height in CSS, but in React Native you must use logical pixel units, rather than percents, ems, or any of that. See http://www.w3schools.com/cssref/pr_dim_max-height.asp for more details. maxWidth number maxWidth is the maximum width for this component, in logical pixels. It works similarly to max-width in CSS, but in React Native you must use logical pixel units, rather than percents, ems, or any of that. See http://www.w3schools.com/cssref/pr_dim_max-width.asp for more details. minHeight number minHeight is the minimum height for this component, in logical pixels. It works similarly to min-height in CSS, but in React Native you must use logical pixel units, rather than percents, ems, or any of that. See http://www.w3schools.com/cssref/pr_dim_min-height.asp for more details. minWidth number minWidth is the minimum width for this component, in logical pixels. It works similarly to min-width in CSS, but in React Native you must use logical pixel units, rather than percents, ems, or any of that. See http://www.w3schools.com/cssref/pr_dim_min-width.asp for more details. padding number padding works like padding in CSS. It’s like setting each of paddingTop, paddingBottom, paddingLeft, and paddingRight to the same thing. See http://www.w3schools.com/css/css_padding.asp for more details. paddingBottom number paddingBottom works like padding-bottom in CSS. See http://www.w3schools.com/cssref/pr_padding-bottom.asp for more details. paddingHorizontal number Setting paddingHorizontal is like setting both of paddingLeft and paddingRight. paddingLeft number paddingLeft works like padding-left in CSS. See http://www.w3schools.com/cssref/pr_padding-left.asp for more details. paddingRight number paddingRight works like padding-right in CSS. See http://www.w3schools.com/cssref/pr_padding-right.asp for more details. paddingTop number paddingTop works like padding-top in CSS. See http://www.w3schools.com/cssref/pr_padding-top.asp for more details. paddingVertical number Setting paddingVertical is like setting both of paddingTop and paddingBottom. position oneOf absolute, relative position in React Native is similar to regular CSS, but everything is set to relative by default, so absolute positioning is always just relative to the parent. If you want to position a child using specific numbers of logical pixels relative to its parent, set the child to have absolute position. If you want to position a child relative to something that is not its parent, just don’t use styles for that. Use the component tree. See https://github.com/facebook/css-layout for more details on how position differs between React Native and CSS. right number right is the number of logical pixels to offset the right edge of this component. It works similarly to right in CSS, but in React Native you must use logical pixel units, rather than percents, ems, or any of that. See https://developer.mozilla.org/en-US/docs/Web/CSS/right for more details of how right affects layout. top number top is the number of logical pixels to offset the top edge of this component. It works similarly to top in CSS, but in React Native you must use logical pixel units, rather than percents, ems, or any of that. See https://developer.mozilla.org/en-US/docs/Web/CSS/top for more details of how top affects layout. width number width sets the width of this component. It works similarly to width in CSS, but in React Native you must use logical pixel units, rather than percents, ems, or any of that. See http://www.w3schools.com/cssref/pr_dim_width.asp for more details. zIndex number zIndex controls which components display on top of others. Normally, you don’t use zIndex. Components render according to their order in the document tree, so later components draw over earlier ones. zIndex may be useful if you have animations or custom modal interfaces where you don’t want this behavior. It works like the CSS z-index property - components with a larger zIndex will render on top. Think of the z-direction like it’s pointing from the phone into your eyeball. See https://developer.mozilla.org/en-US/docs/Web/CSS/z-index for more detail. Shadow Prop Types IOS Name Type Description shadowColor customColorPropType Sets the drop shadow color shadowOffset customReactPropTypes.shape( {width: ReactPropTypes.number, height: ReactPropTypes.number} ) Sets the drop shadow offset shadowOpacity number Sets the drop shadow opacity (multiplied by the color’s alpha component) shadowRadius number Sets the drop shadow blur radius Transforms Name Type decomposedMatrix customDecomposedMatrixPropType transform customReactPropTypes.arrayOf( ReactPropTypes.oneOfType([ ReactPropTypes.shape({perspective: ReactPropTypes.number}), ReactPropTypes.shape({rotate: ReactPropTypes.string}), ReactPropTypes.shape({rotateX: ReactPropTypes.string}), ReactPropTypes.shape({rotateY: ReactPropTypes.string}), ReactPropTypes.shape({rotateZ: ReactPropTypes.string}), ReactPropTypes.shape({scale: ReactPropTypes.number}), ReactPropTypes.shape({scaleX: ReactPropTypes.number}), ReactPropTypes.shape({scaleY: ReactPropTypes.number}), ReactPropTypes.shape({translateX: ReactPropTypes.number}), ReactPropTypes.shape({translateY: ReactPropTypes.number}), ReactPropTypes.shape({skewX: ReactPropTypes.string}), ReactPropTypes.shape({skewY: ReactPropTypes.string}) ]) ) transformMatrix customTransformMatrixPropType Image Name Required Type Platforms Description …Flexbox …ShadowPropTypesIOS …Transforms backfaceVisibility false oneOf visible, hidden backgroundColor false ColorPropType borderBottomLeftRadius false number borderBottomRightRadius false number borderColor false ColorPropType borderRadius false number borderTopLeftRadius false number borderTopRightRadius false number borderWidth false number opacity false number overflow false oneOf visible, hidden resizeMode false oneOf Object.keys(ImageResizeMode)) tintColor false ColorPropType Changes the color of all the non-transparent pixels to the tintColor. overlayColor false string android When the image has rounded corners, specifying an overlayColor will cause the remaining space in the corners to be filled with a solid color. This is useful in cases which are not supported by the Android implementation of rounded corners: - Certain resize modes, such as ‘contain’ - Animated GIFs A typical way to use this prop is with images displayed on a solid background and setting the overlayColor to the same color as the background. For details of how this works under the hood, see http://frescolib.org/docs/rounded-corners-and-circles.html ScrollView Name Required Type Platforms Description …Flexbox …ShadowPropTypesIOS …Transforms backfaceVisibility false oneOf visible, hidden backgroundColor false ColorPropType borderBottomColor false ColorPropType borderBottomLeftRadius false number borderBottomRightRadius false number borderBottomWidth false number borderColor false ColorPropType borderLeftColor false ColorPropType borderLeftWidth false number borderRadius false number borderRightColor false ColorPropType borderRightWidth false number borderStyle false oneOf solid, dotted, dashed borderTopColor false ColorPropType borderTopLeftRadius false number borderTopRightRadius false number borderTopWidth false number borderWidth false number opacity false number overflow false oneOf visible, hidden elevation false number android (Android-only) Sets the elevation of a view, using Android’s underlying elevation API. This adds a drop shadow to the item and affects z-order for overlapping views. Only supported on Android 5.0+, has no effect on earlier versions. Text Name Required Type Platforms Description …View color false ColorPropType fontFamily false string fontSize false number fontStyle false oneOf normal, italic fontWeight false oneOf normal, bold, 100, 200, 300, 400, 500, 600, 700, 800, 900 Specifies font weight. The values ‘normal’ and ‘bold’ are supported for most fonts. Not all fonts have a variant for each of the numeric values, in that case the closest one is chosen. lineHeight false number textAlign false oneOf auto, left, right, center, justify Specifies text alignment. The value ‘justify’ is only supported on iOS and fallbacks to left on Android. textDecorationLine false oneOf none, underline, line-through, underline, line-through textShadowColor false ColorPropType textShadowOffset false ReactPropTypes.shape( {width: ReactPropTypes.number, height: ReactPropTypes.number} ) textShadowRadius false number textAlignVertical false oneOf auto, top, bottom, center android letterSpacing false number ios textDecorationColor false ColorPropType ios textDecorationStyle false oneOf solid, double, dotted, dashed ios writingDirection false oneOf auto, ltr, rtl ios View Name Required Type Platforms Description …Flexbox …ShadowPropTypesIOS …Transforms backfaceVisibility false oneOf visible, hidden backgroundColor false ColorPropType borderBottomColor false ColorPropType borderBottomLeftRadius false number borderBottomRightRadius false number borderBottomWidth false number borderColor false ColorPropType borderLeftColor false ColorPropType borderLeftWidth false number borderRadius false number borderRightColor false ColorPropType borderRightWidth false number borderStyle false oneOf solid, dotted, dashed borderTopColor false ColorPropType borderTopLeftRadius false number borderTopRightRadius false number borderTopWidth false number borderWidth false number opacity false number overflow false oneOf visible, hidden elevation false number android (Android-only) Sets the elevation of a view, using Android’s underlying elevation API. This adds a drop shadow to the item and affects z-order for overlapping views. Only supported on Android 5.0+, has no effect on earlier versions. AppendixTypesnumberReactPropTypes.number stringReactPropTypes.string oneOfReactPropTypes.oneOf([values])","categories":[{"name":"CheatSheet","slug":"CheatSheet","permalink":"https://React-Apollo.github.io/categories/CheatSheet/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"UI","slug":"UI","permalink":"https://React-Apollo.github.io/tags/UI/"}]},{"title":"JavaScript的 this 关键字","slug":"javascript中的this关键字","date":"2017-01-10T15:04:34.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2017/01/10/javascript中的this关键字/","link":"","permalink":"https://React-Apollo.github.io/2017/01/10/javascript中的this关键字/","excerpt":"","text":"主要参考《javascrpt设计模式与开发指南》 javascript(缩写js)语言中的this和java,php中的this是完全不同的概念。js中的this是动态的，总是指向一个对象，但是这个对象是谁，需要根据函数的调用上下文来决定。 作为对象的方法调用(显示绑定) 作为普通的函数来调用(默认绑定) 作为构造器来调用 call和apply方法调用 1作为对象的方法调用12345678910var obj = &#123; a: 1, getA: function()&#123; alert ( this === obj ); // 输出：true alert ( this.a ); // 输出: 1 &#125; &#125;; obj.getA(); //函数被绑定在对象obj上，this指向obj对象 //这种方法，可以立即看到绑定的对象是那一个，所以是最简单的 2作为普通函数的调用1234567891011121314151617181920//在浏览器的JavaScript 里，这个全局对象是window 对象。 window.name = 'globalName'; var getName = function()&#123; //这个函数没有指定对象，默认绑定在window对象上 return this.name; &#125;; console.log( getName() ); // 输出：globalName //或者： window.name = 'globalName'; var myObject = &#123; name: 'sven', getName: function()&#123; return this.name; &#125; &#125;; //下面这个引用是比较迷惑人的，在用变量引用一个对象的方法时候，变量仅仅指向函数本身，和原来函数定义在哪个对象里没有任何关系，这一点要注意 var getName = myObject.getName; //getName函数任然是默认绑定在window全局对象上 console.log( getName() ); // globalName 下面这个实例，我个人认为是js this中最为迷惑的地方，需要注意，可能学了很长时间都对这个地方迷惑，没有什么原因，js就是这么规定的。 那，到底规定什么了？就是 函数内部的函数，也就是闭包函数的对象是默认绑定在全局，全局，全局 对象上的，一定，一定，一定 要记住这一点 123456789101112131415161718192021222324252627&lt;body&gt; &lt;div id=\"div1\"&gt;我是一个div&lt;/div&gt; &lt;/body&gt; &lt;script&gt; window.id = 'window'; document.getElementById( 'div1' ).onclick = function()&#123; alert ( this.id ); // 输出：'div1' var callback = function()&#123; //这个函数内部的函数，他是默认绑定在window上的 alert ( this.id ); // 输出：'window' &#125; callback(); &#125;; //那么要是内部函数要使用外部函数绑定的对象怎么办。 //好办，就是把外部函数的对象保存在一个变量中 //经常在代码中看到的 var that=this就是这个作用 //在内部函数要使用同一个对象就可以用that了。或者用 var self=this //这仅仅是变量的名字不同，道理都一样 document.getElementById( 'div1' ).onclick = function()&#123; var that = this; // 保存div 的引用 var callback = function()&#123; alert ( that.id ); // 输出：'div1' //that指向了外部函数的对象 &#125; callback(); &#125;; 在 ECMA es5的严格模式下问题又有改变了。 123use strict 这时候，内部函数的this不在默认指向window对象，而是指向undefine，实际就是没有默认绑定对象。 3构造器调用123456789101112var MyClass = function()&#123; this.name = 'sven'; &#125;; var obj = new MyClass(); //当使用构造器调用的时候，构造器返回一个对象，this就指向这个对象 alert ( obj.name ); // 输出：sven var MyClass = function()&#123; this.name = 'sven'; return &#123; // 显式地返回一个对象 name: 'anne' &#125; &#125;; 4call apply 调用硬式绑定，通过传参方式动态改变函数的绑定对象。 1234567891011121314 var obj1 = &#123; name: 'sven', getName: function()&#123; return this.name; &#125;&#125;;var obj2 = &#123; name: 'anne'&#125;;console.log( obj1.getName() ); // 输出: sven//下面这个函数硬式绑定到obj2对象上console.log( obj1.getName.call( obj2 ) ); // 输出：anne 这就是this的概念","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://React-Apollo.github.io/tags/javascript/"}]},{"title":"ReadMeKoa 框架","slug":"koa","date":"2015-04-17T00:00:00.000Z","updated":"2019-04-28T05:52:57.896Z","comments":true,"path":"2015/04/17/koa/","link":"","permalink":"https://React-Apollo.github.io/2015/04/17/koa/","excerpt":"","text":"Koa是一个类似于Express的Web开发框架，创始人也是同一个人。它的主要特点是，使用了ES6的Generator函数，进行了架构的重新设计。也就是说，Koa的原理和内部结构很像Express，但是语法和内部结构进行了升级。 官方faq有这样一个问题：”为什么koa不是Express 4.0？“，回答是这样的：”Koa与Express有很大差异，整个设计都是不同的，所以如果将Express 3.0按照这种写法升级到4.0，就意味着重写整个程序。所以，我们觉得创造一个新的库，是更合适的做法。“ Koa 应用一个Koa应用就是一个对象，包含了一个middleware数组，这个数组由一组Generator函数组成。这些函数负责对HTTP请求进行各种加工，比如生成缓存、指定代理、请求重定向等等。 12345678var koa = require('koa');var app = koa();app.use(function *()&#123; this.body = 'Hello World';&#125;);app.listen(3000); 上面代码中，变量app就是一个Koa应用。它监听3000端口，返回一个内容为Hello World的网页。 app.use方法用于向middleware数组添加Generator函数。 listen方法指定监听端口，并启动当前应用。它实际上等同于下面的代码。 1234var http = require('http');var koa = require('koa');var app = koa();http.createServer(app.callback()).listen(3000); 中间件Koa的中间件很像Express的中间件，也是对HTTP请求进行处理的函数，但是必须是一个Generator函数。而且，Koa的中间件是一个级联式（Cascading）的结构，也就是说，属于是层层调用，第一个中间件调用第二个中间件，第二个调用第三个，以此类推。上游的中间件必须等到下游的中间件返回结果，才会继续执行，这点很像递归。 中间件通过当前应用的use方法注册。 123456app.use(function* (next)&#123; var start = new Date; // （1） yield next; // （2） var ms = new Date - start; // （3） console.log('%s %s - %s', this.method, this.url, ms); // （4）&#125;); 上面代码中，app.use方法的参数就是中间件，它是一个Generator函数，最大的特征就是function命令与参数之间，必须有一个星号。Generator函数的参数next，表示下一个中间件。 Generator函数内部使用yield命令，将程序的执行权转交给下一个中间件，即yield next，要等到下一个中间件返回结果，才会继续往下执行。上面代码中，Generator函数体内部，第一行赋值语句首先执行，开始计时，第二行yield语句将执行权交给下一个中间件，当前中间件就暂停执行。等到后面的中间件全部执行完成，执行权就回到原来暂停的地方，继续往下执行，这时才会执行第三行，计算这个过程一共花了多少时间，第四行将这个时间打印出来。 下面是一个两个中间件级联的例子。 123456789app.use(function *() &#123; this.body = \"header\\n\"; yield saveResults.call(this); this.body += \"footer\\n\";&#125;);function *saveResults() &#123; this.body += \"Results Saved!\\n\";&#125; 上面代码中，第一个中间件调用第二个中间件saveResults，它们都向this.body写入内容。最后，this.body的输出如下。 123headerResults Saved!footer 只要有一个中间件缺少yield next语句，后面的中间件都不会执行，这一点要引起注意。 1234567891011121314151617app.use(function *(next)&#123; console.log('&gt;&gt; one'); yield next; console.log('&lt;&lt; one');&#125;);app.use(function *(next)&#123; console.log('&gt;&gt; two'); this.body = 'two'; console.log('&lt;&lt; two');&#125;);app.use(function *(next)&#123; console.log('&gt;&gt; three'); yield next; console.log('&lt;&lt; three');&#125;); 上面代码中，因为第二个中间件少了yield next语句，第三个中间件并不会执行。 如果想跳过一个中间件，可以直接在该中间件的第一行语句写上return yield next。 123app.use(function* (next) &#123; if (skip) return yield next;&#125;) 由于Koa要求中间件唯一的参数就是next，导致如果要传入其他参数，必须另外写一个返回Generator函数的函数。 12345678910111213function logger(format) &#123; return function *(next)&#123; var str = format .replace(':method', this.method) .replace(':url', this.url); console.log(str); yield next; &#125;&#125;app.use(logger(':method :url')); 上面代码中，真正的中间件是logger函数的返回值，而logger函数是可以接受参数的。 多个中间件的合并由于中间件的参数统一为next（意为下一个中间件），因此可以使用.call(this, next)，将多个中间件进行合并。 1234567891011121314151617181920212223242526272829function *random(next) &#123; if ('/random' == this.path) &#123; this.body = Math.floor(Math.random()*10); &#125; else &#123; yield next; &#125;&#125;;function *backwards(next) &#123; if ('/backwards' == this.path) &#123; this.body = 'sdrawkcab'; &#125; else &#123; yield next; &#125;&#125;function *pi(next) &#123; if ('/pi' == this.path) &#123; this.body = String(Math.PI); &#125; else &#123; yield next; &#125;&#125;function *all(next) &#123; yield random.call(this, backwards.call(this, pi.call(this, next)));&#125;app.use(all); 上面代码中，中间件all内部，就是依次调用random、backwards、pi，后一个中间件就是前一个中间件的参数。 Koa内部使用koa-compose模块，进行同样的操作，下面是它的源码。 123456789101112131415function compose(middleware)&#123; return function *(next)&#123; if (!next) next = noop(); var i = middleware.length; while (i--) &#123; next = middleware[i].call(this, next); &#125; yield *next; &#125;&#125;function *noop()&#123;&#125; 上面代码中，middleware是中间件数组。前一个中间件的参数是后一个中间件，依次类推。如果最后一个中间件没有next参数，则传入一个空函数。 路由可以通过this.path属性，判断用户请求的路径，从而起到路由作用。 123456789101112app.use(function* (next) &#123; if (this.path === '/') &#123; this.body = 'we are at home!'; &#125;&#125;)// 等同于app.use(function* (next) &#123; if (this.path !== '/') return yield next; this.body = 'we are at home!';&#125;) 下面是多路径的例子。 1234567891011121314151617181920212223242526272829303132let koa = require('koa')let app = koa()// normal routeapp.use(function* (next) &#123; if (this.path !== '/') &#123; return yield next &#125; this.body = 'hello world'&#125;);// /404 routeapp.use(function* (next) &#123; if (this.path !== '/404') &#123; return yield next; &#125; this.body = 'page not found'&#125;);// /500 routeapp.use(function* (next) &#123; if (this.path !== '/500') &#123; return yield next; &#125; this.body = 'internal server error'&#125;);app.listen(8080) 上面代码中，每一个中间件负责一个路径，如果路径不符合，就传递给下一个中间件。 复杂的路由需要安装koa-router插件。 123456789101112var app = require('koa')();var Router = require('koa-router');var myRouter = new Router();myRouter.get('/', function *(next) &#123; this.response.body = 'Hello World!';&#125;);app.use(myRouter.routes());app.listen(3000); 上面代码对根路径设置路由。 Koa-router实例提供一系列动词方法，即一种HTTP动词对应一种方法。典型的动词方法有以下五种。 router.get() router.post() router.put() router.del() router.patch() 这些动词方法可以接受两个参数，第一个是路径模式，第二个是对应的控制器方法（中间件），定义用户请求该路径时服务器行为。 123router.get('/', function *(next) &#123; this.body = 'Hello World!';&#125;); 上面代码中，router.get方法的第一个参数是根路径，第二个参数是对应的函数方法。 注意，路径匹配的时候，不会把查询字符串考虑在内。比如，/index?param=xyz匹配路径/index。 有些路径模式比较复杂，Koa-router允许为路径模式起别名。起名时，别名要添加为动词方法的第一个参数，这时动词方法变成接受三个参数。 123router.get('user', '/users/:id', function *(next) &#123; // ...&#125;); 上面代码中，路径模式\\users\\:id的名字就是user。路径的名称，可以用来引用对应的具体路径，比如url方法可以根据路径名称，结合给定的参数，生成具体的路径。 12345router.url('user', 3);// =&gt; \"/users/3\"router.url('user', &#123; id: 3 &#125;);// =&gt; \"/users/3\" 上面代码中，user就是路径模式的名称，对应具体路径/users/:id。url方法的第二个参数3，表示给定id的值是3，因此最后生成的路径是/users/3。 Koa-router允许为路径统一添加前缀。 123456var router = new Router(&#123; prefix: '/users'&#125;);router.get('/', ...); // 等同于\"/users\"router.get('/:id', ...); // 等同于\"/users/:id\" 路径的参数通过this.params属性获取，该属性返回一个对象，所有路径参数都是该对象的成员。 12345// 访问 /programming/how-to-noderouter.get('/:category/:title', function *(next) &#123; console.log(this.params); // =&gt; &#123; category: 'programming', title: 'how-to-node' &#125;&#125;); param方法可以针对命名参数，设置验证条件。 12345678910router .get('/users/:user', function *(next) &#123; this.body = this.user; &#125;) .param('user', function *(id, next) &#123; var users = [ '0号用户', '1号用户', '2号用户']; this.user = users[id]; if (!this.user) return this.status = 404; yield next; &#125;) 上面代码中，如果/users/:user的参数user对应的不是有效用户（比如访问/users/3），param方法注册的中间件会查到，就会返回404错误。 redirect方法会将某个路径的请求，重定向到另一个路径，并返回301状态码。 1234567router.redirect('/login', 'sign-in');// 等同于router.all('/login', function *() &#123; this.redirect('/sign-in'); this.status = 301;&#125;); redirect方法的第一个参数是请求来源，第二个参数是目的地，两者都可以用路径模式的别名代替。 context对象中间件当中的this表示上下文对象context，代表一次HTTP请求和回应，即一次访问/回应的所有信息，都可以从上下文对象获得。context对象封装了request和response对象，并且提供了一些辅助方法。每次HTTP请求，就会创建一个新的context对象。 12345app.use(function *()&#123; this; // is the Context this.request; // is a koa Request this.response; // is a koa Response&#125;); context对象的很多方法，其实是定义在ctx.request对象或ctx.response对象上面，比如，ctx.type和ctx.length对应于ctx.response.type和ctx.response.length，ctx.path和ctx.method对应于ctx.request.path和ctx.request.method。 context对象的全局属性。 request：指向Request对象 response：指向Response对象 req：指向Node的request对象 res：指向Node的response对象 app：指向App对象 state：用于在中间件传递信息。 1this.state.user = yield User.find(id); 上面代码中，user属性存放在this.state对象上面，可以被另一个中间件读取。 context对象的全局方法。 throw()：抛出错误，直接决定了HTTP回应的状态码。 assert()：如果一个表达式为false，则抛出一个错误。 123456789this.throw(403);this.throw('name required', 400);this.throw('something exploded');this.throw(400, 'name required');// 等同于var err = new Error('name required');err.status = 400;throw err; assert方法的例子。 12345// 格式ctx.assert(value, [msg], [status], [properties])// 例子this.assert(this.user, 401, 'User not found. Please login!'); 以下模块解析POST请求的数据。 co-body https://github.com/koajs/body-parser https://github.com/koajs/body-parsers 1234var parse = require('co-body');// in Koa handlervar body = yield parse(this); 错误处理机制Koa提供内置的错误处理机制，任何中间件抛出的错误都会被捕捉到，引发向客户端返回一个500错误，而不会导致进程停止，因此也就不需要forever这样的模块重启进程。 123app.use(function *() &#123; throw new Error();&#125;); 上面代码中，中间件内部抛出一个错误，并不会导致Koa应用挂掉。Koa内置的错误处理机制，会捕捉到这个错误。 当然，也可以额外部署自己的错误处理机制。 1234567app.use(function *() &#123; try &#123; yield saveResults(); &#125; catch (err) &#123; this.throw(400, '数据无效'); &#125;&#125;); 上面代码自行部署了try…catch代码块，一旦产生错误，就用this.throw方法抛出。该方法可以将指定的状态码和错误信息，返回给客户端。 对于未捕获错误，可以设置error事件的监听函数。 123app.on('error', function(err)&#123; log.error('server error', err);&#125;); error事件的监听函数还可以接受上下文对象，作为第二个参数。 123app.on('error', function(err, ctx)&#123; log.error('server error', err, ctx);&#125;); 如果一个错误没有被捕获，koa会向客户端返回一个500错误“Internal Server Error”。 this.throw方法用于向客户端抛出一个错误。 12345678910this.throw(403);this.throw('name required', 400);this.throw(400, 'name required');this.throw('something exploded');this.throw('name required', 400)// 等同于var err = new Error('name required');err.status = 400;throw err; this.throw方法的两个参数，一个是错误码，另一个是报错信息。如果省略状态码，默认是500错误。 this.assert方法用于在中间件之中断言，用法类似于Node的assert模块。 1this.assert(this.user, 401, 'User not found. Please login!'); 上面代码中，如果this.user属性不存在，会抛出一个401错误。 由于中间件是层级式调用，所以可以把try { yield next }当成第一个中间件。 12345678910111213app.use(function *(next) &#123; try &#123; yield next; &#125; catch (err) &#123; this.status = err.status || 500; this.body = err.message; this.app.emit('error', err, this); &#125;&#125;);app.use(function *(next) &#123; throw new Error('some error');&#125;) cookiecookie的读取和设置。 12this.cookies.get('view');this.cookies.set('view', n); get和set方法都可以接受第三个参数，表示配置参数。其中的signed参数，用于指定cookie是否加密。如果指定加密的话，必须用app.keys指定加密短语。 12app.keys = ['secret1', 'secret2'];this.cookies.set('name', '张三', &#123; signed: true &#125;); this.cookie的配置对象的属性如下。 signed：cookie是否加密。 expires：cookie何时过期 path：cookie的路径，默认是“/”。 domain：cookie的域名。 secure：cookie是否只有https请求下才发送。 httpOnly：是否只有服务器可以取到cookie，默认为true。 session123456789101112131415var session = require('koa-session');var koa = require('koa');var app = koa();app.keys = ['some secret hurr'];app.use(session(app));app.use(function *()&#123; var n = this.session.views || 0; this.session.views = ++n; this.body = n + ' views';&#125;)app.listen(3000);console.log('listening on port 3000'); Request对象Request对象表示HTTP请求。 （1）this.request.header 返回一个对象，包含所有HTTP请求的头信息。它也可以写成this.request.headers。 （2）this.request.method 返回HTTP请求的方法，该属性可读写。 （3）this.request.length 返回HTTP请求的Content-Length属性，取不到值，则返回undefined。 （4）this.request.path 返回HTTP请求的路径，该属性可读写。 （5）this.request.href 返回HTTP请求的完整路径，包括协议、端口和url。 12this.request.href// http://example.com/foo/bar?q=1 （6）this.request.querystring 返回HTTP请求的查询字符串，不含问号。该属性可读写。 （7）this.request.search 返回HTTP请求的查询字符串，含问号。该属性可读写。 （8）this.request.host 返回HTTP请求的主机（含端口号）。 （9）this.request.hostname 返回HTTP的主机名（不含端口号）。 （10）this.request.type 返回HTTP请求的Content-Type属性。 12var ct = this.request.type;// \"image/png\" （11）this.request.charset 返回HTTP请求的字符集。 12this.request.charset// \"utf-8\" （12）this.request.query 返回一个对象，包含了HTTP请求的查询字符串。如果没有查询字符串，则返回一个空对象。该属性可读写。 比如，查询字符串color=blue&amp;size=small，会得到以下的对象。 1234&#123; color: 'blue', size: 'small'&#125; （13）this.request.fresh 返回一个布尔值，表示缓存是否代表了最新内容。通常与If-None-Match、ETag、If-Modified-Since、Last-Modified等缓存头，配合使用。 1234567891011this.response.set('ETag', '123');// 检查客户端请求的内容是否有变化if (this.request.fresh) &#123; this.response.status = 304; return;&#125;// 否则就表示客户端的内容陈旧了，// 需要取出新内容this.response.body = yield db.find('something'); （14）this.request.stale 返回this.request.fresh的相反值。 （15）this.request.protocol 返回HTTP请求的协议，https或者http。 （16）this.request.secure 返回一个布尔值，表示当前协议是否为https。 （17）this.request.ip 返回发出HTTP请求的IP地址。 （18）this.request.subdomains 返回一个数组，表示HTTP请求的子域名。该属性必须与app.subdomainOffset属性搭配使用。app.subdomainOffset属性默认为2，则域名“tobi.ferrets.example.com”返回[“ferrets”, “tobi”]，如果app.subdomainOffset设为3，则返回[“tobi”]。 （19）this.request.is(types…) 返回指定的类型字符串，表示HTTP请求的Content-Type属性是否为指定类型。 123456789// Content-Type为 text/html; charset=utf-8this.request.is('html'); // 'html'this.request.is('text/html'); // 'text/html'this.request.is('text/*', 'text/html'); // 'text/html'// Content-Type为 application/jsonthis.request.is('json', 'urlencoded'); // 'json'this.request.is('application/json'); // 'application/json'this.request.is('html', 'application/*'); // 'application/json' 如果不满足条件，返回false；如果HTTP请求不含数据，则返回undefined。 1this.is('html'); // false 它可以用于过滤HTTP请求，比如只允许请求下载图片。 12345if (this.is('image/*')) &#123; // process&#125; else &#123; this.throw(415, 'images only!');&#125; （20）this.request.accepts(types) 检查HTTP请求的Accept属性是否可接受，如果可接受，则返回指定的媒体类型，否则返回false。 1234567891011121314151617181920212223242526272829// Accept: text/htmlthis.request.accepts('html');// \"html\"// Accept: text/*, application/jsonthis.request.accepts('html');// \"html\"this.request.accepts('text/html');// \"text/html\"this.request.accepts('json', 'text');// =&gt; \"json\"this.request.accepts('application/json');// =&gt; \"application/json\"// Accept: text/*, application/jsonthis.request.accepts('image/png');this.request.accepts('png');// false// Accept: text/*;q=.5, application/jsonthis.request.accepts(['html', 'json']);this.request.accepts('html', 'json');// \"json\"// No Accept headerthis.request.accepts('html', 'json');// \"html\"this.request.accepts('json', 'html');// =&gt; \"json\" 如果accepts方法没有参数，则返回所有支持的类型（text/html,application/xhtml+xml,image/webp,application/xml,/）。 如果accepts方法的参数有多个参数，则返回最佳匹配。如果都不匹配则返回false，并向客户端抛出一个406”Not Acceptable“错误。 如果HTTP请求没有Accept字段，那么accepts方法返回它的第一个参数。 accepts方法可以根据不同Accept字段，向客户端返回不同的字段。 123456switch (this.request.accepts('json', 'html', 'text')) &#123; case 'json': break; case 'html': break; case 'text': break; default: this.throw(406, 'json, html, or text only');&#125; （21）this.request.acceptsEncodings(encodings) 该方法根据HTTP请求的Accept-Encoding字段，返回最佳匹配，如果没有合适的匹配，则返回false。 12345// Accept-Encoding: gzipthis.request.acceptsEncodings('gzip', 'deflate', 'identity');// \"gzip\"this.request.acceptsEncodings(['gzip', 'deflate', 'identity']);// \"gzip\" 注意，acceptEncodings方法的参数必须包括identity（意为不编码）。 如果HTTP请求没有Accept-Encoding字段，acceptEncodings方法返回所有可以提供的编码方法。 123// Accept-Encoding: gzip, deflatethis.request.acceptsEncodings();// [\"gzip\", \"deflate\", \"identity\"] 如果都不匹配，acceptsEncodings方法返回false，并向客户端抛出一个406“Not Acceptable”错误。 （22）this.request.acceptsCharsets(charsets) 该方法根据HTTP请求的Accept-Charset字段，返回最佳匹配，如果没有合适的匹配，则返回false。 123456// Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5this.request.acceptsCharsets('utf-8', 'utf-7');// =&gt; \"utf-8\"this.request.acceptsCharsets(['utf-7', 'utf-8']);// =&gt; \"utf-8\" 如果acceptsCharsets方法没有参数，则返回所有可接受的匹配。 123// Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5this.request.acceptsCharsets();// [\"utf-8\", \"utf-7\", \"iso-8859-1\"] 如果都不匹配，acceptsCharsets方法返回false，并向客户端抛出一个406“Not Acceptable”错误。 （23）this.request.acceptsLanguages(langs) 该方法根据HTTP请求的Accept-Language字段，返回最佳匹配，如果没有合适的匹配，则返回false。 12345// Accept-Language: en;q=0.8, es, ptthis.request.acceptsLanguages('es', 'en');// \"es\"this.request.acceptsLanguages(['en', 'es']);// \"es\" 如果acceptsCharsets方法没有参数，则返回所有可接受的匹配。 123// Accept-Language: en;q=0.8, es, ptthis.request.acceptsLanguages();// [\"es\", \"pt\", \"en\"] 如果都不匹配，acceptsLanguages方法返回false，并向客户端抛出一个406“Not Acceptable”错误。 （24）this.request.socket 返回HTTP请求的socket。 （25）this.request.get(field) 返回HTTP请求指定的字段。 Response对象Response对象表示HTTP回应。 （1）this.response.header 返回HTTP回应的头信息。 （2）this.response.socket 返回HTTP回应的socket。 （3）this.response.status 返回HTTP回应的状态码。默认情况下，该属性没有值。该属性可读写，设置时等于一个整数。 （4）this.response.message 返回HTTP回应的状态信息。该属性与this.response.message是配对的。该属性可读写。 （5）this.response.length 返回HTTP回应的Content-Length字段。该属性可读写，如果没有设置它的值，koa会自动从this.request.body推断。 （6）this.response.body 返回HTTP回应的信息体。该属性可读写，它的值可能有以下几种类型。 字符串：Content-Type字段默认为text/html或text/plain，字符集默认为utf-8，Content-Length字段同时设定。 二进制Buffer：Content-Type字段默认为application/octet-stream，Content-Length字段同时设定。 Stream：Content-Type字段默认为application/octet-stream。 JSON对象：Content-Type字段默认为application/json。 null（表示没有信息体） 如果this.response.status没设置，Koa会自动将其设为200或204。 （7）this.response.get(field) 返回HTTP回应的指定字段。 1var etag = this.get('ETag'); 注意，get方法的参数是区分大小写的。 （8）this.response.set() 设置HTTP回应的指定字段。 1this.set('Cache-Control', 'no-cache'); set方法也可以接受一个对象作为参数，同时为多个字段指定值。 1234this.set(&#123; 'Etag': '1234', 'Last-Modified': date&#125;); （9）this.response.remove(field) 移除HTTP回应的指定字段。 （10）this.response.type 返回HTTP回应的Content-Type字段，不包括“charset”参数的部分。 12var ct = this.reponse.type;// \"image/png\" 该属性是可写的。 1234this.reponse.type = 'text/plain; charset=utf-8';this.reponse.type = 'image/png';this.reponse.type = '.png';this.reponse.type = 'png'; 设置type属性的时候，如果没有提供charset参数，Koa会判断是否自动设置。如果this.response.type设为html，charset默认设为utf-8；但如果this.response.type设为text/html，就不会提供charset的默认值。 （10）this.response.is(types…) 该方法类似于this.request.is()，用于检查HTTP回应的类型是否为支持的类型。 它可以在中间件中起到处理不同格式内容的作用。 12345678910111213var minify = require('html-minifier');app.use(function *minifyHTML(next)&#123; yield next; if (!this.response.is('html')) return; var body = this.response.body; if (!body || body.pipe) return; if (Buffer.isBuffer(body)) body = body.toString(); this.response.body = minify(body);&#125;); 上面代码是一个中间件，如果输出的内容类型为HTML，就会进行最小化处理。 （11）this.response.redirect(url, [alt]) 该方法执行302跳转到指定网址。 1234this.redirect('back');this.redirect('back', '/index.html');this.redirect('/login');this.redirect('http://google.com'); 如果redirect方法的第一个参数是back，将重定向到HTTP请求的Referrer字段指定的网址，如果没有该字段，则重定向到第二个参数或“/”网址。 如果想修改302状态码，或者修改body文字，可以采用下面的写法。 123this.status = 301;this.redirect('/cart');this.body = 'Redirecting to shopping cart'; （12）this.response.attachment([filename]) 该方法将HTTP回应的Content-Disposition字段，设为“attachment”，提示浏览器下载指定文件。 （13）this.response.headerSent 该方法返回一个布尔值，检查是否HTTP回应已经发出。 （14）this.response.lastModified 该属性以Date对象的形式，返回HTTP回应的Last-Modified字段（如果该字段存在）。该属性可写。 1this.response.lastModified = new Date(); （15）this.response.etag 该属性设置HTTP回应的ETag字段。 1this.response.etag = crypto.createHash('md5').update(this.body).digest('hex'); 注意，不能用该属性读取ETag字段。 （16）this.response.vary(field) 该方法将参数添加到HTTP回应的Vary字段。 CSRF攻击CSRF攻击是指用户的session被劫持，用来冒充用户的攻击。 koa-csrf插件用来防止CSRF攻击。原理是在session之中写入一个秘密的token，用户每次使用POST方法提交数据的时候，必须含有这个token，否则就会抛出错误。 123456789101112131415161718192021222324var koa = require('koa');var session = require('koa-session');var csrf = require('koa-csrf');var route = require('koa-route');var app = module.exports = koa();app.keys = ['session key', 'csrf example'];app.use(session(app));app.use(csrf());app.use(route.get('/token', token));app.use(route.post('/post', post));function* token () &#123; this.body = this.csrf;&#125;function* post() &#123; this.body = &#123;ok: true&#125;;&#125;app.listen(3000); POST请求含有token，可以是以下几种方式之一，koa-csrf插件就能获得token。 表单的_csrf字段 查询字符串的_csrf字段 HTTP请求头信息的x-csrf-token字段 HTTP请求头信息的x-xsrf-token字段 数据压缩koa-compress模块可以实现数据压缩。 12345app.use(require('koa-compress')())app.use(function* () &#123; this.type = 'text/plain' this.body = fs.createReadStream('filename.txt')&#125;) 源码解读每一个网站就是一个app，它由lib/application定义。 12345678910111213function Application() &#123; if (!(this instanceof Application)) return new Application; this.env = process.env.NODE_ENV || 'development'; this.subdomainOffset = 2; this.middleware = []; this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response);&#125;var app = Application.prototype;exports = module.exports = Application; app.use()用于注册中间件，即将Generator函数放入中间件数组。 123456789app.use = function(fn)&#123; if (!this.experimental) &#123; // es7 async functions are allowed assert(fn &amp;&amp; 'GeneratorFunction' == fn.constructor.name, 'app.use() requires a generator function'); &#125; debug('use %s', fn._name || fn.name || '-'); this.middleware.push(fn); return this;&#125;; app.listen()就是http.createServer(app.callback()).listen(...)的缩写。 12345678910111213141516171819202122app.listen = function()&#123; debug('listen'); var server = http.createServer(this.callback()); return server.listen.apply(server, arguments);&#125;;app.callback = function()&#123; var mw = [respond].concat(this.middleware); var fn = this.experimental ? compose_es7(mw) : co.wrap(compose(mw)); var self = this; if (!this.listeners('error').length) this.on('error', this.onerror); return function(req, res)&#123; res.statusCode = 404; var ctx = self.createContext(req, res); onFinished(res, ctx.onerror); fn.call(ctx).catch(ctx.onerror); &#125;&#125;; 上面代码中，app.callback()会返回一个函数，用来处理HTTP请求。它的第一行mw = [respond].concat(this.middleware)，表示将respond函数（这也是一个Generator函数）放入this.middleware，现在mw就变成了[respond, S1, S2, S3]。 compose(mw)将中间件数组转为一个层层调用的Generator函数。 123456789101112131415function compose(middleware)&#123; return function *(next)&#123; if (!next) next = noop(); var i = middleware.length; while (i--) &#123; next = middleware[i].call(this, next); &#125; yield *next; &#125;&#125;function *noop()&#123;&#125; 上面代码中，下一个generator函数总是上一个Generator函数的参数，从而保证了层层调用。 var fn = co.wrap(gen)则是将Generator函数包装成一个自动执行的函数，并且返回一个Promise。 123456//co packageco.wrap = function (fn) &#123; return function () &#123; return co.call(this, fn.apply(this, arguments)); &#125;;&#125;; 由于co.wrap(compose(mw))执行后，返回的是一个Promise，所以可以对其使用catch方法指定捕捉错误的回调函数fn.call(ctx).catch(ctx.onerror)。 将所有的上下文变量都放进context对象。 1234567891011121314151617app.createContext = function(req, res)&#123; var context = Object.create(this.context); var request = context.request = Object.create(this.request); var response = context.response = Object.create(this.response); context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.onerror = context.onerror.bind(context); context.originalUrl = request.originalUrl = req.url; context.cookies = new Cookies(req, res, this.keys); context.accept = request.accept = accepts(req); context.state = &#123;&#125;; return context;&#125;; 真正处理HTTP请求的是下面这个Generator函数。 123456789101112131415161718192021222324252627282930313233343536373839404142function *respond(next) &#123; yield *next; // allow bypassing koa if (false === this.respond) return; var res = this.res; if (res.headersSent || !this.writable) return; var body = this.body; var code = this.status; // ignore body if (statuses.empty[code]) &#123; // strip headers this.body = null; return res.end(); &#125; if ('HEAD' == this.method) &#123; if (isJSON(body)) this.length = Buffer.byteLength(JSON.stringify(body)); return res.end(); &#125; // status body if (null == body) &#123; this.type = 'text'; body = this.message || String(code); this.length = Buffer.byteLength(body); return res.end(body); &#125; // responses if (Buffer.isBuffer(body)) return res.end(body); if ('string' == typeof body) return res.end(body); if (body instanceof Stream) return body.pipe(res); // body: json body = JSON.stringify(body); this.length = Buffer.byteLength(body); res.end(body);&#125; 参考链接 Koa Guide William XING, Is Koa.js right for me?⬆ back to top","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://React-Apollo.github.io/categories/Node-js/"}],"tags":[]}]}