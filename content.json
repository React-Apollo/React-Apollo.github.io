{"meta":{"title":"Javascript-React-Apollo-GraphQL-Ramda-Prisma","subtitle":"All In One","description":"base on javascript","author":"React-Apollo","url":"https://React-Apollo.github.io"},"pages":[{"title":"about","date":"2018-04-07T02:42:18.255Z","updated":"2018-04-07T02:42:18.255Z","comments":false,"path":"about/index.html","permalink":"https://React-Apollo.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2016-07-05T11:39:04.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"categories/index.html","permalink":"https://React-Apollo.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-06-04T03:30:57.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"tags/index.html","permalink":"https://React-Apollo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ML|Basic Linear Algebra for Deep Learning","slug":"ML|Basic Linear Algebra for Deep Learning","date":"2018-04-07T07:52:49.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/04/07/ML|Basic Linear Algebra for Deep Learning/","link":"","permalink":"https://React-Apollo.github.io/2018/04/07/ML|Basic Linear Algebra for Deep Learning/","excerpt":"","text":"原文地址 深度学习的线性代数基础 简介线性代数对于计算机科学家而言有点,有点陌生,因为它是连续的区别于离散量. 线性代数是几何和泛函分析的核心.也是理解机器学习的很关键的前提,尤其是如果你是要编写深度学习的算法. 在机器学习入门时,不需要了解线性代数,但是在某些地方有了线性代数的基础,可以增加理解不同算法差异的直觉. 这会帮助你更好的决定如何来开发机器学习系统. 所以如果你真的想要在这个领域有所建树,线性代数的掌握是必须的. 在线性代数中,数据由线性方程组表征,线性方程组的形式是矩阵(matrices)和矢量(Vector).所以在线性代数中大多数情况下,我们在处理矩阵和矢量,而不是标量(scalar).如果拥有了类似 Nupmy一样的软件包,可以很容易的用几行代码来计算复杂的矩阵乘法. 数学对象 标量(Scalar)标量是简单的数字,例如 23 矢量(Vector)矢量是一组有序的数组,可以是行(row),也可以是列(column).一个矢量只有一个缩影,例如 V2指向矢量内的第二个值,在上图中指的的是-8. 矩阵(Matrix)矩阵是数字的二维数组. 它有两个索引,第一个指向 row,第二个指向 column.例如, M23指向第二行,第三列的值. 是”8”.矩阵可以有多行多列. Vector 也是一个Matrix,只不过只有一行或者一列. 张量(Tensor)Tensor 是一个数字数组, 以规则的网格来排布,拥有一个可变的轴.Tensor有三个轴,第一个指向行,第二个指向列,第三个指向轴.例如, V232指向第二行,第三列,第二个轴上的值.在下图中指向0 Tensor 是最重要的术语,因为 Tensor是一个多维数组,根据 indices 的不同,可以是一个 vector或者一个matrix,.例如一阶 tensor 就是一个 Vector(1索引),二阶(2索引),三阶(3 索引). 还有高阶索引(超过三阶的). 计算的规则1.Matrix-Scalar 操作如果是对一个矩阵执行加减乘除操作,只需要对矩阵的每个元素分别执行操作就可以了. 2.矩阵和矢量的乘法矩阵和矢量的乘积得到一个与矩阵相同行数的矢量. 看看第二张图的计算步骤 11+35=16 41+05=4 21+15=7 另一个例子 这是操作的 cheatsheet 3.Matrix-Matrix 加法和减法矩阵的加减法很简单,必须条件是两个举证要有相同的维度,结果也是同样的维度 4.Matrix-Matrix 乘法其实就是矩阵-矢量的乘法, 把第二个矩阵按列分割为矢量.第一个矩阵分别和矢量做乘法.最后放到一个新的矩阵中. 矩阵乘法的 cheatsheet 矩阵乘法的属性矩阵乘法某些属性可以让我们在一个矩阵乘法中绑定一些计算. 接下来我们逐个介绍. 先从标量开始, 然后是矩阵. 这样做易于理解. 1.Not Commutative标量的乘法是满足交换律的,矩阵的乘法不行.意思是,标量的乘法,73等同于37.但是矩阵的乘法 AB 和 BA是不同的. 2.Associative标量和矩阵都可以用组合律. 标量3(53)等同于(35)3.矩阵一样, A(BC)等同于(A*B)C. 3.Distributive标量和矩阵都满足分配率的3(5+3)=35+33,A(B+C)=AB+AC 4.Identity Matrix单位矩阵是一种特殊的矩阵,首先来看看单位是如何定义的. 数字1是一个单位,因为任何数乘与1都是它本身. 因此矩阵乘一个单位也等于自己. 如果一个矩阵乘与单位矩阵,就满足交换律:AI=IA=A Matrix Inverse(逆) 和 Transpose(转置)Inverse 和 Transpos 是矩阵的两个特殊的属性 1.Inverse什么是 Inverse?一个数字乘与它的逆,等于1. 除了0,每个数字都有逆. 并不是每个矩阵都有逆. 为什么需要逆这个计算? 因为我们不能除矩阵.矩阵没有除法的概念,但是我们可以给矩阵乘一个逆,结果和除法是一样的. 2.Transpose(转置)本质上,转置就是一个矩阵沿着45度轴的一个镜像.获取一个矩阵的转置很容易. 第一个列变为转置矩阵的第一行,第二列变为转置矩阵的第二行. 总结ResourcesDeep Learning (book) — Ian Goodfellow, Joshua Bengio, Aaron Courvillehttps://machinelearningmastery.com/linear-algebra-machine-learning/Andrew Ng’s Machine Learning course on Courserahttps://en.wikipedia.org/wiki/Linear_algebrahttps://www.mathsisfun.com/algebra/scalar-vector-matrix.htmlhttps://www.quantstart.com/articles/scalars-vectors-matrices-and-tensors-linear-algebra-for-deep-learning-part-1https://www.aplustopper.com/understanding-scalar-vector-quantities/","categories":[{"name":"Basic Math","slug":"Basic-Math","permalink":"https://React-Apollo.github.io/categories/Basic-Math/"}],"tags":[{"name":"Linear Algebra","slug":"Linear-Algebra","permalink":"https://React-Apollo.github.io/tags/Linear-Algebra/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://React-Apollo.github.io/tags/Machine-Learning/"}]},{"title":"ML|How to create a Neural Netwrok in javascript in only 30 lines of codes","slug":"ML|How to create a Neural Netwrok in javascript in only 30 lines of codes","date":"2018-04-03T14:51:47.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/04/03/ML|How to create a Neural Netwrok in javascript in only 30 lines of codes/","link":"","permalink":"https://React-Apollo.github.io/2018/04/03/ML|How to create a Neural Netwrok in javascript in only 30 lines of codes/","excerpt":"","text":"使用 synaptic.js 训练一个神经网络 . 解决 XOR 问题 xor 问题实例 num1 xor num2 res 1 xor 1 0 0 xor 0 0 1 xor 0 1 0 xor 1 1 Neurons and synapses神经网络的构建块是: neurons(神经元). neurons类似函数,接收一些输入条件, 返回结果.有不同类型的 neurons,我们使用sigmoid neurons(多层感知),它接收给定的数字, 返回0到1之间的数字 下面的圆环就代表 sigmodi neurons. 接收5返回的是1. 箭头被称为 synapses(突触),负责把 neuron 连接到神经网络的其他层. 那么为什么5是红色的? 因为它是三个 synapses 的总和. 继续来分解一下: 最左侧的的两个绿色的值,和一个被称为 bias 的棕色值. 棕色的值是来源于另一个 neuron 的 首先两个输入值和他们的weights(权重)相乘,分别是蓝色的7,3. 最后,我们在加上 bias ,最终得到红色的5. 这就是我们的人工神经网络的输入值 在这个 sigmoid neuron 上, 所有的输入都被压缩为0~1之间的值. 如果把这些 neuron 的网络连接在一起,就可以得到一个 neural network. 形成的Neural work 会从前到后的传播,彼此通过 synapses 连接在一起. 如下图: neural network 的目标是训练它做归纳,例如识别手写体的数字,或者垃圾邮件.要有一个好的归纳, 拥有正确的 weights bias是重点. 如上述实例中的蓝色和棕色数字. 在训练一个 neural network 时, 简单的给它展示一些手写数字的实例,让 network 可以预测正确的结果. 在每次预测后,将会要计算预测到底有多离谱,逐渐调整 weights 和 bias,直到 networks 在下一轮训练时做的更好. 这个学习过程被称为 backpropagation(反向传播).这个过程重复上千次.neural network 将会非常擅长归纳问题. backpropagation的工作技术超出了本教程. 1234const &#123; Layer, Network &#125; = window.synaptic;var inputLayer = new Layer(2);var hiddenLayer = new Layer(3);var outputLayer = new Layer(1); 接下来,把这些层连接起来,实例化一个新的 network,如下: 1234567inputLayer.project(hiddenLayer);hiddenLayer.project(outputLayer);var myNetwork = new Network(&#123; input: inputLayer, hidden: [hiddenLayer], output: outputLayer&#125;); 由此得到一个2-3-1 network, 如下: 现在来训练这个 network: 12345678910111213141516// train the network - learn XORvar learningRate = .3;for (var i = 0; i &lt; 20000; i++) &#123; // 0,0 =&gt; 0 myNetwork.activate([0,0]); myNetwork.propagate(learningRate, [0]); // 0,1 =&gt; 1 myNetwork.activate([0,1]); myNetwork.propagate(learningRate, [1]); // 1,0 =&gt; 1 myNetwork.activate([1,0]); myNetwork.propagate(learningRate, [1]); // 1,1 =&gt; 0 myNetwork.activate([1,1]); myNetwork.propagate(learningRate, [0]);&#125; 运行2000次, 每次向前,向后传播四次. 传递四个可能的值:[0,0],[0,1],[1,0],[1,1] 从myNetwork.activate([0,0])开始,[0,0]是发送的 network的数据点.这是向前传播,因此被称为 activating 网络. 每次向前传播之后,需要向后传播,这时, network 更新自己的 weights 和 biases. backpropgation通过这一行代码执行:myNetwork.propagate(learningRate,[0]), learningRate是一个常量,告诉 newtork每次要调整多少 weights. 第二个参数0代表给定输入[0,0]应该得到的正确结果. network 之后比较它的预期值和最终的正确值,这会告诉 network 预期到底是正确还是错误的. network 用比较结果作为正确的 weights 和 bias 的基础,以便于下一次能更准确一点. 完成2000次处理过程以后,我们可以用四种可能的输入结果来检查 network 的激活情况. 12345678console.log(myNetwork.activate([0,0])); -&gt; [0.015020775950893527]console.log(myNetwork.activate([0,1]));-&gt;[0.9815816381088985]console.log(myNetwork.activate([1,0]));-&gt; [0.9871822457132193]console.log(myNetwork.activate([1,1]));-&gt; [0.012950087641929467] 如果取整,就会得到争取的结果.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"ML","slug":"ML","permalink":"https://React-Apollo.github.io/tags/ML/"},{"name":"Neural Network","slug":"Neural-Network","permalink":"https://React-Apollo.github.io/tags/Neural-Network/"},{"name":"Javascript","slug":"Javascript","permalink":"https://React-Apollo.github.io/tags/Javascript/"}]},{"title":"Prisma|Reusing & Composing GraphQL APIs with GraphQL Bindings","slug":"Prisma|Reusing   Composing GraphQL APIs with GraphQL Bindings","date":"2018-03-31T12:57:01.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/03/31/Prisma|Reusing   Composing GraphQL APIs with GraphQL Bindings/","link":"","permalink":"https://React-Apollo.github.io/2018/03/31/Prisma|Reusing   Composing GraphQL APIs with GraphQL Bindings/","excerpt":"","text":"Prisma|Reusing &amp; Composing GraphQL APIs with GraphQL Bindings 原文地址 使用 GraphQL binding,不需要了解细节问题,可以访问到 GraphQL API 的功能 什么是GraphQL bindings?graphql binding是构建的模块,可以让你在自己的 GraphQL Server中嵌入已经村啊在的 GraphQL APIS 像是搭积木的块. 创建一个 GraphQL API binding的核心思想是提供一个专用的(dedicated)对象,来代表 API 的功能. 这个对象暴露的方法是 GraphQL schema中定义查询的镜像. 不需要在手动构建查询字符串,然后发送到 API(通过fetch或者 GraphQL客户端,例如graphql-request),只需要使用特定程序语言”构建”查询,调用查询方法即可. 在使用 typed 语言时, GraphQL binding 会把 GraphQL API 的 type 映射到对应的编程语言上. GraphQL最具威力的地方就是它的强类型 schema. 然而通过字符串发送查询时, 优势就没有了. Binding可以让我们重新获取这一优势 GraphQL binding 最简单的例子假设有如下的 schema: 123type Query &#123; hello(name:String):String!&#125; 现在,在使用 binding 和这个 schema 交互时,不需要构建查询字符串. 只需要在对象helloWroldBinding对象上调用 代表hello 查询的函数即可: 12345helloWorldBinding.query.hello() .then(result =&gt; console.log(result))helloWorldBinding.query.hello(&#123; name: 'Nikolas' &#125;) .then(result =&gt; console.log(result)) 调用函数时,对象的查询会被发送到 API: 123456789# helloWorldBinding.query.hello()query &#123; hello&#125;# helloWorldBinding.query.hello(&#123; name: &apos;Nikolas&apos; &#125;)query &#123; hello(name: &quot;Nikolas&quot;)&#125; 使用 GraphQL binding 的好处 简化和抽象 API 对IDE的支持 可重用 边编译边做错误检查 语言通用性 构建和共享 GraphQL bindings使用graphql-binding package 这个包的核心是一个Binding类,这个类接收 Graphql shcema 作为构造参数. 这个例子比较简单,实际使用中 schema 需要是远程的 schemas 12345678910111213141516171819202122232425262728const &#123; makeExecutableSchema &#125; = require('graphql-tools')const &#123; Binding &#125; = require('graphql-binding')const users = [ &#123; name: 'Alice', &#125;, &#123; name: 'Bob', &#125;,]const typeDefs = ` type Query &#123; findUser(name: String!): User &#125; type User &#123; name: String! &#125;`const resolvers = &#123; Query: &#123; findUser: (parent, &#123; name &#125;) =&gt; users.find(u =&gt; u.name === name), &#125;,&#125;const schema = makeExecutableSchema(&#123; typeDefs, resolvers &#125;) 上面是创建 schema 的过程,有了 schema 就可以创建Binding实例了: 123const findUserBinding = new Binding(&#123; schema,&#125;) 最后就可以使用 binding 对象findUserBinding来访问 schema 的findUser查询: 1findUserBinding.query.findUser(&#123;name:'Bob'&#125;) 为 GraphQL bidings 生成静态类型使用 GraphQL CLI 生成 TS 类型GraphQL CLI 包含有graphql prepare命令,可以轻松生成静态类型 第一步添加静态类型生成 1234567projects: helloworld: schemaPath: schema.graphql extensions: prepare-binding: output: helloworld.ts generator: binding-ts schemaPaht:指向 GraphQL schema. extensions.prepare-binding.output: 存放生成的 bindings extensions.prepare-binding.generator: generator 使用的地方.. 存在的 generator:binding-js&amp;binding-ts可以用于任何的 GraphQL API.prisma-js&amp;prisma-ts为Prisma 服务提供额外的便利性 假设你的schema 位于shcema.graphql,你可以调用graphql prepare命令生成 TypeScript bindings. 放置在generated/helloworls.ts: 1234567891011121314151617181920212223242526272829303132333435import &#123; Binding as BaseBinding, BindingOptions &#125; from 'graphql-binding'import &#123; GraphQLResolveInfo &#125; from 'graphql'export interface User &#123; name: String&#125;/*The `Boolean` scalar type represents `true` or `false`.*/export type Boolean = boolean/*The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.*/export type String = stringexport interface Schema &#123; query: Query&#125;export type Query = &#123; findUser: (args: &#123; name: String &#125;, context: &#123; [key: string]: any &#125;, info?: GraphQLResolveInfo | string) =&gt; Promise&lt;User | null&gt;&#125;export class Binding extends BaseBinding &#123; constructor(&#123; schema, fragmentReplacements &#125;: BindingOptions) &#123; super(&#123; schema, fragmentReplacements &#125;); &#125; query: Query = &#123; findUser: (args, context, info): Promise&lt;User | null&gt; =&gt; super.delegate('query', 'findUser', args, context, info) &#125;&#125; 这个文件不能手动修改. 新型的ORM: GraphQL database bindingsGraphQL bindings 可以在 database layer 和 application layer 之间生成映射. 在上下文中,可以在 server 中扮演 ORM的角色 例如,使用 Prisma 作为 graphql database layer.你可以直接使用prisma-binding,或者使用prisma-ts生成静态类型 一下是prisma-binding的工作.假设有一个简单的 data model 1234type User&#123; id:ID! @unique name:String!&#125; 在部署以后,会自动生成 Prisma database schema. 这个 schema 定义了 User类型的 CURD 操作. 1234567891011121314type Query &#123; users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]! user(where: UserWhereUniqueInput!): User&#125;type Mutation &#123; createUser(data: UserCreateInput!): User! updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User deleteUser(where: UserWhereUniqueInput!): User&#125;type Subscription &#123; user(where: UserSubscriptionWhereInput): UserSubscriptionPayload&#125; 现在可以实例化Prisma类, 1234567const &#123; Prisma &#125; = require('prisma-binding')const prisma = new Prisma(&#123; schemaPath: 'generated/prisma.graphql', endpoint: 'hhttp://localhost:60000/helloworld/dev', secret: 'my-super-secret-secret' // defined in prisma.yml &#125;) prisma实例现在作为 query,mutations和 subscription的代理. 实例如下: 1234567891011121314// Retrieve `name` of a specific userprisma.query.user(&#123; where &#123; id: 'abc' &#125; &#125;, '&#123; name &#125;')// Retrieve all fields of all usersprisma.query.users()// Create new user called `Sarah` and retrieve the `id`prisma.mutation.createUser(&#123; data: &#123; name: 'Sarah' &#125; &#125;, '&#123; id &#125;')// Update name of a specific user and retrieve the `id`prisma.mutation.updateUser(&#123; where: &#123; id: 'abc' &#125;, data: &#123; name: 'Sarah' &#125; &#125;, '&#123; id &#125;')// Delete a specific userprisma.mutation.deleteUser(&#123; where: &#123; id: 'abc' &#125; &#125;) 实际新版的 prisma 就是这个思路. ==完==","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"Apollo|apollo-link-state local state management","slug":"Apollo|apollo-link-state local state management","date":"2018-03-28T10:40:14.000Z","updated":"2018-04-07T02:42:18.247Z","comments":true,"path":"2018/03/28/Apollo|apollo-link-state local state management/","link":"","permalink":"https://React-Apollo.github.io/2018/03/28/Apollo|apollo-link-state local state management/","excerpt":"","text":"Apollo-client中的本地数据管理方法. 和远程数据的流动方向一样, 但是在到达 server之前会被 apollo-link-state 截获,并做处理.数据仍然保持单向流动. 调用withClientState方法,并使用 resolver做对应的处理. 12345678910111213141516171819202122import &#123; withClientState &#125; from 'apollo-link-state';// This is the same cache you pass into new ApolloClientconst cache = new InMemoryCache(...);const stateLink = withClientState(&#123; cache, resolvers: &#123; Mutation: &#123; updateNetworkStatus: (_, &#123; isConnected &#125;, &#123; cache &#125;) =&gt; &#123; const data = &#123; networkStatus: &#123; __typename: 'NetworkStatus', isConnected &#125;, &#125;; cache.writeData(&#123; data &#125;); return null; &#125;, &#125;, &#125;&#125;); 在 Apollo-client 上挂载 state,state link 应该在在链的末端,由此其他的 link 可以做逻辑上的处理, 但是必须要在 HttpLink之前,只有这样本地的操作才可以在到达网络之前被截获. 如果使用了持久化查询(persisted queries), 也必须要在apollo-link-persisted-queries之前. 1234const client = new ApolloClient(&#123; cache, link: ApolloLink.from([stateLink, new HttpLink()]),&#125;); 请求远程数据和本地数据,通过@client指令来区分. 12345const UPDATE_NETWORK_STATUS = gql` mutation updateNetworkStatus($isConnected: Boolean) &#123; updateNetworkStatus(isConnected: $isConnected) @client &#125;`; 在组件注入 query 或者 mutate 就可以了 12345const WrappedComponent = graphql(UPDATE_NETWORK_STATUS, &#123; props: (&#123; mutate &#125;) =&gt; (&#123; updateNetworkStatus: isConnected =&gt; mutate(&#123; variables: &#123; isConnected &#125; &#125;), &#125;),&#125;)(NetworkStatus); 如果要从其他组件访问 nework status 怎么办? 因为在访问之前,并不知道是否有UPDATA_NETWORK_STATUS存在,为了防止出现 undefined,需要提供一个默认的 state 作为初始值. 1234567891011121314const stateLink = withClientState(&#123; cache, resolvers: &#123; Mutation: &#123; /* same as above */ &#125;, &#125;, defaults: &#123; networkStatus: &#123; __typename: 'NetworkStatus', isConnected: true, &#125;, &#125;,&#125;); 组件查询 network也使用@client指令 1234567891011const GET_ARTICLES = gql` query &#123; networkStatus @client &#123; isConnected &#125; articles &#123; id title &#125; &#125;`; Defaults123456789101112131415161718const defaults = &#123; todos: [], visibilityFilter: 'SHOW_ALL', networkStatus: &#123; __typename: 'NetworkStatus', isConnected: false, &#125;&#125;;const resolvers = &#123; /* ... */ &#125;;const cache = new InMemoryCache();const stateLink = withClientState(&#123; resolvers, cache, defaults&#125;); Resolversresolvers 是实现 local state 的地方. resolver的 map是对应每个 GraphQL 对象类型的resolver 函数. apollo-link-state有四个重要的部分 cache在上下文中,可以用来读取数据 resolver 应该返回一个有_typename属性的对象, 也可以用dataIdFromObject代替. 目的是 Apollo 用于数据的normalize 如果需要执行异步操作,可以使用 promise. Query只针对 cache. 如果在所有的 mutate 之前执行 query,需要提供默认值 Default resolvers不一定要为每个字段都建立特定的 resolvers,如果从 parent 对象返回的值和children 请求的字段一致,就不需要 resolvers.这就是default resovlers 1234567891011const getUser = gql` query &#123; user(id: 1) @client &#123; name &#123; last first &#125; &#125; &#125;`; Resolvers signatureApollo-client 中的resolver 函数和用graph-tools构建的 server 中的 resolvers 是完全一样的. 1fieldName:(obj,args,context,info)=&gt;result; obj: 包含 parent 字段 或者ROOT_QUERY对象 args: 传递进入的参数, 例如updataNetworkStatus(isConnected:true),args对象就是{isConnected:true} context: 在所有的link 中共享的数据. 重要的的一点是Apollo cache添加在其中,所以可以用cache.writeData({}).如果想设定额外的值,可以在组件内设定,或者使用apollo-link-context. info: 有关 state 执行状态的信息. 个人不会用到 Async resolvers如果想访问 REST 数据,可以参考apollo-link-rest. 对于 RN或者 其他的 browser API,需要在组件的生命周期方法中添加触发函数. 这一部分暂时不写Organizing resolvers使用鸭子类型 ,每个feature都有自己的一套方法,然后合并起来 1234567891011import merge from 'lodash.merge';import &#123; withClientState &#125; from 'apollo-link-state';import currentUser from './resolvers/user';import cameraRoll from './resolvers/camera';import networkStatus from './resolvers/camera';const stateLink = withClientState(&#123; cache, resolvers: merge(currentUser, cameraRoll, networkStatus),&#125;); 可以设定默认值 12345678910111213const currentUser = &#123; defaults: &#123; currentUser: null, &#125;, resolvers: &#123; ... &#125;&#125;;const cameraRoll = &#123; defaults: &#123; ... &#125;, resolvers: &#123; ... &#125;&#125;;const stateLink = withClientState(&#123; ...merge(currentUser, cameraRoll, networkStatus), cache,&#125;); updating the cache可以通过context访问或者更新 cache. Apollo cache API 有几个方法 writeData直接在 Cahce 中写入数据,不用通过 query. 12345678const filter = &#123; Mutation: &#123; updateVisibilityFilter: (_, &#123; visibilityFilter &#125;, &#123; cache &#125;) =&gt; &#123; const data = &#123; visibilityFilter, __typename: 'Filter' &#125;; cache.writeData(&#123; data &#125;); &#125;, &#125;,&#125;; 如果传递id属性,也可以在已经存在的对象中写入片段数据. 这里的id应该对应对象的 cache key. 如果使用InMemroyCache,并且没有覆盖dataObjectFromId,cache key就是_typename:id 12345678const user = &#123; Mutation: &#123; updateUserEmail: (_, &#123; id, email &#125;, &#123; cache &#125;) =&gt; &#123; const data = &#123; email &#125;; cache.writeData(&#123; id: `User:$&#123;id&#125;`, data &#125;); &#125;, &#125;,&#125;; writeQuery 和 readQuery在某些情况下,写入到 cache 的数据依赖于已经存在的数据,例如 ,在 list 中添加一条 item或者对属性做修改. 做法是使用cache.readQuery传递 query,在写入数据之前从 cache 中读取数据. 看看 list的例子 1234567891011121314151617181920212223242526272829303132let nextTodoId = 0;const todos = &#123; defaults: &#123; todos: [], &#125;, resolvers: &#123; Mutation: &#123; addTodo: (_, &#123; text &#125;, &#123; cache &#125;) =&gt; &#123; const query = gql` query GetTodos &#123; todos @client &#123; id text completed &#125; &#125; `; const previous = cache.readQuery(&#123; query &#125;); const newTodo = &#123; id: nextTodoId++, text, completed: false, __typename: 'TodoItem' &#125;, const data = &#123; todos: previous.todos.concat([newTodo]), &#125;; // you can also do cache.writeData(&#123; data &#125;) here if you prefer cache.writeQuery(&#123; query, data &#125;); return newTodo; &#125;, &#125;, &#125;,&#125;; 为了在 list 中添加 todo, 需要当前的 todos, 可以通过cache.readQuery获取. 为了写入数据到 cache.可以使用cache.writeQuery,cache.writeData. 不同点在于cache.writeQuery需要传递 query,来验证 data的结构. 在底层,cache.write自动从data构建了 query. writeFragment 和 readFragmentcache.writeFragment,在有了 cache key 情况下, 可以灵活的读取数据. 1234567891011121314151617181920const todos = &#123; resolvers: &#123; Mutation: &#123; toggleTodo: (_, variables, &#123; cache &#125;) =&gt; &#123; const id = `TodoItem:$&#123;variables.id&#125;`; const fragment = gql` fragment completeTodo on TodoItem &#123; completed &#125; `; const todo = cache.readFragment(&#123; fragment, id &#125;); const data = &#123; ...todo, completed: !todo.completed &#125;; // you can also do cache.writeData(&#123; data, id &#125;) here if you prefer cache.writeFragment(&#123; fragment, id, data &#125;); return null; &#125;, &#125;, &#125;,&#125;; @client directiveCombining local and remote data下面的例子中,我们从 server 获取到 username,从 apollo cache 获取到 cart 信息.两者在结果中融合在一起 1234567891011121314const getUser = gql` query getUser($id: String) &#123; user(id: $id) &#123; id name cart @client &#123; product &#123; name id &#125; &#125; &#125; &#125;`;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"},{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"}]},{"title":"quokka.js 的使用","slug":"quokka 的用法","date":"2018-03-27T17:13:38.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/03/27/quokka 的用法/","link":"","permalink":"https://React-Apollo.github.io/2018/03/27/quokka 的用法/","excerpt":"","text":"Instant console tools quokka.js 文档 直接看图, 可以实现Ramda的Try Ramda 类似的效果. 安装 实时反馈 console输出 实际操作效果","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://React-Apollo.github.io/tags/vscode/"},{"name":"tools","slug":"tools","permalink":"https://React-Apollo.github.io/tags/tools/"}]},{"title":"Apollo|Using Fragments","slug":"Apollo|Using Fragments","date":"2018-03-27T10:39:30.000Z","updated":"2018-04-07T02:42:18.247Z","comments":true,"path":"2018/03/27/Apollo|Using Fragments/","link":"","permalink":"https://React-Apollo.github.io/2018/03/27/Apollo|Using Fragments/","excerpt":"","text":"GraphQL fragments是可以共享的查询逻辑 1234567891011fragment NameParts on Person &#123; firstName lastName&#125;query getPerson &#123; people(id: \"7\") &#123; ...NameParts avatar(size: LARGE) &#125;&#125; 在 Apollo中 fragment 有两个主要的用法: 在多个查询,突变或订阅中共享字段 Breaking your queries up to allow you to co-locate field access with the places they are used. Reusing Fragments直接的用法就是重用片段 123456789101112131415import gql from 'graphql-tag';CommentsPage.fragments = &#123; comment: gql` fragment CommentsPageComment on Comment &#123; id postedBy &#123; login html_url &#125; createdAt content &#125; `,&#125;; 需要使用 fragment 时, 简单的使用...Name语法. 在查询文档中嵌入 12345678910111213141516171819202122const SUBMIT_COMMENT_MUTATION = gql` mutation submitComment($repoFullName: String!, $commentContent: String!) &#123; submitComment(repoFullName: $repoFullName, commentContent: $commentContent) &#123; ...CommentsPageComment &#125; &#125; $&#123;CommentsPage.fragments.comment&#125;`;export const COMMENT_QUERY = gql` query Comment($repoName: String!) &#123; # ... entry(repoFullName: $repoName) &#123; # ... comments &#123; ...CommentsPageComment &#125; # ... &#125; &#125; $&#123;CommentsPage.fragments.comment&#125;`; Colocating FragmentsGraphQL的一个好处是, 响应数据天然是树形结构,在很多实例中, 和组件的层级关系形成映射.由此,结合GraphQL对 fragment 的支持,可以按照对应结构对查询做出分割. 例如在GitHunt 中构建FeedPage实例,有如下的层级结构 12345FeedPage└── Feed └── FeedEntry ├── RepoInfo └── VoteButtons FeedPage 执行一个查询获取Entry列表.每个子组件需要Entry的不同字段. graphql-anywhere包提供的工具可以构建出子组件需要的所有字段的查询,从而让你轻松的传递所有组件需要确切字段 Creating Fragments再次使用gql助手,添加子字段 12345678910VoteButtons.fragments = &#123; entry: gql` fragment VoteButtons on Entry &#123; score vote &#123; vote_value &#125; &#125; `,&#125;; 如果片段包含有子片段, 使用gql助手传递 123456789101112131415161718FeedEntry.fragments = &#123; entry: gql` fragment FeedEntry on Entry &#123; commentCount repository &#123; full_name html_url owner &#123; avatar_url &#125; &#125; ...VoteButtons ...RepoInfo &#125; $&#123;VoteButtons.fragments.entry&#125; $&#123;RepoInfo.fragments.entry&#125; `,&#125;; Filtering With Fragments在字段传递给子组件的时候,也可是过滤出确切的字段 12345678910import &#123; filter &#125; from 'graphql-anywhere';&lt;VoteButtons entry=&#123;filter(VoteButtons.fragments.entry, entry)&#125; canVote=&#123;loggedIn&#125; onVote=&#123;type =&gt; onVote(&#123; repoFullName: full_name, type, &#125;)&#125;/&gt; filter()会从 entry中得到确切的字段 使用 Webpack 导入 fragments在使用graphql-tag/loader导入.graphql文件时,可以使用import, 1#import \"./someFragments.graphql\"","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"}]},{"title":"Cheatsheet|Typescript","slug":"Cheatsheet|TypeScript","date":"2018-03-26T14:21:43.000Z","updated":"2018-04-07T02:42:18.247Z","comments":true,"path":"2018/03/26/Cheatsheet|TypeScript/","link":"","permalink":"https://React-Apollo.github.io/2018/03/26/Cheatsheet|TypeScript/","excerpt":"","text":"","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://React-Apollo.github.io/tags/javascript/"},{"name":"typescript","slug":"typescript","permalink":"https://React-Apollo.github.io/tags/typescript/"},{"name":"cheatsheet","slug":"cheatsheet","permalink":"https://React-Apollo.github.io/tags/cheatsheet/"}]},{"title":"Apollo| apollo-link 概念","slug":"Apollo| apollo-link 概念","date":"2018-03-22T10:38:59.000Z","updated":"2018-04-07T02:42:18.247Z","comments":true,"path":"2018/03/22/Apollo| apollo-link 概念/","link":"","permalink":"https://React-Apollo.github.io/2018/03/22/Apollo| apollo-link 概念/","excerpt":"","text":"这个概念实际和 redux的 middleware 类似, 就是在数据流处理中的增加环节 概念总览 Apollo Link设计目的是组合围绕 GraphQL数据操作的 actions.每个link代表着创建复杂数据控制流程的子功能. 基础是一个函数接收一个操作,返回一个 observable. 一个操作对象有一下的信息: ① query :DocumentNode(解析 GraphQL Operation)描述发生的操作 ② variables:伴随 operation 发送的变量映射 ③ operationName: 查询的名字,可以为 null ④ extensions:发送到 server 的数据在 Store的映射 ⑤ getContext: 返回请求 context 的函数. 被 link 用来决定执行哪一个 actions ⑥ setContext: 创建一个新的 context 对象,或者是接受之前的 context,返回一个新的 context. 和React 的setState行为类似 ⑦ toKey: 把当前的操作转为字符串作为 uniq的函数 可以链式操作这些操作. compose action,从而实现复杂的操作逻辑 上图中最后 link的终点是 server,实际 结果可以来自于任何地方 Requestlink 的核心是request方法,接收参数如下: operation: 传递给 link的操作 forward: 声明链中接下来的 link Contextlink 可以形成链式操作, 所以需要在链中传递一些数据.context 的操作和 React 的setState类似 123456789101112131415const timeStartLink = new ApolloLink((operation, forward) =&gt; &#123; operation.setContext(&#123; start: new Date() &#125;); return forward(operation);&#125;);const logTimeLink = new ApolloLink((operation, forward) =&gt; &#123; return forward(operation).map((data) =&gt; &#123; // data from a previous link const time = new Date() - operation.getContext().start; console.log(`operation $&#123;operation.operationName&#125; took $&#123;time&#125; to complete`); return data; &#125;)&#125;);const link = timeStartLink.concat(logTimeLink) conxt 可以在 operation 开始的时候发送.例如可以在执行 query时 发送 context 12345678910111213const link = new ApolloLink((operation, forward) =&gt; &#123; const &#123; saveOffline &#125; = operation.getContext(); if (saveOffline) // do offline stuff return forward(operation);&#125;)const client = new ApolloClient(&#123; cache: new InMemoryCache() link,&#125;);// send context to the linkconst query = client.query(&#123; query: MY_GRAPHQL_QUERY, context: &#123; saveOffline: true &#125;&#125;);","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"}]},{"title":"Apollo| Stateless Links","slug":"Apollo|Stateless Links","date":"2018-03-22T10:37:32.000Z","updated":"2018-04-07T02:42:18.247Z","comments":true,"path":"2018/03/22/Apollo|Stateless Links/","link":"","permalink":"https://React-Apollo.github.io/2018/03/22/Apollo|Stateless Links/","excerpt":"","text":"Stateless Links有些Link在每次请求中做的工作相同, 不需要知道具体的操作是什么. 这样的 Link 被称为 stateless Link. 不会在 link 之间共享 state. 对应的是 stateful Link Stateless Links 可以作为包装ApolloLink接口的简单函数. 例如: 123456789import &#123; ApolloLink &#125; from 'apollo-link';const consoleLink = new ApolloLink((operation, forward) =&gt; &#123; console.log(`starting request for $&#123;operation.operationName&#125;`); return forward(operation).map((data) =&gt; &#123; console.log(`ending request for $&#123;operation.operationName&#125;`); return data; &#125;)&#125;) statelss link 可以作为 middleware. 给 apollo-link-http 添加请求头是非常简单的一件事: 12345678import &#123; ApolloLink &#125; from 'apollo-link';const authLink = new ApolloLink((operation, forward) =&gt; &#123; operation.setContext((&#123; headers &#125;) =&gt; (&#123; headers: &#123; authorization: Meteor.userId() // however you get your token &#125;&#125;)); return forward(operation);&#125;); 可以定制操作函数例如: 12345678910import &#123; ApolloLink &#125; from 'apollo-link';const reportErrors = (errorCallback) =&gt; new ApolloLink((operation, forward) =&gt; &#123; const observer = forward(operation); // errors will be sent to the errorCallback observer.subscribe(&#123; error: errorCallback &#125;) return observer;&#125;);const link = reportErrors(console.error); Extending ApolloLink12345678910111213141516import &#123; ApolloLink &#125; from 'apollo-link';class ReportErrorLink extends ApolloLink &#123; constructor(errorCallback) &#123; super(); this.errorCallback = errorCallback; &#125; request(operation, forward) &#123; const observer = forward(operation); // errors will be sent to the errorCallback observer.subscribe(&#123; error: this.errorCallback &#125;) return observer; &#125;&#125;const link = new ReportErrorLink(console.error);","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"}]},{"title":"Apollo|Stateful Links","slug":"Apollo|Stateful Links","date":"2018-03-22T10:37:07.000Z","updated":"2018-04-07T02:42:18.247Z","comments":true,"path":"2018/03/22/Apollo|Stateful Links/","link":"","permalink":"https://React-Apollo.github.io/2018/03/22/Apollo|Stateful Links/","excerpt":"","text":"Stateful Links某些 Link 需要在请求之间共享 state,从而完成额外的功能.Stateful links 总是重写ApolloLink 1234567891011121314import &#123; ApolloLink &#125; from 'apollo-link';class OperationCountLink extends ApolloLink &#123; constructor() &#123; super(); this.operations = 0; &#125; request(operation, forward) &#123; this.operations++ return forward(operation); &#125;&#125;const link = new OperationCountLink();","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"}]},{"title":"摘要|Using Apollo with TypeScript","slug":"摘要|Using Apollo with TypeScript","date":"2018-03-16T10:40:34.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/03/16/摘要|Using Apollo with TypeScript/","link":"","permalink":"https://React-Apollo.github.io/2018/03/16/摘要|Using Apollo with TypeScript/","excerpt":"","text":"typescript 需要额外定义类型12345678910111213141516171819202122232425262728293031323334353637383940import React from \"react\";import gql from \"graphql-tag\";import &#123; graphql &#125; from \"react-apollo\";const HERO_QUERY = gql` query GetCharacter($episode: Episode!) &#123; hero(episode: $episode) &#123; name id friends &#123; name id appearsIn &#125; &#125; &#125;`;//类型type Hero = &#123; name: string; id: string; appearsIn: string[]; friends: Hero[];&#125;;//查询结果的类型type Response = &#123; hero: Hero;&#125;;const withCharacter = graphql&lt;Response&gt;(HERO_QUERY, &#123; options: () =&gt; (&#123; variables: &#123; episode: \"JEDI\" &#125; &#125;)&#125;);export default withCharacter((&#123; data: &#123; loading, hero, error &#125; &#125;) =&gt; &#123; if (loading) return &lt;div&gt;Loading&lt;/div&gt;; if (error) return &lt;h1&gt;ERROR&lt;/h1&gt;; return ...// actual component with data;&#125;); 对于查询参数也需要定义类型123456789type InputProps = &#123; episode: string&#125;;const withCharacter = graphql&lt;Response, InputProps&gt;(HERO_QUERY, &#123; options: (&#123; episode &#125;) =&gt; (&#123; variables: &#123; episode &#125; &#125;),&#125;); 在包装组件获取 props 时也需要定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React from \"react\";import gql from \"graphql-tag\";import &#123; graphql, NamedProps, QueryProps&#125; from \"react-apollo\";const HERO_QUERY = gql` query GetCharacter($episode: Episode!) &#123; hero(episode: $episode) &#123; name id friends &#123; name id appearsIn &#125; &#125; &#125;`;type Hero = &#123; name: string; id: string; appearsIn: string[]; friends: Hero[];&#125;;type Response = &#123; hero: Hero;&#125;;type WrappedProps = Response &amp; QueryProps;type InputProps = &#123; episode: string&#125;;const withCharacter = graphql&lt;Response, InputProps, WrappedProps&gt;(HERO_QUERY, &#123; options: (&#123; episode &#125;) =&gt; (&#123; variables: &#123; episode &#125; &#125;), props: (&#123; data &#125;) =&gt; (&#123; ...data &#125;)&#125;);export default withCharacter((&#123; loading, hero, error &#125;) =&gt; &#123; if (loading) return &lt;div&gt;Loading&lt;/div&gt;; if (error) return &lt;h1&gt;ERROR&lt;/h1&gt;; return ...// actual component with data;&#125;); 使用class组件定义","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"}]},{"title":"PokeMon datamodel","slug":"Pokemo-datamodel","date":"2018-03-16T10:04:10.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/03/16/Pokemo-datamodel/","link":"","permalink":"https://React-Apollo.github.io/2018/03/16/Pokemo-datamodel/","excerpt":"","text":"123456789101112type Trainer &#123; id: String! name: String! ownedPokemons: [Pokemon] # 一个训练师有多个宠物&#125;type Pokemon &#123; id: String! url: String! name: String! trainer: Trainer # 一个宠物属于一个训练师&#125; 基础查询 12345678910111213const TrainerQuery = gql` query TrainerQuery($name: String!) &#123; Trainer(name: $name) &#123; id name ownedPokemons &#123; id name url &#125; &#125; &#125;` ownedPokeMons是一个数组,可以用Trainer.ownedPokemons.length,获取到训练师所有的宠物的数量. 宠物详情查询 123456789const PokemonQuery = gql` query PokemonQuery($id: ID!) &#123; Pokemon(id: $id) &#123; id url name &#125; &#125;`","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"datamodel","slug":"datamodel","permalink":"https://React-Apollo.github.io/tags/datamodel/"}]},{"title":"The way to Typescript","slug":"The way to  TypeScript","date":"2018-03-16T08:34:49.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/03/16/The way to  TypeScript/","link":"","permalink":"https://React-Apollo.github.io/2018/03/16/The way to  TypeScript/","excerpt":"","text":"The init work to Typescript","categories":[{"name":"Init","slug":"Init","permalink":"https://React-Apollo.github.io/categories/Init/"}],"tags":[{"name":"Anything","slug":"Anything","permalink":"https://React-Apollo.github.io/tags/Anything/"}]},{"title":"摘要|Offline-First Web Application Using Redux and PouchDB","slug":"摘要|Offline-First Web Application Using Redux and PouchDB","date":"2018-03-12T10:07:01.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/03/12/摘要|Offline-First Web Application Using Redux and PouchDB/","link":"","permalink":"https://React-Apollo.github.io/2018/03/12/摘要|Offline-First Web Application Using Redux and PouchDB/","excerpt":"","text":"摘要|Offline-First Web Application Using Redux and PouchDB 5步构建离线优先web 应用 离线应用使用本地存储作为主要数据源, 数据不断和远程数据库同步为什么使用离线优先的模式?离线优先的应用有如下有点: 页面加载更高效 离线,在线工作状态没有区别 避免偶然的数据丢失. 使用 React,Redux和 PouchDB1.React和 Redux 构架 Redux作为 React 的数据管理工具, 模式是单一 store 2.PouchDB PoucdDB来源于 couchDB, 属于客户端的 NO-SQL 数据库. 用来存储本地数据 3.如何使用 Redux 和 PouchDB可以使用开源的包:redux-pouchdb 之后只需要导出 reducer 就可以了 4. 本地数据和远程数据库同步a)使用 CouchDB 使用CouchDB 的原因是,它和 pouchDB 同步很容易. PouchDB提供了同步的方法,允许单向或者双向同步. 只需要在开始的时候使用 Pouch.sync. b)使用已经存在的数据库PouchDB 在后台会一直尝试和远程数据库建立连接, 如果网络状态不稳定,等到有网络连接时,后台就会执行同步操作,发送离线数据 如果用户关掉窗口怎么办?所有的变化都保存在 reducer 中,并和 PouchDB 同步. 所以如果用户关掉窗口,数据也不会丢失. 5. Service Workers","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React-Native","slug":"React-Native","permalink":"https://React-Apollo.github.io/tags/React-Native/"},{"name":"offline","slug":"offline","permalink":"https://React-Apollo.github.io/tags/offline/"},{"name":"PouchDB","slug":"PouchDB","permalink":"https://React-Apollo.github.io/tags/PouchDB/"}]},{"title":"摘要|GraphQL Persisted Queries using GET Requests","slug":"摘要|GraphQL Persisted Queries using GET Requests","date":"2018-03-11T10:28:49.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/03/11/摘要|GraphQL Persisted Queries using GET Requests/","link":"","permalink":"https://React-Apollo.github.io/2018/03/11/摘要|GraphQL Persisted Queries using GET Requests/","excerpt":"","text":"原文:GraphQL Persisted Queries using GET Requests 摘要总结通过express 的中间件实现了 graphql Persisted Queries,在前端查询时使用的普通的GET请求,带有hash变量和具体变量, hash变量用于从服务器获取到对应的查询或者突变 schema,然后和具体的变量组合成真正的查询字符窜, 之后实施真正的 Graphql 查询工作, 并返回信息给前端 实现要点:1. 构建的hash 和查询的映射extracted_queries.js 12345678module.exports = &#123; 1: `query Greeting($name: String!) &#123; greeting(name: $name) &#123; name text &#125; &#125;` &#125; 2. 构建 Presist Query 中间件persistedQueries.js 12345678910111213141516171819const &#123; omit &#125; = require('ramda')const queryMap = require('./extracted_queries.js')const persistedQueries = (req, res, next) =&gt; &#123; const &#123; hash = '' &#125; = req.query if (!hash) return next() const query = queryMap[hash] if (!query) &#123; res.status(400).json(&#123; error: [&#123;&#125;] &#125;) return next(new Error('Invalid query hash')) &#125; req.query = &#123; query, variables: omit(['hash'], req.query) &#125; next()&#125;module.exports = persistedQueries 如果 hash存在,就提取出查询字符串和变量组成新的查询 3. 构建 graphql server1234567891011121314151617181920212223const express = require('express')const bodyParser = require('body-parser') const playground = require('graphql-playground-middleware-express').defaultconst &#123; graphqlExpress, graphiqlExpress &#125; = require('apollo-server-express')const &#123; makeExecutableSchema &#125; = require('graphql-tools')const persistedQueries = require('./persistedQueries')const typeDefs = require('./schemas')const resolvers = require('./resolvers')const port = 4000const app = express()const schema = makeExecutableSchema(&#123; typeDefs, resolvers &#125;)app.use( '/graphql', bodyParser.json(), persistedQueries, //对 get请求进行匹配操作.匹配的查询进入具体的查询操作 graphqlExpress(&#123; schema &#125;))//playground实现app.use( '/playground', playground(&#123; endpoint: '/graphql' &#125;))app.listen(port, () =&gt; console.log(`listening on port: $&#123;port&#125;`)) 构想如果是常规的 Redux 构架, REST API太多, 造成 Action过多, 如果是使用上述的方法, 可以把一个大的页面的数据查询组合成一个单独的 REST请求. 简化了前端的 Action这样还可以使用不同的 GraphQL的数据","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Persisted Queries","slug":"Persisted-Queries","permalink":"https://React-Apollo.github.io/tags/Persisted-Queries/"}]},{"title":"摘要|How do GraphQL remote schemas work?","slug":"摘要|How do GraphQL remote schemas work","date":"2018-03-10T22:16:54.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/03/10/摘要|How do GraphQL remote schemas work/","link":"","permalink":"https://React-Apollo.github.io/2018/03/10/摘要|How do GraphQL remote schemas work/","excerpt":"","text":"Understanding GraphQL schema stitching(part I)目的是使用已经有的 graphql API,通过我们自己的服务器暴露出来. 在配置阶段,我们只是简单的转发收到的GraphQL query 和 mutations. 负责转发这些操作的组件被称为 remote(executable)schema. Remote shcema 作为 schema stitching schema的基础工具. 下面讨论一下细节问题. 回忆一下 GraphQL schemasschema由两个主要组件构成(这里的组件不是 react组件) schema definition: 这部分通常用 schema definition language(SDL).本质上, schema 定义了 server能够接受的操作是什么, 需要报含Query type,可选的Mutations,Subscription. 可以用typeDefs定义 Resolvers: 这里是 shcema 真正进入到实际操作的地方, Resolvers实现了有由 schema 定义的 API 规范. 当一个 schema 有了 definition和 resolver,被称为executable schema. 下面是简单的实例,使用graphql-tools 的makeEcecutableSchema函数: 123456789101112131415161718192021222324252627const &#123; makeExecutableSchema &#125; = require('graphql-tools')// SCHEMA DEFINITIONconst typeDefs = `type Query &#123; user(id: ID!): User&#125;type User &#123; id: ID! name: String&#125;`// RESOLVERSconst resolvers = &#123; Query: &#123; user: (root, args, context, info) =&gt; &#123; return fetchUserById(args.id) //可以是数据库查询,或者是从其他的 //REST API 获取数据 &#125; &#125;,&#125;// (EXECUTABLE) SCHEMAconst schema = makeExecutableSchema(&#123; typeDefs, resolvers&#125;) typeDefs包含了 schema 定义, 由Query和简单的User type组成. resolvers是包含了如何实现Query type 中user字段实现的方案 makeEcecutableSchema: 从 SDL type 映射到对应的 resolver. 返回的实例可以用于直接的查询. 例如graphql函数 123456789101112131415... // other importsconst &#123; graphql &#125; = require('graphql')const schema = ... // the schema from aboveconst query = ` query &#123; user(id: \"abc\") &#123; id name &#125; &#125;`graphql(schema, query) .then(result =&gt; console.log(result)) 因为 grphql 函数可以根据 GraphQLSchema的实例来查询,所以也可以被认为是 GraphQL(execute) 引擎 以上只是回顾. 现在看看如何根据已经存在的 graphql API 创建GraphQLSchema的可执行实例 Introspecting GraphQL APISGraphQL的有一个很趁手的属性, introspection. 可以发起一个 introspection query 来获取schema的定义. 12345678910query &#123; __schema &#123; types &#123; name fields &#123; name &#125; &#125; &#125;&#125; 返回的是 json 格式的数据 12345678910111213141516171819202122232425262728&#123; \"data\": &#123; \"__schema\": &#123; \"types\": [ &#123; \"name\": \"Query\", \"fields\": [ &#123; \"name\": \"user\" &#125; ] &#125;, &#123; \"name\": \"User\", \"fields\": [ &#123; \"name\": \"id\" &#125;, &#123; \"name\": \"name\" &#125; ] &#125;, // ... some more metadata ] &#125; &#125;&#125; 返回的 schema和我们自己定义的 shcema 很像, 稍有差别,但是可以修改 创建一个 remote schema makeRemoteExecutableSchema接收两个参数 一个 shcema 定义(这里通过 introspection 获取). 最佳实践是直接定义为 .grpahql文件 Link连接被代理的 GraphQL API. 本质上, Link 是转发 query 和 mutation 的组件. 没有办法获取到 remote的 resolver.但是可以创建新的 resolver,来转发操作到内部的 GraphQL API. 看看实际的代码, 基于一个 API,用于User模型. 1234567891011121314151617181920212223242526272829const fetch = require('node-fetch')const &#123; makeRemoteExecutableSchema, introspectSchema &#125; = require('graphql-tools')const &#123; GraphQLServer &#125; = require('graphql-yoga')const &#123; createHttpLink &#125; = require('apollo-link-http')const &#123; DATABASE_SERVICE_ID &#125; = require('./services')async function run() &#123; // 1. Create Apollo Link that's connected to the underlying GraphQL API const makeDatabaseServiceLink = () =&gt; createHttpLink(&#123; uri: `https://api.graph.cool/simple/v1/$&#123;DATABASE_SERVICE_ID&#125;`, fetch &#125;) // 2. Retrieve schema definition of the underlying GraphQL API const databaseServiceSchemaDefinition = await introspectSchema(makeDatabaseServiceLink()) // 3. Create the executable schema based on schema definition and Apollo Link const databaseServiceExecutableSchema = makeRemoteExecutableSchema(&#123; schema: databaseServiceSchemaDefinition, link: makeDatabaseServiceLink() &#125;) // 4. Create and start proxy server based on the executable schema const server = new GraphQLServer(&#123; schema: databaseServiceExecutableSchema &#125;) server.start(() =&gt; console.log('Server is running on http://localhost:4000'))&#125;run() 用于User type 的 CRUD API 123456789101112131415type User @model &#123; id: ID! @isUnique name: String!&#125;type Query &#123; allUsers: [User!]! User(id: ID!): User&#125;type Mutation &#123; createUser(name: String!): User updateUser(id: ID!, name: String): User deleteUser(id: ID!): User&#125; 底层的 Remote schemasInspecting GraphQL schemas 篮框显示Query type和他的属性. 有字段allUsers,但是 没有 resolver,所以这不是可执行的. 现在有 resolver了. 继续看看 resolver的实现,(这是由 makeRemoteExecuteableSchema 自动生成的). 1234567891011121314151617181920212223function (root, args, context, info) &#123; return __awaiter(_this, void 0, void 0, function () &#123; var fragments, document, result; return __generator(this, function (_a) &#123; switch (_a.label) &#123; case 0: fragments = Object.keys(info.fragments).map(function (fragment) &#123; return info.fragments[fragment]; &#125;); document = &#123; kind: graphql_1.Kind.DOCUMENT, definitions: [info.operation].concat(fragments), &#125;; return [4 /*yield*/, fetcher(&#123; query: graphql_2.print(document), variables: info.variableValues, context: &#123; graphqlContext: context &#125;, &#125;)]; case 1: result = _a.sent(); return [2 /*return*/, errors_1.checkResultAndHandleErrors(result, info)]; &#125; &#125;); &#125;);&#125; 12-16行代码 函数fetcher用三个参数调用,query,variables,context,","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"GraphQL|Github graphql API  文档示意","slug":"GraphQL|Github graphql API  文档示意","date":"2018-03-09T10:52:29.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/03/09/GraphQL|Github graphql API  文档示意/","link":"","permalink":"https://React-Apollo.github.io/2018/03/09/GraphQL|Github graphql API  文档示意/","excerpt":"","text":"克隆 gitpoint 的项目 ,记录一下 GraphQL 的查询,就可以作为文档了. 按照 gitpoint 的 tab顺序来. 项目初衷, gitpoint 用的是 Redux,写的很好,功能也很完备,Redux的一个优点是单一数据来源.但是如果是远程数据, REST API 提供的数据, 却并不是单一来源的,而且每个远程请求的状态都要自己配置. 代码量太大. 使用 GraphQL的服务, 真正做到了单一数据来源, 把多个数据接口变为一个接口. 返回数据可以灵活安排, 代码减少了很多. 1.Profile 查询1.1 profile.screen 数据查询viewer 查询当前登录用户的信息 123456789101112131415161718192021222324252627282930313233343536373839404142query viewer&#123; viewer&#123; login email bio name avatarUrl location repositories&#123; totalCount &#125; repositoriesContributedTo&#123; totalCount &#125; followers&#123; totalCount &#125; following&#123; totalCount &#125; organizations(first:5)&#123; edges&#123; node&#123; name avatarUrl teams(first:5)&#123; edges&#123; node&#123; name avatarUrl &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 结果 一次查询出 profile 页面的所有数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; \"data\": &#123; \"viewer\": &#123; \"repositoriesContributedTo\": &#123; \"totalCount\": 6 &#125;, \"login\": \"phpsmarter\", \"email\": \"3238355967@qq.com\", \"bio\": \"A React Native code beginner\", \"name\": \"phpsmarter\", \"avatarUrl\": \"https://avatars3.githubusercontent.com/u/10001670?v=4\", \"location\": null, \"repositories\": &#123; \"totalCount\": 486 &#125;, \"followers\": &#123; \"totalCount\": 5 &#125;, \"following\": &#123; \"totalCount\": 0 &#125;, \"organizations\": &#123; \"edges\": [ &#123; \"node\": &#123; \"name\": \"edulamp\", \"avatarUrl\": \"https://avatars2.githubusercontent.com/u/10001682?v=4\", \"teams\": &#123; \"edges\": [ &#123; \"node\": &#123; \"name\": \"Owners\", \"avatarUrl\": \"https://avatars2.githubusercontent.com/t/1156109?s=400&amp;v=4\" &#125; &#125; ] &#125; &#125; &#125; ] &#125; &#125; &#125;&#125; 1.2 查询粉丝12345678910111213query FollowerList &#123; user(login: \"phpsmarter\") &#123; followers(first: 10) &#123; edges &#123; node &#123; name avatarUrl email &#125; &#125; &#125; &#125;&#125; 结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; \"data\": &#123; \"user\": &#123; \"followers\": &#123; \"edges\": [ &#123; \"node\": &#123; \"name\": \"liujian zhang\", \"avatarUrl\": \"https://avatars2.githubusercontent.com/u/4494312?v=4\", \"email\": \"ziaochina@gmail.com\" &#125; &#125;, &#123; \"node\": &#123; \"name\": \"Ömer DOĞAN\", \"avatarUrl\": \"https://avatars2.githubusercontent.com/u/6252528?v=4\", \"email\": \"omer_dogan@outlook.com\" &#125; &#125;, &#123; \"node\": &#123; \"name\": \"Archakov Dennis\", \"avatarUrl\": \"https://avatars3.githubusercontent.com/u/12086860?v=4\", \"email\": \"hello@archakov.im\" &#125; &#125;, &#123; \"node\": &#123; \"name\": \"Prachi Sharma\", \"avatarUrl\": \"https://avatars0.githubusercontent.com/u/13256500?v=4\", \"email\": \"prachi.asm@gmail.com\" &#125; &#125;, &#123; \"node\": &#123; \"name\": null, \"avatarUrl\": \"https://avatars0.githubusercontent.com/u/21312042?v=4\", \"email\": \"\" &#125; &#125; ] &#125; &#125; &#125;&#125; ==================================================================== 2. Repo的查询2.1 repoList的查询2.2 repo的查询12345678910111213141516171819202122232425262728query repo($owner: String!, $name: String!) &#123; repository(owner: $owner, name: $name) &#123; name url stargazers &#123; totalCount &#125; owner &#123; avatarUrl login &#125; collaborators(first: 20) &#123; edges &#123; node &#123; avatarUrl name url &#125; &#125; &#125; pullRequests &#123; totalCount &#125; createdAt description forkCount &#125;&#125; 结果是 1234567891011121314151617181920212223242526272829303132&#123; \"data\": &#123; \"repository\": &#123; \"name\": \"react-native-lagou\", \"url\": \"https://github.com/phpsmarter/react-native-lagou\", \"stargazers\": &#123; \"totalCount\": 1 &#125;, \"owner\": &#123; \"avatarUrl\": \"https://avatars3.githubusercontent.com/u/10001670?v=4\", \"login\": \"phpsmarter\" &#125;, \"collaborators\": &#123; \"edges\": [ &#123; \"node\": &#123; \"avatarUrl\": \"https://avatars3.githubusercontent.com/u/10001670?v=4\", \"name\": \"phpsmarter\", \"url\": \"https://github.com/phpsmarter\" &#125; &#125; ] &#125;, \"pullRequests\": &#123; \"totalCount\": 0 &#125;, \"createdAt\": \"2016-02-18T10:18:18Z\", \"description\": \"用react native写的仿拉勾ios版本demo\", \"forkCount\": 0 &#125; &#125;&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Github","slug":"Github","permalink":"https://React-Apollo.github.io/tags/Github/"},{"name":"API","slug":"API","permalink":"https://React-Apollo.github.io/tags/API/"}]},{"title":"摘要|Functional Components with React stateless functions and Ramda","slug":"摘要|Functional Components with React stateless functions and Ramda","date":"2018-03-08T09:59:14.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/03/08/摘要|Functional Components with React stateless functions and Ramda/","link":"","permalink":"https://React-Apollo.github.io/2018/03/08/摘要|Functional Components with React stateless functions and Ramda/","excerpt":"","text":"原文在这里. 有段时间不看了, 有些忘了,有些地方还有一定的加深. 什么是 React stateless function? es6的语法 12345class List extends React.Component &#123; render() &#123; return (&lt;ul&gt;&#123;this.props.children&#125;&lt;/ul&gt;); &#125;&#125; 简单的 javascripg函数也可以! 1234567//Stateless function syntaxconst List = function(children) &#123; return (&lt;ul&gt;&#123;children&#125;&lt;/ul&gt;);&#125;;//ES6 arrow syntaxconst List = (children) =&gt; (&lt;ul&gt;&#123;children&#125;&lt;/ul&gt;); 彻底的模板,没有自己任何的数据,也没有生命周期方法. 纯粹依赖于输入. 首先来定义一个 App Container目的是最为一个函数接收 app sate 对象 1234567891011import React from 'react';import ReactDOM from 'react-dom';const App = appState =&gt; (&lt;div className=\"container\"&gt; &lt;h1&gt;App name&lt;/h1&gt; &lt;p&gt;Some children here...&lt;/p&gt;&lt;/div&gt;);//这里定义了渲染的方法,作为 APP函数的属性,并且是柯理化的, 等待传入 dom 元素App.render = R.curry((node, props) =&gt; ReactDOM.render(&lt;App &#123;...props&#125;/&gt;, node));export default App; 在纯函数中,state 必须要在外部管理,然后以 props 的形式传递给组件.下面看看这个解释的例子 Stateless Timer component简单的 timer 组件只接受 secondsElapsed 参数: 12345import React from 'react';export default (&#123; secondsElapsed &#125;) =&gt; (&lt;div className=\"well\"&gt; Seconds Elapsed: &#123;secondsElapsed&#125;&lt;/div&gt;); 添加到 APP 中 1234567891011121314import React from 'react';import ReactDOM from 'react-dom';import R from 'ramda';import Timer from './timer';const App = appState =&gt; (&lt;div className=\"container\"&gt; &lt;h1&gt;App name&lt;/h1&gt; //Timer 只从父组件接受 props 作为自己的数据 &lt;Timer secondsElapsed=&#123;appState.secondsElapsed&#125; /&gt;&lt;/div&gt;);App.render = R.curry((node, props) =&gt; ReactDOM.render(&lt;App &#123;...props&#125;/&gt;, node));export default App; 最后创建main.js 文件,启动渲染过程 123456789101112131415161718import App from './components/app'; //导入容器组件// 我们已经有了柯理化的方法//App.render = R.curry((node, props) =&gt; ReactDOM.render(&lt;App &#123;...props&#125;/&gt;, node));//配置好渲染的目标元素const render = App.render(document.getElementById('app'));//state 初始值let appState = &#123; secondsElapsed: 0&#125;;//first render 首次渲染render(appState);//多次重复渲染setInterval(() =&gt; &#123; appState.secondsElapsed++; render(appState);&#125;, 1000); 对于上面的代码, 变化的是组件的 state, 渲染的目标元素是一直不变的, 所以我们用柯理化配置好一个工厂函数 12//闭包再工作!const render = App.render(document.getElementById(‘app’)); 柯理化返回的函数,等待传入 props 1(props) =&gt; ReactDOM.render(...) 只要 State发生变化,我们需要渲染时,只需要传递 state 就可以了 1234setInterval(() =&gt; &#123; appState.secondsElapsed++; render(appState);&#125;, 1000); 每一秒钟, secondsElapsed 属性会递增1, 然后作为参数传递给 render 函数 现在可以实现 Redux 风格的 reduce 函数, reduce式的函数不能突变当前值 1currentState-&gt;newState 使用 Radma 的 Lenses 来实现 1234567const secondsElapsedLens = R.lensProp('secondsElapsed');const incSecondsElapsed = R.over(secondsElapsedLens, R.inc);setInterval(() =&gt; &#123; appState = incSecondsElapsed(appState); render(appState);&#125;, 1000); 首先创建 Lens: 1const secondsElapsedLens = R.lensProp('secondsElapsed'); lens可以聚焦于给定的属性,不会针对特定的对象, 所以可以重用. View 1R.view(secondsElapsedLens, &#123; secondsElapsed: 10 &#125;); //=&gt; 10 Set 1R.set(secondsElapsedLens, 11, &#123; secondsElapsed: 10 &#125;); //=&gt; 11 用给定的函数 Set 1R.over(secondsElapsedLens, R.inc, &#123; secondsElapsed: 10 &#125;); //=&gt; 11 inSecondElapsed reducer 是一个偏应用函数(partial application),这一行1const incSecondsElapsed = R.over(secondsElapsedLens, R.inc); 会返回一个新的函数,一旦用appState 调用, 就会应用 R.inc在 lensed prop secondElapsed 上. 1appState=incSecondElapsed(appState) 组合 React stateless components开篇提到,React 组件可以作为函数, 那么可以用 R.compose来 compose 这些函数吗?当然是可以的 用 React.createClass 是这样的: 123456789101112131415const TodoList = React.createClass(&#123; render: function() &#123; const createItem = function(item) &#123; return (&lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/li&gt;); &#125;; return (&lt;div className=\"panel panel-default\"&gt; &lt;div className=\"panel-body\"&gt; &lt;ul&gt; &#123;this.props.items.map(createItem)&#125; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;); &#125;&#125;); 现在问题是: TodoList 可以由小的可重用部分 composition 而成吗? 可以的. 可以分为三个更小的组件 容器组件 12345const Container = children =&gt; (&lt;div className=\"panel panel-default\"&gt; &lt;div className=\"panel-body\"&gt; &#123;children&#125; &lt;/div&gt;&lt;/div&gt;); 列表组件 123const List = children =&gt; (&lt;ul&gt; &#123;children&#125;&lt;/ul&gt;); 列表项组件 123const ListItem = (&#123; id, text &#125;) =&gt; (&lt;li key=&#123;id&#125;&gt; &lt;span&gt;&#123;text&#125;&lt;/span&gt;&lt;/li&gt;); 现在一步一动,看看每一步的输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133Container(&lt;h1&gt;Hello World!&lt;/h1&gt;);/** * &lt;div className=\"panel panel-default\"&gt; * &lt;div className=\"panel-body\"&gt; * &lt;h1&gt;Hello World!&lt;/h1&gt; * &lt;/div&gt; * &lt;/div&gt; */Container(List(&lt;li&gt;Hello World!&lt;/li&gt;));/** * &lt;div className=\"panel panel-default\"&gt; * &lt;div className=\"panel-body\"&gt; * &lt;ul&gt; * &lt;li&gt;Hello World!&lt;/li&gt; * &lt;/ul&gt; * &lt;/div&gt; * &lt;/div&gt; */const TodoItem = &#123; id: 123, text: 'Buy milk'&#125;;Container(List(ListItem(TodoItem)));/** * &lt;div className=\"panel panel-default\"&gt; * &lt;div className=\"panel-body\"&gt; * &lt;ul&gt; * &lt;li&gt; * &lt;span&gt;Buy milk&lt;/span&gt; * &lt;/li&gt; * &lt;/ul&gt; * &lt;/div&gt; * &lt;/div&gt; */``` - Container(List(ListItem(TodoItem)))这里我们把TodoItem 数据传给 ListItem, 然后结果作为 List 的参数, 返回的结果又作为 Container的参数如果用 compose 函数,过程如下```jsR.compose(Container, List)(&lt;li&gt;Hello World!&lt;/li&gt;);/** * &lt;div className=\"panel panel-default\"&gt; * &lt;div className=\"panel-body\"&gt; * &lt;ul&gt; * &lt;li&gt;Hello World!&lt;/li&gt; * &lt;/ul&gt; * &lt;/div&gt; * &lt;/div&gt; */const ContainerWithList = R.compose(Container, List);R.compose(ContainerWithList, ListItem)(&#123;id: 123, text: 'Buy milk'&#125;);/** * &lt;div className=\"panel panel-default\"&gt; * &lt;div className=\"panel-body\"&gt; * &lt;ul&gt; * &lt;li&gt; * &lt;span&gt;Buy milk&lt;/span&gt; * &lt;/li&gt; * &lt;/ul&gt; * &lt;/div&gt; * &lt;/div&gt; */const TodoItem = &#123; id: 123, text: 'Buy milk'&#125;;const TodoList = R.compose(Container, List, ListItem);TodoList(TodoItem);/** * &lt;div className=\"panel panel-default\"&gt; * &lt;div className=\"panel-body\"&gt; * &lt;ul&gt; * &lt;li&gt; * &lt;span&gt;Buy milk&lt;/span&gt; * &lt;/li&gt; * &lt;/ul&gt; * &lt;/div&gt; * &lt;/div&gt; */``` - const TodoList = R.compose(Container, List, ListItem)列表的工厂函数,TodoList 组件可以看作为Container,List和 ListItem 的组合现在 还只能接受一个参数, 需要可以接受一个数组```jsconst mapTodos = function(todos) &#123; return todos.map(function(todo) &#123; return ListItem(todo); &#125;);&#125;;const TodoList = R.compose(Container, List, mapTodos);const mock = [ &#123;id: 1, text: 'One'&#125;, &#123;id: 1, text: 'Two'&#125;, &#123;id: 1, text: 'Three'&#125;];TodoList(mock);/** * &lt;div className=\"panel panel-default\"&gt; * &lt;div className=\"panel-body\"&gt; * &lt;ul&gt; * &lt;li&gt; * &lt;span&gt;One&lt;/span&gt; * &lt;/li&gt; * &lt;li&gt; * &lt;span&gt;Two&lt;/span&gt; * &lt;/li&gt; * &lt;li&gt; * &lt;span&gt;Three&lt;/span&gt; * &lt;/li&gt; * &lt;/ul&gt; * &lt;/div&gt; * &lt;/div&gt; */ mapTodos 可以有更简单的模式 123456789101112131415161718192021222324252627//Thisreturn todos.map(function(todo) &#123; return ListItem(todo);&#125;);//Is the same asreturn todos.map(ListItem);//So the result would beconst mapTodos = function(todos) &#123; return todos.map(ListItem);&#125;;//The same using Ramdaconst mapTodos = function(todos) &#123; return R.map(ListItem, todos);&#125;;//Now remember two things from Ramda docs:// - Ramda functions are automatically curried// - The parameters to Ramda functions are arranged to make it convenient for currying.// The data to be operated on is generally supplied last.//So:const mapTodos = R.map(ListItem);//At this point mapTodos variable is rendudant, we don't need it anymore:const TodoList = R.compose(Container, List, R.map(ListItem)); const mapTodos = R.map(ListItem); Ramda 函数式自动柯理化的,所以代码是这样的, 等待传递数据数组,返回的数组的形式是{data.item}组成的数组 完整的 TodoList 的代码就是1234567891011121314151617181920import React from 'React';import R from 'ramda';const Container = children =&gt; (&lt;div className=\"panel panel-default\"&gt; &lt;div className=\"panel-body\"&gt; &#123;children&#125; &lt;/div&gt;&lt;/div&gt;);const List = children =&gt; (&lt;ul&gt; &#123;children&#125;&lt;/ul&gt;);const ListItem = (&#123; id, text &#125;) =&gt; (&lt;li key=&#123;id&#125;&gt; &lt;span&gt;&#123;text&#125;&lt;/span&gt;&lt;/li&gt;);const TodoList = R.compose(Container, List, R.map(ListItem));export default TodoList; 工厂配置好了,就等数据了 模拟一下 appState 的 todo 数据 12345678let appState = &#123; secondsElapsed: 0, todos: [ &#123;id: 1, text: 'Buy milk'&#125;, &#123;id: 2, text: 'Go running'&#125;, &#123;id: 3, text: 'Rest'&#125; ]&#125;; 在 App 组件中添加 TodoList 组件作为子组件 123456import TodoList from './todo-list';const App = appState =&gt; (&lt;div className=\"container\"&gt; &lt;h1&gt;App name&lt;/h1&gt; &lt;Timer secondsElapsed=&#123;appState.secondsElapsed&#125; /&gt; &lt;TodoList todos=&#123;appState.todos&#125; /&gt;&lt;/div&gt;); TodoList组件期待的参数是一个todos数组, 12&lt;TodoList todos=&#123;appState.todos&#125; /&gt;//const TodoList = R.compose(Container, List, R.map(ListItem)) React stateless component是作为函数的,所以我们也可以传递参数 1TodoList(&#123;todos: appState.todos&#125;); 最好是传递单个参数,所以这种情况,再改进一下 1const TodoList = R.compose(Container, List, R.map(ListItem), R.prop('todos')); 调用就直接改为: 1TodoList(appState) 结束","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"Ramda","slug":"Ramda","permalink":"https://React-Apollo.github.io/tags/Ramda/"},{"name":"FP","slug":"FP","permalink":"https://React-Apollo.github.io/tags/FP/"}]},{"title":"Prisma|Native Authenticate Method","slug":"Prisma|Native Authenticate method","date":"2018-03-06T22:18:42.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/03/06/Prisma|Native Authenticate method/","link":"","permalink":"https://React-Apollo.github.io/2018/03/06/Prisma|Native Authenticate method/","excerpt":"","text":"针对以下的 schema1234567891011121314151617181920212223type Query &#123; vehicles(dealership: ID!): [Vehicle!]!&#125;type Mutation &#123; updateVehicleAskingPrice(id: ID!, askingPrice: Int!): Vehicle&#125;type Vehicle &#123; id: ID! year: Int! make: String! model: Int! askingPrice: Float costBasis: Float numberOfOffers: Int&#125;type User &#123; id: ID! name: String! role: String!&#125; updataVehicleAskingPrice应该只能有管理员操作 costBasis: 仅限于管理员 numberOfOffers: 认证用户可以使用 12345678910111213141516171819const Mutation = &#123; updateVehicleAskingPrice: async (parent, &#123; id, askingPrice &#125;, context, info) =&gt; &#123; const userId = getUserId(context) //用户的 role进行查询,看看是否数据管 const isRequestingUserManager = await context.db.exists.User(&#123; id: userId, role: `MANAGER` &#125;) if (isRequestingUserManager) &#123; return await context.db.mutation.updateVehicle(&#123; where: &#123; id &#125;, data: &#123; askingPrice &#125; &#125;) &#125; throw new Error( `Invalid permissions, you must be a manager to update vehicle year` ) &#125;&#125; 使用exists函数. 字段级别的认证 123456789101112131415const Query = &#123; vehicles: async (parent, args, context, info) =&gt; &#123; const vehicles = await context.db.query.vehicles(&#123; where: &#123; dealership: args.id &#125; &#125;) const user = getUser(context) return vehicles.map(vehicle =&gt; (&#123; ...vehicle, costBasis: user &amp;&amp; user.role.includes(`MANAGER`) ? vehicle.costBasis : null, numberOfOffers: user ? vehicle.numberOfOffers : null &#125;)) &#125;&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"Apollo|Query","slug":"Apollo|API Query","date":"2018-03-06T12:28:41.000Z","updated":"2018-04-07T02:42:18.247Z","comments":true,"path":"2018/03/06/Apollo|API Query/","link":"","permalink":"https://React-Apollo.github.io/2018/03/06/Apollo|API Query/","excerpt":"","text":"Query核心的理念是这也就是”GraphQL”,并没有什么新内容. 基础查询简单的使用graphql container. 解析查询使用的gql模板字符串,并传递给graphqlcontainer.作为第一个参数. 实例 : 在‘GitHunt’中,我们会在Profile组件显示当前登录的用户 1234567891011121314151617import React, &#123; Component &#125; from 'react';import &#123; graphql &#125; from 'react-apollo';import gql from 'graphql-tag';class Profile extends Component &#123; ... &#125;// We use the gql tag to parse our query string into a query documentconst CurrentUserForLayout = gql` query CurrentUserForLayout &#123; currentUser &#123; login avatar_url &#125; &#125;`;const ProfileWithData = graphql(CurrentUserForLayout)(Profile); 在我们使用graphql时, 会发生两件事: 查询从 Apollo-client的 data store 加载,如果不在 data store 中就从 server 加载 我们的组件订阅到 store. 所以如果数据发生改变, 组件就会更新 此外,对于在 query中的currentUser字段,data属性也包含有字段loading,这是一个布尔值, 表示当前从 server 加载数据的状态. 还有一个字段error,表示是否在加载数据时出现错误. 所以具体的属性的外观如下: 123456(props) =&gt; &#123; const loading = props.data.loading; const error = props.data.error; const currentUser = props.data.currentUser; // render UI with loading, error, or currentUser&#125; data.currentUser属性会随着用户的变化而发生变化. 信息存储在 Apollo client 的 全局 cache 中. data属性的结构如上所示, graphql会传递查询结果到被包装的组件,形式是data属性. 实际也传递所有的父组件的 props. 对于查询, data属性的外观如下 ...fileds: 查询中的每个根字段 loading: 如果有查询进行中, 这个字段为true,包含refetch查询时也是如此 error: APolloError对象代表查询中可能出现的各种错误. 例如下面的查询: 1234 query getUserAndLikes($id: ID!) &#123; user(userId: $id) &#123; name &#125; likes(userId: $id) &#123; count &#125;&#125; 我们得到的 props 如下: 123456789101112 data: &#123; user: &#123; name: \"James\" &#125;, likes: &#123; count: 10 &#125;, loading: false, error: null, variables: &#123; id: 'asdf' &#125;, refetch() &#123; ... &#125;, fetchMore() &#123; ... &#125;, startPolling() &#123; ... &#125;, stopPolling() &#123; ... &#125;, // ... more methods&#125; Variables 和 options如果想定制query,可以提供 option选项,作为graphql的第二个参数(第一个参数为查询字符串).如果需要传递变量,要在这个地方传递 12345678910111213141516171819202122232425262728293031// Suppose our profile query took an avatar sizeconst CurrentUserForLayout = gql` query CurrentUserForLayout($avatarSize: Int!) &#123; currentUser &#123; login avatar_url(avatarSize: $avatarSize) &#125; &#125;`;const ProfileWithData = graphql(CurrentUserForLayout, &#123; options: &#123; variables: &#123; avatarSize: 100 &#125; &#125;,&#125;)(Profile);``` `这里可能会有疑问, 一般在获取当前用户的时候需要传递 token,在 apollo client 中,我们在配置url 时,在头部从本地数据库获得到用户token,然后传递`.## 从 props 进行计算典型应用中,查询的变量或从包装组件的 props 中计算. 无论在什么地方使用组件,调用都会传递参数,所以`options`可以作为函数接受传递给组件的 props```js// The caller could do something like:&lt;ProfileWithData avatarSize=&#123;300&#125; /&gt;// And our HOC could look like:const ProfileWithData = graphql(CurrentUserForLayout, &#123; options: (&#123; avatarSize &#125;) =&gt; (&#123; variables: &#123; avatarSize &#125; &#125;),&#125;)(Profile); 默认情况下, graphql会尝试从ownPorps中获取需要的变量 其他的 options可以传递其他的 options,例如pollInterval 1234const ProfileWithData = graphql(CurrentUserForLayout, &#123; // See the watchQuery API for the options you can provide here options: &#123; pollInterval: 20000 &#125;,&#125;)(Profile); skipping an operation//如果认证没有通过就跳过这个查询,可以直接设为静态的 skip:true123const ProfileWithData = graphql(CurrentUserForLayout, &#123; skip: (ownProps) =&gt; !ownProps.authenticated,&#125;)(Profile); 改变 prop的名字12345678910111213141516171819import React, &#123; Component &#125; from 'react';import &#123; graphql &#125; from 'react-apollo';import gql from 'graphql-tag';class Profile extends Component &#123; ... &#125;const CurrentUserForLayout = gql` query CurrentUserForLayout &#123; currentUser &#123; login avatar_url &#125; &#125;`;// We want the prop to be called 'CurrentUserForLayout' instead of dataconst ProfileWithData = graphql(CurrentUserForLayout, &#123; name: 'CurrentUserForLayout'&#125;)(Profile); 任意的转换想完全控制传递给子组件的 props,可以使用props option 把 query 的data 映射为任意数量的 props 1234567891011121314151617181920212223242526import React, &#123; Component &#125; from 'react';import &#123; graphql &#125; from 'react-apollo';import gql from 'graphql-tag';// Here Profile has a more generic API, that's not coupled to Apollo or the// shape of the query that we've usedclass Profile extends Component &#123; ... &#125;const CurrentUserForLayout = gql` query CurrentUserForLayout &#123; currentUser &#123; login avatar_url &#125; &#125;`;const ProfileWithData = graphql(CurrentUserForLayout, &#123; // ownProps are the props that are passed into the `ProfileWithData` // when it is used by a parent component props: (&#123; ownProps, data: &#123; loading, currentUser, refetch &#125; &#125;) =&gt; (&#123; userLoading: loading, user: currentUser, refetchUser: refetch, &#125;),&#125;)(Profile); 这个方式最大限度的解耦了展示组件(Profile)和 Apollo API Reference123render() &#123; const &#123; data &#125; = this.props; // &lt;- The `data` prop.&#125; 如果我们要下面的查询 1234&#123; viwer&#123;name&#125; todos&#123;text&#125;&#125; 你的data props 将会包含如下数据 123456render() &#123; const &#123; data &#125; = this.props; console.log(data.viewer); // &lt;- The data returned by your query for `viewer`. console.log(data.todos); // &lt;- The data returned by your query for `todos`.&#125; data.networkStatud loading setVariables: query 的变量改变 fetchMore: 表示fetchMore在调用 refetch: refetch 在调用 poll: polling 在调用 ready: 没有操作进行中 error: 没有请求, 但是至少有一个错误 如果 network status 小于7 等同于data.loading==true 实例 1234567891011function MyComponent(&#123; data: &#123; networkStatus &#125; &#125;) &#123; if (networkStatus === 6) &#123; return &lt;div&gt;Polling!&lt;/div&gt;; &#125; else if (networkStatus &lt; 7) &#123; return &lt;div&gt;Loading...&lt;/div&gt;; &#125; else &#123; // ... &#125;&#125;export default graphql(gql`query &#123; ... &#125;`)(MyComponent); data.variablesApollo 用于获取数据的参数, 如果你想渲染一些与参数有关的信息 12345678910function MyComponent(&#123; data: &#123; variables &#125; &#125;) &#123; return ( &lt;div&gt; Query executed with the following variables: &lt;code&gt;&#123;JSON.stringify(variables)&#125;&lt;/code&gt; &lt;/div&gt; );&#125;export default graphql(gql`query &#123; ... &#125;`)(MyComponent); data.refetch(variables) 强制你的组件重新执行在graphql()函数中定义的操作. 当你想重载数据,或者是遇到错误时再次获取数据 data.refetch返回一个promise,resolves返回新的数据. data.fetchMore(options)data.fetchMore函数可以实现组件的分页操作. 接收单个options对象作为参数,有下面的属性: [query]:可选项,如果不使用就从graphql() hoc采用 [variables]: 可选的参数, 和上面一样的用法 updateQuery(previousResult,{fetchMoreResult,queryVariables}):实际执行分页时的函数. 第一个参数previousResult,是之前的查询返回的数据, 第二个参数有两个属性,fetchMoreResult,queryVariables,fetchMoreResult是新查询返回的数据, queryVariables是获取更多数据时采用的参数.使用这些参数,你应该返回一个新的data,和之前的data的外观一致. 参看下面的的实例 12345678910data.fetchMore(&#123; updateQuery: (previousResult, &#123; fetchMoreResult, queryVariables &#125;) =&gt; &#123; return &#123; ...previousResult, // Add the new feed data to the end of the old feed data. //在旧的数据末尾拼接新的数据 feed: [...previousResult.feed, ...fetchMoreResult.feed], &#125;; &#125;,&#125;); data.subscribeToMore(options)这个函数会配置 subscrption,当 server 发布subscription时,触发更新.需要在 server 做相应的工作.还会返回一个unscribe()函数,可以用于解绑定 通常的实践是在componentWillReceiveProps内包装subscribeToMore调用,在原始的查询完成之后,执行订阅. 为了确保不会多次创建 subscription.可以添加到组件实例上. [document]: graphql 的查询字符串 [variables]: 可选的参数, 可以用在documentoption 中 [updataQuery]: 可选的函数, server 发送更新时时会执行. 第一个参数previousResult是之前的查询结果,第二个参数是一个对象,有两个属性,subscriptionData是订阅的结果. variables是用于订阅的参数 [onError]: 可选的出现错误的回调函数 123456789101112131415161718192021222324252627class SubscriptionComponent extends Component &#123; componentWillReceiveProps(nextProps) &#123; if(!nextProps.data.loading) &#123; // Check for existing subscription if (this.unsubscribe) &#123; // Check if props have changed and, if necessary, stop the subscription if (this.props.subscriptionParam !== nextProps.subscriptionParam) &#123; this.unsubscribe(); &#125; else &#123; return; &#125; &#125; // Subscribe this.unsubscribe = nextProps.data.subscribeToMore(&#123; document: gql`subscription &#123;...&#125;`, updateQuery: (previousResult, &#123; subscriptionData, variables &#125;) =&gt; &#123; // Perform updates on previousResult with subscriptionData return updatedResult; &#125; &#125;); &#125; &#125; render() &#123; ... &#125;&#125; data.startPolling(interval)这个函数设置一个间隔, 间隔时间完了以后会发送一个 fetch请求. 直接收一个整数参数. Polling 是保持 UI中数据随时更新的好方法. 通过设置每5秒中重新获取数据. 可以有效的模拟实现实时数据更新, 后台不需要做任何的构建工作 123456789101112class MyComponent extends Component &#123; componentDidMount() &#123; // In this specific case you may want to use `options.pollInterval` instead. this.props.data.startPolling(1000); &#125; render() &#123; // ... &#125;&#125;export default graphql(gql`query &#123; ... &#125;`)(MyComponent); data.stopPolling()通过调用这个函数,可以停止当前的 polling 过程. 1234567891011121314151617181920212223242526class MyComponent extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; &#123; this.props.data.startPolling(1000); &#125;&#125;&gt; Start Polling &lt;/button&gt; &lt;button onClick=&#123;() =&gt; &#123; this.props.data.stopPolling(); &#125;&#125;&gt; Stop Polling &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default graphql(gql`query &#123; ... &#125;`)(MyComponent);``` ### `data.updataQuery(updaterFn)`在 query 和 mutate 之外对 data做出改变 data.updateQuery((previousResult) =&gt; ({ …previousResult, count: previousResult.count + 1,}));12345678910111213### `config.options`用于配置查询和更新的对象或者函数如果`config.options`是一个函数,就可以接受一个组件的 props 作为第一个参数.```jsexport default graphql(gql`&#123; ... &#125;`, &#123; options: &#123; // Options go here. &#125;,&#125;)(MyComponent); 12345export default graphql(gql`&#123; ... &#125;`, &#123; options: (props) =&gt; (&#123; // Options are computed from `props` here. &#125;),&#125;)(MyComponent); options.variables用于执行查询的变量. 这些变量应该和查询中定义的变量一一对应. 如果config.options作为函数,就可以从props 中计算变量 实例:123456789101112export default graphql(gql` query ($width: Int!, $height: Int!) &#123; ... &#125;`, &#123; options: (props) =&gt; (&#123; variables: &#123; width: props.size, height: props.size, &#125;, &#125;),&#125;)(MyComponent); optins.fetchPolicyfetchPolicy 是可选项,可以定制组件和 Apollo data cache 交互的方法. 默认情况下, 组件首先尝试从 cache获取数据. 如果需要的所有数据都在 cache 中, Apoll 会直接从 cache 中返回数据. 有效的fetchPolicy如下: cache-first: 默认的选项 cache-and-network : 如果 cache 中有全部数据, 就会直接返回,但是网络获取也会执行, 从而保持了 server 和 cache 的数据一致性. 不仅使用户迅速获得数据,还保持数据的一致性 network-only: 不从 cache 中返回数据 cache-only: 不执行网络获取 123export default graphql(gql`query &#123; ... &#125;`, &#123; options: &#123; fetchPolicy: 'cache-and-network' &#125;,&#125;)(MyComponent); options.errorPolicy用于定制 fetch data error的处理. runtime error和获取数据错误 none: 默认值, ignore: all: options.pollInterval123export default graphql(gql`query &#123; ... &#125;`, &#123; options: &#123; pollInterval: 5000 &#125;,&#125;)(MyComponent); options.notifyOnNetworkStatusChange网络状态发生变化时,触发组件的重新渲染 实例:123export default graphql(gql`query &#123; ... &#125;`, &#123; options: &#123; notifyOnNetworkStatusChange: true &#125;,&#125;)(MyComponent); optins.context在context对象下的所有的内容都可以直接传递到 network chain 中.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Apollo-Client","slug":"Apollo-Client","permalink":"https://React-Apollo.github.io/tags/Apollo-Client/"}]},{"title":"Apollo|API Reference","slug":"Apollo|API Reference","date":"2018-03-06T09:51:39.000Z","updated":"2018-04-07T02:42:18.247Z","comments":true,"path":"2018/03/06/Apollo|API Reference/","link":"","permalink":"https://React-Apollo.github.io/2018/03/06/Apollo|API Reference/","excerpt":"","text":"ApolloClient link cache ssrMode ssForceFetchDelay connectToDevTools queryDeduplication defaultOptions 12345678910111213const defaultOptions = &#123; watchQuery: &#123; fetchPolicy: 'cache-and-network', errorPolicy: 'ignore', &#125;, query: &#123; fetchPolicy: 'network-only', errorPolicy: 'all', &#125;, mutate: &#123; errorPolicy: 'all' &#125;&#125; ApolloProvider为所有的组件提供一个ApolloClient实例 client 123456ReactDOM.render( &lt;ApolloProvider client=&#123;client&#125;&gt; &lt;MyRootComponent /&gt; &lt;/ApolloProvider&gt;, document.getElementById('root'),); graphql(query,[config])(Component)123456789101112131415161718function TodoApp(&#123; data: &#123; todos &#125; &#125;) &#123; return ( &lt;ul&gt; &#123;todos.map((&#123; id, text &#125;) =&gt; ( &lt;li key=&#123;id&#125;&gt;&#123;text&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; );&#125;export default graphql(gql` query TodoAppQuery &#123; todos &#123; id text &#125; &#125;`)(TodoApp); 可以定义中间函数 12345678// Create our enhancer function.const withTodoAppQuery = graphql(gql`query &#123; ... &#125;`);// Enhance our component.const TodoAppWithData = withTodoAppQuery(TodoApp);// Export the enhanced component.export default TodoAppWithData; Query Configurationconfig.options12345export default graphql(gql`&#123; ... &#125;`, &#123; options: (props) =&gt; (&#123; // Options are computed from `props` here. &#125;),&#125;)(MyComponent); config.props123456789101112131415export default graphql(gql`&#123; ... &#125;`, &#123; props: (&#123; data: &#123; fetchMore &#125; &#125;) =&gt; (&#123; onLoadMore: () =&gt; &#123; fetchMore(&#123; ... &#125;); &#125;, &#125;),&#125;)(MyComponent);function MyComponent(&#123; onLoadMore &#125;) &#123; return ( &lt;button onClick=&#123;onLoadMore&#125;&gt; Load More! &lt;/button&gt; );&#125; config.skip不会执行其中的React Apollo 功能可以传递布尔值,也是传递函数给config.skip,这里连个查询根据 props.userQuery1的属性来判断实现那个查询, 注意 true 时跳过查询12345678910export default compose( graphql(gql`query MyQuery1 &#123; ... &#125;`, &#123; skip: props =&gt; !props.useQuery1 &#125;), graphql(gql`query MyQuery2 &#123; ... &#125;`, &#123; skip: props =&gt; props.useQuery1 &#125;),)(MyComponent);function MyComponent(&#123; data &#125;) &#123; // The data may be from `MyQuery1` or `MyQuery2` depending on the value // of the prop `useQuery1`. console.log(data);&#125; config.namename 配置传递给组件 props的名字. 默认是query用 data. mutation用mutate. 12345678910111213141516//⛔️注入多个函数时用 compose函数export default compose( graphql(gql`mutation (...) &#123; ... &#125;`, &#123; name: 'createTodo' &#125;), graphql(gql`mutation (...) &#123; ... &#125;`, &#123; name: 'updateTodo' &#125;), graphql(gql`mutation (...) &#123; ... &#125;`, &#123; name: 'deleteTodo' &#125;),)(MyComponent);function MyComponent(props) &#123; // Instead of the default prop name, `mutate`, // we have three different prop names. console.log(props.createTodo); console.log(props.updateTodo); console.log(props.deleteTodo); return null;&#125; config.withRef这个存在时什么意义呢? config.aliascompose(...enhancers)(component)借此可以一次使用多个组件增强子. compose(funcC,funcB,funcA)(component), 实际的执行方式为 funcC(funcB(funcA(component))) 123456export default compose( withApollo, graphql(`query &#123; ... &#125;`), graphql(`mutation &#123; ... &#125;`), connect(...),)(MyComponent); withApollo(component)12345export default withApollo(MyComponent);function MyComponent(&#123; client &#125;) &#123; console.log(client);&#125; 使用 withApollo可以在组件中直接访问到Client 实例","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Apollo-Client","slug":"Apollo-Client","permalink":"https://React-Apollo.github.io/tags/Apollo-Client/"}]},{"title":"Apollo|Recompose Pattern","slug":"Apollo|Recompose Pattern","date":"2018-03-06T07:29:33.000Z","updated":"2018-04-07T02:42:18.247Z","comments":true,"path":"2018/03/06/Apollo|Recompose Pattern/","link":"","permalink":"https://React-Apollo.github.io/2018/03/06/Apollo|Recompose Pattern/","excerpt":"","text":"Recompose patterns1. Loading status常规做法: 根据 data.loading来显示 Loading 组件 123456789const Component = props =&gt; &#123; if (props.data.loading) &#123; return &lt;LoadingPlaceholder&gt; &#125; return ( &lt;div&gt;Our component&lt;/div&gt; )&#125; Recompose 有一个工具函数branch(),可以基于其中检测函数(test)的结果来组合不同的 Hoc, 可以和另一个 Recompose方法renderComponent(),联合使用.所以可以说:”如果处于 loading 状态, 就渲染LoadingPlaceholder而不是默认要展示内容的组件”,实例如下: Recompose loading 12345678910111213141516171819 import &#123; propType &#125; from 'graphql-anywhere'//props.data.loading为真时就渲染传入的组件,这里是LoadingPlaceholderconst renderWhileLoading = (component, propName = 'data') =&gt; branch( props =&gt; props[propName] &amp;&amp; props[propName].loading, renderComponent(component), );// 这个组件是实际展示数据的组件const Component = props =&gt; (&lt;div&gt;Our component for &#123;props.user.name&#125;&lt;/div&gt;)Component.propTypes = &#123; user: propType(getUser).isRequired, // autogenerating proptypes, as we expect them to be always there (yeah, if no error)&#125;//如果 graphql 的状态是 data.loading, renderWhileLoading 会劫持渲染const enhancedComponent = compose( graphql(getUser, &#123; name: \"user\" &#125;), renderWhileLoading(LoadingPlaceholder, \"user\"))(Component);export default enhancedComponent; 注意事项: Loading只有才查询的第一次才会为真. 如果使用options.notifyOnNetworkStatusChange,可以用data.networkStatus字段来跟踪其他的 loading 状态.模式和上面的一样 2. 处理错误和 loadingStatus 的方法类似,如果出了问题,我们想显示一个不同的组件,或者允许用户重新加载(refetch()). 使用withProps()方法直接用 props 传递 refetch 方法. 这里的方法是通用的, 没有和任何的组件耦合. 12345678910111213141516171819202122232425const renderForError = (component, propName = \"data\") =&gt; branch( props =&gt; props[propName] &amp;&amp; props[propName].error, renderComponent(component), );const ErrorComponent = props =&gt;( &lt;span&gt; Something went wrong, you can try to //⛔️ props 传入的 refetch 方法 &lt;button onClick=&#123;props.refetch&#125;&gt;refetch&lt;/button&gt; &lt;/span&gt;)//为组件注入新的props 和 refetch 方法const setRefetchProp = (propName = \"data\") =&gt; withProps(props =&gt; (&#123;refetch: props[propName] &amp;&amp; props[propName].data&#125;))const enhancedComponent = compose( graphql(getUser, &#123; name: \"user\" &#125;), renderWhileLoading(LoadingPlaceholder, \"user\"), setRefetchProp(\"user\"), renderForError(ErrorComponent, \"user\"),)(Component);export default enhancedComponent; 3. 查询周期在有些用例中,需要在查询完成之后执行一些其他工作. 上面的实例中,没有错误出现,没有 loading 的时候会渲染默认组件. 但是组件是无状态的,没有生命周期函数的钩子(hook).如果还要使用额外的周期功能,可以用 Recompose 的lifecycle()函数来补救 12345678910111213const execAtMount = lifecycle(&#123; componentWillMount() &#123; executeSomething(); &#125;,&#125;)const enhancedComponent = compose( graphql(getUser, &#123; name: \"user\" &#125;), renderWhileLoading(LoadingPlaceholder, \"user\"), setRefetchProp(\"user\"), renderForError(ErrorComponent, \"user\"), execAtMount,)(Component); 上面的实例,如果我们需要在组件加载时做些额外的工作,可以这么操作 来看看另一个更为复杂的用例, 例如我正在使用re-select,可以让用户从查询的结果中挑选部分内容. 想一直显示 re-select,它有自己的 loading state indicator.接着在查询成功以后自动的选择预定义的选项. 如果使用默认的访问策略(fetchPolicy)让每个组件都获取数据,只有一个特别的地方需要处理. 需要留意的地方:要查询的数据已经在 cache 中的时候,就会跳过 loading state. 这种情况下,我们需要在组件加载时处理networkStatus===7. 同时还要使用recompose的withState()方法保存选项值. 在这个例子中我们保持默认的data属性不变. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const DEFAULT_PICK = \"orange\";const withPickerValue = withState(\"pickerValue\", \"setPickerValue\", null);// find matching optionconst findOption = (options, ourLabel) =&gt; lodashFind(options, option =&gt; option.label.toLowerCase() === ourLabel.toLowerCase());const withAutoPicking = lifecycle(&#123; componentWillReceiveProps(nextProps) &#123; // when value was already picked if (nextProps.pickerValue) &#123; return; &#125; // networkStatus change from 1 to 7 - initial load finished successfully if (this.props.data.networkStatus === 1 &amp;&amp; nextProps.data.networkStatus === 7) &#123; const match = findOption(nextProps.data.options) if (match) &#123; nextProps.setPickerValue(match); &#125; &#125; &#125;, componentWillMount() &#123; const &#123; pickerValue, setPickerValue, data &#125; = this.props; if (pickerValue) &#123; return; &#125; // when Apollo query is resolved from cache, // it already have networkStatus 7 at mount time if (data.networkStatus === 7 &amp;&amp; !data.error) &#123; const match = findOption(data.options); if (match) &#123; setPickerValue(match); &#125; &#125; &#125;,&#125;);const Component = props =&gt; ( &lt;Select loading=&#123;props.data.loading&#125; value=&#123;props.pickerValue &amp;&amp; props.pickerValue.value || null&#125; onChange=&#123;props.setPickerValue&#125; options=&#123;props.data.options || undefined&#125; /&gt;);const enhancedComponent = compose( graphql(getOptions), withPickerValue, withAutoPicking,)(Component); 4. 控制轮询 这个例子是一个显示 meteor框架中的数据库迁移状态的组件:migrations panel.并不总是运行迁移,所以设置轮询为30s,就比较好.但是如果在数据库迁移过程中,我们需要竟可能快的显示进度. 解决问题的关键是 react-apollo 的options参数, 这个参数可以是一个依赖于 React props 为参数的函数.(options参数描述了查询自身的参数, 和 React 的 props 是不同的). 我们可以根据传递到graphql 组件的 props,通过使用recompose的withState()函数设定轮询的周期,并且使用componentWillReceiveProps React的生命周期函数来查看从 GraphQL获取的数据,并作出相应的调整. 基本的流程就是,默认30秒查询一次数据库迁移状态的数据,如果数据存在时,就立刻把查询的轮询时间改为0.5s. 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import &#123; graphql &#125; from \"react-apollo\";import gql from \"graphql-tag\";import &#123; compose, withState, lifecycle &#125; from \"recompose\";const DEFAULT_INTERVAL = 30 * 1000;const ACTIVE_INTERVAL = 500;const withData = compose( // Pass down two props to the nested component: `pollInterval`, // which defaults to our normal slow poll, and `setPollInterval`, // which lets the nested components modify `pollInterval`. withState(\"pollInterval\", \"setPollInterval\", DEFAULT_INTERVAL), graphql( gql` query getMigrationStatus &#123; activeMigration &#123; name version progress &#125; &#125; `, &#123; // If you think it's clear enough, you can abbreviate this as: // options: (&#123;pollInterval&#125;) =&gt; (&#123;pollInterval&#125;), options: props =&gt; &#123; return &#123; pollInterval: props.pollInterval &#125;; &#125; &#125; ), lifecycle(&#123; componentWillReceiveProps(&#123; data: &#123; loading, activeMigration &#125;, pollInterval, setPollInterval &#125;) &#123; if (loading) &#123; return; &#125; if (activeMigration &amp;&amp; pollInterval !== ACTIVE_INTERVAL) &#123; setPollInterval(ACTIVE_INTERVAL); &#125; else if ( !activeMigration &amp;&amp; pollInterval !== DEFAULT_INTERVAL ) &#123; setPollInterval(DEFAULT_INTERVAL); &#125; &#125; &#125;));const MigrationPanelWithData = withData(MigrationPanel); 但是这个轮询似乎还有缺陷, 如果在30s轮询周期内, 数据库迁移完成了,我们就看不到任何的提示. 或许要使用 subscription方法.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"}]},{"title":"Prisma|Github oAuth登录操作","slug":"Prisma|Github oAuth登录操作","date":"2018-03-05T15:27:47.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/03/05/Prisma|Github oAuth登录操作/","link":"","permalink":"https://React-Apollo.github.io/2018/03/05/Prisma|Github oAuth登录操作/","excerpt":"","text":"之前有版本,经过Prisma 的版本变更.做修改.Prisma的改变还比较大,但是登录的原理是不变的 OAuth 协议的认证和授权的过程如下： 1. 用户打开我的应用，我想要通过GitHub获取改用户的基本信息 2. 在转跳到GitHub的授权页面后，用户同意我获取他的基本信息 3. 页面获得GitHub提供的授权码(githubCode)，使用该授权码向GitHub申请一个令牌 4. GitHub对博客提供的授权码进行验证，验证无误后，发放一个令牌(githubToken)给博客端 5. 应用使用令牌，向GitHub获取用户信息 6. GitHub 确认令牌无误，返回给我基本的用户信息 在本应用中,从github 中获取用户基本信息以后,在 prisma数据库中存储信息,并且返回给用于一个应用内的 token.后续应用内的操作通过这个 token换取用户信息进行操作datamodel 12345678910111213141516171819202122type User &#123; id: ID! @unique createdAt: DateTime! updatedAt: DateTime! githubUserId: String! @unique name: String! bio: String! public_repos: Int! public_gists: Int! notes: [Note!]! @relation(name: \"UserNote\")&#125;type Note &#123; id: ID! @unique owner: User! @relation(name: \"UserNote\") text: String!&#125; schemamodel 12345678910111213141516type Query &#123; me: User, note(id: ID!): Note&#125;type Mutation &#123; createNote(text: String!): Note! updateNote(id: ID!, text: String!): Note deleteNote(id: ID!): Note authenticate(githubCode: String!): AuthenticateUserPayload&#125;type AuthenticateUserPayload &#123; user: User! token: String!&#125; datamodel定义了数据库要使用的 model, schemamodel定义了要提供给用户使用的 API接口. 所以编程就围绕 schemamodel 展开 重点关注 authenticate 这个 model. 通过参数 githubCode获得用户的 token 获取 token 的代码从 github 获取信息的代码的两个工具函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546import * as fetch from 'isomorphic-fetch'export interface GithubUser &#123; id: string, name: string, bio: string, public_repos: number, public_gists: number&#125;//获取 githubToken 的方法export async function getGithubToken(githubCode: string): Promise&lt;string&gt; &#123; const endpoint = 'https://github.com/login/oauth/access_token' const data = await fetch(endpoint, &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json', 'Accept': 'application/json' &#125;, body: JSON.stringify(&#123; client_id: process.env.GITHUB_CLIENT_ID, client_secret: process.env.GITHUB_CLIENT_SECRET, code: githubCode, &#125;) &#125;) .then(response =&gt; response.json()) if (data.error) &#123; throw new Error(JSON.stringify(data.error)) &#125; return data.access_token&#125;//获取 githubUser 的方法,获取的是 User的详细信息export async function getGithubUser(githubToken: string): Promise&lt;GithubUser&gt; &#123; const endpoint = `https://api.github.com/user?access_token=$&#123;githubToken&#125;` const data = await fetch(endpoint) .then(response =&gt; response.json()) if (data.error) &#123; throw new Error(JSON.stringify(data.error)) &#125; return data&#125; 从 prisma 获取用户信息的工具函数在其他操作需要用户信息时,可以从 http 请求只能获取用户 token,换取用户信息, 1234567891011121314151617181920212223242526272829303132333435import * as jwt from 'jsonwebtoken'import &#123; Prisma &#125; from 'prisma-binding'//在上下文中提供可以操作的 prisma 数据库句柄export interface Context &#123; db: Prisma request: any&#125;export interface User &#123; id: string name: string bio: string public_repos: string public_gists: string&#125;export function getUserId(ctx: Context) &#123; //从 http request 头部获得 token const Authorization = ctx.request.get('Authorization') if (Authorization) &#123; const token = Authorization.replace('Bearer ', '') const &#123; userId &#125; = jwt.verify(token, process.env.JWT_SECRET!) as &#123; userId: string &#125; return userId &#125; throw new AuthError()&#125;export class AuthError extends Error &#123; constructor() &#123; super('Not authorized') &#125;&#125; auth的 resolvers1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//Context是可以操作 prisma 数据库的句柄import &#123; Context, User &#125; from '../../utils'import &#123; getGithubToken, getGithubUser, GithubUser &#125; from '../../github'import * as jwt from 'jsonwebtoken'// Helpers -------------------------------------------------------------------async function getPrismaUser(ctx: Context, githubUserId: string): Promise&lt;User&gt; &#123; return await ctx.db.query.user(&#123; where: &#123; githubUserId &#125; &#125;)&#125;async function createPrismaUser(ctx, githubUser: GithubUser): Promise&lt;User&gt; &#123; const user = await ctx.db.mutation.createUser(&#123; data: &#123; githubUserId: githubUser.id, name: githubUser.name, bio: githubUser.bio, public_repos: githubUser.public_repos, public_gists: githubUser.public_gists, notes: [], &#125;, &#125;) return user&#125;// Resolvers -----------------------------------------------------------------export const auth = &#123; authenticate: async (parent, &#123; githubCode &#125;, ctx: Context, info) =&gt; &#123; const githubToken = await getGithubToken(githubCode) const githubUser = await getGithubUser(githubToken) //在 prisma 中查找用户,如果不存在就创建一个,然后返回一个 token 给用户 let user = await getPrismaUser(ctx, githubUser.id) if (!user) &#123; user = await createPrismaUser(ctx, githubUser) &#125; return &#123; token: jwt.sign(&#123; userId: user.id &#125;, process.env.JWT_SECRET), user, &#125; &#125;,&#125;// --------------------------------------------------------------------------- 执行其他操作时需要用户信息时的操作下面操作由于,已经在 schemamodel 中定义了 user和 note 的关联关系, 只需要在 owner中关联 userID就可以了,其他信息可以灵活查询获取. 12345678910111213141516171819202122232425262728293031323334353637383940414243mport &#123; Context, getUserId, AuthError &#125; from '../../utils'export const notes = &#123; async createNote(_, &#123; text &#125;, ctx: Context, info) &#123; const userId = getUserId(ctx) return await ctx.db.mutation.createNote(&#123; data: &#123; owner: &#123; connect: &#123; id: userId &#125; &#125;, text &#125;&#125;) &#125;, async updateNote(_, &#123; id, text &#125;, ctx: Context, info) &#123; const userId = getUserId(ctx) //检查这条消息是不是该用户创建的,是的话才能执行更新操作 const hasPermission = await ctx.db.exists.Note(&#123; id, owner: &#123; id: userId &#125; &#125;) if (!hasPermission) &#123; throw new AuthError() &#125; return await ctx.db.mutation.updateNote(&#123; where: &#123; id &#125;, data: &#123; text &#125; &#125;) &#125;, async deleteNote(_, &#123; id &#125;, ctx: Context, info) &#123; const userId = getUserId(ctx) //检查这条消息是不是该用户创建的,是的话才能执行删除操作 const hasPermission = await ctx.db.exists.Note(&#123; id, owner: &#123; id: userId &#125; &#125;) if (!hasPermission) &#123; throw new AuthError() &#125; return await ctx.db.mutation.deleteNote(&#123; where: &#123; id &#125; &#125;) &#125;&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"},{"name":"oAuth","slug":"oAuth","permalink":"https://React-Apollo.github.io/tags/oAuth/"}]},{"title":"Prisma|HackerNews_clone","slug":"Prisma|HackerNews_Clone","date":"2018-03-05T10:27:34.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/03/05/Prisma|HackerNews_Clone/","link":"","permalink":"https://React-Apollo.github.io/2018/03/05/Prisma|HackerNews_Clone/","excerpt":"","text":"from howtographql.com API需求: Retrieve a list (feed) of link elements Allow users to signup up with their name, email and password Users who signed up should be able to login again with their email and password Allow authenticated users to post new link elements Allow authenticated users to upvote an existing link element Send realtime updates to subscribed clients when a new link element is created Send realtime updates to subscribed clients when an existing link element is upvoted 定义 应用 schema这一步非常好,根据应用的需求首先定义需要实现的 query,mutation,subscribe,然后围绕这个schema 展开工作,目前我们不关注User,Link,Vote的实现细节 123456789101112131415161718192021222324252627type Query &#123; # Retrieve a list (\"feed\") of link elements feed(filter: String, skip: Int, first: Int): [Link!]!&#125;type Mutation &#123; # Allow users to signup up with their name, email and password signup(name: String!, email: String!, password: String!): AuthPayload! # Users who signed up should be able to login again with their email and password login(email: String!, password: String!): AuthPayload! # Allow authenticated users to post new link elements post(url: String!, description: String!): Link # Allow authenticated users to upvote an existing link element vote(linkId: ID!): Vote&#125;type Subscription &#123; # Send realtime updates to subscribed clients when a new link element is created newLink: LinkSubscriptionPayload # Send realtime updates to subscribed clients when an existing link element is upvoted newVote: VoteSubscriptionPayload&#125;type AuthPayload &#123; token: String user: User&#125; 接下来就是逐渐实现这些操作.每一步实现的流程实际是基本类似的-这也就是schema-driven-development 调整 data model 调整之后,部署服务 用新的根字段扩展应用的 schema 实现 resolver, 通过代理执行对应的 Prisma resolver 初始化文件结构12345678910.├── package.json├── src│ ├── index.js│ ├── schema.graphql│ └── generated│ └── prisma.graphql└── database ├── prisma.yml └── datamodel.graphql src包含应用的实现代码和应用schema(application schema),Prisma根据 dataModel生成的 Prisma schema database 包含初始化配置文件 prisma.yml和应用的 data model \u001b src/schema.graphql(Apllication schema)定义了暴露给 client 端的 graphql API. src/generated/prisma.graphql(Prisma schema)定义了对数据库操作的 CRUD API. 对于在 data model 中的每个类型, Prisma会生成读写数据库节点的操作 data model并不是实际的 Graphql schema,缺少 root type. data model 用于生成实际执行的 schema. 理解初始化步骤有两个依赖包: graphql-yoga: GraphQL Server 需要的文件,实际是 express 服务器 prisma-binding: 可以允许绑定应用 schema 的 resolvers到自动生成的 Prisma database服务. 123456789101112const server = new GraphQLServer(&#123; typeDefs: './src/schema.graphql', resolvers, context: req =&gt; (&#123; ...req, db: new Prisma(&#123; typeDefs: 'src/generated/database.graphql', endpoint: 'http://localhost:60000/hackernews-node/dev', secret: 'mysecret123', &#125;), &#125;),&#125;) 查询在 data model 中定义 Link type12345type Link &#123; id: ID! @unique description: String! url: String!&#125; yarn prisma deploy 之后 会自动生成prisma.graphql 123456789101112type Query &#123; links(where: LinkWhereInput, orderBy: LinkOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Link]! link(where: LinkWhereUniqueInput!): Link&#125;type Mutation &#123; createLink(data: LinkCreateInput!): Link! updateLink(data: LinkUpdateInput!, where: LinkWhereUniqueInput!): Link deleteLink(where: LinkWhereUniqueInput!): Link updateManyLinks(data: LinkUpdateInput!, where: LinkWhereInput!): BatchPayload! deleteManyLinks(where: LinkWhereInput!): BatchPayload!&#125; 对 应用的 schema 做出调整定义feed查询 12345# import Link from \"./generated/prisma.graphql\"type Query &#123; feed(filter: String, skip: Int, first: Int): [Link!]!&#125; 实现 feed的 resolver每个Query,Mutation都由 resolver 支撑. 相应的定义为 Query.js,Mutation.js,Subscription.js. 123456789101112function feed(parent, args, context, info) &#123; const &#123; filter, first, skip &#125; = args // destructure input arguments const where = filter ? &#123; OR: [&#123; url_contains: filter &#125;, &#123; description_contains: filter &#125;] &#125; : &#123;&#125; return context.db.query.links(&#123; first, skip, where &#125;, info)&#125;module.exports = &#123; feed,&#125; resolver 函数接收四个参数, parent:包含 resolver 链的初始值 args:包含查询参数的对象. context:包含定制的数据,可以在 resolver 链中传递.例如每个 resolver 都可以读写 info包含了 AST信息 打开 index.js替换下面的resolver对象: 123456789const resolvers = &#123; Query,&#125;``` 导入我们自己定义的`Query`对象```jsconst Query=require('./resolvers/Query') 测试 API在项目的根目录执行1yarn dev 打开 graphiQL, 输入 12345678mutation &#123; createLink(data: &#123; url: \"https://www.graph.cool\", description: \"A GraphQL Database\" &#125;) &#123; id &#125;&#125; MutationsMutation for posting new links打开 src/schema.graphql添加如下代码 123type Mutation &#123; post(url: String!, description: String!): Link!&#125; 在src/resolvers创建新的Mutation.js,添加代码: 12345678function post(parent, args, context, info) &#123; const &#123; url, description &#125; = args return context.db.mutation.createLink(&#123; data: &#123; url, description &#125; &#125;, info)&#125;module.exports = &#123; post,&#125; 在index.js中添加新的mutation声明 123456const Mutation = require('./resolvers/Mutation')const resolvers = &#123; Query, Mutation,&#125; 测试一下 12345mutation &#123; post(url: \"https://www.howtographql.com\", description: \"Fullstack tutorial website for GraphQL\") &#123; id &#125;&#125; Signup&amp;Login为用户提供登录功能Signup注册的实现步骤: 服务器收到新用户的email,password(还有name) 服务器在数据库创建新用户,并储存name,email和 hash过的密码 服务器创建一个认证 token(JWT) 服务器把 token返回给用户 Login 服务器收到login mutation 服务器比较password的一致性 如果密码一致, 服务器创建一个 token 服务器把 token 返回给用户 实现注册流程创建secret 12345const APP_SECRET = 'GraphQL-is-aw3some'module.exports = &#123; APP_SECRET&#125; 在应用的 schema 中添加 signup Mutation 1234type Mutation &#123; post(url: String!, description: String!): Link! signup(email: String!, password: String!, name: String!): AuthPayload&#125; src/schema.graphql1234type AuthPayload &#123; token: String user: User&#125; database/datamodel.graphql 123456type User &#123; id: ID! @unique name: String! email: String! @unique password: String!&#125; 部署以后会生成 12345678910111213type Query &#123; users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]! user(where: UserWhereUniqueInput!): User&#125;type Mutation &#123; createUser(data: UserCreateInput!): User! updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User deleteUser(where: UserWhereUniqueInput!): User upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User! updateManyUsers(data: UserUpdateInput!, where: UserWhereInput!): BatchPayload! deleteManyUsers(where: UserWhereInput!): BatchPayload!&#125; 打开应用 schema src/schema.graphql添加如下的类型 12345type User&#123; id: ID! name:String! email:String!&#125; 这里的定义和 Prisma schema 里的定义类似,但是没有password,也就是不允许用户查询 password 接下来需要signup mutation 12345678910111213async function signup(parent, args, context, info) &#123; const password = await bcrypt.hash(args.password, 10) const user = await context.db.mutation.createUser(&#123; data: &#123; ...args, password &#125;, &#125;) const token = jwt.sign(&#123; userId: user.id &#125;, APP_SECRET) return &#123; token, user, &#125;&#125; 在signup resolver 中, 首先创建密码的加密版本, 接下来, 使用Prisma的实例,创建新的User节点.最后返回包含AuthPayload包含创建的 token 和新的 user 对象 实现login mutation接下来,实现login mutation. src/schema.graphql中添加Mutation 类型 12345type Mutation &#123; post(url: String!, description: String!): Link! signup(email: String!, password: String!, name: String!): AuthPayload login(email: String!, password: String!): AuthPayload&#125; 打开 src/resolvers/Mutation.js添加如下函数 123456789101112131415161718async function login(parent, args, context, info) &#123; const user = await context.db.query.user(&#123; where: &#123; email: args.email &#125; &#125;) if (!user) &#123; throw new Error(`Could not find user with email: $&#123;args.email&#125;`) &#125; const valid = await bcrypt.compare(args.password, user.password) if (!valid) &#123; throw new Error('Invalid password') &#125; const token = jwt.sign(&#123; userId: user.id &#125;, APP_SECRET) return &#123; token, user, &#125;&#125; 首先使用 email 查询是否存在, 然后比较密码是否一致. 完成后,返回一个 token 给用户 应用 Authentication创建User和Link的关联在需求中,我们提出只有通过认证的用户才可以创建新的 Link元素. 打开 database/datamodel.js 改变User和Link类型 1234567891011121314type Link &#123; id: ID! @unique description: String! url: String! postedBy: User&#125;type User &#123; id: ID! @unique name: String! email: String! @unique password: String! links: [Link!]!&#125; 可以执行如下的操作 12345678910111213mutation &#123; createLink(data: &#123; url: \"https://www.graphql.org\", description: \"Official GraphQL Website\", postedBy: &#123; connect: &#123; email: \"johndoe@graph.cool\" &#125; &#125; &#125;) &#123; id &#125;&#125; 打开 src/resolvers/Mutation.js改变post 1234567function post(parent, &#123; url, description &#125;, context, info) &#123; const userId = getUserId(context) return context.db.mutation.createLink( &#123; data: &#123; url, description, postedBy: &#123; connect: &#123; id: userId &#125; &#125; &#125; &#125;, info, )&#125; 和之前的版本不同的地方是,首先获取到用户的 id, 然后传递给createLink-mutation 作为connect的参数. 现在我们需要一个工具函数 getUserId, src/utils.js 12345678910function getUserId(context) &#123; const Authorization = context.request.get('Authorization') if (Authorization) &#123; const token = Authorization.replace('Bearer ', '') const &#123; userId &#125; = jwt.verify(token, APP_SECRET) return userId &#125; throw new Error('Not authenticated')&#125; context参数有一个request属性,代表着携带 query 或者 mutation的 HTTP 请求. 重要的是,它提供了访问头 .token就在头部中 认证一个用户 在 playground中, 发送signup或者login mutation,从 graphql server 中获取到 token. 在PlayGround中设置Header 发送post mutation,创建新的Link 元素 12345678mutation &#123; login( email: \"johndoe@graph.cool\" password: \"graphql\" ) &#123; token &#125;&#125; 设置好以后,执行 12345678mutation &#123; post( url: \"https://www.graphqlweekly.com\" description: \"Weekly GraphQL Newsletter\" ) &#123; id &#125;&#125; 投票部分Subscriptions实现 GraphQL订阅打开src/schema.graphql,添加Subscription 1234type Subscription &#123; newLink: LinkSubscriptionPayload newVote: VoteSubscriptionPayload&#125; 在src/resolvers创建一个新的文件, SubScription.js添加如下代码: 12345678910111213141516171819202122const newLink = &#123; subscribe: (parent, args, ctx, info) =&gt; &#123; return ctx.db.subscription.link( &#123; &#125;, info, ) &#125;,&#125;const newVote = &#123; subscribe: (parent, args, ctx, info) =&gt; &#123; return ctx.db.subscription.vote( &#123; &#125;, info, ) &#125;,&#125;module.exports = &#123; newLink, newVote,&#125; 现在的src/inde.js文件 1234567891011const &#123; GraphQLServer &#125; = require('graphql-yoga')const &#123; Prisma &#125; = require('prisma-binding')const Query = require('./resolvers/Query')const Mutation = require('./resolvers/Mutation')const Subscription = require('./resolvers/Subscription')const resolvers = &#123; Query, Mutation, Subscription&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"algolia-cnode即时搜索实现- React版","slug":"algolia-cnode搜索实现","date":"2018-03-04T14:59:12.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/03/04/algolia-cnode搜索实现/","link":"","permalink":"https://React-Apollo.github.io/2018/03/04/algolia-cnode搜索实现/","excerpt":"","text":"参考的文献是: Algolia Auto-Sync for GraphQL backends. 实现了 Graphql 数据数据添加和删除时的数据同步 基本流程是,你给 algolia 提供一个需要索引的文本或者资源, algolia 会做出索引,之后就可以使用提供的 API获取结果. 总共索引了1-95页的数据, 可能排序上还要优化, 方法现在没有问题 基础流程没有什么问题.遇到的问题是,之前从 medium 网站抓取了300多篇文章, 建完索引之后,没有结果. algolia 实现的是在建立索引机制以后的数据才可以使用, 我索性把 cnode 1-95页的数据都建了索引. cnode 每页是40条, 总共是3800条数据, 现在有3600数据加了索引,没有插入的还没看是什么原因. 大概步骤项目分为四大块:①:后台服务器,组要是由于目前在使用 graphql,觉得很有潜力,而且 graphcool 提供了 algolia 的整合服务,使用还是比较简单的,主要工作是建立模型,导入和 aloglia 对接的 APP ID和 Token. ②: algolia上的配置, 主要 是获取 APPID和 Token. ③: 从 cnode,导入数据,严格说这一部分和这里的文章关系不太大.④: 前端的配置, 这个有教程,最简单的异步, 获取数据的方法都封装好了, 直接使用即可. 实现的结果 实现方案注册,建立应用,获取 APPID ①登录:https://www.algolia.com,注册直接用 github 登录. ②:点击右上角 dashboard 进入管理界面 ③: 点击 创建一个应用 ④:进入应用,其他不动, 我们只会使用到 key, 点击钥匙 ⑤: 这里会有一个 search-only-key,专门用于前端搜索用的, 我们在 all api key下创建一个新的有用读写记录的key. 注意还有 application ID ⑥ 点击 ⑦: 设置,名字,还有权限,只需要读写的权限就可以了.点击生成, 而搜索的 key是这样 通过以上的步骤,现在我们有三个要使用的 id, 一个应用的 ID,一个所有使用的key,一个用于配置服务的key. 由于用于索引的数据都是从后台同步的,这里目前就不要再做任何的工作了. 后续可以做些优化工作. 后台服务服务的建立建立模型 创建graphcool服务器, 这个参看 graphcool网站的教程, 建立模型 创建了一个简单的模型包含有 title,content, tab 字段,添加其他的也可以.首要任务是跑通流程 使用整合服务 整合 aloglia 的服务, 点击进入添加key 有两个key,我们要使用允许读写的的那个key才行 点击 添加index. 123456789101112131415161718192021222324 &#123; node &#123; content tab title &#125; &#125;``` ---点击创建 index,我们的配置工作就完成了现在可以添加一条索引,验证一项 algolia 会不会自动同步数据![](https://ws3.sinaimg.cn/large/006tNc79gy1fp0uzl3kthj30yj06n74c.jpg) dashboard 中如果有记录,证明数据同步成功了.如果这里是0,要看看前面的配置有没有问题,如果有问题,不要急着做下一步, 到这里配置就完成了, 导入数据和配置是独立的过程. ![](https://ws4.sinaimg.cn/large/006tNc79gy1fp0v1aiw8cj30fq05pt8l.jpg) 在 graphcool 手动输入一条信息, algolia如果有记录出现,配置完成 接着进行下一步, 导入数据### 导入数据, 这里不详细说, 通过 cnode的 API获取数据,然后依照 graphql 的mutate 方法,导入到 Graphcool 的数据库.参见下面的代码 ‘use strict’import express from ‘express’import bodyParser from ‘body-parser’import cors from ‘cors’import * as R from ‘ramda’var path = require(‘path’)require(‘es6-promise’).polyfill()require(‘isomorphic-fetch’)import fetch from ‘node-fetch’import { request } from ‘graphql-request’const dataArray = []var t = require(‘transducers-js’) // 导入transducers-js执行tranducer操作const URL = ‘http://localhost‘const PORT = 3001const api = ‘https://api.graph.cool/simple/v1/cjearwrd40zes01671xikrsnh‘ // graphcool API// graphql模板-数据插入的模板const mu = `mutation createList( $tab: String!, $content:String!, $title: String!){ createList( content: $content, tab:$tab, title:$title, ){ id } }`//主方法export const start = async () =&gt; { try { const app = express() app.use(cors()) app.use(express.static(__dirname)) app.listen(PORT, () =&gt; { console.log(Visit ${URL}:${PORT}) }) const startTime = Date.now() for (var i = 1; i &lt;= 95; i++) { const pageData = await singlePageData(i) //获取单页数据 dataArray.push(pageData) } const flattenData = R.flatten(dataArray) const getData = compose(R.map(insertData), flattenData) await getData(dataArray); //插入数据库 const endTime = Date.now() const spend = endTime - startTime console.log(&apos;spending time:&apos;, spend) } catch (e) { console.log(e) }}//单条记录插入 graphcool数据库的方法const insertData = data =&gt; { var flattenData = function (n) { return { content: n.content, tab: n.tab, title: n.title} };//数据插入 graphql 数据方法柯理化 const func = R.curry((api, template, variables) =&gt; request(api, template, variables).then(data =&gt; { console.log(‘data:’, data) }) ) const waitForData = func(api, mu) var xf = t.comp(R.map(flattenData), R.map(waitForData)) //这里用了 transducer.js 的方法 const mediateFunc = R.curry((xf, data) =&gt; t.into([], xf, data)) const getFinalRes = mediateFunc(xf) getFinalRes(data)}; //异步 compose 方法const compose = (…functions) =&gt; input =&gt; functions.reduceRight((chain, func) =&gt; chain.then(func), Promise.resolve(input))//拼接 API的方法const variablesTemp = num =&gt; https://cnodejs.org/api/v1/topics?page=${num}//获取数据,并取出 data字段的方法const fetchData = url =&gt; fetch(url).then(res =&gt; res.json()).then(data =&gt; data.data)//异步 compose 组合的获取 API url 并 获取数据的方法const singlePageData = compose(fetchData, variablesTemp)12345678910插入数据以后, 在 graphcool 后台可以看到记录数, 在 algolia的 dashboard 也可以看到记录数. 整个配置和数据导入就完成了. 由于我们这里是从 cnode获取手动获取数据, 如果是原生使用 Graphcool 的数据库, 插入条目以后,会立刻自动通过. 用 cnode 的 API稍微麻烦一点### 前端的配置React/React-Native的配置可以在github搜索,有很多代码实例#### app.js 文件配置 导入 app ID 和仅用于搜索的 key和 index name.这个 name 是在后台配置时建立的, algolia 显示的就是这个名字. import React from “react”;import { Text, View } from “react-native”;import { InstantSearch } from “react-instantsearch/native”;import styles from “./src/styles”;import SearchBox from “./src/SearchBox”;import Results from “./src/Results”; export default class App extends React.PureComponent { render() { return ( Medium Search ); }}12345678910111213141516171819202122232425#### Searchbox.js 输入的数据和 algolia 发生联系的组件```jsimport React from \"react\";import &#123; TextInput &#125; from \"react-native\";import &#123; connectSearchBox &#125; from \"react-instantsearch/connectors\";import styles from \"./styles\";const SearchBox = connectSearchBox((&#123; refine, currentRefinement &#125;) =&gt; &#123; return ( &lt;TextInput style=&#123;styles.textBox&#125; onChangeText=&#123;text =&gt; refine(text)&#125; value=&#123;currentRefinement&#125; placeholder=\"Search Something\" clearButtonMode=\"always\" spellCheck=&#123;false&#125; autoCorrect=&#123;false&#125; autoCapitalize=\"none\" /&gt; );&#125;);export default SearchBox; List 列表显示数据123456789101112131415161718192021222324252627import React from \"react\";import &#123; FlatList &#125; from \"react-native\";import &#123; connectInfiniteHits &#125; from \"react-instantsearch/connectors\";import Repository from \"./Repository\";import ItemSeperator from \"./ItemSeperator\";const Results = connectInfiniteHits((&#123; hits, hasMore, refine &#125;) =&gt; &#123; const onEndReached = () =&gt; &#123; if (hasMore) &#123; refine(); &#125; &#125;; //终端打印搜索数据 console.log(hits); return ( &lt;FlatList data=&#123;hits&#125; onEndReached=&#123;onEndReached&#125; keyExtractor=&#123;repo =&gt; repo.objectID&#125; renderItem=&#123;(&#123; item &#125;) =&gt; &lt;Repository repo=&#123;item&#125; /&gt;&#125; ItemSeparatorComponent=&#123;ItemSeperator&#125; /&gt; );&#125;);export default Results; 具体的 item,就不写了. 其实上面 console.log 打印出数据整个流程就完成了.在 algolia 的 dashboard 也可以查看搜索的情况 整个即时搜索的流程完成, 速度还是挺快的, 大部分工作人家的算法帮我们完成了. 如果查看页面发现还有许多要优化的地方,后面再说.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"cnode","slug":"cnode","permalink":"https://React-Apollo.github.io/tags/cnode/"},{"name":"algolia","slug":"algolia","permalink":"https://React-Apollo.github.io/tags/algolia/"},{"name":"express","slug":"express","permalink":"https://React-Apollo.github.io/tags/express/"}]},{"title":"cnode GraphQL 版本","slug":"Cnode-Graphql-API","date":"2018-03-02T16:35:42.000Z","updated":"2018-04-07T02:42:18.247Z","comments":true,"path":"2018/03/02/Cnode-Graphql-API/","link":"","permalink":"https://React-Apollo.github.io/2018/03/02/Cnode-Graphql-API/","excerpt":"","text":"按照cnode-api的顺序来的, 基本只是做了包装,需要修改的可以看代码,做出修改. 通过 graphql 的 rest-wrapper resolver 包装以后,就可以获得 graphql的一些很好的特征了. 因为没有数据写入的Grpahql 的数据库,所以所有的操作都用的是query. 没有用 mutate. 因为最终还是访问的 REST API.这的graphql采用的是 graphcool 的服务器, 尽管试, 没有写入操作. Graphcool-cnode-server graphiQL地址 服务器的初始化可以参考这里Graphcool Server 可以选择部署在本地docker 中, 如果用于测试可以 直接部署在云上. 大致的流程如下在 GraphQL客户端或者是 GraphiQL执行的操作,会经过 resolver 函数的处理, resolver 实际是 express 服务器, 在这里可以执行数据库操作,或者是执行转发任务, 如果是为 API 提供服务, 就使用转发. 我们这里就是转发. 主题1 get/tpoics 主题首页就是数据列表,tab用于分类, page 用于分页 allTopics.graphql 123456789101112131415161718//⛔️有些字段没有列出,可以做修改type AllTopicsPayload &#123; id: String! tab: String title: String! visit: Int! aurl: String! author_id: String!&#125;input QueryInput &#123; page: Int! tab: String!&#125;extend type Query &#123; AllTopics(page: Int!, tab: String!): [AllTopicsPayload!]!&#125; allTopics.js 123456789101112131415161718192021222324252627282930require('isomorphic-fetch');const R = require('ramda');const url = 'https://cnodejs.org/api/v1/topics';module.exports = (event) =&gt; &#123; const &#123; tab, page &#125; = event.data; urlWithParams = `$&#123;url&#125;?tab=$&#123;tab&#125;&amp;page=$&#123;page&#125;`; let options = &#123; method: 'GET' &#125;; return fetch(urlWithParams, options).then((response) =&gt; response.json()).then((responseData) =&gt; &#123; const NodeList = responseData.data; const allCnode = []; const selectPropertyX = (x) =&gt; (&#123; id: x.id, tab: x.tab, aurl: x.author.avatar_url, visit: x.visit_count, title: x.title, author_id: x.author_id &#125;); const allTopics = R.map(selectPropertyX, NodeList); //const getIdcollections=R.curry(R.map(selectPropertyX,data)); //const allCnode=getIdcollections(NodeList); return &#123; data: allTopics &#125;; &#125;);&#125;; 查询示意图 注意事项graphiQL里执行的操作就是最好的文档, 这里执行的查询结果, 在其他地方可以完全复现,如果复现不了,就是你的客户端代码由问题. 在客户端我们可以使用 graphql-tag 的方法把这段查询的字符串给拼接出来.如果拼接没有问题, 得到的结果是完全一样的 2 get/topics主题详情 getOneTopic.graphql 12345678910 type OneTopicPayload &#123; id: String! tab: String title: String!, content:String!,&#125;extend type Query &#123; getOneTopic(id:String!): OneTopicPayload!&#125; getOneTopic.js 1234567891011121314require('isomorphic-fetch')const R = require('ramda');module.exports = event =&gt; &#123; const &#123;id&#125; = event.data const url = `https://cnodejs.org/api/v1/topic/$&#123;id&#125;` return fetch(url) .then(response =&gt; response.json()) .then(responseData =&gt; &#123; return &#123;data: responseData.data&#125; &#125;)&#125; 查询 3新建主题 post/topicscreateTopic.graphql 123456789101112type createTopicPayload &#123; tab: String!@default(value: \"dev\") #默认选了 dev title:String! accesstoken: String! content: String! success: Boolean &#125;extend type Query &#123; createTopic(title: String!,accesstoken:String!,tab:String!,content:String!): createTopicPayload&#125; createTopic.js 123456789101112131415161718192021222324'use latest'import fetch from 'node-fetch'const api = 'https://cnodejs.org/api/v1/topics' module.exports = async event =&gt; &#123; const &#123;tab, accesstoken, title, content&#125; = event.data const body = &#123; accesstoken: accesstoken, tab: tab, title: title, content: content &#125; const ress = await fetch(api, &#123; method: 'POST', body: JSON.stringify(body), headers: &#123;'Accept': 'application/json', 'Content-Type': 'application/json'&#125;, &#125;) .then(res =&gt; res.json()) .then(json =&gt; json) const success = &#123; 'success': ress.success &#125; console.log(ress); return &#123;data: success&#125;&#125; 查询示意 4编辑主题 post/topics/updateupdateTopic.graphql 12345678910111213type updateTopicPayload &#123; tab: String!@default(value: \"dev\") title:String! accesstoken: String! content: String! success: Boolean topic_id:String! &#125;extend type Query &#123; updateTopic(title: String!,accesstoken:String!,tab:String!,content:String!,topic_id:String!): updateTopicPayload&#125; updateTopic.js 12345678910111213141516171819202122232425'use latest';import fetch from 'node-fetch';const api = 'https://cnodejs.org/api/v1/topics/update';module.exports = async event =&gt; &#123; const &#123; tab, accesstoken, title, content, topic_id &#125; = event.data; const body = &#123; accesstoken: accesstoken, tab: tab, title: title, content: content, topic_id: topic_id &#125;; const ress = await fetch(api, &#123; method: 'POST', body: JSON.stringify(body), headers: &#123; Accept: 'application/json', 'Content-Type': 'application/json' &#125; &#125;) .then(res =&gt; res.json()) .then(json =&gt; json); const success = &#123; success: ress.success &#125;; console.log(ress); return &#123; data: ress &#125;;&#125;; 查询结果和创建基本是一样的 收藏1收藏主题 get topic_collection/collectcreateTopicCollection.graphql 12345678910type createTopicCollectionPayload &#123; topic_id: String accesstoken: String success: Boolean &#125;extend type Query &#123; createTopicCollection(topic_id: String!,accesstoken:String!): createTopicCollectionPayload&#125; createTopicCollection.js 123456789101112131415161718192021'use latest'import fetch from 'node-fetch'const api = 'https://cnodejs.org/api/v1/topic_collect/collect'module.exports = async event =&gt; &#123; const &#123;topic_id, accesstoken&#125; = event.data const body = &#123; accesstoken: accesstoken, topic_id: topic_id &#125; const ress = await fetch(api, &#123; method: 'POST', body: JSON.stringify(body), headers: &#123;'Accept': 'application/json', 'Content-Type': 'application/json'&#125;, &#125;) .then(res =&gt; res.json()) .then(json =&gt; json) const success = &#123; 'success': ress.success &#125; return &#123;data: success&#125;&#125; 2取消主题收藏 post/topic_collection/de_collectcancelTopicCollection.graphql 12345678910type cancelTopicCollectionPayload &#123; topic_id: String accesstoken: String success: Boolean &#125;extend type Query &#123; cancelTopicCollection(topic_id: String!,accesstoken:String!): cancelTopicCollectionPayload&#125; cancelTopicCollection.js 123456789101112131415161718192021'use latest'import fetch from 'node-fetch'const api = 'https://cnodejs.org/api/v1/topic_collect/de_collect'module.exports = async event =&gt; &#123; const &#123;topic_id, accesstoken&#125; = event.data const body = &#123; accesstoken: accesstoken, topic_id: topic_id &#125; const ress = await fetch(api, &#123; method: 'POST', body: JSON.stringify(body), headers: &#123;'Accept': 'application/json', 'Content-Type': 'application/json'&#125;, &#125;) .then(res =&gt; res.json()) .then(json =&gt; json) const success = &#123; 'success': ress.success &#125; return &#123;data: success&#125;&#125; 3 主题首页 get/topic_collection/:loginnameallCollections.graphql 12345678910type AllCollectionsPayload &#123; id: String! tab: String title: String! visit: Int! &#125;extend type Query &#123; AllCollections(name:String!): [AllCollectionsPayload !]!&#125; allCollections.js 12345678910111213141516171819require('isomorphic-fetch')const R = require('ramda')const url = 'https://cnodejs.org/api/v1/topic_collect/'module.exports = (event) =&gt; &#123; const &#123;name&#125; = event.data urlWithParams = `$&#123;url&#125;$&#123;name&#125;` let options = &#123; method: 'GET' &#125; return fetch(urlWithParams, options).then((response) =&gt; response.json()).then((responseData) =&gt; &#123; const Collections = responseData.data const selectPropertyX = (x) =&gt; (&#123;id: x.id, tab: x.tab, title: x.title, visit: x.visit_count, author_id: x.author_id&#125;) const allCollections = R.map(selectPropertyX, Collections) return &#123;data: allCollections&#125; &#125;)&#125;; 查询结果 评论1 新建评论 post/ topic/:topic_id/repliescreateReplies.graphql 123456789101112type createRepliesPayload &#123; topic_id:String! accesstoken:String! content: String! reply_id: String success:Boolean &#125;extend type Query &#123; createReplies(topic_id: String!,accesstoken:String!,content:String!,reply_id:String): createRepliesPayload&#125; createReplies.js 123456789101112131415161718192021222324'use latest'import fetch from 'node-fetch'module.exports = async event =&gt; &#123; const &#123;topic_id, accesstoken, content, reply_id&#125; = event.data const body = &#123; accesstoken: accesstoken, content: content, reply_id: reply_id &#125; const api=`https://cnodejs.org/api/v1/topic/$&#123;topic_id&#125;/replies` const ress = await fetch(api, &#123; method: 'POST', body: JSON.stringify(body), headers: &#123;'Accept': 'application/json', 'Content-Type': 'application/json'&#125; &#125;) .then(res =&gt; res.json()) .then(json =&gt; json) const success = &#123; 'success': ress.success &#125; console.log(ress) return &#123;data: success&#125;&#125; 查询结果 2为评论点赞 post /reply/:reply_id/upscreateUps.graphql 123456789101112type createUpsPayload &#123; accesstoken:String! reply_id: String! success:Boolean &#125;extend type Query &#123; createUps(accesstoken:String!,reply_id:String): createUpsPayload&#125; createUps.js 123456789101112131415161718192021222324'use latest'import fetch from 'node-fetch'module.exports = async event =&gt; &#123; const &#123; accesstoken, reply_id&#125; = event.data const body = &#123; accesstoken: accesstoken &#125; const api = `https://cnodejs.org/api/v1/reply/$&#123;reply_id&#125;/ups` const ress = await fetch(api, &#123; method: 'POST', body: JSON.stringify(body), headers: &#123;'Accept': 'application/json', 'Content-Type': 'application/json'&#125; &#125;) .then(res =&gt; res.json()) .then(json =&gt; json) const success = &#123; 'success': ress.success &#125; console.log(ress) return &#123;data: success&#125;&#125; 查询结果 用户1用户详情 get /user/:loginnamegetUserInfo.graphql 123456789101112type UserInfoPayload &#123; loginname: String! avatar_url: String! score: Int! recent_topics:[Json!]! recent_replies:[Json!]!&#125;extend type Query &#123; getUserInfo(name:String!): UserInfoPayload!&#125; getUserInfo.js 1234567891011121314151617require('isomorphic-fetch')const url = 'https://cnodejs.org/api/v1/user/'module.exports =async (event) =&gt; &#123; const &#123;name&#125; = event.data urlWithParams = `$&#123;url&#125;$&#123;name&#125;` let options = &#123; method: 'GET' &#125; return fetch(urlWithParams, options) .then(response =&gt; response.json()) .then(responseData =&gt; &#123; return &#123;data: responseData.data&#125; &#125;)&#125; 查询结果 消息通知获取未读消息 get/message/countgetMessageCount.graphql 12345678type MessageCountPayload &#123; accesstoken:String! data:Int success:Boolean&#125;extend type Query &#123; getMessageCount(accesstoken:String!): MessageCountPayload!&#125; getMessageCount.js 123456789101112131415require('isomorphic-fetch')const url = 'https://cnodejs.org/api/v1/message/count?accesstoken='module.exports =async (event) =&gt; &#123; const &#123;accesstoken&#125; = event.data urlWithParams = `$&#123;url&#125;$&#123;accesstoken&#125;` let options = &#123; method: 'GET' &#125; return fetch(urlWithParams, options) .then(response =&gt; response.json()) .then(responseData =&gt; &#123; return &#123;data: responseData&#125; &#125;) &#125; 2获取已读和未读消息 get /messagesgetMessages.graphql 1234567891011 type MessagesPayload &#123; has_read_messages:[Json] hasnot_read_messages:[Json] &#125;extend type Query &#123; getMessages(accesstoken:String!): MessagesPayload!&#125; getMessages.js 123456789101112131415require('isomorphic-fetch')const url = 'https://cnodejs.org/api/v1/messages?accesstoken='module.exports =async (event) =&gt; &#123; const &#123;accesstoken&#125; = event.data urlWithParams = `$&#123;url&#125;$&#123;accesstoken&#125;` let options = &#123; method: 'GET' &#125; return fetch(urlWithParams, options) .then(response =&gt; response.json()) .then(responseData =&gt; &#123; return &#123;data: responseData.data&#125; &#125;)&#125; 查询结果 3全部标记已读 post /message/mark_allmarkAll.graphql 12345678type markAllPayload &#123; accesstoken: String! success: Boolean&#125;extend type Query &#123; markAll(accesstoken:String!): markAllPayload&#125; markAll.js 12345678910111213141516171819202122'use latest';import fetch from 'node-fetch';const api = 'https://cnodejs.org/api/v1/message/mark_all';module.exports = async event =&gt; &#123; const &#123;accesstoken&#125; = event.data; const body = &#123; accesstoken: accesstoken, &#125;; const ress = await fetch(api, &#123; method: 'POST', body: JSON.stringify(body), headers: &#123; Accept: 'application/json', 'Content-Type': 'application/json' &#125; &#125;) .then(res =&gt; res.json()) .then(json =&gt; json); const success = &#123; success: ress.success &#125;; console.log(ress); return &#123; data: ress &#125;;&#125;; 查询结果 后记,如果要在 客户端使用 GraphQL查询,怎么操作呢?我使用的的 Apollo-client的方法 ① 在顶层组件导入配置文件1234567891011121314151617181920import &#123; ApolloProvider &#125; from 'react-apollo'import &#123; ApolloClient, HttpLink, InMemoryCache&#125; from 'apollo-client-preset'const httpLink = new HttpLink(&#123; uri: 'https://api.graph.cool/simple/v1/cjaxudkum2ugf0127kok921bc' &#125;)const client = new ApolloClient(&#123; link: httpLink, cache: new InMemoryCache(), connectToDevTools: false&#125;)export default class App extends React.Component &#123; render() &#123; return ( &lt;ApolloProvider client=&#123;client&#125;&gt; &lt;Navigator /&gt; &lt;/ApolloProvider&gt; ) &#125;&#125; ②实际是单一数据来源的 store, 在组件中可以直接使用查询了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import &#123; graphql &#125; from 'react-apollo';import gql from 'graphql-tag';//这里拼接的查询字符串和我们在浏览器中使用的字符串完全相同//如果在浏览器中正常,这里没有结果,或者结果不一致, 问题就在这里了.const getCollections = gql` query ($name: String!)&#123; AllCollections(name:$name) &#123; id, tab, title, visit &#125; &#125;`;class Collection extends Component &#123; componentDidMount() &#123; &#125; render() &#123; const &#123;navigate&#125; = this.props.navigation; //console.log(this.props.data) if(this.props.data.loading)&#123; return ( &lt;View style=&#123;&#123;flex:1,alignItems:'center',justifyContent:'center'&#125;&#125;&gt; &lt;Text&gt;Loading...&lt;/Text&gt; &lt;/View&gt; ) &#125; //console.log(this.props.data.AllCollections); return ( &lt;List containerStyle=&#123;&#123; borderTopWidth: 0, borderBottomWidth: 0 &#125;&#125;&gt; &lt;FlatList data=&#123;this.props.data.AllCollections&#125; renderItem=&#123;(&#123; item &#125;) =&gt; ( &lt;ListItem roundAvatar title=&#123;`$&#123;item.title&#125;`&#125; subtitle=&#123;`访问次数:$&#123;item.visit&#125;`&#125; avatar=&#123;&#123; uri: \"https://avatars3.githubusercontent.com/u/3118295?v=4&amp;s=120\" &#125;&#125; containerStyle=&#123;&#123; borderBottomWidth: 0.2 &#125;&#125; onPress=&#123;() =&gt; navigate('Detail',&#123;id:`$&#123;item.id&#125;`&#125;)&#125; /&gt; )&#125; keyExtractor=&#123;item =&gt; item.id&#125; onEndReachedThreshold=&#123;50&#125; /&gt; &lt;/List&gt; ); &#125; &#125; //注入 graphql 查询 export default graphql(getCollections, &#123;options: (&#123;navigation&#125;) =&gt; &#123; return (&#123; variables: &#123; name: 'alsotang', &#125; &#125;); &#125;&#125;)(Collection) GraphQL在这里不仅仅是对 API进行了包装这么简单,它大概提供了一下的好处: ①:严格了类型,类型错误,或者缺少都会报错 ②:可以根据需求灵活的选择需要返回的数据,例如 列表并不需要 cotent,我们可以选择性的在 graphql 返回数据时省掉这一个字段. 如果 graphQL 服务器和 REST 服务器在同一个主机下,效率会大大提高. ③:为 API生成了一个单一的入口,多个查询可以一次返回. 减少请求次数 ④: 提供了强有力的测试和说明工具: graphiql, 统一前后端的操作. ⑤: graphQL自带说明性质, 有很好的代码提示和自动完成功能. 后续的客户端也会提供这个功能, 出错的机会大大降低了","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"},{"name":"cnode","slug":"cnode","permalink":"https://React-Apollo.github.io/tags/cnode/"}]},{"title":"摘要|有关 Redux 模式最好的一张图","slug":"摘要|有关 Redux 模式最好的一张图","date":"2018-03-02T05:10:46.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/03/02/摘要|有关 Redux 模式最好的一张图/","link":"","permalink":"https://React-Apollo.github.io/2018/03/02/摘要|有关 Redux 模式最好的一张图/","excerpt":"","text":"今天在 medium 网,看到这篇文章When do I know I’m ready for Redux? 要点: ① Redux的单向数据流. 数据只从 Redux=&gt;component. 其实 Redux 也是一个 React 组件, 这个组件的state有特殊的意义. 处理的数据把它转变为 props 就可以传递给子组件了. 这个做法就是 React 的标准模式. 所以如果有一个问题, Redux到底是什么? 它其实也是一个 React 的组件 ② 组件的 dispatch 操作, 并没有真正的操作组件里的函数, 只是通过引用赋值,调用了 Redux中定义的 action 函数, 所以这幅图中从组件到Redux并没有直接相连. 这里阐述的很好.","categories":[{"name":"Readme","slug":"Readme","permalink":"https://React-Apollo.github.io/categories/Readme/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"}]},{"title":"摘要|Better Redux Selectors with Ramda","slug":"摘要| Better  Redux Selectors with Ramda","date":"2018-02-28T09:55:17.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/02/28/摘要| Better  Redux Selectors with Ramda/","link":"","permalink":"https://React-Apollo.github.io/2018/02/28/摘要| Better  Redux Selectors with Ramda/","excerpt":"","text":"原文 目标目标是把Redux中selector: 1234567export const getUserName = state =&gt; state.user.nameexport const isLoggedIn = state =&gt; state.user.id != nullexport const getTotalItemCount = state =&gt; Object.values(state.items.byId) .reduce((total, item) =&gt; total + item.count, 0) 转换为: 1234567891011121314import R from 'ramda'// Helper functionsconst isNotNil = R.complement(R.isNil)const pathIsNotNil = path =&gt; R.compose(isNotNil, R.path(path))const addProp = propName =&gt; R.useWith(R.add, [R.identity, R.prop(propName)])const sumProps = propName =&gt; R.reduce(addProp(propName), 0)const sumCounts = sumProps('count')// Selector functionsexport const getUserName = R.path(['user', 'name'])export const isLoggedIn = pathIsNotNil(['user', 'id'])export const getTotalItemCount = R.compose(sumCounts, R.values, R.path(['items', 'byId'])) 介绍Selector函数回顾selector 的概念在 Redux 的文档中出现过, 为了代替直接在 React 组件中访问 state tree,可以定义从 state 获取数据的函数. 可以认为是从 state获取数据的 API. 不是必须的, 甚至 Redux也不是一定要用. Selector函数接收 Redux的 state 对象作为参数, 返回任何你需要的数据. 实例: 从 State tree 获取 属性 123function getUserName(state) &#123; return state.user.name&#125; 从属性衍生数据 123function isLoggedIn(state) &#123; return state.user.id != null&#125; 从一个列表数据中衍生数据 123456function getTotalItemCount(state) &#123; return Object.keys(state.items.byId) .reduce(function(total, id) &#123; return total + state.items.byId[id].count &#125;, 0)&#125; 假定列表的每个 item都有一个count属性, 这个 selector 使用array.reduce()函数计算count的综合. 123456789101112131415export function getUserName(state) &#123; return state.user.name&#125;export function isLoggedIn(state) &#123; return state.user.id != null&#125;export function getTotalItemCount(state) &#123; return Object.keys(state.items.byId) .reduce(function(total, id) &#123; return total + state.items.byId[id].count &#125;, 0)&#125; 如果使用 ES2015语法,会更简洁 1234567export const getUserName = state =&gt; state.user.nameexport const isLoggedIn = state =&gt; state.user.id != nullexport const getTotalItemCount = state =&gt; Object.values(state.items.byId) .reduce((total, item) =&gt; total + item.count, 0) Object.values 是 ES2017的语法 Ramda 的原则 自动柯理化 数据最后传入 使用 Ramda编写 SelectorsgetUserName1export const getUserName = state =&gt; R.path(['user', 'name'], state) 改为柯理化的版本: 1export const getUserName = state =&gt; R.path(['user', 'name'])(state) 就可以等待数据了 1export const getUserName = R.path(['user', 'name']) 这里的函数就看不到数据了, 这个技术被称为 point-free style 或者tacit programming. isLoggedIn我们想要的版本是获取用于的 ID, 然后判断是否为 true 1export const isLoggedIn = pathIsNotNullOrUndefined(['user', 'id']) Ramda的 isNil 方法123R.isNil(null) // trueR.isNil(undefined) // trueR.isNil(false) // false 现在可以改为: 1const isNotNil = val =&gt; !R.isNil(val) 在更进一步: 1const isNotNil = val =&gt; R.not(R.isNil(val)) 另一个方法: 12345const isNotNil = R.complement(R.isNil)isNotNil(true) // trueisNotNil(null) // falseisNotNil(undefined) // false 进一步重构的版本: 12345const pathIsNotNil = (path, state) =&gt; isNotNil(R.path(path, state))//⛔️柯理化的版本const pathIsNotNil = path =&gt; state =&gt; isNotNil(R.path(path, state)) 也就是从一个 state获取嵌套属性,并且判断是否为 true, 由于属性的路径是在 default 中已经配置好的, 所以我们可以使用柯理化提前配置获取的方法, 等待变化的 state 数据. 这就配置出了一个处理 state 的工厂. 为什么柯理化在函数式编程中很重要,这就是原因. 配置出的工厂是与数据独立的, 这就是上面提到的 tacit programming 无参数编程, 函数的配置和传入的参数是无关的, 顶多是对参数的类型做出约束. 在使用 R.compose 做重构 12const pathIsNotNil = path =&gt; state =&gt; R.compose(isNotNil, R.path)(path, state) 整个操作和path,state 有关, 通过 path从 state 获取属性, 然后判断是否为 true, 1234const pathIsNotNil = path =&gt; state =&gt; R.compose(isNotNil, R.path(path))(state)//👇👇柯理化const pathIsNotNil = path =&gt; R.compose(isNotNil, R.path(path)) 在 pathIsNotNil中实际的数据只有 state,path 是属于配置项, 也就是在程序中是不改变的. 123export const isLoggedIn = pathIsNotNil(['user', 'id'])//配置了从对象的路径 user.id 获取属性值,然后判断是否为 true getTotalItemCount//刚开始的方法123export const getTotalItemCount = state =&gt; Object.values(state.items.byId) .reduce((total, item) =&gt; total + item.count, 0) 面对复杂的问题, 使用函数式风格进行分解是比较好的选择.创建一个函数sumCounts,接收一个数组, 返回项目中count属性的总计. 12const sumCounts = items =&gt; items.reduce((total, item) =&gt; total + item.count, 0) 使用 map1const sumCounts = R.compose(R.sum, R.map(R.prop('count'))) R.map 对数组的每一项调用 R.prop(‘count’)函数, 获取的所有count 属性,放到一个新的数组中, 之后用 R.sum 对数组中的属性值做合计 Ramda 针对map 这个函数的使用,也有更简单的方法 1const sumCounts = R.compose(R.sum, R.pluck('count')) R.pluck 从数组中获取每一项的属性值 使用 Reduce 函数的替代方案1const sumCounts = R.reduce((total, item) =&gt; total + item.count, 0) 12const addCount=(total,item)=&gt;total+item.countconst sumCounts = R.reduce(addCount, 0) 使用 Ramda 的 R.add 方法 1const addCount = (total, item) =&gt; R.add(total, item.count) 从对象中获取属性 1234const addCount = (total, item) =&gt; R.add(total, prop('count', item))// 柯理化形式const addCount = (total, item) =&gt; R.add(total, prop('count')(item)) 上面的函数通用的模式是: 接收两个参数,传递给另一个函数, 第一个参数不懂, 对第二个参数运用一个函数进行处理,之后再执行第一个函数 Ramda 有一个函数可以帮我们完成这个任务, useWith,useWith函数接收两个参数, 第一个参数是单个的函数,和一个函数数组. 数组中的函数被称为变换函数-在对应位置的参数被第一个函数调用之前进行变换处理. 换句话说,数组的第一个函数对第一个参数进行处理, 第二个函数对第二个参数进行处理,以此类推.转换后的参数传递个第一个参数的函数. 在我们的实例中,第一个参数的函数 R.add, 1const addCount = R.useWith(R.add, [/* transformers */]) 需要对 R.add 的第二个参数进行处理, 从 count属性中获取值, 所以放在第二个函数的位置 1const addCount = R.useWith(R.add [/* 1st */, R.prop('count')]) 第一个参数怎么办? 这个参数对应的是 total 值, 不需要转换 , Ramda有一个函数可以原封不动的返回一个数值, R.identity. 1const addCount = R.useWith(R.add, [R.identity, R.prop('count')]) 现在的函数: 123const addCount = R.useWith(R.add, [R.identity, R.prop('count')])const sumCounts = R.reduce(addCount, 0) 现在可以获得更为通用的方式,获取任意的属性, 12345const addProp = propName =&gt; R.useWith(R.add, [R.identity, R.prop(propName)])const sumProps = propName =&gt; R.reduce(addProp(propName), 0)const sumCounts = sumProps('count') 参数的转换方式也可以抽象出来: 123456789const addTransformedItem = transformer =&gt; R.useWith(R.add, [R.identity, transformer])const sumTransformedItems = transformer =&gt; R.reduce(addTransformedItem(transformer), 0)const totalItemComments = R.compose(R.length, R.prop('comments'))const sumComments = sumTransformedItems(totalItemComments) 最终在 Ramda 的帮助下, 总的数据获取流是有更小的可以重用的函数组成的.. 结构如果有下面的数据 123456789const state = &#123; items: &#123; byId: &#123; 'item1': &#123; id: 'item1', count: 2 &#125;, 'item2': &#123; id: 'item2', count: 4 &#125;, 'item3': &#123; id: 'item3', count: 7 &#125; &#125; &#125;&#125; 12export const getTotalItemCount = R.compose(sumCounts, R.values, R.path(['items', 'byId'])) 最终得到的结果1234567891011121314mport R from 'ramda'// Helper functionsconst isNotNil = R.complement(R.isNil)const pathIsNotNil = path =&gt; R.compose(isNotNil, R.path(path))const addProp = propName =&gt; R.useWith(R.add, [R.identity, R.prop(propName)])const sumProps = propName =&gt; R.reduce(addProp(propName), 0)const sumCounts = sumProps('count')// Selector functionsexport const getUserName = R.path(['user', 'name'])export const isLoggedIn = pathIsNotNil(['user', 'id'])export const getTotalItemCount = R.compose(sumCounts, R.values, R.path(['items', 'byId'])) 函数式编程最好的解释应该是: 数据和要对数据进行操作的函数式分离开的. 基于此, 就可以发现, React的组件也可以看成一个函数, 接收应用的数据, 对数据进行处理,之后进行渲染.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"Ramda","slug":"Ramda","permalink":"https://React-Apollo.github.io/tags/Ramda/"},{"name":"FP","slug":"FP","permalink":"https://React-Apollo.github.io/tags/FP/"}]},{"title":"摘要| Functional Redux Reducers with Ramda","slug":"摘要| Functional Redux Reducers with Ramda","date":"2018-02-27T21:44:34.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/02/27/摘要| Functional Redux Reducers with Ramda/","link":"","permalink":"https://React-Apollo.github.io/2018/02/27/摘要| Functional Redux Reducers with Ramda/","excerpt":"","text":"原文地址 Example Redux Reducer———————–假设我们要在 React 组件中展示一组 短吻鳄(gators)的列表,数据从 GatorAPI获取, 具体的数据并不重要. 现在需要把 fetch 的数据添加到 redux 的 state 树中 这个 state 的结构是 ① 在 all 数组中包括 gatorIds,没有重复值(Ramda中如何实现唯一值?) ② 在 lookup 添加新的 gator对象的 hash ById 索引, 索引值是 id(如何实现索引) ③ 在获取数据成功以后, 改变 loading flag的状态, 以便于在渲染时,去掉 spinning组件 Redux reducer的模式Redux reducer 的模式其实是固定的:(prevState,action)=&gt;nextState根据传入的 action,对State 做出修改. 就这么简单, 修改是 Immutable的. 哪怕是一个数字加1, 也会形成新的 state, 这里很有必要使用 FB 的 Immutable.js. 如果是 prevState 和 nextState 之间有公共部分, 虽然是两个不同的对象,但是在底层Immutable.js 可以共享两个对象的共同部分.注意这并不是引用. 实例代码123456789101112131415const reverseMerge = flip(merge);export function fetchSuccess(state, &#123; payload: &#123; gators &#125; &#125;) &#123; const gatorIds = map(prop(\"id\"), gators); const gatorLookup = indexBy(prop(\"id\"), gators); return evolve( &#123; all: compose(uniq, concat(gatorIds)), byId: reverseMerge(gatorLookup), loading: always(false) &#125;, state ); &#125; 使用的 Ramda函数①always: Ramda 中一切都是函数, 如果想使用 int或者字符串,也有通过函数返回 always就是为了这个出发点, val=()=&gt;val, ②compose 函数: 看家函数, Ramda数据流思考的方向, 数据从右传入,经过一系列操作. 实例代码中的 用法可以翻译为 uniq(concat(gatorIds,all)),把 prevState 的 all 属性取出,然后和远程获取的数据拼接, 使用 uniq 函数去重 ③evolve: 接收两个参数, 一组转换函数, 一个对象, 函数对对象的属性递归的进行处理 ④ flip 函数: 翻转两个参数的位置, merge(a,b), 在 merge()中, 如果存在两个属性名相同, b对象的属性值会覆盖 a 的属性值, 在 Redux中, 操作是merge(state,payload.data) 我们希望在出现同名属性的时候, payload 的属性会覆盖 state 的属性. 但是在evolve函数中, state是作为最后一个参数传递, 所以这里借助flip函数交换一下参数的位置. ⑤ indexBy 函数: 提取一个对象的键值作为索引 123[&#123; id: 1, title: \"one\" &#125;, &#123; id: 2, title: \"two\" &#125;]&#123; 1: &#123; id: 1, title: \"one\" &#125;, 2: &#123; id: 2, title: \"two\" &#125; &#125; ⑥ map 函数 , map(elem=&gt;console.log(elm),elements) ⑦ merge 函数 ⑧ prop 函数: 返回对象的属性值, 123prop(\"a\",&#123;a:\"alligator\",b:\"bayou\",c:\"cayman\"&#125;)//=&gt; \"alligator\" ⑨ uniq函数, 接收一个列表,返回一个新列表, 重复值被去除 再看看代码123456789101112131415const reverseMerge = flip(merge);export function fetchSuccess(state, &#123; payload: &#123; gators &#125; &#125;) &#123; const gatorIds = map(prop(\"id\"), gators); const gatorLookup = indexBy(prop(\"id\"), gators); return evolve( &#123; all: compose(uniq, concat(gatorIds)), byId: reverseMerge(gatorLookup), loading: always(false) &#125;, state ); &#125; 定义函数 reverseMerge,交换 merge 函数的参数 map, gators列表, 应用 prop(“id”),因此获取到 ids列表 indexBy函数返回的列表可以通过 id属性值作为索引来访问 evolve 函数, 接收三个函数和 state, 三个函数分别对 state 的不同属性做出修改 state 中的all列表传递给 compose 函数和从 API获取的 gatorIds 合并, 去重, 然后返回 state中的 byId 对象传递给 reverseMerge 函数,和 gatorLookup 合并, 重复值会被 gatorLookup 的属性值覆盖到 Loading的值被修改为 false. 结论实际使用时还有很多的函数可以使用, 在 Redux中有两个地方,ramda可以大有所为,一个就是这里, 还有一个地方就是container 组件包装时对state的筛选 , mapStateToProps,","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"Ramda","slug":"Ramda","permalink":"https://React-Apollo.github.io/tags/Ramda/"},{"name":"FP","slug":"FP","permalink":"https://React-Apollo.github.io/tags/FP/"}]},{"title":"摘要| Recompose recipes","slug":"摘要| Recompose recipes","date":"2018-02-26T14:57:50.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/02/26/摘要| Recompose recipes/","link":"","permalink":"https://React-Apollo.github.io/2018/02/26/摘要| Recompose recipes/","excerpt":"","text":"","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"摘要| Recompose 文档","slug":"摘要| Recompose","date":"2018-02-26T13:30:14.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/02/26/摘要| Recompose/","link":"","permalink":"https://React-Apollo.github.io/2018/02/26/摘要| Recompose/","excerpt":"","text":"Recompose API在文档中, HOC 指的是一个函数接收一个 React 组件,返回另一个新的 React 组件 1const EnhancedComponent=hoc(BaseComponent) 有时是可以组合的 123const composedHoc=compose(hoc1,hoc2,hoc3)//等同于const composedHoc=BaseComponent=&gt;hoc1(hoc2(hoc3(BaseComponent))) 绝大多数的 Recompose 助手函数都是返回 hoc的函数 Higher-order componentsmapProps123mapProps( propsMapper:(ownerProps:Object)=&gt;Object, ):HigherOrderComponent 接收一个函数,映射拥有者的 props称为新的 props 集合, 并传递给 baseComponent.mapProps()和其他的函数式工具可以很好的一起工作, 例如 Recomopose 没有omitProps()函数,但是可以很容易的使用 lodash 的函数omit() 1234const omitProps = keys =&gt; mapProps(props =&gt; omit(keys, props))// 因为 lodash-fp 是支持柯理化的,所以也可以写为const omitProps = compose(mapProps, omit) withProps123withProps( createProps: (ownerProps: Object) =&gt; Object | Object): HigherOrderComponent 新创建的props 和 owner props 合并 withPropsOnChange()1234withPropsOnChange( shouldMapOrKeys: Array&lt;string&gt; | (props: Object, nextProps: Object) =&gt; boolean, createProps: (ownerProps: Object) =&gt; Object): HigherOrderComponent 只有在 shouldMapKeys 发生变化时才可以创建新的 props. 确保 createProps 内的计算只有在必要的情况下才进行. withHandlers()12345678withHandlers( handlerCreators: &#123; [handlerName: string]: (props: Object) =&gt; Function &#125; | handlerCreatorsFactory: (initialProps) =&gt; &#123; [handlerName: string]: (props: Object) =&gt; Function &#125;): HigherOrderComponent 接收一组 handler creator 或者是 工厂函数. 这些函数都是高阶函数, 接收一组 props,返回操作函数 这么做,就是让 handler 通过闭包访问当前的 props,但是又不用改变函数的签名 传递给组件的handlers都是 immutable 属性, 在渲染器中会一直保持不变.这么做避免了在函数式组件中创建函数的一个缺陷, 就是原先的函数式组件中,每次渲染都会创建新的 handler,打断了使用shouldComponentUpdate()函数通过判读 props 变化的优化措施. 所以在创建 handler 时最好使用 withHandlers() ,mapProps和withProps每次会创建新的 handler 实例: 1234567891011121314151617181920const enhance = compose( withState('value', 'updateValue', ''), withHandlers(&#123; onChange: props =&gt; event =&gt; &#123; props.updateValue(event.target.value) &#125;, onSubmit: props =&gt; event =&gt; &#123; event.preventDefault() submitForm(props.value) &#125; &#125;))const Form = enhance((&#123; value, onChange, onSubmit &#125;) =&gt; &lt;form onSubmit=&#123;onSubmit&#125;&gt; &lt;label&gt;Value &lt;input type=\"text\" value=&#123;value&#125; onChange=&#123;onChange&#125; /&gt; &lt;/label&gt; &lt;/form&gt;) defaultProps()123defaultProps( props: Object): HigherOrderComponent default 的 props 会和 owner props合并,但是owner props 的优先级更高,有相同属性的,不会被替换 renameProps()12345renameProp( oldName: string, newName: string): HigherOrderComponent Rename 单个属性 renameProps() :更改多个属性名withState()12345withState( stateName: string, stateUpdaterName: string, initialState: any | (props: Object) =&gt; any): HigherOrderComponent 传递两个额外的 props 到 base component: state value和一个 更新 state value 的函数, state updater 的签名如下: 123stateUpdater&lt;T&gt;((prevValue: T) =&gt; T, ?callback: Function): voidstateUpdater(newValue: any, ?callback: Function): void 第一个形式接收之前的state,映射为新的 state value. withState()和withHadlers()一起创建特定的 updater 函数. 例如 123456789const addCounting = compose( withState('counter', 'setCounter', 0), withHandlers(&#123; increment: (&#123; setCounter &#125;) =&gt; () =&gt; setCounter(n =&gt; n + 1), decrement: (&#123; setCounter &#125;) =&gt; () =&gt; setCounter(n =&gt; n - 1), reset: (&#123; setCounter &#125;) =&gt; () =&gt; setCounter(0) &#125;)) 第二种形式接收单个值, 被作为新的 state 两种形式都接受可选的参数,这个参数是一个回调函数, 一旦setState()完成,组件重新渲染,回调函数会执行. 初始值是必须的. 要么是 state 值, 或者是从初始 props 返回的初始 State. withStateHandlers()123456withStateHandlers( initialState: Object | (props: Object) =&gt; any, stateUpdaters: &#123; [key: string]: (state:Object, props:Object) =&gt; (...payload: any[]) =&gt; Object &#125;) 传递 state对象属性和 immutable 版本的 updater 函数到 base component 每个 state updater 函数接收state,props和 payload必须返回新的 state 或者 undefined. 新的 state 和之前的 state 进行浅层比较, 如果返回 undefined,组件就不会重新渲染. 实例: 1234567891011121314151617181920212223const Counter = withStateHandlers( (&#123; initialCounter = 0 &#125;) =&gt; (&#123; counter: initialCounter, &#125;), &#123; incrementOn: (&#123; counter &#125;) =&gt; (value) =&gt; (&#123; counter: counter + value, &#125;), decrementOn: (&#123; counter &#125;) =&gt; (value) =&gt; (&#123; counter: counter - value, &#125;), resetCounter: (_, &#123; initialCounter = 0 &#125;) =&gt; () =&gt; (&#123; counter: initialCounter, &#125;), &#125; )( (&#123; counter, incrementOn, decrementOn, resetCounter &#125;) =&gt; &lt;div&gt; &lt;Button onClick=&#123;() =&gt; incrementOn(2)&#125;&gt;Inc&lt;/Button&gt; &lt;Button onClick=&#123;() =&gt; decrementOn(3)&#125;&gt;Dec&lt;/Button&gt; &lt;Button onClick=&#123;resetCounter&#125;&gt;Reset&lt;/Button&gt; &lt;/div&gt; ) withReducer()1234567withReducer&lt;S, A&gt;( stateName: string, dispatchName: string, reducer: (state: S, action: A) =&gt; S, initialState: S | (ownerProps: Object) =&gt; S): HigherOrderComponent 和withState()类似,但是使用的是 reducer 函数. reducer 函数接收一个 state,一个 action, 返回一个新的 state. 之后新的 state 被应用 branch()12345branch( test: (props: Object) =&gt; boolean, left: HigherOrderComponent, right: ?HigherOrderComponent): HigherOrderComponent 接收一个检测函数, 和两个高阶组件, test 函数接受 owner 的 props.如果返回的是 true, left高阶组件被应用到 basecomponent, 反之,right 高阶组件被应用的 base component . 如果没有提供right 高阶组件, 返回包装的组件 renderComponent()123renderComponent( Component: ReactClass | ReactFunctionalComponent | string): HigherOrderComponent 接受一个组件, 返回高阶组件版本. 和其他的期待高阶组件的助手函数联合使用,例如branch(): 123456789101112131415161718192021// `isLoading()` is a function that returns whether or not the component// is in a loading stateconst spinnerWhileLoading = isLoading =&gt; branch( isLoading, renderComponent(Spinner) // `Spinner` is a React component )// Now use the `spinnerWhileLoading()` helper to add a loading spinner to any// base componentconst enhance = spinnerWhileLoading( props =&gt; !(props.title &amp;&amp; props.author &amp;&amp; props.content))const Post = enhance((&#123; title, author, content &#125;) =&gt; &lt;article&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;h2&gt;By &#123;author.name&#125;&lt;/h2&gt; &lt;div&gt;&#123;content&#125;&lt;/div&gt; &lt;/article&gt;) renderNothing()1renderNothing: HigherOrderComponent 总是渲染null的高阶组件 也是和其他期待高阶组件的助手函数一起工作 12345678910111213141516171819// `hasNoData()` is a function that returns true if the component has// no dataconst hideIfNoData = hasNoData =&gt; branch( hasNoData, renderNothing )// Now use the `hideIfNoData()` helper to hide any base componentconst enhance = hideIfNoData( props =&gt; !(props.title &amp;&amp; props.author &amp;&amp; props.content))const Post = enhance((&#123; title, author, content &#125;) =&gt; &lt;article&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;h2&gt;By &#123;author.name&#125;&lt;/h2&gt; &lt;div&gt;&#123;content&#125;&lt;/div&gt; &lt;/article&gt;) shouldUpdate()123shouldUpdate( test: (props: Object, nextProps: Object) =&gt; boolean): HigherOrderComponent 高阶组件版本的 shouldComponentUpdate(),test 函数接受当前的props和下一个 props pure()1pure: HigherOrderComponent 阻止组件更新,除非是 props 发生变化. 使用shallowEquall()检测变化. onlyUdateForKeys()1234onlyUpdateForKeys( propKeys: Array&lt;string&gt;): HigherOrderComponent 阻止组件更新,只有在对应的 props中给定key的部分发生变化时才能执行更新. 使用的是shallowEqual()检测变化 这个方法对于优化是最好的, 因为只关心特定的 props 部分. 实例: 123456789101112131415/** * If the owner passes unnecessary props (say, an array of comments), it will * not lead to wasted render cycles. * * Goes well with destructuring because it's clear which props the component * actually cares about. */const enhance = onlyUpdateForKeys(['title', 'content', 'author'])const Post = enhance((&#123; title, content, author &#125;) =&gt; &lt;article&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;h2&gt;By &#123;author.name&#125;&lt;/h2&gt; &lt;div&gt;&#123;content&#125;&lt;/div&gt; &lt;/article&gt;) onlyUpdateForPropTypes()工作方式和onlyUpdateForKeys()类似,只是 props keys 是从 base component 的propTypes中获取的,和setPropTypes()一起非常有用. 如果base component 没有任何的propTypes,组件不会执行任何更新操作. 这可能不是想要的结果,所以会在终端打印警告信息 123456789101112131415161718import PropTypes from 'prop-types'; // You need to import prop-types. See https://facebook.github.io/react/docs/typechecking-with-proptypes.htmlconst enhance = compose( onlyUpdateForPropTypes, setPropTypes(&#123; title: PropTypes.string.isRequired, content: PropTypes.string.isRequired, author: PropTypes.object.isRequired &#125;))const Post = enhance((&#123; title, content, author &#125;) =&gt; &lt;article&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;h2&gt;By &#123;author.name&#125;&lt;/h2&gt; &lt;div&gt;&#123;content&#125;&lt;/div&gt; &lt;/article&gt;) withContext()1234withContext( childContextTypes: Object, getChildContext: (props: Object) =&gt; Object): HigherOrderComponent 为子组件提供上下文. getContext()123getContext( contextTypes: Object): HigherOrderComponent 从上下文中获取值并以 props 的形式传递. lifycycle()123lifecycle( spec: Object,): HigherOrderComponent 这是高阶组件版本的React.Component(),支持除了render()之外的所有Component API, render()方式是默认实现的. 任何lifecycle()方法引起的 state改变, 会传递给包装组件 实例: 1234567891011const PostsList = (&#123; posts &#125;) =&gt; ( &lt;ul&gt;&#123;posts.map(p =&gt; &lt;li&gt;&#123;p.title&#125;&lt;/li&gt;)&#125;&lt;/ul&gt;)const PostsListWithData = lifecycle(&#123; componentDidMount() &#123; fetchPosts().then(posts =&gt; &#123; this.setState(&#123; posts &#125;); &#125;) &#125;&#125;)(PostsList); toClass()1toClass:HigherOrderComponent 接收一个函数组件,包装成一个类. 如果是已经是一个类,就直接返回了 Sattic property helpers这些方法不仅仅是要返回新的组件, 还改变了组建的属性 setStatic()1234setStatic( key: string, value: any): HigherOrderComponent 为 base component 赋予propTypes 属性 setDisplayName123setDisplayName( displayName: string): HigherOrderComponent 赋予displayName属性 UtilitiesRecompose 包含一些额外的助手, 不是高阶组件,但是仍然非常有用 compose()1compose(...functions: Array&lt;Function&gt;): Function 把多个高阶组件组合成一个. 这个方法和 Redux 中的 compose(), lodash-fp的 flowRight(), Ramda 的compose()工作原理是类似的. getDisplayName()123getDisplayName( component: ReactClass | ReactFunctionalComponent): string 返回 React 组件的显示名 wrapDisplayName()1234wrapDisplayName( component: ReactClass | ReactFunctionalComponent, wrapperName: string): string 返回显示名包装的React 组件. shallowEqual()1shallowEqual(a:Object,b:Object):boolean isClassComponent()1isClassComponent(value:any):boolean createSink()1createSink(callback:(props:Object)=&gt;void):ReactClass 什么也渲染,仅仅调用回调函数 componentFromProp()1componentFromProp(propName: string): ReactFunctionalComponent 创建一个组件以 props的形式接收另一个组件, 并使用剩余的 props 渲染这个组件 123456const enhance = defaultProps(&#123; component: 'button' &#125;)const Button = enhance(componentFromProp('component'))&lt;Button foo=\"bar\" /&gt; // renders &lt;button foo=\"bar\" /&gt;&lt;Button component=\"a\" foo=\"bar\" /&gt; // renders &lt;a foo=\"bar\" /&gt;&lt;Button component=&#123;Link&#125; foo=\"bar\" /&gt; // renders &lt;Link foo=\"bar\" /&gt; nest()123nest( ...Components: Array&lt;ReactClass | ReactFunctionalComponent | string&gt;): ReactClass 返回嵌套的组件 123456789101112// Given components A, B, and Cconst ABC = nest(A, B, C)&lt;ABC pass=\"through\"&gt;Child&lt;/ABC&gt;// Effectively the same as&lt;A pass=\"through\"&gt; &lt;B pass=\"through\"&gt; &lt;C pass=\"through\"&gt; Child &lt;/C&gt; &lt;/B&gt;&lt;/A&gt; hoistStatics()1hoistStatics(hoc: HigherOrderComponent): HigherOrderComponent","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"FP","slug":"FP","permalink":"https://React-Apollo.github.io/tags/FP/"},{"name":"HOC","slug":"HOC","permalink":"https://React-Apollo.github.io/tags/HOC/"}]},{"title":"Prisma|GraphQL Server Basics:Schema","slug":"Prisma|GraphQL Server Basics:Schema","date":"2018-02-25T10:28:43.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/02/25/Prisma|GraphQL Server Basics:Schema/","link":"","permalink":"https://React-Apollo.github.io/2018/02/25/Prisma|GraphQL Server Basics:Schema/","excerpt":"","text":"GraphQL Server Basics: The Schema 原文在这里 构建 GraphQL 服务器第一步是设计 schema. 这里讲解 schema 的组成 GraphQL schema 定义了服务器的 API定义语言: Schema Definition Language(SDL) 示例: 1234type User&#123; id:ID! name:String!&#125; 只有User,并不能给客户端提供任何的功能. 只是简单的定义了用户的模型. 为了添加功能, 需要在 root type 中添加字段:Query,Mutation,Subscription. 这些字段定义了 GraphQL API 的入口 示例代码: 123456query &#123; user(id:\"abc\")&#123; id name &#125;&#125; 对于这个查询,要想获取结果, 必须要定义Query类型 123type Query&#123; user(id:ID!):User&#125; 因此shcema 的 root type定义了 server 可以接受的 query,mutation的结构 GraphQLSchema对象是 GraphQL Server 的核心主要包括两个主要的组件: ①schema 定义 ②实际实现的 resolvers 函数 针对上面的例子, GraphQLSchema对象是: 12345678910111213141516171819202122//const UserType = new GraphQLObjectType(&#123; name: 'User', fields: &#123; id: &#123; type: GraphQLID &#125;, name: &#123; type: GraphQLString &#125; &#125;&#125;)const schema = new GraphQLSchema(&#123; query: new GraphQLObjectType(&#123; name: 'Query', fields: &#123; user: &#123; type: UserType, args: &#123; id: &#123; type: GraphQLID &#125; &#125; &#125; &#125; &#125;)&#125;) SDL版的 schema 被翻译为 JS的形式.这里还没有 resolvers,所以还实现不了具体的功能 Resolvers负责具体实现 APIGraphQL Server 中的结构和行为在 GraphQL Server 中结构和行为是明显分开的, 结构就是 shcema,行为实现的关键组件就是resolver函数. 下面这一点是非常重要的一句总结: 每个GraphQL schema的字段都有 resolver 支撑 在基础结构中, GraphQL Server 为每个字段都提供 resolver 函数.每个resolver 都知道怎么获取对应字段的数据. 因为GraphQL 查询的精髓:仅仅返回字段的集合(collection) GraphQL Server 要做的事情**只是为查询中的每个字段调用 resolver 函数. 简单说: 只是调用远程的函数**. resolver 函数的剖析针对上面的user 字段: 123456789101112131415161718192021const UserType = new GraphQLObjectType(&#123; name: 'User', fields: &#123; id: &#123; type: GraphQLID &#125;, name: &#123; type: GraphQLString &#125; &#125;&#125;)const schema = new GraphQLSchema(&#123; query: new GraphQLObjectType(&#123; name: 'Query', fields: &#123; user: &#123; type: UserType, args: &#123; id: &#123; type: GraphQLID &#125; &#125; &#125; &#125; &#125;)&#125;) 假设有一个函数fetchUserById,被实际调用,返回一个 js 对象(有id,name字段), resolver 函数使得 schema 可以执行实际的功能了. 下面看看 resolver 函数中的四个参数: root: resolver 中的root 是之前调用的结果 args: 包含了查询的参数,这个例子中是id context:在 resolver 函数链中传递的对象, 每个 resolver 都可以访问(用于 resolver 之间通讯和共享信息) info: 查询或者 mutation 的 AST结构图. 完整的查询 resolver 返回的字段: 这就是实际的操作, 每个字段都是单独返回的1234567891011121314151617const UserType = new GraphQLObjectType(&#123; name: 'User', fields: &#123; id: &#123; type: GraphQLID, resolve: (root, args, context, info) =&gt; &#123; return root.id &#125; &#125;, name: &#123; type: GraphQLString, resolve: (root, args, context, info) =&gt; &#123; return root.name &#125; &#125; &#125;&#125;) 执行查询 具体的步骤: ① query到达服务器 ② 服务器调用 resolver 用于查询user的字段 ③ 为type User的字段 id调用 resolver函数, root 为这个 resolver 提供参数,就是之前调用的返回值, root.id. ④ 和③类似,只是返回root.name ,③和④是并行操作 ⑤操作结束, 最终的结果包装在data 字段中 12345678&#123; \"data\": &#123; \"user\": &#123; \"id\": \"abc\", \"name\": \"Sarah\" &#125; &#125;&#125; 这些琐碎的流程实际GraphQL.js已经为我们完成了 优化请求: DataLoader 模式在客户端发送嵌套查询时, 很容易出现性能问题 例如: 12345678910111213query &#123; user(id: \"abc\") &#123; name article(title: \"GraphQL is great\") &#123; comments &#123; text writtenBy &#123; name &#125; &#125; &#125; &#125;&#125; 如果一篇文章有五条评论,我们要执行五次writtenBy resolver.DataLoader可以让你避免这个问题,简单说就是函数调用是批量进行的 GraphQL.js VS. graphql-toolsGraphQL.js 为 graphql-tools提供了基础GraphQL.js 是底层干活的, graphql-tools 提供了一个易于使用的应用层. GraphQL.js 的组成部分 parse和buildASTSchema:给定一个 schema 的字符串,这两个函数会创建一个GraphQLSchema的实例:const schema=buildASTSchema(parse(sdlString)) validate: validate确保 query符合 API的定义 execute: 给定一个schema 实例和一个查询, execute负责调用字段的 resolver函数,根据 GraphQL 规范创建响应. printSchema: 接收 schema实例用 SDL 形式返回它的定义 GraphQL 中最重要的函数是graphql,接收GraphQLSchema实例和查询-然后调用验证和执行 1graphql(schema, query).then(result =&gt; console.log(result)) 可以认为graphql的功能就是作为GraphQL engine. graphql-tools 桥接接口和实现在GraphQL.js的基础上, graphql-tools提供了一个重要的功能addResolverFunctionToSchema. 基于 SDL 创建 schema的问题就解决了.准确的讲应该是makeEcecutableSchema: 1234567891011121314151617181920212223const &#123; makeExecutableSchema &#125; = require('graphql-tools')const typeDefs = `type Query &#123; user(id: ID!): User&#125;type User &#123; id: ID! name: String&#125;`const resolvers = &#123; Query: &#123; user: (root, args, context, info) =&gt; &#123; return fetchUserById(args.id) &#125; &#125;,&#125;const schema = makeExecutableSchema(&#123; typeDefs, resolvers&#125;) 所以使用graphql-tools的最大好处是连接你的scehma 和 resolvers 什么时候不要使用 graphql-tools?graphql-tools 只是在GraphQL.js的基础是提供一个便于使用的抽象. 所以有的时候直接使用 graphql-tools 可能不太好 这是以牺牲灵活性为代价的. 如果你的服务器需要定制很多需求, 例如动态构建或者修改 scehma. 可能要返回去使用GraphQL.js graphene.js 快速浏览graphene.js是从 Python表兄那里获取的灵感. 底层仍然是 GraphQL.js, 但是不能声明式定义 schema. graphenes.js使用了最新的 js 语法, 查询和 mutation可以以 js 的类形式表现.丰富了 graphql的 Ecosystem 结论 GraqhQL.js 是实现功能的引擎.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"Prisma|DataModel_airbnb","slug":"Prisma|DataModel_airbnb ","date":"2018-02-25T08:59:29.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/02/25/Prisma|DataModel_airbnb /","link":"","permalink":"https://React-Apollo.github.io/2018/02/25/Prisma|DataModel_airbnb /","excerpt":"","text":"primsa文档中的示例代码片段","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"GraphQL query 实现的细节","slug":"GraphQL-query 的实现细节","date":"2018-02-24T23:57:50.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/02/24/GraphQL-query 的实现细节/","link":"","permalink":"https://React-Apollo.github.io/2018/02/24/GraphQL-query 的实现细节/","excerpt":"","text":"graphql在执行操作的时候,是如何体现灵活性的? ①查询字符串的组成 ②解析 ③再解析 ④返回结果 原来这里每个字段实际是独立的,每个 resolver 实际是单独返回每个字段 注意③和④的结果和返回的结果, 每个字段是单独返回的.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"SVG|Doughnut","slug":"SVG-doughnut","date":"2018-02-24T10:15:32.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/02/24/SVG-doughnut/","link":"","permalink":"https://React-Apollo.github.io/2018/02/24/SVG-doughnut/","excerpt":"","text":"See the Pen CSS only interactive donut chart by phpsmarter (@phpsmarter) on CodePen.","categories":[{"name":"UI","slug":"UI","permalink":"https://React-Apollo.github.io/categories/UI/"}],"tags":[{"name":"UI","slug":"UI","permalink":"https://React-Apollo.github.io/tags/UI/"},{"name":"SVG","slug":"SVG","permalink":"https://React-Apollo.github.io/tags/SVG/"}]},{"title":"聊天软件的 Prisma_DataModel","slug":"聊天软件的DataModel","date":"2018-02-23T22:08:10.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/02/23/聊天软件的DataModel/","link":"","permalink":"https://React-Apollo.github.io/2018/02/23/聊天软件的DataModel/","excerpt":"","text":"基于 Chatty clone 数据的关联模型 一个用户可以属于多个小组, 有多个朋友, 有多条消息 一个小组可以有多个用户,可以有多条消息 一条消息来自于一个用户, 发送给某个或某几个组 多播 系统消息可以发送给所有组.广播 流程具体的模型流程来自 Node in Action 用户注册流程 加组,如果组不存在就创建新的 发送消息, 获取用户名,来自组名, 发送到组, 消息内容 1234567891011121314151617181920212223242526272829type User &#123; id: ID! @isUnique email: String @isUnique username: String!@isUnique password: String! userOfGroups: [Group!]@relation(name: \"userOnGroup\") #一个用户可以属于一个小组 userOfFriends: [User] #一个用户可以有多个朋友 userOfMessages: [Message]@relation(name: \"userOfMessage\") #一个用户有多条消息 createdAt: Date! updatedAt:Date!&#125;type Group &#123; id: ID!@isUnique nameOfGroup: String usersOfGroup: [User]@relation(name: \"userOnGroup\")# 一个小组有多个用户 messagesOfGroup: [Message]@relation(name: \" messageOfGroup\") #一个小组可以有多条消息 createdAt: Date! updatedAt:Date!&#125;type Message &#123; id: Int! toGroup: [Group]@relation(name:\"messageOfGroup\") #一条消息可以发送多个组 fromUser: User!@relation(name:\"userOfMessage\")#一条消息有一个发送用户 text: String! createdAt: Date! updatedAt:Date!&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"Apollo-Server 实例代码","slug":"Apollo-Server 代码","date":"2018-02-23T19:31:50.000Z","updated":"2018-04-07T02:42:18.247Z","comments":true,"path":"2018/02/23/Apollo-Server 代码/","link":"","permalink":"https://React-Apollo.github.io/2018/02/23/Apollo-Server 代码/","excerpt":"","text":"和之前的网站抓取时实际一样的, Prisma内部使用的是Apollo-server 的服务, 在这个实例中,使用的是 mongodb-mongoose的接口, 在 resolvers 中实际不限制任何获取数据的方法, graphql 的核心只是按照 schema 来组织数据.接下来再看看直接在 resolvers 中返回另一个 graphql 数据的实例","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphql","slug":"Graphql","permalink":"https://React-Apollo.github.io/tags/Graphql/"},{"name":"prisma","slug":"prisma","permalink":"https://React-Apollo.github.io/tags/prisma/"}]},{"title":"EcoSystem|如何用 GraphQL包装 REST API","slug":"EcoStystem|如何用 GraphQL包装 REST API","date":"2018-02-23T11:54:55.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/02/23/EcoStystem|如何用 GraphQL包装 REST API/","link":"","permalink":"https://React-Apollo.github.io/2018/02/23/EcoStystem|如何用 GraphQL包装 REST API/","excerpt":"","text":"数组和对象的处理是常规编程中处理的主要内容, 可说是数据的表现形式,但是原始数据可能达不到我们的要求,所以有很多的处理方法. 我想在 GraphQL的模式下,在 resolver 中处理 REST API,或者其他的 graphQL server 的数据,出发点是类似的.数据的本质并没有改变.GrahQL 的核心是提供了: 单一的入口 严格的类型约束 灵活的查询构成 所以如果我们要使用 graphQL 包装 REST API,从 REST API返回的数据必须要遵循 GraphQL 的核心概念. 保证严格约束下的灵活性. 核心概念就如此. Analyze the data model of the REST API Derive the GraphQL schema for the API based on the data model Implement resolver functions for the schema resolverresolver 函数只是简单的 express 服务器, 可以在其中调用任何的接口,根据 schema 返回数据. 复杂的操作都要在 resolver中实现.Prisma的内核其实就是一个 Node.js Express server. 对于简单的schema, 自动生成了很多的 CURD方法,现阶段从 mysql 数据库获取数据,然后按照 schema的要求返回 json 数据. 这个 server, 就是 graphql-yoga. 简单和容易体现在, resolvers 是系统自动生成的,还是我们来编写.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"EcoSystem|Graphql-binding","slug":"EcoSystem|Graphql-binding","date":"2018-02-23T08:30:29.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/02/23/EcoSystem|Graphql-binding/","link":"","permalink":"https://React-Apollo.github.io/2018/02/23/EcoSystem|Graphql-binding/","excerpt":"","text":"🔗 graphql-binding 可以在 graphql server 中嵌入grahql API核心概念是通过为 GraphQL API 创建一个对象,表现出 API 的功能. 这个对象暴露的方法和GraphQL API schema 中定义的查询方法是镜像关系. Install1yarn add graphql-binding APIconstructor1constructor(options: BindingOptions): Binding Key Required Type Default Note schema Yes GraphQLSchema - The executable GraphQL schema for binding fragmentReplacements No FragmentReplacements {} A list of GraphQL fragment definitions, specifying fields that are required for the resolver to function correctly before No () =&gt; void (() =&gt; undefined) A function that will be executed before a query/mutation is sent to the GraphQL API handler No any null The handler object from JS Proxy subscriptionHandler No any null … query&amp;mutation12binding.query.&lt;rootField&gt;: QueryMap&lt;any&gt; // where &lt;rootField&gt; is the name of a field on the Query type in the mapped GraphQL schemabinding.mutation.&lt;rootField&gt;: QueryMap&lt;any&gt; // where &lt;rootField&gt; is the name of a field on the Mutation type in the mapped GraphQL schema binding对象暴露出两个接口 query,mutate可以用于执行操作.分别接收三个参数 实例假设有下面的 schema 1234567type Query &#123; user(id: ID!): User&#125;type Mutation &#123; createUser(): User!&#125; 12binding.query.user(&#123; id: 'abc' &#125;)binding.mutation.createUser() 1234567findUser(parent, args, context, info) &#123; return binding.user(&#123; id: args.id &#125;, context, info)&#125;newUser(parent, args, context, info) &#123; return binding.createUser(&#123;&#125;, context, info)&#125; subscription123binding.subscription.&lt;rootField&gt;(...): AsyncIterator&lt;any&gt; | Promise&lt;AsyncIterator&lt;any&gt;&gt; // where &lt;rootField&gt; is the name of a field //on the Subscription type in the mapped GraphQL schema 简单实例1234567891011121314151617181920212223242526272829303132333435const &#123; makeExecutableSchema &#125; = require('graphql-tools')const &#123; Binding &#125; = require('graphql-binding')const users = [ &#123; name: 'Alice', &#125;, &#123; name: 'Bob', &#125;,]const typeDefs = ` type Query &#123; findUser(name: String!): User &#125; type User &#123; name: String! &#125;`const resolvers = &#123; Query: &#123; findUser: (parent, &#123; name &#125;) =&gt; users.find(u =&gt; u.name === name), &#125;,&#125;const schema = makeExecutableSchema(&#123; typeDefs, resolvers &#125;)const findUserBinding = new Binding(&#123; schema,&#125;)findUserBinding.findUser(&#123; name: 'Bob' &#125;) .then(result =&gt; console.log(result)) 与 Prisma 的联系graphcool-binding(prisma) 是这个版本的实现方案 123456789101112131415161718192021// Instantiate `Prisma` based on concrete serviceconst prisma = new Prisma(&#123; typeDefs: 'schemas/database.graphql', endpoint: 'https://us1.prisma.sh/demo/my-service/dev' secret: 'my-super-secret-secret'&#125;)// Retrieve `name` of a specific userprisma.query.user(&#123; where &#123; id: 'abc' &#125; &#125;, '&#123; name &#125;')// Retrieve `id` and `name` of all usersprisma.query.users(null, '&#123; id name &#125;')// Create new user called `Sarah` and retrieve the `id`prisma.mutation.createUser(&#123; data: &#123; name: 'Sarah' &#125; &#125;, '&#123; id &#125;')// Update name of a specific user and retrieve the `id`prisma.mutation.updateUser(&#123; where: &#123; id: 'abc' &#125;, data: &#123; name: 'Sarah' &#125; &#125;, '&#123; id &#125;')// Delete a specific user and retrieve the `name`prisma.mutation.deleteUser(&#123; where: &#123; id: 'abc' &#125; &#125;, '&#123; id &#125;') 内部机制 prisma 的函数调用最终翻译为 graphql-binding 的方式 123456prisma.exists.Post(&#123; id: 'abc', author: &#123; name: 'Sarah' &#125;&#125;)","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"F8App_DataModel_Prisma_version","slug":"F8app-2016-dataModel-Prisma-version","date":"2018-02-22T21:52:32.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/02/22/F8app-2016-dataModel-Prisma-version/","link":"","permalink":"https://React-Apollo.github.io/2018/02/22/F8app-2016-dataModel-Prisma-version/","excerpt":"","text":"F8App GraphQL 服务器 Prisma版本的Datamodel重构版添加了关联的类型, Tag类型, 关联条件实际只有演讲↔️演讲者, 演讲↔️地图,演讲↔️标签的关系 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879type Agenda &#123; id: ID! @unique startTime:String endTime:String speakers:[Speaker!]! @relation(name:\"AgendaBySpeaker\") #一个 agenda可以有多个发言者 tags:[Tag!]! # 一个 Agenda可以有多个 tag, 不会发生歧义所以不用@ relation关联条件 allDay:Boolean@default(value:\"false\") day:Int! hasDetails:Boolean@default(value:\"true\") onMySchedule:Boolean@default(value:\"false\") sessionDescription:String sessionLocation:Map!@relation(name:\"AgendaOfMap\") #每个 agenda有一个地理位置 sessionSlug: String sessionTitle:String! createdAt: DateTime! updatedAt: DateTime!&#125;type Speaker &#123; id: ID! @unique speakerPic: String speakerName: String! speakerTitle:String! createdAt: DateTime! updatedAt: DateTime! agendas:[Agenda!]!@relation(name:\"AgendaBySpeaker\") #一个发言者可以有多个 agenda&#125;type Map &#123; id:ID!@unique x1:String x2:String x3:String name:String createdAt: DateTime! updatedAt: DateTime! mapOfAgendas:[Agenda!]!@relation(name:\"AgendaOfMap\") # 一个地图可以有多个 agenda&#125;type Faq &#123; id:ID!@unique question:String anwser:String createdAt: DateTime! updatedAt: DateTime!&#125;type Notification &#123; id:ID!@unique text:String! createdAt: DateTime! updatedAt: DateTime!&#125;type Page &#123; id:ID!@unique alias: String title:String createdAt: DateTime! updatedAt: DateTime!&#125;type Todo &#123; id:ID!@unique createdAt: DateTime! updatedAt: DateTime! text: String isCompleted:Boolean@default(value:\"false\")&#125;type Tag &#123;id:ID!@unique createdAt: DateTime! updatedAt: DateTime! text: String description:String agenda:Agenda &#125; playground中的方法 单个 Agenda 的mutate 操作12345678910111213141516171819202122232425262728mutate AgendaCreateInput &#123; startTime: String endTime: String allDay: Boolean day: Int! hasDetails: Boolean onMySchedule: Boolean sessionDescription: String sessionSlug: String sessionTitle: String! speakers:&#123; speakerPic: String speakerName: String! speakerTitle: String! &#125; tags:&#123; text: String description: String &#125; sessionLocation:&#123; x1: String x2: String x3: String name: String &#125;&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"f8App-datamodel","slug":"f8App-datamodel-item","date":"2018-02-22T14:56:04.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/02/22/f8App-datamodel-item/","link":"","permalink":"https://React-Apollo.github.io/2018/02/22/f8App-datamodel-item/","excerpt":"","text":"","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"EcoSystem|graphql-yoga-todo-app","slug":"Graphql-yoga-todo-app","date":"2018-02-21T21:42:39.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/02/21/Graphql-yoga-todo-app/","link":"","permalink":"https://React-Apollo.github.io/2018/02/21/Graphql-yoga-todo-app/","excerpt":"","text":"","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"摘要| Query Component  in  apollo-client","slug":"摘要| Query component","date":"2018-02-20T10:11:49.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/02/20/摘要| Query component/","link":"","permalink":"https://React-Apollo.github.io/2018/02/20/摘要| Query component/","excerpt":"","text":"","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphql","slug":"Graphql","permalink":"https://React-Apollo.github.io/tags/Graphql/"},{"name":"apollo","slug":"apollo","permalink":"https://React-Apollo.github.io/tags/apollo/"}]},{"title":"Prisma API","slug":"Prisma API","date":"2018-02-19T20:00:40.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/02/19/Prisma API/","link":"","permalink":"https://React-Apollo.github.io/2018/02/19/Prisma API/","excerpt":"","text":"Prisma的 API 是什么?Prisma服务暴露的 GraphQL API是基于部署的 data model 自动生成的. Prisma API 为 data model 中的 type 定义了 CRUD 操作, 探索 Prisma APIGraphql Playground是探索 Prisma API 的最好工具. 使用prisma playground可以打开这个工具 Conceptsdata model 和 Prisma database schema高级概念12345type Post &#123; id: ID! @unique title: String! published: Boolean @default(value: \"false\")&#125; Retrive a single node by its email 1234567query &#123; post(where: &#123; email: \"hello@graph.cool\" &#125;) &#123; id &#125;&#125; update single node title 123456789101112mutation &#123; updatePost( where: &#123; id: \"ohco0iewee6eizidohwigheif\" &#125; data: &#123;//⛔️这里注意这个 data title: \"GraphQL is awesome\" &#125; ) &#123; id &#125;&#125; 立刻更新多个 node 的published 123456789101112mutation &#123; updatePost( where: &#123; id_in: [\"ohco0iewee6eizidohwigheif\", \"phah4ooqueengij0kan4sahlo\", \"chae8keizohmiothuewuvahpa\"] &#125; data: &#123; published: true &#125; ) &#123; count &#125;&#125; connectionsconnections基于的是 Relay connection model.除了提供分页信息,还提供诸如 aggregation 等信息 1234567891011121314query &#123; postsConnection &#123; # `aggregate` allows to perform common aggregation operations aggregate &#123; count &#125; edges &#123; # each `node` refers to a single `Post` element node &#123; title &#125; &#125; &#125;&#125; 认证token:在发送 query 和 mutation 时要在 http header 中 添加 token Error handling有两种错误: Application error: 表示请求无效 Internal server errors: 通常意味着 Prisma的服务有问题. 查看服务日志可以提供更多的信息. QueriesPrisma 提供两种查询 对象查询: 获取特定 type的单个或多个 node Connection 查询:提供高级特性 Hierarchical 查询: 跨关联获取数据 Query 参数: 允许过滤,排序, 分页等操作 Prisma API 都是基于 data model. 1234567891011121314151617181920type Post &#123; id: ID! @unique title: String! published: Boolean! author: User!&#125;type User &#123; id: ID! @unique age: Int email: String! @unique name: String! accessRole: AccessRole posts: [Post!]!&#125;enum AccessRole &#123; USER ADMIN&#125; 对象查询:123456query &#123; posts &#123; id title &#125;&#125; 使用 where 参数 123456789query &#123; post(where: &#123; id: \"cixnen24p33lo0143bexvr52n\" &#125;) &#123; id title published &#125;&#125; 获取 大于18岁的用户: 12345678query &#123; users(where: &#123; age_gt: 18 &#125;) &#123; id name &#125;&#125; 也可以跨关系查询, 获取Post作者年龄超过18岁的节点 1234567891011121314query &#123; posts(where: &#123; author: &#123; age_gt: 18 &#125; &#125;) &#123; id title author &#123; name age &#125; &#125;&#125; connections queries在特殊案例中要使用高级特性, 可以用 connection queries. 他们是 Relay connection 的扩展. Relay connections 的核心概念是提供 data graph 中edge 的 meta-information.例如 例如 edge 不仅提供对象的信息,还提供关联的cursor,可以借此实现强有力的分页功能. 我们使用postsConnectionquery 来获取所有的Posts nodes.同时也请求了每个 edge的cursor. 123456789101112# Fetch all postsquery &#123; postsConnection &#123; edges &#123; cursor node &#123; id title &#125; &#125; &#125;&#125; connection 查询也提供聚合方式 12345678910# Count all posts with a title containing 'GraphQL'query &#123; postsConnection(where: &#123; title_contains: \"GraphQL\" &#125;) &#123; aggregate &#123; count &#125; &#125;&#125; 跨关联查询数据datamodel 中可用的每个 relation 都在两个 model 中添加新的字段 如下,我们活儿特定的 User, 所有与之有关的 Post nodes, 123456789101112query &#123; user(where: &#123; id: \"cixnekqnu2ify0134ekw4pox8\" &#125;) &#123; id name posts &#123; id published &#125; &#125;&#125; Query 参数 使用orderBy对数据排序 使用where对查询的标量或者过滤器进行筛选 使用first,last,after和skip提供分页 通过字段进行排序orderBy:&lt;field&gt;_ASC,orderBy:&lt;field&gt;_DESC 根据标题升序排列所有的 Post node 1234567query &#123; posts(orderBy: title_ASC) &#123; id title published &#125;&#125; Filtering by value查询所有未出版的 Post: 123456789query &#123; posts(where: &#123; published: false &#125;) &#123; id title published &#125;&#125; 查询含有列表标题之一的所有 Post: 123456789query &#123; posts(where: &#123; title_in: [\"My biggest Adventure\", \"My latest Hobbies\"] &#125;) &#123; id title published &#125;&#125; Relation filters查询用户角色作者的所有 Post 123456789query &#123; posts(where: &#123; author: &#123; accessRole: USER &#125; &#125;) &#123; title &#125;&#125; 组合多个 过滤器使用 OR或者AND查询所有的已经出版的Post nodes, 并且标题在列表中 12345678910111213query &#123; posts(where: &#123; AND: [&#123; title_in: [\"My biggest Adventure\", \"My latest Hobbies\"] &#125;, &#123; published: true &#125;] &#125;) &#123; id title published &#125;&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"Primsa-YAML 配置文件","slug":"Prisma-yaml","date":"2018-02-19T08:05:43.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/02/19/Prisma-yaml/","link":"","permalink":"https://React-Apollo.github.io/2018/02/19/Prisma-yaml/","excerpt":"","text":"example每个 Prisma 服务包括一个配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# REQUIRED# `my-demo-app` is the name of this Prisma service.service: my-demo-app# REQUIRED# This service is based on the type definitions in the two files# `database/types.graphql` and `database/enums.graphql`datamodel: - database/types.graphql - database/enums.graphql# OPTIONAL# The service will be deployed to the `local` cluster.# Note that if you leave out this option, you will be# asked which cluster to deploy to, and your decision# will be persisted here.cluster: local# REQUIRED# This service will be deployed to the `dev` stage.stage: dev# OPTIONAL (default: false)# Whether authentication is required for this service# is based on the value of the `PRISMA_DISABLE_AUTH`# environment variable.disableAuth: $&#123;env:PRISMA_DISABLE_AUTH&#125;# OPTIONAL# If your Prisma service requires authentication, this is the secret for creating JWT tokens.secret: # OPTIONAL# Path where the full GraphQL schema will be written to# after deploying. Note that it is generated based on your# data model.schema: schemas/prisma.graphql# OPTIONAL# This service has one event subscription configured. The corresponding# subscription query is located in `database/subscriptions/welcomeEmail.graphql`.# When the subscription fires, the specified `webhook` is invoked via HTTP.subscriptions: sendWelcomeEmail: query: database/subscriptions/sendWelcomeEmail.graphql webhook: url: https://$&#123;self.custom:serverlessEndpoint&#125;/sendWelcomeEmail headers: Authorization: $&#123;env:MY_ENDPOINT_SECRET&#125;# OPTIONAL# Points to a `.graphql` file containing GraphQL operations that will be# executed when initially deploying a service.seed: import: database/seed.graphql# OPTIONAL# This service only defines one custom variable that's referenced in# the `webhook` of the `subscription`custom: serverlessEndpoint: https://bcdeaxokbj.execute-api.eu-west-1.amazonaws.com/dev 文件结构如下: 123456789.├── prisma.yml├── database│ ├── subscriptions│ │ └── welcomeEmail.graphql│ ├── types.graphql│ └── enums.graphql└── schemas └── prisma.graphql YAML 文件结构/Applications/Chromium.app/Contents/MacOS/Chromium","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"Prisma DataModel","slug":"Prisma Data Model","date":"2018-02-17T21:34:38.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/02/17/Prisma Data Model/","link":"","permalink":"https://React-Apollo.github.io/2018/02/17/Prisma Data Model/","excerpt":"","text":"alias: eiroozae8u description: An overview of how to design data models with Prisma. Data ModellingOverviewPrisma uses the GraphQL Schema Definition Language (SDL) for data modeling. Your data model is written in one or more .graphql-files and is the foundation for the actual database schema that Prisma generates under the hood. If you’re using just a single file for your type definitions, this file is typically called datamodel.graphql. To learn more about the SDL, you can check out the official GraphQL documentation. The .graphql-files containing the data model need to be specified in prisma.yml under the datamodel property. For example: 123datamodel: - types.graphql - enums.graphql If there is only a single file that defines the data model, it can be specified as follows: 1datamodel: datamodel.graphql The data model is the foundation for the GraphQL API of your Prisma service. Based on the data model, Prisma will generate a powerful GraphQL schema (called Prisma database schema) which defines CRUD operations for the types in the data model. A GraphQL schema defines the operations of a GraphQL API. It effectively is a collection of types written in SDL (the SDL also supports primitives like interfaces, enums, union types and more, you can learn everything about GraphQL’s type system here). A GraphQL schema has three special root types: Query, Mutation and Subscription. These types define the entry points for the API and define what operations the API will accept. To learn more about GraphQL schema, check out this article. ExampleA simple datamodel.graphql file: 123456789101112131415161718192021type Tweet &#123; id: ID! @unique createdAt: DateTime! text: String! owner: User! location: Location!&#125;type User &#123; id: ID! @unique createdAt: DateTime! updatedAt: DateTime! handle: String! @unique name: String tweets: [Tweet!]!&#125;type Location &#123; latitude: Float! longitude: Float!&#125; This example illustrates a few important concepts when working with your data model: The three types Tweet, User and Location are mapped to tables in the database. There is a bidirectional relation between User and Tweet There is a unidirectional relation from Tweet to Location Except for the name field on User, all fields are required in the data model (as indicated by the ! following the type). The id, createdAt and updatedAt fields are managed by Prisma and read-only in the exposed GraphQL API (meaning they can not be altered via mutations). Creating and updating your data model is as simple as writing a text file. Once you’re happy with your data model, you can apply the changes to your Prisma service by running prisma deploy: 1234567891011121314151617181920212223242526272829303132333435363738$ prisma deployChanges: Tweet (Type) + Created type `Tweet` + Created field `id` of type `GraphQLID!` + Created field `createdAt` of type `DateTime!` + Created field `text` of type `String!` + Created field `owner` of type `Relation!` + Created field `location` of type `Relation!` + Created field `updatedAt` of type `DateTime!` User (Type) + Created type `User` + Created field `id` of type `GraphQLID!` + Created field `createdAt` of type `DateTime!` + Created field `updatedAt` of type `DateTime!` + Created field `handle` of type `String!` + Created field `name` of type `String` + Created field `tweets` of type `[Relation!]!` Location (Type) + Created type `Location` + Created field `latitude` of type `Float!` + Created field `longitude` of type `Float!` + Created field `id` of type `GraphQLID!` + Created field `updatedAt` of type `DateTime!` + Created field `createdAt` of type `DateTime!` TweetToUser (Relation) + Created relation between Tweet and User LocationToTweet (Relation) + Created relation between Location and TweetApplying changes... (22/22)Applying changes... 0.4s Building blocks of the data modelThere are several available building blocks to shape your data model. Types consist of multiple fields and are used to group similar entities together. Each type in your data model is mapped to the database and CRUD operations are added to the GraphQL schema. Relations describe relationships between types. Interfaces are abstract types that include a certain set of fields which a type must include to implement the interface. Currently, interfaces cannot be user-defined, but there’s a pending feature request for advanced interface support. Special directives covering different use cases such as type constraints or cascading delete behaviour. The rest of this page describes these building blocks in more detail. Prisma database schema vs Data modelWhen starting out with GraphQL and Prisma, the amount of .graphql-files you’re working with can be confusing. Yet, it’s crucial to understand what the role of each of them is. In general, a .graphql-file can contain either of the following: GraphQL operations (i.e. queries, mutations or subscriptions) GraphQL type definitions in SDL In the context of distinguishing the Prisma database schema from the data model, only the latter is relevant! Note that not every .graphql-file that falls into the latter category is per se a valid GraphQL schema. As mentioned in the info box above, a GraphQL schema is characterised by the fact that it has three root types: Query, Mutation and Subscription in addition to any other types that are required for the API. Now, by that definition the data model is not actually a GraphQL schema, despite being a .graphql-file written in SDL. It lacks the root types and thus doesn’t actually define API operations! Prisma simply uses the data model as a handy tool for you to express what the data model looks like. As mentioned above, Prisma will then generate an actual GraphQL schema that contains the Query, Mutation and Subscription root types. This schema is typically stored inside your project as prisma.graphql and called the Prisma database schema. Note that you should never make any manual changes to this file! As an example, consider the following very simple data model: datamodel.graphql 1234type User &#123; id: ID! @uniue name: String!&#125; If you’re deploying this data model to your Prisma service, Prisma will generate the following Prisma database schema that defines the GraphQL API of your service: prisma.graphql 1234567891011121314type Query &#123; users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]! user(where: UserWhereUniqueInput!): User&#125;type Mutation &#123; createUser(data: UserCreateInput!): User! updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User deleteUser(where: UserWhereUniqueInput!): User&#125;type Subscription &#123; user(where: UserSubscriptionWhereInput): UserSubscriptionPayload&#125; Note that this is a simplified version of the generated schema, you can find the full schema here. If you’ve already looked into building your own GraphQL server based on Prisma, you might have come across another .graphql-file which is referred to as your application schema. This is another proper GraphQL schema (meaning it contains the Query, Mutation and Subscription root types) that defines the API exposed to your client applications. It uses the underlying Prisma GraphQL API as a “query engine” to actually run the queries, mutations and subscriptions against the database.A GraphQL server based on Prisma usually has two GraphQL APIs, think of them as two layers for your service:- Application layer: Defined by the application schema (here is where you implement business logic, authentication, integrate with 3rd-party services, etc)- Database layer: Defined by the Prisma database service Object typesAn object type (or short type) defines the structure for one concrete part of your data model. It is used to represents entities from your application domain. If you are familiar with SQL databases you can think of an object type as the schema for a table in your relational database. A type has a name and one or multiple fields. An instantiation of a type is called a node. This term refers to a node inside your data graph.Every type you define in your data model will be available as an analogous type in the generated Prisma database schema. Defining an object typeA object type is defined in the data model with the keyword type: 12345type Article &#123; id: ID! @unique text: String! isPublished: Boolean @default(value: &quot;false&quot;)&#125; The type defined above has the following properties: Name: Article Fields: id, text and isPublished (with the default value false) Generated API operations for typesThe types in your data model affect the available operations in the Prisma GraphQL API. For every type, queries allow you to fetch one or many nodes of that type mutations allow you to create, update or delete nodes of that type subscriptions allow you to get notified of changes to nodes of that type (i.e. new nodes are created or existing nodes are updated or deleted) FieldsFields are the building blocks of a type, giving a node its shape. Every field is referenced by its name and is either scalar or a relation field. Scalar typesStringA String holds text. This is the type you would use for a username, the content of a blog post or anything else that is best represented as text. Note: String values are currently limited to 256KB in size on the shared demo cluster. This limit can be increased on other clusters using the cluster configuration. In queries or mutations, String fields have to be specified using enclosing double quotes: string: &quot;some-string&quot;. IntegerAn Int is a number that cannot have decimals. Use this to store values such as the weight of an ingredient required for a recipe or the minimum age for an event. Note: Int values range from -2147483648 to 2147483647. In queries or mutations, Int fields have to be specified without any enclosing characters: int: 42. FloatA Float is a number that can have decimals. Use this to store values such as the price of an item in a store or the result of complex calculations. In queries or mutations, Float fields have to be specified without any enclosing characters and an optional decimal point: float: 42, float: 4.2. BooleanA Boolean can have the value true or false. This is useful to keep track of settings such as whether the user wants to receive an email newsletter or if a recipe is appropriate for vegetarians. In queries or mutations, Boolean fields have to be specified without any enclosing characters: boolean: true, boolean: false. DateTimeThe DateTime type can be used to store date or time values. A good example might be a person’s date of birth. In queries or mutations, DateTime fields have to be specified in ISO 8601 format with enclosing double quotes: datatime: &quot;2015&quot; datatime: &quot;2015-11&quot; datatime: &quot;2015-11-22&quot; datetime: &quot;2015-11-22T13:57:31.123Z&quot;. EnumEnums are defined on a service scope. Like a Boolean an Enum can have one of a predefined set of values. The difference is that you can define the possible values. For example you could specify how an article should be formatted by creating an Enum with the possible values COMPACT, WIDE and COVER. Note: Enum values can at most be 191 characters long. In queries or mutations, Enum fields have to be specified without any enclosing characters. You can only use values that you defined for the enum: enum: COMPACT, enum: WIDE. JSONSometimes you need to store arbitrary JSON values for loosely structured data. The JSON type makes sure that it is actually valid Json and returns the value as a parsed Json object/array instead of a string. Note: Json values are currently limited to 256KB in size on the shared demo cluster. This limit can be increased on other clusters using the cluster configuration. In queries or mutations, Json fields have to be specified with enclosing double quotes. Special characters have to be escaped: json: &quot;{\\&quot;int\\&quot;: 1, \\&quot;string\\&quot;: \\&quot;value\\&quot;}&quot;. IDAn ID value is a generated unique 25-character string based on cuid. Fields with ID values are system fields and just used internally, therefore it is not possible to create new fields with the ID type. Type modifiersListScalar fields can be marked with the list field type. A field of a relation that has the many multiplicity will also be marked as a list. In queries or mutations, list fields have to be enclosed by square brackets, while the separate entries of the list adhere to the same formatting rules as lined out above: listString: [&quot;a string&quot;, &quot;another string&quot;], listInt: [12, 24]. RequiredFields can be marked as required (sometimes also referred to as “non-null”). When creating a new node, you need to supply a value for fields which are required and don’t have a default value. Required fields are marked using a ! after the field type: name: String!. Field constraintsFields can be configured with certain field constraints to add further semantics to your data model. UniqueSetting the unique constraint makes sure that two nodes of the type in question cannot have the same value for a certain field. The only exception is the null value, meaning that multiple nodes can have the value null without violating the constraint. A typical example would be an email field on the User type where the assumption is that every User should have a globally unique email address. Please note that only the first 191 characters in a String field are considered for uniqueness and the unique check is case insensitive. Storing two different strings is not possible if the first 191 characters are the same or if they only differ in casing. To mark a field as unique, simply append the @unique directive to it: 1234type User &#123; email: String! @unique age: Int!&#125; For every field that’s annotated with @unique, you’re able to query the corresponding node by providing a value for that field. For example, for the above data model, you can now retrieve a particular User node by its email address: 1234567query &#123; user(where: &#123; email: &quot;alice@graph.cool&quot; &#125;) &#123; age &#125;&#125; More constraintsMore database constraints will be added going forward according to this feature request. Default valueYou can set a default value for scalar fields. The value will be taken for new nodes when no value was supplied during creation. To specify a default value for a field, you can use the @default directive: 123456type Story &#123; isPublished: Boolean @default(value: &quot;false&quot;) someNumber: Int! @default(value: &quot;42&quot;) title: String! @default(value: &quot;My New Post&quot;) publishDate: DateTime! @default(value: &quot;2018-01-26&quot;)&#125; Notice that you need to always provide the value in double-quotes, even for non-string types such as Boolean or Int. System fieldsThe three fields id, createdAt and updatedAt have special meaning. They are optional in your data model, but will always be maintained in the underlying database. This way you can always add the field to your data model later, and the data will be available for existing nodes. The values of these fields are currently read-only in the GraphQL API (except when importing data) but will be made configurable in the future. See this proposal for more information. Notice that you cannot have custom fields that are called id, createdAt and updatedAt since these field names are reserved for the system fields. Here are the only supported declarations for these three fields: id: ID! @unique createdAt: DateTime!* updatedAt: DateTime! System field: idA node will automatically get assigned a globally unique identifier when it’s created, this identifier is stored in the id field. Whenever you add the id field to a type definition to expose it in the GraphQL API, you must annotate it with the @unique directive. The id has the following properties: Consists of 25 alphanumeric characters (letters are always lowercase) Always starts with a (lowercase) letter c Follows cuid (collision resistant unique identifiers) scheme Notice that all your object types will implement the Node interface in the database schema. This is what the Node interface looks like: 123interface Node &#123; id: ID! @unique&#125; System fields: createdAt and updatedAtThe data model further provides two special fields which you can add to your types: createdAt: DateTime!: Stores the exact date and time for when a node of this object type was created. updatedAt: DateTime!: Stores the exact date and time for when a node of this object type was last updated. If you want your types to expose these fields, you can simply add them to the type definition, for example: 12345type User &#123; id: ID! @unique createdAt: DateTime! updatedAt: DateTime!&#125; Generated API operations for fieldsFields in the data model affect the available query arguments. RelationsA relation defines the semantics of a connection between two types. Two types in a relation are connected via a relation field. When a relation might be ambiguous, the relation field needs to be annotated with the @relation directive to disambiguate it. A relation can also connect a type with itself. It is then referred to as a self-relation. Required relationsFor a to-one relation field, you can configure whether it is required or optional. The required flag acts as a contract in GraphQL that this field can never be null. A field for the address of a user would therefore be of type Address or Address!. Nodes for a type that contains a required to-one relation field can only be created using a nested mutation to ensure the according field will not be null. Note that a to-many relation field is always set to required. For example, a field that contains many user addresses always uses the type [Address!]! and can never be of type [Address!]. The reason is that in case the field doesn’t contain any nodes, [] will be returned, which is not null. The @relation directiveWhen defining relations between types, there is the @relation directive which provides meta-information about the relation. It can take two arguments: name: An identifier for this relation (provided as a string). This argument is only required if relations are ambiguous. Note that the name argument is required every time you’re using the @relation directive. onDelete: Specifies the deletion behaviour and enables cascading deletes. In case a node with related nodes gets deleted, the deletion behaviour determines what should happen to the related nodes. The input values for this argument are defined as an enum with the following possible values: SET_NULL (default): Set the related node(s) to null. CASCADE: Delete the related node(s). Note that is not possible to set both ends of a bidirectional relation to CASCADE. Note: Here is an example of a data model where the @relation directive is used: 12345678910type User &#123; id: ID! @unique stories: [Story!]! @relation(name: &quot;StoriesByUser&quot; onDelete: CASCADE)&#125;type Story &#123; id: ID! @unique text: String! author: User @relation(name: &quot;StoriesByUser&quot;)&#125; The deletion behaviour in this example is as follows: When a User node gets deleted, all its related Story nodes will be deleted as well. When a Story node gets deleted, it will simply be removed from the stories list on the related User node. Omitting the @relation directiveIn the simplest case, where a relation between two types is unambiguous and the default deletion behaviour (SET_NULL) should be applied, the corresponding relation fields do not have to be annotated with the @relation directive. Here we are defining a bidirectional one-to-many relation between the User and Story types. Since onDelete has not been provided, the default deletion behaviour is used: SET_NULL: 12345678910type User &#123; id: ID! @unique stories: [Story!]!&#125;type Story &#123; id: ID! @unique text: String! author: User&#125; The deletion behaviour in this example is as follows: When a User node gets deleted, the author field on all its related Story nodes will be set to null. Note that if the author field was marked as required, the operation would result in an error. When a Story node gets deleted, it will simply be removed from the stories list on the related User node. Using the name argument of the @relation directiveIn certain cases, your data model may contain ambiguous relations. For example, consider you not only want a relation to express the “author-relationship” between User and Story, but you also want a relation to express which Story nodes have been liked by a User. In that case, you end up with two different relations between User and Story! In order to disambiguate them, you need to give the relation a name: 123456789101112type User &#123; id: ID! @unique writtenStories: [Story!]! @relation(name: &quot;WrittenStories&quot;) likedStories: [Story!]! @relation(name: &quot;LikedStories&quot;)&#125;type Story &#123; id: ID! @unique text: String! author: User! @relation(name: &quot;WrittenStories&quot;) likedBy: [User!]! @relation(name: &quot;LikedStories&quot;)&#125; If the name wasn’t provided in this case, there would be no way to decide whether writtenStories should relate to the author or the likedBy field. Using the onDelete argument of the @relation directiveAs mentioned above, you can specify a dedicated deletion behaviour for the related nodes. That’s what the onDelete argument of the @relation directive is for. Consider the following example: 1234567891011121314151617type User &#123; id: ID! @unique comments: [Comment!]! @relation(name: &quot;CommentAuthor&quot;, onDelete: CASCADE) blog: Blog @relation(name: &quot;BlogOwner&quot;, onDelete: CASCADE)&#125;type Blog &#123; id: ID! @unique comments: [Comment!]! @relation(name: &quot;Comments&quot;, onDelete: CASCADE) owner: User! @relation(name: &quot;BlogOwner&quot;, onDelete: SET_NULL)&#125;type Comment &#123; id: ID! @unique blog: Blog! @relation(name: &quot;Comments&quot;, onDelete: SET_NULL) author: User @relation(name: &quot;CommentAuthor&quot;, onDelete: SET_NULL)&#125; Let’s investigate the deletion behaviour for the three types: When a User node gets deleted, all related Comment nodes will be deleted. the related Blog node will be deleted. When a Blog node gets deleted, all related Comment nodes will be deleted. the related User node will have its blog field set to null. When a Comment node gets deleted, the related Blog node continues to exist and the deleted Comment node is removed from its comments list. the related User node continues to exist and the deleted Comment node is removed from its comments list. Generated API operations for relationsThe relations that are included in your schema affect the available operations in the GraphQL API. For every relation, relation queries allow you to query data across types or aggregated for a relation (note that this is also possible using Relay‘s connection model) nested mutations allow you to create, connect, update, upsert and delete nodes across types relation subscriptions allow you to get notified of changes to a relation GraphQL directivesDirectives are used to provide additional information in your data model. They look like this: @name(argument: &quot;value&quot;) or simply @name when there are no arguments. Data model directivesData model directives describe additional information about types or fields in the GraphQL schema. Unique scalar fieldsThe @unique directive marks a scalar field as unique. Unique fields will have a unique index applied in the underlying database. 1234# the `User` type has a unique `email` fieldtype User &#123; email: String @unique&#125; Find more info about the @unique directive above. Relation fieldsThe directive @relation(name: String, onDelete: ON_DELETE! = NO_ACTION) can be attached to a relation field. See above for more information. Default value for scalar fieldsThe directive @default(value: String!) sets a default value for a scalar field. Note that the value argument is of type String for all scalar fields (even if the fields themselves are not strings): 123456# the `title`, `published` and `someNumber` fields have default values `New Post`, `false` and `42`type Post &#123; title: String! @default(value: &quot;New Post&quot;) published: Boolean! @default(value: &quot;false&quot;) someNumber: Int! @default(value: &quot;42&quot;)&#125; Temporary directivesTemporary directives are used to perform one-time migration operations. After deploying a service that contain a temporary directive, it needs to be manually removed from the type definitions file. Renaming a type or fieldThe temporary directive @rename(oldName: String!) is used to rename a type or field. 1234# renaming the `Post` type to `Story`, and its `text` field to `content`type Story @rename(oldName: &quot;Post&quot;) &#123; content: String @rename(oldName: &quot;text&quot;)&#125; If the rename directive is not used, Prisma would remove the old type and field before creating the new one, resulting in loss of data! Migrating the value of a scalar fieldThe temporary directive @migrationValue(value: String!) is used to migrate the value of a scalar field. When changing an optional field to a required field, it is necessary to also use this directive. Naming conventionsDifferent objects you encounter in a Prisma service like types or relations follow separate naming conventions to help you distinguish them. TypesThe type name determines the name of derived queries and mutations as well as the argument names for nested mutations. Type names can only contain alphanumeric characters and need to start with an uppercase letter. They can contain at most 64 characters. It’s recommended to choose type names in the singular form. Type names are unique on a service level. Examples Post PostCategory Scalar and relation fieldsThe name of a scalar field is used in queries and in query arguments of mutations. Field names can only contain alphanumeric characters and need to start with a lowercase letter. They can contain at most 64 characters. The name of relation fields follows the same conventions and determines the argument names for relation mutations. It’s recommended to only choose plural names for list fields. Field names are unique on a type level. Examples name email categoryTags RelationsRelation names can only contain alphanumeric characters and need to start with an uppercase letter. They can contain at most 64 characters. Relation names are unique on a service level. Examples UserOnPost, UserPosts or PostAuthor, with field names user and posts Appointments, EmployeeOnAppointment or AppointmentEmployee, with field names employee and appointments EnumsEnum values can only contain alphanumeric characters and underscores and need to start with an uppercase letter. The name of an enum value can be used in query filters and mutations. They can contain at most 191 characters. Enum names are unique on a service level. Enum value names are unique on an enum level. Examples A ROLE_TAG RoleTag More SDL featuresIn this section, we describe further SDL features that are not yet supported for data modelling with Prisma. Interfaces“Like many type systems, GraphQL supports interfaces. An interface is an abstract type that includes a certain set of fields that a type must include to implement the interface.” From the official GraphQL Documentation Note: To learn more about when and how interfaces are coming to Prisma, check out this feature request. Interfaces“Like many type systems, GraphQL supports interfaces. An interface is an abstract type that includes a certain set of fields that a type must include to implement the interface.” From the official GraphQL Documentation Note: To learn more about when and how interfaces are coming to Prisma, check out this feature request. Union types“Union types are very similar to interfaces, but they don’t get to specify any common fields between the types.” From the official GraphQL Documentation Note: To learn more about when and how union types are coming to Prisma, check out this feature request.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"Readme|Reactpattern","slug":"Readme|React-pattern","date":"2018-02-17T13:29:04.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/02/17/Readme|React-pattern/","link":"","permalink":"https://React-Apollo.github.io/2018/02/17/Readme|React-pattern/","excerpt":"","text":"原文在reactpattern这个Readme 来的正是时候. Contents Stateless function JSX spread attributes Destructuring arguments Conditional rendering Children types Array as children Function as children Render callback Children pass-through Proxy component Style component Event switch Layout component Container component Higher-order component State hoisting Controlled input Stateless functionStateless functions are a brilliant way to define highly reusable components. They don’t hold state; they’re just functions. 1const Greeting = () =&gt; &lt;div&gt;Hi there!&lt;/div&gt; They get passed props and context. 12const Greeting = (props, context) =&gt; &lt;div style=&#123;&#123;color: context.color&#125;&#125;&gt;Hi &#123;props.name&#125;!&lt;/div&gt; They can define local variables, where a function block is used. 12345678const Greeting = (props, context) =&gt; &#123; const style = &#123; fontWeight: \"bold\", color: context.color, &#125; return &lt;div style=&#123;style&#125;&gt;&#123;props.name&#125;&lt;/div&gt;&#125; But you could get the same result by using other functions. 1234567const getStyle = context =&gt; (&#123; fontWeight: \"bold\", color: context.color,&#125;)const Greeting = (props, context) =&gt; &lt;div style=&#123;getStyle(context)&#125;&gt;&#123;props.name&#125;&lt;/div&gt; They can have defined defaultProps, propTypes and contextTypes. 123456789Greeting.propTypes = &#123; name: PropTypes.string.isRequired&#125;Greeting.defaultProps = &#123; name: \"Guest\"&#125;Greeting.contextTypes = &#123; color: PropTypes.string&#125; JSX spread attributesSpread Attributes is a JSX feature. It’s syntactic sugar for passing all of an object’s properties as JSX attributes. These two examples are equivalent.12345// props written as attributes&lt;main className=\"main\" role=\"main\"&gt;&#123;children&#125;&lt;/main&gt;// props \"spread\" from object&lt;main &#123;...&#123;className: \"main\", role: \"main\", children&#125;&#125; /&gt; Use this to forward props to underlying components. 12const FancyDiv = props =&gt; &lt;div className=\"fancy\" &#123;...props&#125; /&gt; Now, I can expect FancyDiv to add the attributes it’s concerned with as well as those it’s not. 123&lt;FancyDiv data-id=\"my-fancy-div\"&gt;So Fancy&lt;/FancyDiv&gt;// output: &lt;div className=\"fancy\" data-id=\"my-fancy-div\"&gt;So Fancy&lt;/div&gt; Keep in mind that order matters. If props.className is defined, it’ll clobber the className defined by FancyDiv 123&lt;FancyDiv className=\"my-fancy-div\" /&gt;// output: &lt;div className=\"my-fancy-div\"&gt;&lt;/div&gt; We can make FancyDivs className always “win” by placing it after the spread props ({...props}). 123// my `className` clobbers your `className`const FancyDiv = props =&gt; &lt;div &#123;...props&#125; className=\"fancy\" /&gt; You should handle these types of props gracefully. In this case, I’ll merge the author’s props.className with the className needed to style my component. 12345const FancyDiv = (&#123; className, ...props &#125;) =&gt; &lt;div className=&#123;[\"fancy\", className].join(' ')&#125; &#123;...props&#125; /&gt; destructuring argumentsDestructuring assignment is an ES2015 feature. It pairs nicely with props in Stateless Functions. These examples are equivalent.123const Greeting = props =&gt; &lt;div&gt;Hi &#123;props.name&#125;!&lt;/div&gt;const Greeting = (&#123; name &#125;) =&gt; &lt;div&gt;Hi &#123;name&#125;!&lt;/div&gt; The rest parameter syntax (...) allows you to collect all the remaining properties in a new object. 12const Greeting = (&#123; name, ...props &#125;) =&gt; &lt;div&gt;Hi &#123;name&#125;!&lt;/div&gt; In turn, this object can use JSX Spread Attributes to forward props to the composed component. 12const Greeting = (&#123; name, ...props &#125;) =&gt; &lt;div &#123;...props&#125;&gt;Hi &#123;name&#125;!&lt;/div&gt; Avoid forwarding non-DOM props to composed components. Destructuring makes this very easy because you can create a new props object without component-specific props. conditional renderingYou can’t use regular if/else conditions inside a component definition. The conditional (ternary) operator is your friend. if 1&#123;condition &amp;&amp; &lt;span&gt;Rendered when `truthy`&lt;/span&gt; &#125; unless 1&#123;condition || &lt;span&gt;Rendered when `falsey`&lt;/span&gt; &#125; if-else (tidy one-liners) 1234&#123;condition ? &lt;span&gt;Rendered when `truthy`&lt;/span&gt; : &lt;span&gt;Rendered when `falsey`&lt;/span&gt;&#125; if-else (big blocks) 123456789&#123;condition ? ( &lt;span&gt; Rendered when `truthy` &lt;/span&gt;) : ( &lt;span&gt; Rendered when `falsey` &lt;/span&gt;)&#125; Children typesReact can render children of many types. In most cases it’s either an array or a string. string 123&lt;div&gt; Hello World!&lt;/div&gt; array 123&lt;div&gt; &#123;[\"Hello \", &lt;span&gt;World&lt;/span&gt;, \"!\"]&#125;&lt;/div&gt; Functions may be used as children. However, it requires coordination with the parent component to be useful. function 123&lt;div&gt; &#123;(() =&gt; &#123; return \"hello world!\"&#125;)()&#125;&lt;/div&gt; Array as childrenProviding an array as children is a very common. It’s how lists are drawn in React. We use map() to create an array of React Elements for every value in the array. 12345&lt;ul&gt; &#123;[\"first\", \"second\"].map((item) =&gt; ( &lt;li&gt;&#123;item&#125;&lt;/li&gt; ))&#125;&lt;/ul&gt; That’s equivalent to providing a literal array. 123456&lt;ul&gt; &#123;[ &lt;li&gt;first&lt;/li&gt;, &lt;li&gt;second&lt;/li&gt;, ]&#125;&lt;/ul&gt; This pattern can be combined with destructuring, JSX Spread Attributes, and other components, for some serious terseness. 12345&lt;ul&gt; &#123;arrayOfMessageObjects.map((&#123; id, ...message &#125;) =&gt; &lt;Message key=&#123;id&#125; &#123;...message&#125; /&gt; )&#125;&lt;/ul&gt; Function as childrenUsing a function as children isn’t inherently useful. 1&lt;div&gt;&#123;() =&gt; &#123; return \"hello world!\"&#125;()&#125;&lt;/div&gt; However, it can be used in component authoring for some serious power. This technique is commonly referred to as render callbacks. This is a powerful technique used by libraries like ReactMotion. When applied, rendering logic can be kept in the owner component, instead of being delegated. See Render callbacks, for more details. Render callbackHere’s a component that uses a Render callback. It’s not useful, but it’s an easy illustration to start with. 1const Width = (&#123; children &#125;) =&gt; children(500) The component calls children as a function, with some number of arguments. Here, it’s the number 500. To use this component, we give it a function as children. 123&lt;Width&gt; &#123;width =&gt; &lt;div&gt;window is &#123;width&#125;&lt;/div&gt;&#125;&lt;/Width&gt; We get this output. 1&lt;div&gt;window is 500&lt;/div&gt; With this setup, we can use this width to make rendering decisions. 1234567&lt;Width&gt; &#123;width =&gt; width &gt; 600 ? &lt;div&gt;min-width requirement met!&lt;/div&gt; : null &#125;&lt;/Width&gt; If we plan to use this condition a lot, we can define another components to encapsulate the reused logic. 12345678const MinWidth = (&#123; width: minWidth, children &#125;) =&gt; &lt;Width&gt; &#123;width =&gt; width &gt; minWidth ? children : null &#125; &lt;/Width&gt; Obviously a static Width component isn’t useful but one that watches the browser window is. Here’s a sample implementation. 123456789101112131415161718192021class WindowWidth extends React.Component &#123; constructor() &#123; super() this.state = &#123; width: 0 &#125; &#125; componentDidMount() &#123; this.setState( &#123;width: window.innerWidth&#125;, window.addEventListener( \"resize\", (&#123; target &#125;) =&gt; this.setState(&#123;width: target.innerWidth&#125;) ) ) &#125; render() &#123; return this.props.children(this.state.width) &#125;&#125; Many developers favor Higher Order Components for this type of functionality. It’s a matter of preference. Children pass-throughYou might create a component designed to apply context and render its children. 123456789class SomeContextProvider extends React.Component &#123; getChildContext() &#123; return &#123;some: \"context\"&#125; &#125; render() &#123; // how best do we return `children`? &#125;&#125; You’re faced with a decision. Wrap children in an extraneous &lt;div /&gt; or return children directly. The first options gives you extra markup (which can break some stylesheets). The second will result in unhelpful errors. 12345// option 1: extra divreturn &lt;div&gt;&#123;children&#125;&lt;/div&gt;// option 2: unhelpful errorsreturn children It’s best to treat children as an opaque data type. React provides React.Children for dealing with children appropriately. 1return React.Children.only(this.props.children) Proxy component(I’m not sure if this name makes sense) Buttons are everywhere in web apps. And every one of them must have the type attribute set to “button”. 1&lt;button type=\"button\"&gt; Writing this attribute hundreds of times is error prone. We can write a higher level component to proxy props to a lower-level button component. 12const Button = props =&gt; &lt;button type=\"button\" &#123;...props&#125;&gt; We can use Button in place of button and ensure that the type attribute is consistently applied everywhere. 12345&lt;Button /&gt;// &lt;button type=\"button\"&gt;&lt;button&gt;&lt;Button className=\"CTA\"&gt;Send Money&lt;/Button&gt;// &lt;button type=\"button\" class=\"CTA\"&gt;Send Money&lt;/button&gt; Style componentThis is a Proxy component applied to the practices of style. Say we have a button. It uses classes to be styled as a “primary” button. 1&lt;button type=\"button\" className=\"btn btn-primary\"&gt; We can generate this output using a couple single-purpose components. 123456789101112131415import classnames from 'classnames'const PrimaryBtn = props =&gt; &lt;Btn &#123;...props&#125; primary /&gt;const Btn = (&#123; className, primary, ...props &#125;) =&gt; &lt;button type=\"button\" className=&#123;classnames( \"btn\", primary &amp;&amp; \"btn-primary\", className )&#125; &#123;...props&#125; /&gt; It can help to visualize this. 1234PrimaryBtn() ↳ Btn(&#123;primary: true&#125;) ↳ Button(&#123;className: \"btn btn-primary\"&#125;, type: \"button\"&#125;) ↳ '&lt;button type=\"button\" class=\"btn btn-primary\"&gt;&lt;/button&gt;' Using these components, all of these result in the same output.123&lt;PrimaryBtn /&gt;&lt;Btn primary /&gt;&lt;button type=\"button\" className=\"btn btn-primary\" /&gt; This can be a huge boon to style maintenance. It isolates all concerns of style to a single component. Event switchWhen writing event handlers it’s common to adopt the handle{eventName} naming convention. 1handleClick(e) &#123; /* do something */ &#125; For components that handle several event types, these function names can be repetitive. The names themselves might not provide much value, as they simply proxy to other actions/functions. 123handleClick() &#123; require(\"./actions/doStuff\")(/* action stuff */) &#125;handleMouseEnter() &#123; this.setState(&#123; hovered: true &#125;) &#125;handleMouseLeave() &#123; this.setState(&#123; hovered: false &#125;) &#125; Consider writing a single event handler for your component and switching on event.type. 123456789101112handleEvent(&#123;type&#125;) &#123; switch(type) &#123; case \"click\": return require(\"./actions/doStuff\")(/* action dates */) case \"mouseenter\": return this.setState(&#123; hovered: true &#125;) case \"mouseleave\": return this.setState(&#123; hovered: false &#125;) default: return console.warn(`No case for event type \"$&#123;type&#125;\"`) &#125;&#125; Alternatively, for simple components, you can call imported actions/functions directly from components, using arrow functions. 1&lt;div onClick=&#123;() =&gt; someImportedAction(&#123; action: \"DO_STUFF\" &#125;)&#125; Don’t fret about performance optimizations until you have problems. Seriously don’t. Layout componentLayout components result in some form of static DOM element. It might not need to update frequently, if ever. Consider a component that renders two children side-by-side. 1234&lt;HorizontalSplit leftSide=&#123;&lt;SomeSmartComponent /&gt;&#125; rightSide=&#123;&lt;AnotherSmartComponent /&gt;&#125;/&gt; We can aggressively optimize this component. While HorizontalSplit will be parent to both components, it will never be their owner. We can tell it to update never, without interrupting the lifecycle of the components inside. 123456789101112class HorizontalSplit extends React.Component &#123; shouldComponentUpdate() &#123; return false &#125; render() &#123; &lt;FlexContainer&gt; &lt;div&gt;&#123;this.props.leftSide&#125;&lt;/div&gt; &lt;div&gt;&#123;this.props.rightSide&#125;&lt;/div&gt; &lt;/FlexContainer&gt; &#125;&#125; Container component“A container does data fetching and then renders its corresponding sub-component. That’s it.”&mdash;Jason Bonta Given this reusable CommentList component. 123456const CommentList = (&#123; comments &#125;) =&gt; &lt;ul&gt; &#123;comments.map(comment =&gt; &lt;li&gt;&#123;comment.body&#125;-&#123;comment.author&#125;&lt;/li&gt; )&#125; &lt;/ul&gt; We can create a new component responsible for fetching data and rendering the stateless CommentList component. 12345678910111213141516171819class CommentListContainer extends React.Component &#123; constructor() &#123; super() this.state = &#123; comments: [] &#125; &#125; componentDidMount() &#123; $.ajax(&#123; url: \"/my-comments.json\", dataType: 'json', success: comments =&gt; this.setState(&#123;comments: comments&#125;); &#125;) &#125; render() &#123; return &lt;CommentList comments=&#123;this.state.comments&#125; /&gt; &#125;&#125; We can write different containers for different application contexts. Higher-order componentA higher-order function is a function that takes and/or returns a function. It’s not more complicated than that. So, what’s a higher-order component? If you’re already using container components, these are just generic containers, wrapped up in a function. Let’s start with our stateless Greeting component. 12345const Greeting = (&#123; name &#125;) =&gt; &#123; if (!name) &#123; return &lt;div&gt;Connecting...&lt;/div&gt; &#125; return &lt;div&gt;Hi &#123;name&#125;!&lt;/div&gt;&#125; If it gets props.name, it’s gonna render that data. Otherwise it’ll say that it’s “Connecting…”. Now for the the higher-order bit. 123456789101112131415161718192021const Connect = ComposedComponent =&gt; class extends React.Component &#123; constructor() &#123; super() this.state = &#123; name: \"\" &#125; &#125; componentDidMount() &#123; // this would fetch or connect to a store this.setState(&#123; name: \"Michael\" &#125;) &#125; render() &#123; return ( &lt;ComposedComponent &#123;...this.props&#125; name=&#123;this.state.name&#125; /&gt; ) &#125; &#125; This is just a function that returns component that renders the component we passed as an argument. Last step, we need to wrap our our Greeting component in Connect. 1const ConnectedMyComponent = Connect(Greeting) This is a powerful pattern for providing fetching and providing data to any number of stateless function components. State hoistingStateless functions don’t hold state (as the name implies). Events are changes in state.Their data needs to be passed to stateful container components parents. This is called “state hoisting”.It’s accomplished by passing a callback from a container component to a child component. 12345678class NameContainer extends React.Component &#123; render() &#123; return &lt;Name onChange=&#123;newName =&gt; alert(newName)&#125; /&gt; &#125;&#125;const Name = (&#123; onChange &#125;) =&gt; &lt;input onChange=&#123;e =&gt; onChange(e.target.value)&#125; /&gt; Name receives an onChange callback from NameContainer and calls on events. The alert above makes for a terse demo but it’s not changing state.Let’s change the internal state of NameContainer. 12345678910class NameContainer extends React.Component &#123; constructor() &#123; super() this.state = &#123;name: \"\"&#125; &#125; render() &#123; return &lt;Name onChange=&#123;newName =&gt; this.setState(&#123;name: newName&#125;)&#125; /&gt; &#125;&#125; The state is hoisted to the container, by the provided callback, where it’s used to update local state.This sets a nice clear boundary and maximizes the re-usability of stateless function. This pattern isn’t limited to stateless functions.Because stateless function don’t have lifecycle events,you’ll use this pattern with component classes as well. Controlled input is an important pattern to know for use with state hoisting (It’s best to process the event object on the stateful component) Controlled inputIt’s hard to talk about controlled inputs in the abstract.Let’s start with an uncontrolled (normal) input and go from there. 1&lt;input type=\"text\" /&gt; When you fiddle with this input in the browser, you see your changes.This is normal. A controlled input disallows the DOM mutations that make this possible.You set the value of the input in component-land and it doesn’t change in DOM-land. 1&lt;input type=\"text\" value=\"This won't change. Try it.\" /&gt; Obviously static inputs aren’t very useful to your users.So, we derive a value from state. 12345678910class ControlledNameInput extends React.Component &#123; constructor() &#123; super() this.state = &#123;name: \"\"&#125; &#125; render() &#123; return &lt;input type=\"text\" value=&#123;this.state.name&#125; /&gt; &#125;&#125; Then, changing the input is a matter of changing component state. 123456return ( &lt;input value=&#123;this.state.name&#125; onChange=&#123;e =&gt; this.setState(&#123; name: e.target.value &#125;)&#125; /&gt;) This is a controlled input.It only updates the DOM when state has changed in our component.This is invaluable when creating consistent UIs. If you’re using stateless functions for form elements,read about using state hoisting to move new state up the component tree.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"pattern","slug":"pattern","permalink":"https://React-Apollo.github.io/tags/pattern/"}]},{"title":"摘要|React Higher Order Components in depth","slug":"摘要|React Higher Order Components in depth","date":"2018-02-13T23:32:45.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/02/13/摘要|React Higher Order Components in depth/","link":"","permalink":"https://React-Apollo.github.io/2018/02/13/摘要|React Higher Order Components in depth/","excerpt":"","text":"原文在React Higher Order Components in depth 已经有了中文版的翻译, 只做摘要 什么是高阶组件 HOC? HOC是包装另一个组件的 React 组件 通常是一个函数,作为类工厂,1hocFactory:: W: React.Component =&gt; E: React.Component “wrap”部分: Props 代理: HOC负责操作传递给包装组件W 的 props. HOC 扩展了 W的功能 HOC可以做什么 代码重用,逻辑抽象和 bootstrap 式的抽象(一般-&gt;特殊的样式定义) 渲染劫持 State抽象和操作 Props 操作 HOC 工厂的实现讨论一下 props 代理和继承反转(Inheritance Inversion) Props Proxy1234567function ppHOC(WrappedComponent) &#123; return class PP extends React.Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125;/&gt; &#125; &#125;&#125; 通过 Props 代理可以做的事情 操控 props 通过 Refs 访问实例 抽象 State 用其他的元素包装组件 操控 props可以在 props 传递给包装组件之前,对 props 做出 read,add, edit和 remove 操作,例如添加 props 12345678910function ppHOC(WrappedComponent) &#123; return class PP extends React.Component &#123; render() &#123; const newProps = &#123; user: currentLoggedInUser &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125;/&gt; &#125; &#125;&#125; 通过 Refs 访问实例可以通过 this 关键字访问包装的组件 例如 123456789101112function refsHOC(WrappedComponent) &#123; return class RefsHOC extends React.Component &#123; proc(wrappedComponentInstance) &#123; wrappedComponentInstance.method() &#125; render() &#123; const props = Object.assign(&#123;&#125;, this.props, &#123;ref: this.proc.bind(this)&#125;) return &lt;WrappedComponent &#123;...props&#125;/&gt; &#125; &#125;&#125; state 抽象可以通过给包装组件提供 props 和 回调函数来抽象出 state实例是 smart component 处理 dumb component 1234567891011121314151617181920212223242526function ppHOC(WrappedComponent) &#123; return class PP extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; name: '' &#125; this.onNameChange = this.onNameChange.bind(this) &#125; onNameChange(event) &#123; this.setState(&#123; name: event.target.value &#125;) &#125; render() &#123; const newProps = &#123; name: &#123; value: this.state.name, onChange: this.onNameChange &#125; &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125;/&gt; &#125; &#125;&#125; 使用方法如下: 123456@ppHOCclass Example extends React.Component &#123; render() &#123; return &lt;input name=\"name\" &#123;...this.props.name&#125;/&gt; &#125;&#125; 通过抽象 state, 把包装组件和 props,method 就分离开了 可以用其他的元素包裹包装组件例如可以提供样式 1234567891011function ppHOC(WrappedComponent) &#123; return class PP extends React.Component &#123; render() &#123; return ( &lt;div style=&#123;&#123;display: 'block'&#125;&#125;&gt; &lt;WrappedComponent &#123;...this.props&#125;/&gt; &lt;/div&gt; ) &#125; &#125;&#125; 继承反转这个没看懂1234567function iiHOC(WrappedComponent) &#123; return class Enhancer extends WrappedComponent &#123; render() &#123; return super.render() &#125; &#125;&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"hoc","slug":"hoc","permalink":"https://React-Apollo.github.io/tags/hoc/"},{"name":"fp","slug":"fp","permalink":"https://React-Apollo.github.io/tags/fp/"}]},{"title":"FlowType cheatsheet","slug":"FlowType cheatsheet","date":"2018-02-13T10:44:12.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/02/13/FlowType cheatsheet/","link":"","permalink":"https://React-Apollo.github.io/2018/02/13/FlowType cheatsheet/","excerpt":"","text":"","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"cheatsheet","slug":"cheatsheet","permalink":"https://React-Apollo.github.io/tags/cheatsheet/"},{"name":"flowtype","slug":"flowtype","permalink":"https://React-Apollo.github.io/tags/flowtype/"}]},{"title":"摘要|Why use static types in JavaScript? (A 4-part primer on static typing with Flow)","slug":"摘要|Why use static types in JavaScript?","date":"2018-02-12T20:48:38.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/02/12/摘要|Why use static types in JavaScript?/","link":"","permalink":"https://React-Apollo.github.io/2018/02/12/摘要|Why use static types in JavaScript?/","excerpt":"","text":"原文参见Why use static types in JavaScript part one Flow 的快速介绍boolean描述boolean值1var isFetching: boolean = false; numbernumber 包含了Infinity和NaN123var luckyNumber: number = 10;var notSoLuckyNumber: number = NaN; string:1var myName: string = 'Preethi'; null1var data: null = null; void1var data: void = undefined; Array可以用Array&lt;T&gt;描述数组的元素类型, 例如下面1var messages: Array&lt;string&gt; = ['hello', 'world', '!']; object可以定义对象的规格: 1234var aboutMe: &#123; name: string, age: number &#125; = &#123; name: 'Preethi', age: 26,&#125;; function123var calculateArea = (radius: number): number =&gt; &#123; return 3.14 * radius * radius&#125;; 异步函数也可以添加类型12345678async function amountExceedsPurchaseLimit( amount: number, getPurchaseLimit: () =&gt; Promise&lt;number&gt;): Promise&lt;boolean&gt; &#123; var limit = await getPurchaseLimit(); return limit &gt; amount;&#125; type alias可以组合现有的类型,创建新的类型12345type PaymentMethod = &#123; id: number, name: string, limit: number,&#125;; 上面创建了一个新的类型PaymentMethod,组合了三个类型 现在可以直接使用了: 12345var myPaypal: PaymentMethod = &#123; id: 123456, name: 'Preethi Paypal', limit: 10000,&#125;; generics12345type GenericObject&lt;T&gt; = &#123; key: T &#125;;var numberT: GenericObject&lt;number&gt; = &#123; key: 123 &#125;;var stringT: GenericObject&lt;string&gt; = &#123; key: \"Preethi\" &#125;;var arrayT: GenericObject&lt;Array&lt;number&gt;&gt; = &#123; key: [1, 2, 3] &#125; 创建了一个抽象类型T,现在可以用来表示 numberT代表number类型, 以此类推. part two规范参数和返回值的类型:12const calculateArea = (radius: number): number =&gt; 3.14 * radius * radius; 带有说明性质12345678910function calculatePayoutDate( quote: boolean, amount: number, paymentMethod: string): Date &#123; let payoutDate; /* business logic */ return payoutDate;&#125; 很清楚的展示了参数类型,和函数的意图 减少了复杂的错误处理机制代码有关的错误检查的代码不需要了12345678const calculateAreas = (radii: Array&lt;number&gt;): Array&lt;number&gt; =&gt; &#123; var areas = []; for (var i = 0; i &lt; radii.length; i++) &#123; areas[i] = 3.14 * (radii[i] * radii[i]); &#125; return areas;&#125;; 可以很放心的实行重构隔离行为和数据再来看看calculateAreas函数 12345678const calculateAreas = (radii: Array&lt;number&gt;): Array&lt;number&gt; =&gt; &#123; var areas = []; for (var i = 0; i &lt; radii.length; i++) &#123; areas[i] = 3.14 * (radii[i] * radii[i]); &#125; return areas;&#125;; 首先我们要考虑数据的类型 ,之后才能考虑具体的操作 减少了整整一类的 bugs.因为远程获取数据是不可靠的, message 有可能没有数据,所以声明数据为? maybe类型123456789type AppState = &#123; isFetching: boolean, messages: ?Array&lt;string&gt;&#125;;var appState: AppState = &#123; isFetching: false, messages: null,&#125;; 减少了单元测试的数量提供了 domain 模型工具","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://React-Apollo.github.io/tags/javascript/"}]},{"title":"摘要|A gentle Introduction to React's Higher Order Components","slug":"摘要|A gentle Introduction to React's Higher Order Components","date":"2018-02-12T18:02:51.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/02/12/摘要|A gentle Introduction to React's Higher Order Components/","link":"","permalink":"https://React-Apollo.github.io/2018/02/12/摘要|A gentle Introduction to React's Higher Order Components/","excerpt":"","text":"原文在A gentle Introduction to React’s Higher Order Components副标题是:如何在在高阶组件中使用条件性渲染 Higher order components缩写为 HOCs.可以用于各种用例, 这里集中在条件性渲染上. 不断增长的组件假设有给TodoList组件,实例代码如下: 12345678910111213function App(props) &#123; return ( &lt;TodoList todos=&#123;props.todos&#125; /&gt; );&#125;function TodoList(&#123; todos &#125;) &#123; return ( &lt;div&gt; &#123;todos.map(todo =&gt; &lt;TodoItem key=&#123;todo.id&#125; todo=&#123;todo&#125; /&gt;)&#125; &lt;/div&gt; );&#125; 实际编程中,光有这些是远远不够的, 需要有为空, 长度为0,渲染中的状态 123456789101112131415161718192021222324252627function TodoList(&#123; todos, isLoadingTodos &#125;) &#123; if (isLoadingTodos) &#123; return ( &lt;div&gt; &lt;p&gt;Loading todos ...&lt;/p&gt; &lt;/div&gt; ); &#125; if (!todos) &#123; return null; &#125; if (!todos.length) &#123; return ( &lt;div&gt; &lt;p&gt;You have no Todos.&lt;/p&gt; &lt;/div&gt; ); &#125; return ( &lt;div&gt; &#123;todos.map(todo =&gt; &lt;TodoItem key=&#123;todo.id&#125; todo=&#123;todo&#125; /&gt;)&#125; &lt;/div&gt; );&#125; 由此代码就显得复杂了.高阶组件可以让这个问题简化一下. 导入高阶组件HOCS通常接收一个组件和可选的参数,然后返回一个输入组件(input component)的增强版本(enhanced components). 定义第一个高阶组件 withTodosNull高阶组件返回 stateless-component或者 ES6 class 组件都可以,如果需要访问组件生命周期中的方法,或者是this.state,应该要返回一个 ES6 class 组件 1234567function withTodosNull(Component) &#123; return function (props) &#123; return !props.todos ? null : &lt;Component &#123; ...props &#125; /&gt; &#125;&#125; 这是一个三元操作符,高阶组件根据 props 来决定是渲染null 还是组件本身.所有的 props 都向下传递. 改为 ES6的箭头函数,更容易理解: 1234const withTodosNull = (Component) =&gt; (props) =&gt; !props.todos ? null : &lt;Component &#123; ...props &#125; /&gt; 最终的高阶函数完成了: 1234567891011121314const withTodosNull = (Component) =&gt; (props) =&gt; ...function TodoList(&#123; todos &#125;) &#123; ...&#125;const TodoListWithNull = withTodosNull(TodoList);function App(props) &#123; return ( &lt;TodoListWithNull todos=&#123;props.todos&#125; /&gt; );&#125; 与 null 组件类似 123456789const withTodosEmpty = (Component) =&gt; (props) =&gt; !props.todos.length ? &lt;div&gt;&lt;p&gt;You have no Todos.&lt;/p&gt;&lt;/div&gt; : &lt;Component &#123; ...props &#125; /&gt;const withLoadingIndicator = (Component) =&gt; (props) =&gt; props.isLoadingTodos ? &lt;div&gt;&lt;p&gt;Loading todos ...&lt;/p&gt;&lt;/div&gt; : &lt;Component &#123; ...props &#125; /&gt; 如果在 input 子类的组件中使用 loading 时, 并不需要出传递其他的 props,可以用 ES6 的展开操作符 把 props 分割一下: 1234const withLoadingIndicator = (Component) =&gt; (&#123; isLoadingTodos, ...others &#125;) =&gt; isLoadingTodos ? &lt;div&gt;&lt;p&gt;Loading todos ...&lt;/p&gt;&lt;/div&gt; : &lt;Component &#123; ...others &#125; /&gt; 最终在TodoList组件中的使用: 12345678910111213141516171819202122232425const withTodosNull = (Component) =&gt; (props) =&gt; ...const withTodosEmpty = (Component) =&gt; (props) =&gt; ...const withLoadingIndicator = (Component) =&gt; (&#123; isLoadingTodos, ...others &#125;) =&gt; ...function TodoList(&#123; todos &#125;) &#123; ...&#125;const TodoListOne = withTodosEmpty(TodoList);const TodoListTwo = withTodosNull(TodoListOne);const TodoListThree = withLoadingIndicator(TodoListTwo);function App(props) &#123; return ( &lt;TodoListThree todos=&#123;props.todos&#125; isLoadingTodos=&#123;props.isLoadingTodos&#125; /&gt; );&#125; 高阶组件中的顺序也很重要,因为,前一个组件的条件满足,就直接返回了. 使用 Recompose 进一步改进代码123456789import &#123; compose &#125; from 'recompose';...const withConditionalRenderings = compose( withLoadingIndicator, withTodosNull, withTodosEmpty); 这个增强的过程就是: 1const TodoListWithConditionalRendering = withConditionalRenderings(TodoList); 12345678910111213141516171819202122232425262728293031import &#123; compose &#125; from 'recompose';const withTodosNull = (Component) =&gt; (props) =&gt; ...const withTodosEmpty = (Component) =&gt; (props) =&gt; ...const withLoadingIndicator = (Component) =&gt; (&#123; isLoadingTodos, ...others &#125;) =&gt; ...function TodoList(&#123; todos &#125;) &#123; ...&#125;const withConditionalRenderings = compose( withLoadingIndicator, withTodosNull, withTodosEmpty);const TodoListWithConditionalRendering = withConditionalRenderings(TodoList);function App(props) &#123; return ( &lt;TodoListWithConditionalRendering todos=&#123;props.todos&#125; isLoadingTodos=&#123;props.isLoadingTodos&#125; /&gt; );&#125; 重用抽象的高阶组件上面的组件适应于特定的渲染, 不能用在其他地方. 考虑到长期的使用,应该抽象出来,以便于其他的组价也可以使用 在withTodoNull中添加一个 optional 负载,这个负载是一个函数,负责返回 true 或者 false, 用于决定最终的渲染结果: 1234const withTodosNull = (Component, conditionalRenderingFn) =&gt; (props) =&gt; conditionalRenderingFn(props) ? null : &lt;Component &#123; ...props &#125; /&gt; 现在这个函数的名字就有点误导了, 改为: 1234const withCondition = (Component, conditionalRenderingFn) =&gt; (props) =&gt; conditionalRenderingFn(props) ? null : &lt;Component &#123; ...props &#125; /&gt; 现在就可以用这个抽象的条件判断组件来实现具体的逻辑 12345678const withCondition = (Component, conditionalRenderingFn) =&gt; (props) =&gt; conditionalRenderingFn(props) ? null : &lt;Component &#123; ...props &#125; /&gt;const conditionFn = (props) =&gt; !props.todos;const TodoListWithCondition = withCondition(TodoList, conditionFn); 为了利于实现柯理化, 把负载的函数也分开传递: 1234const withCondition = (conditionalRenderingFn) =&gt; (Component) =&gt; (props) =&gt; conditionalRenderingFn(props) ? null : &lt;Component &#123; ...props &#125; /&gt; 在使用时传递条件函数就可以了: 12345678910111213import &#123; compose &#125; from 'recompose';...const conditionFn = (props) =&gt; !props.todos;const withConditionalRenderings = compose( withLoadingIndicator, withCondition(conditionFn), withTodosEmpty);const TodoListWithConditionalRendering = withConditionalRenderings(TodoList); maybe 和 either 高阶组件什么也不返回,或者返回输入组件的类型,在函数式编程中有名字的叫 Maybe.1234const withMaybe = (conditionalRenderingFn) =&gt; (Component) =&gt; (props) =&gt; conditionalRenderingFn(props) ? null : &lt;Component &#123; ...props &#125; /&gt; 两个组件返回其一的在函数式编程中称为 either 1234const withEither = (conditionalRenderingFn, EitherComponent) =&gt; (Component) =&gt; (props) =&gt; conditionalRenderingFn(props) ? &lt;EitherComponent /&gt; : &lt;Component &#123; ...props &#125; /&gt; 最最终的版本终于是最后一个版本了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import &#123; compose &#125; from 'recompose';const withMaybe = (conditionalRenderingFn) =&gt; (Component) =&gt; (props) =&gt; conditionalRenderingFn(props) ? null : &lt;Component &#123; ...props &#125; /&gt;const withEither = (conditionalRenderingFn, EitherComponent) =&gt; (Component) =&gt; (props) =&gt; conditionalRenderingFn(props) ? &lt;EitherComponent /&gt; : &lt;Component &#123; ...props &#125; /&gt;const EmptyMessage = () =&gt; &lt;div&gt; &lt;p&gt;You have no Todos.&lt;/p&gt; &lt;/div&gt;const LoadingIndicator = () =&gt; &lt;div&gt; &lt;p&gt;Loading todos ...&lt;/p&gt; &lt;/div&gt;const isLoadingConditionFn = (props) =&gt; props.isLoadingTodos;const nullConditionFn = (props) =&gt; !props.todos;const isEmptyConditionFn = (props) =&gt; !props.todos.lengthconst withConditionalRenderings = compose( withEither(isLoadingConditionFn, LoadingIndicator), withMaybe(nullConditionFn), withEither(isEmptyConditionFn, EmptyMessage));const TodoListWithConditionalRendering = withConditionalRenderings(TodoList);function App(props) &#123; return ( &lt;TodoListWithConditionalRendering todos=&#123;props.todos&#125; isLoadingTodos=&#123;props.isLoadingTodos&#125; /&gt; );&#125;function TodoList(&#123; todos &#125;) &#123; return ( &lt;div&gt; &#123;todos.map(todo =&gt; &lt;TodoItem key=&#123;todo.id&#125; todo=&#123;todo&#125; /&gt;)&#125; &lt;/div&gt; );&#125; 确实赏心悦目的代码改进, 每一步都体现了程序员的思考过程.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"hoc","slug":"hoc","permalink":"https://React-Apollo.github.io/tags/hoc/"}]},{"title":"摘要|Full-stack React + GraphQL Tutorial(part4)","slug":"摘要|Full-stack React + GraphQL Tutorial(part4)","date":"2018-02-10T20:23:46.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/02/10/摘要|Full-stack React + GraphQL Tutorial(part4)/","link":"","permalink":"https://React-Apollo.github.io/2018/02/10/摘要|Full-stack React + GraphQL Tutorial(part4)/","excerpt":"","text":"这个是之前看到apollo-client 的入门文章,随着学习,回过头来看看,觉得非常有意思 不准备全部翻译,有些有用的地方强调一下 系列文章 Part 1 : Setting up a simple client Part 2: Setting up a simple server Part 3: Writing mutations and keeping the client in sync Part 4: (this part)Optimistic UI and client side store updates Part 5: Input types and custom cache resolvers Part 6: Subscriptions on the server Part 7: GraphQL Subscriptions on the client Part 8: PaginationMutation 和延迟网络操作存在不可预测的延迟,这个没有办法去估计和预测. 只有通过一定的策略去提供更为友好的操作方法.mutation 之后的 store 更新针对 mutation 和其他需要根据客户端的操作来更新 store的操作, Apollo-client提供了一套有力的工具:readQuery,writeQuery,readFragment和writeFragment. 客户端的添加操作,可以如下操作,先写入缓存里 1234567891011121314151617181920212223242526272829303132333435363738394041424344const handleKeyUp = (evt) =&gt; &#123; if (evt.keyCode === 13) &#123; evt.persist(); mutate(&#123; variables: &#123; name: evt.target.value &#125;, update: (store, &#123; data: &#123; addChannel &#125; &#125;) =&gt; &#123; // Read the data from the cache for this query. const data = store.readQuery(&#123;query: channelsListQuery &#125;); // Add our channel from the mutation to the end. data.channels.push(addChannel); // Write the data back to the cache. store.writeQuery(&#123; query: channelsListQuery, data &#125;); &#125;, &#125;) .then( res =&gt; &#123; evt.target.value = ''; &#125;); &#125; &#125;;``` 这样一旦, mutation 操作完成,可以立刻得到结果,不会有延迟存在.![](https://ws1.sinaimg.cn/large/006tNc79gy1fobmr5zy1sj30c2092q2w.jpg)实际的延迟仍然存在,但是通过技巧处理了这个问题#### Optimistic UIapollo-client提供了 Optimistic UI 来完美的解决这个问题途径通过在mutation中添加`optimisticResponse`属性.```jsmutate(&#123; variables: &#123; name: evt.target.value &#125;, optimisticResponse: &#123; addChannel: &#123; name: evt.target.value, id: Math.round(Math.random() * -1000000), __typename: 'Channel', &#125;, &#125;, update: ...&#125;) 为了让用户知道,添加的数据还没有被服务器确认,还需要一些小技巧保持条目也 optimistic我们在上面生成了一个负的 id 1id: Math.round(Math.random() * -1000000), 为了让未经服务器确认的消息和真实的消息 有所区分,要添加额外的 CSS: 12345678return ( &lt;div className=\"channelsList\"&gt; &lt;AddChannel /&gt; &#123; channels.map( ch =&gt; (&lt;div key=&#123;ch.id&#125; className=&#123;'channel ' + (ch.id &lt; 0 ? 'optimistic' : '')&#125;&gt;&#123;ch.name&#125;&lt;/div&gt;) )&#125; &lt;/div&gt; ); 123div.optimistic &#123; color: rgba(255, 255, 255, 0.5);&#125; 注意:这里的 id 并不重要,重要的是显示的内容,所以用了一个 id 为负值的参数,既区分了真实和模拟的数据,又据此添加了对应的样式. 当真实的数据从服务器返回以后,会替代负id的样式, 就确认mutation 了.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Apollo-client","slug":"Apollo-client","permalink":"https://React-Apollo.github.io/tags/Apollo-client/"},{"name":"Grahpql","slug":"Grahpql","permalink":"https://React-Apollo.github.io/tags/Grahpql/"}]},{"title":"摘要|Full-stack React + GraphQL Tutorial(part1)","slug":"摘要|Full-stack React + GraphQL Tutorial","date":"2018-02-10T20:10:01.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/02/10/摘要|Full-stack React + GraphQL Tutorial/","link":"","permalink":"https://React-Apollo.github.io/2018/02/10/摘要|Full-stack React + GraphQL Tutorial/","excerpt":"","text":"这个是之前看到apollo-client 的入门文章,随着学习,回过头来看看,觉得非常有意思 不准备全部翻译,有些有用的地方强调一下 系列文章 Part 1 (this part): Setting up a simple client Part 2: Setting up a simple server Part 3: Writing mutations and keeping the client in sync Part 4: Optimistic UI and client side store updates Part 5: Input types and custom cache resolvers Part 6: Subscriptions on the server Part 7: GraphQL Subscriptions on the client Part 8: Pagination配置使用 create-react-app 的方法,很简单,而且可以部署到 github, 因为这是静态文件,嵌入的 js打包文件. app.js 文件修改如下-导入一个列表组件:12345678910111213141516171819202122import React, &#123; Component &#125; from 'react'; import logo from './logo.svg'; import './App.css';const ChannelsList = () =&gt; (&lt;ul&gt; &lt;li&gt;Channel 1&lt;/li&gt; &lt;li&gt;Channel 2&lt;/li&gt; &lt;/ul&gt;);class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;div className=\"App-header\"&gt; &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; &lt;h2&gt;Welcome to Apollo&lt;/h2&gt; &lt;/div&gt; &lt;ChannelsList /&gt; &lt;/div&gt; ); &#125; &#125;export default App; 编写 graphql schema 文件1234567891011export const typeDefs = `type Channel &#123; id: ID! # \"!\" denotes a required field name: String&#125;# This type specifies the entry points into our API. In this case# there is only one - \"channels\" - which returns a list of channels.type Query &#123; channels: [Channel] # \"[]\" means this is a list of channels&#125;`; 这是标准的做法,如果是定义了一个 schema 实体, 返回列表就是一个数组根据这个 schmea 可以编写查询 123456query ChannelsListQuery &#123; channels &#123; id name &#125;&#125; 对组件进行包装: 123456789const channelsListQuery = gql` query ChannelsListQuery &#123; channels &#123; id name &#125; &#125; `;const ChannelsListWithData = graphql(channelsListQuery)(ChannelsList); 由于 apollo-client 利用了网络层的状态标志,省去了自己构建的麻烦:1234567891011const ChannelsList = (&#123; data: &#123;loading, error, channels &#125;&#125;) =&gt; &#123; if (loading) &#123; return &lt;p&gt;Loading ...&lt;/p&gt;; &#125; if (error) &#123; return &lt;p&gt;&#123;error.message&#125;&lt;/p&gt;; &#125; return &lt;ul&gt; &#123; channels.map( ch =&gt; &lt;li key=&#123;ch.id&#125;&gt;&#123;ch.name&#125;&lt;/li&gt; ) &#125; &lt;/ul&gt;; &#125;; 直接可以使用的loading 和 error 标记 后面的模拟数据部分,新版已经改进了,不能再使用","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Apollo-client","slug":"Apollo-client","permalink":"https://React-Apollo.github.io/tags/Apollo-client/"},{"name":"Grahpql","slug":"Grahpql","permalink":"https://React-Apollo.github.io/tags/Grahpql/"}]},{"title":"翻译|Prisma  Data Model","slug":"翻译|Prisma  Data Model","date":"2018-02-09T11:02:23.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/02/09/翻译|Prisma  Data Model/","link":"","permalink":"https://React-Apollo.github.io/2018/02/09/翻译|Prisma  Data Model/","excerpt":"","text":"概览Prisma 使用 GraphQL Schema Definition Language 定义数据模型.数据模型可以写在一个或多个.graphql文件中.在内部它是 Prisma 生成实际数据库 schema 的基础.如果只使用单个的定义文件,可以被称为datamodel.graphql. .graphql文件需要在prisma.yml中声明. 例如: 123datamodel: - types.graphql - enums.graphql 如果是单个文件:1datamodel:datamodel.graphql data model 是 基于Prisma服务的 GraphQL API 的基础. Prisma会以此生成一套强有力的 Graphql Schema(被称为 Prisma data schema),为 data model 定义了全部的 CRUD 操作. 实例一个简单的datamodel.graphql文件: 123456789101112131415161718192021type Tweet &#123; id: ID! @unique createdAt: DateTime! text: String! owner: User! location: Location!&#125;type User &#123; id: ID! @unique createdAt: DateTime! updatedAt: DateTime! handle: String! @unique name: String tweets: [Tweet!]!&#125;type Location &#123; latitude: Float! longitude: Float!&#125; 实例展示了一些data model 的重要概念: 三个类型 Tweet,User,Location被映射到数据库的表中 User,Tweet之间是双向关系 Tweet到Location是单向关系 除了 User的 name字段,所有的字段都是必须的(用!表示) id,createdAt,updateAt字段由 Prisma 管理,在 GraphQL API 中只读 创建和更新 datamodel 和修改文本文件一样简单.一旦 datamodel 的修改达到你的需求,可以执行prisma deploy命令 :1234567891011121314151617181920212223242526272829303132333435363738$ prisma deployChanges: Tweet (Type) + Created type `Tweet` + Created field `id` of type `GraphQLID!` + Created field `createdAt` of type `DateTime!` + Created field `text` of type `String!` + Created field `owner` of type `Relation!` + Created field `location` of type `Relation!` + Created field `updatedAt` of type `DateTime!` User (Type) + Created type `User` + Created field `id` of type `GraphQLID!` + Created field `createdAt` of type `DateTime!` + Created field `updatedAt` of type `DateTime!` + Created field `handle` of type `String!` + Created field `name` of type `String` + Created field `tweets` of type `[Relation!]!` Location (Type) + Created type `Location` + Created field `latitude` of type `Float!` + Created field `longitude` of type `Float!` + Created field `id` of type `GraphQLID!` + Created field `updatedAt` of type `DateTime!` + Created field `createdAt` of type `DateTime!` TweetToUser (Relation) + Created relation between Tweet and User LocationToTweet (Relation) + Created relation between Location and TweetApplying changes... (22/22)Applying changes... 0.4s 构建 data model 模块有几种可以使用的模块用于描述 data model Types 包含fields,用于把类似的实体分组. 每个data model 中的 type 都被映射到数据库的表和 CRUD操作,然后添加的 graphQL 的 schema 中 Relations 描述 typee 之间的关系 Interfaces属于抽象 types,包含了一组特定的字段, type在实现时必须要遵循. 现在 interface 还不能由用户定义.但是已经有这样的需求. 特定的directives指令,包含不同的使用用例, 例如 type 约束或者是级联删除的行为. 接下里的内容就是描述这些构建块的具体细节问题 Prisma 的 database 和 data model刚开使用 GraphQL和 Prisma时, .graphql文件的数量会让你不是所措.然而理解每个文件扮演的角色又是很关键的问题.总体上讲,一个graphql文件可以包含下面的内容: GraphQL 的操作(例如 query, mutate或者 subscriptions) 使用 SDL 定义的 GraphQL type 如果要区分 Prisma database schema 和 data model的话,只有后者是有关联的! 现在这一很重要data model 并不是实际的 GraphQL schema,虽然也是用 SDL定义的,但是缺少 root types,所以不能生成实际的 API 操作符! Prisma 只是使用 data model作为一个硬工具表达一下具体的 data model 的外观. 正如上面提到的, Prisma 会生成实际的 GraphQL schema,包含query,mutation,subscription 三种 root type. 生成的 prisma.graphql文件被称为 Prisma database schema .注意了,一定不要修改这个文件.这是系统自己生成的. 作为实例,看看一个最简单的 data model: datamodel graphql 1234type User &#123; id: ID! @uniue name: String!&#125; 如果部署了 Prisma 的服务, Prisma 将会生成服务所需的一些 API: prisma.graphql 1234567891011121314type Query &#123; users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]! user(where: UserWhereUniqueInput!): User&#125;type Mutation &#123; createUser(data: UserCreateInput!): User! updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User deleteUser(where: UserWhereUniqueInput!): User&#125;type Subscription &#123; user(where: UserSubscriptionWhereInput): UserSubscriptionPayload&#125; 其实在生成的 Graphql server 中还有一个.graphql文件, 这个文件被称为 application shema. 这里定义的 API是实际暴露给最终用户的. Prisma 的 API 就作为 “query egine”来实际执行操作. 所以,一个 基于PRISMA的Graphql server实际包含两个 API.可以认为是服务的两个数据层: Aplication layer: 定义客户端可以使用的操作 Database layer: 定义 Prisma database 的服务 Object typesobject type(简称为 type)定义了实现data model 的实际组成部分. 用于代表应用主域的实体.如果你很熟悉 SQL databases,可以把 type 看成是 关系型数据库的 table,一个 type 有一个名字,一个或者多个字段.type的实例称为 node,这个术语指的是 data graph 中的 node. 在 data model 中定义的每个 type和 Prisma生成的 database schema 很类似. 定义一个 object type用type关键字定义一个object type 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566type Article &#123; id: ID! @unique text: String! isPublished: Boolean @default(value: \"false\")&#125;``` 上面的 type 定义包含下面的属性:- Name:`Article`- Fields: `id`,`text`,`isPublished`(默认值是`false`)### 为 type 生成 API 操作符在 datamodel 中定义的 type 会影响 prisma graphql API 的生成. - queries- mutations- subscriptions## FieldsFields 是构建 type的基础块. 每个字段由名字来引用, 要么是标量,要么是 relation 字段### 标量类型#### String`String`承载 text,可以用于 username,blog的正文,或者代表 txt 的内容注意: String在共享的 cluster 中容量是256kb.可以通过 clusters 的配置来扩增.在 query 或者 mutation 中, String字段要用双引号定义:`string:\"some-string\"`#### Integer`Int`是没有小数位的数字,可以用来储存成分重量, 或者最小年龄等. `int:42`#### Float`float`是有小数位的数字, `float:42`,`float:4.2`#### Boolean`boolean:true`,`boolean:false`#### DateTime`DateTime` type 用来保存日期或者时间值. 某人的出生日期就是一个例子.在`query`和`mutations`中,`DateTime`字段要定义为`ISO8601 format`.- `datetime:\"2015\"`#### Enum 枚举用于定义服务的范围和 boolean 一样,有一套预设值,不同点是可以自己设置. 限定为`191个字符`#### JSON有时候要储存松散的数据结构,可以可以用 JSON.`json: \"&#123;\\\"int\\\": 1, \\\"string\\\": \\\"value\\\"&#125;\"`#### ID25个字符串,基于 cuid.### Type modifiers#### List`listString: [\"a string\", \"another string\"], listInt: [12, 24]`.#### Requiredfields 可以被标记位 required(non-null). `name:String!`### field 限定字段可以使用特定的字段限定#### Unique连个 node,不能有同样的值.唯一例外是`null`.&gt;通常 User type 的`email`是唯一的只有开始的191个字符是唯一的, 并且是区分大小写的. ```jstype User &#123; email: String! @unique age: Int!&#125; 对于使用@unique限定的字段可以借此查询对应的 node.例如可以返回拥有此 email 的用户节点:1234567query &#123; user(where: &#123; email: \"alice@graph.cool\" &#125;) &#123; age &#125;&#125; 后续还有其他的限定条件加入Default Value可以为标量设定默认值. @default指令 123456type Story &#123; isPublished: Boolean @default(value: \"false\") someNumber: Int! @default(value: \"42\") title: String! @default(value: \"My New Post\") publishDate: DateTime! @default(value: \"2018-01-26\")&#125; 一定要用双引号,即使不是字符串 System fields三个字段id,createdAt,updatedAT有特殊的意义. 在 datamodel 中是可选,但是在底层的数据库中会一直存在.除非要是导入的数据, 否则, 这三个值在 graphql API 中是只读的. Relationsrelation 定义了连接两个 type 的语法. 两个类型通过 relation fields 连接在一起.如果 relation 可能会混淆的时候,要使用@relation来区分开连接自身的字段也可以 Required relations@relation directive有两个参数 name: 用于识别 relation. onDelete:用于定义删除行为: SET_NULL(default):设定 related node 为null CASCADE:删除 related nodes. 实例:12345678910type User &#123; id: ID! @unique stories: [Story!]! @relation(name: \"StoriesByUser\" onDelete: CASCADE)&#125;type Story &#123; id: ID! @unique text: String! author: User @relation(name: \"StoriesByUser\")&#125; 上面例子的删除行为: 当Usernode被删除以后, 与之有关的Story node 也被删除 当Story node被删除,只会从User 的stories列表中删除 省略@relation指令当两个 type 不会发生歧义的时候,可以不用写这个指令 12345678910type User &#123; id: ID! @unique stories: [Story!]!&#125;type Story &#123; id: ID! @unique text: String! author: User&#125; 当User删除掉, author中所有的相关Story都会被设为null.如果 author 被设定为 required,操作就会引发错误 当一个Story被删除掉以后,只会从User node list 中删除 在@relation指令中使用name参数123456789101112type User &#123; id: ID! @unique writtenStories: [Story!]! @relation(name: \"WrittenStories\") likedStories: [Story!]! @relation(name: \"LikedStories\")&#125;type Story &#123; id: ID! @unique text: String! author: User! @relation(name: \"WrittenStories\") likedBy: [User!]! @relation(name: \"LikedStories\")&#125; 在@relation指令中使用onDelete参数1234567891011121314151617type User &#123; id: ID! @unique comments: [Comment!]! @relation(name: \"CommentAuthor\", onDelete: CASCADE) blog: Blog @relation(name: \"BlogOwner\", onDelete: CASCADE)&#125;type Blog &#123; id: ID! @unique comments: [Comment!]! @relation(name: \"Comments\", onDelete: CASCADE) owner: User! @relation(name: \"BlogOwner\", onDelete: SET_NULL)&#125;type Comment &#123; id: ID! @unique blog: Blog! @relation(name: \"Comments\", onDelete: SET_NULL) author: User @relation(name: \"CommentAuthor\", onDelete: SET_NULL)&#125; 看看三个不同的类型: User node 被删除 所有的Comment nodes 被删除 Blog node 也被删除 当Blog node 被删除, 所有相关的Commentnodes被删除 拥有blog字段的User node 被设置为空 当Comment node 被删除 相关的Blog node会继续存在,Comments会从comment list 中删掉 相关的User会一直存在, Comment node会从comments list 中删掉 为 relations 生成 API 操作 relation queries 会跨 types查询数据或者聚合 relation nest mutations 跨 types, create,connect,update upsert和 delete nodes relation subscription 改变 relation时获取通知 GraphQL 指令临时性指令renaming a type or field@rename(oldName:String!) 1234# renaming the `Post` type to `Story`, and its `text` field to `content`type Story @rename(oldName: \"Post\") &#123; content: String @rename(oldName: \"text\")&#125;","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"}]},{"title":"Prisma 实现新特性的步骤","slug":"在 prisma 中实现新特性的步骤","date":"2018-02-08T21:11:39.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/02/08/在 prisma 中实现新特性的步骤/","link":"","permalink":"https://React-Apollo.github.io/2018/02/08/在 prisma 中实现新特性的步骤/","excerpt":"","text":"Adjust data model (if necessary) Deploy Prisma database service to apply changes to data model (if necessary) Add new root field (on the Query, Mutation or Subscription field) to application schema Implement the resolver for the new root field","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"摘要|GraphQL Databases — A preview into the future of Graphcool","slug":"摘要|GraphQL Databases — A preview into the future of Graphcool","date":"2018-02-08T18:08:58.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/02/08/摘要|GraphQL Databases — A preview into the future of Graphcool/","link":"","permalink":"https://React-Apollo.github.io/2018/02/08/摘要|GraphQL Databases — A preview into the future of Graphcool/","excerpt":"","text":"GraphQL 数据库- Graphcool 未来展望 构建 GraphQL 服务器的方法更加符合常规定义的 GraphQL schema 如何映射到数据库在 graphql的应用中有两层,一层是数据库层,一层是应用层(graphql发挥作用的地方).可以作为 REST API 的”gateway”,整合多个 API,或者是遗留的资源. GraphQL DataBase 使用 SDL 简单明了的进行数据模型管理 建立 GraphQL CRUD API. Graphcool database service graphcool.yml:graphcool服务的根配置. 在 Prisma里结构已经改变了 database/datamodel.graphql:定义应用的数据模型,之前的版本叫types.graphql database/schema.grphql:这是根据命令自动生成的. 包括完整的根据 datamodel生成的 database schema.绝大多数都是 CRUD 操作的方法.是应用的基础. Application(GraphQL Server)这个一部分是之前的版本没有的部分 所以要留心.新版本(Prisma)现在只是覆盖数据库层.所以需要额外的层作为实际的 web 服务. 这就是这个一部分的目的. 这一部分也有 schema.graphql,包含了应用的 schema. 定义了最终暴露给客户端的 API. graphQL 配置.因为现在有两个独立的 GraphQL API(一个是应用的,一个是数据库的).添加工具管理这两个部分是很有意义的.grqphqlconfig.yml就是配置文件 在 database/datamodel中会生成完整的 CRUD 操作, 但是如果不想完全暴露给应用. 可以对其进行进行裁剪. 应用的 schema 就是这个目的.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"摘要|GraphQL Server Basics  The Network Layer","slug":"摘要|GraphQL Server Basics- The Network Layer","date":"2018-02-08T12:12:39.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/02/08/摘要|GraphQL Server Basics- The Network Layer/","link":"","permalink":"https://React-Apollo.github.io/2018/02/08/摘要|GraphQL Server Basics- The Network Layer/","excerpt":"","text":"#GraphQL Server Basics: The Network LayerGraphQL Server Basics: The Network Layer Graphql 通过 HTTP协议提供服务以 schema 为核心,定义好了以后后端的 schema和 resolver 之后, 如何实现 Graphql 就是问题了 express.js 的中间件Express 中间件接收req,res,next函数.因为 express 可以处理 http 请求, Graphql 定义的 schema 和 resolver 提供了功能, 需要的就是把他们粘合起来 中间的桥梁有express-grahpql,apollo-server.本质上他们都是 express 的中间件 GraphQL 中间件GraphQL 结合了 HTTP请求和 Graphlql.jsexpress-grahpql是 facebook 版本的 GraphQL的中间件,主要有两个作用: 解析请求中的查询和 mutate, 转发给 graphql函数,最终做处理 把结果附加到 res对象,返回给客户端 12345678910111213141516171819202122232425const express = require('express')const graphqlHTTP = require('express-graphql')const &#123; GraphQLSchema, GraphQLObjectType, GraphQLString &#125; = require('graphql')const app = express()const schema = new GraphQLSchema(&#123; query: new GraphQLObjectType(&#123; name: 'Query', fields: &#123; hello: &#123; type: GraphQLString, resolve: (root, args, context, info) =&gt; &#123; return 'Hello World' &#125; &#125; &#125;&#125;)app.use('/graphql', graphqlHTTP(&#123; schema, graphiql: true // enable GraphiQL&#125;))app.listen(4000) apollo-server 与 express-graphql 类似两者类似, apollo-server 提供了对更多框架的支持而已. graphql-yoga这是最容易使用的,就是 Graphql 背后的中间件 12345678910111213141516const &#123; GraphQLServer &#125; = require('graphql-yoga')const typeDefs = ` type Query &#123; hello: String! &#125;`const resolvers = &#123; Query: &#123; hello: (root, args, context, info) =&gt; 'Hello World' &#125;&#125;const server = new GraphQLServer(&#123; typeDefs, resolvers &#125;)server.start() // defaults to port 4000","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"graqhql","slug":"graqhql","permalink":"https://React-Apollo.github.io/tags/graqhql/"}]},{"title":"Apollo-client 的Incremental loading(增量加载)","slug":"apollo-client-Incremental loading","date":"2018-02-04T13:22:27.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/02/04/apollo-client-Incremental loading/","link":"","permalink":"https://React-Apollo.github.io/2018/02/04/apollo-client-Incremental loading/","excerpt":"","text":"Incremental loadingfetchmore方法1234567891011121314151617181920212223242526272829const FeedQuery = gql` query Feed($type: FeedType!, $offset: Int, $limit: Int) &#123; # ... &#125;`;const FeedWithData = graphql(FeedQuery, &#123; props(&#123; data: &#123; loading, feed, currentUser, fetchMore &#125; &#125;) &#123; return &#123; loading, feed, currentUser, loadNextPage() &#123; return fetchMore(&#123; variables: &#123; offset: feed.length, &#125;, updateQuery: (previousResult, &#123; fetchMoreResult &#125;) =&gt; &#123; if (!fetchMoreResult) &#123; return previousResult; &#125; return Object.assign(&#123;&#125;, previousResult, &#123; feed: [...previousResult.feed, ...fetchMoreResult.feed], &#125;); &#125;, &#125;); &#125;, &#125;; &#125;,&#125;)(Feed); 执行查询任务的时候, props里会有一个length属性, 可以作为无限加载的一个偏移标记,比如在 cnode 的查询 REST中,如果下一页page+1,就可以用这个 length+1来作为下一个加载的查询参数1page=length+1","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphql","slug":"Graphql","permalink":"https://React-Apollo.github.io/tags/Graphql/"},{"name":"apollo","slug":"apollo","permalink":"https://React-Apollo.github.io/tags/apollo/"}]},{"title":"Recompose  libary Readme","slug":"Recompose  libary Readme","date":"2018-02-02T20:12:01.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/02/02/Recompose  libary Readme/","link":"","permalink":"https://React-Apollo.github.io/2018/02/02/Recompose  libary Readme/","excerpt":"","text":"APIIn these API docs, a higher-order component (HOC) refers to a function that accepts a single React component and returns a new React component. 1const EnhancedComponent = hoc(BaseComponent) This form makes HOCs (sometimes called enhancers) composable: 1234const composedHoc = compose(hoc1, hoc2, hoc3)// Same asconst composedHoc = BaseComponent =&gt; hoc1(hoc2(hoc3(BaseComponent))) Most Recompose helpers are functions that return higher-order components: 12345const hoc = mapProps(ownerProps =&gt; childProps)const EnhancedComponent = hoc(BaseComponent)// Same asconst EnhancedComponent = mapProps(ownerProps =&gt; childProps)(BaseComponent) Some, like pure, are higher-order components themselves: 1const PureComponent = pure(BaseComponent) TOC Higher-order components mapProps() withProps() withPropsOnChange() withHandlers() defaultProps() renameProp() renameProps() flattenProp() withState() withStateHandlers() withReducer() branch() renderComponent() renderNothing() shouldUpdate() pure() onlyUpdateForKeys() onlyUpdateForPropTypes() withContext() getContext() lifecycle() toClass() Static property helpers setStatic() setPropTypes() setDisplayName() Utilities compose() getDisplayName() wrapDisplayName() shallowEqual() isClassComponent() createSink() componentFromProp() nest() hoistStatics() Observable utilities componentFromStream() componentFromStreamWithConfig() mapPropsStream() mapPropsStreamWithConfig() createEventHandler() createEventHandlerWithConfig() setObservableConfig() Higher-order componentsmapProps()123mapProps( propsMapper: (ownerProps: Object) =&gt; Object,): HigherOrderComponent Accepts a function that maps owner props to a new collection of props that are passed to the base component. mapProps() pairs well with functional utility libraries like lodash/fp. For example, Recompose does not come with a omitProps() function, but you can easily build one using lodash-fp’s omit(): 1234const omitProps = keys =&gt; mapProps(props =&gt; omit(keys, props))// Because of currying in lodash-fp, this is the same asconst omitProps = compose(mapProps, omit) withProps()123withProps( createProps: (ownerProps: Object) =&gt; Object | Object): HigherOrderComponent Like mapProps(), except the newly created props are merged with the owner props. Instead of a function, you can also pass a props object directly. In this form, it is similar to defaultProps(), except the provided props take precedence over props from the owner. withPropsOnChange()1234withPropsOnChange( shouldMapOrKeys: Array&lt;string&gt; | (props: Object, nextProps: Object) =&gt; boolean, createProps: (ownerProps: Object) =&gt; Object): HigherOrderComponent Like withProps(), except the new props are only created when one of the owner props specified by shouldMapOrKeys changes. This helps ensure that expensive computations inside createProps() are only executed when necessary. Instead of an array of prop keys, the first parameter can also be a function that returns a boolean, given the current props and the next props. This allows you to customize when createProps() should be called. withHandlers()12345678withHandlers( handlerCreators: &#123; [handlerName: string]: (props: Object) =&gt; Function &#125; | handlerCreatorsFactory: (initialProps) =&gt; &#123; [handlerName: string]: (props: Object) =&gt; Function &#125;): HigherOrderComponent Takes an object map of handler creators or a factory function. These are higher-order functions that accept a set of props and return a function handler: This allows the handler to access the current props via closure, without needing to change its signature. Handlers are passed to the base component as immutable props, whose identities are preserved across renders. This avoids a common pitfall where functional components create handlers inside the body of the function, which results in a new handler on every render and breaks downstream shouldComponentUpdate() optimizations that rely on prop equality. This is the main reason to use withHandlers to create handlers instead of using mapProps or withProps, which will create new handlers every time when it get updated. Usage example: 1234567891011121314151617181920const enhance = compose( withState('value', 'updateValue', ''), withHandlers(&#123; onChange: props =&gt; event =&gt; &#123; props.updateValue(event.target.value) &#125;, onSubmit: props =&gt; event =&gt; &#123; event.preventDefault() submitForm(props.value) &#125; &#125;))const Form = enhance((&#123; value, onChange, onSubmit &#125;) =&gt; &lt;form onSubmit=&#123;onSubmit&#125;&gt; &lt;label&gt;Value &lt;input type=\"text\" value=&#123;value&#125; onChange=&#123;onChange&#125; /&gt; &lt;/label&gt; &lt;/form&gt;) defaultProps()123defaultProps( props: Object): HigherOrderComponent Specifies props to be passed by default to the base component. Similar to withProps(), except the props from the owner take precedence over props provided to the HoC. Although it has a similar effect, using the defaultProps() HoC is not the same as setting the static defaultProps property directly on the component. renameProp()1234renameProp( oldName: string, newName: string): HigherOrderComponent Renames a single prop. renameProps()123renameProps( nameMap: &#123; [key: string]: string &#125;): HigherOrderComponent Renames multiple props, using a map of old prop names to new prop names. flattenProp()123flattenProp( propName: string): HigherOrderComponent Flattens a prop so that its fields are spread out into the props object. 12345678910const enhance = compose( withProps(&#123; object: &#123; a: 'a', b: 'b' &#125;, c: 'c' &#125;), flattenProp('object'))const Abc = enhance(BaseComponent)// Base component receives props: &#123; a: 'a', b: 'b', c: 'c', object: &#123; a: 'a', b: 'b' &#125; &#125; An example use case for flattenProp() is when receiving fragment data from Relay. Relay fragments are passed as an object of props, which you often want flattened out into its constituent fields: 123456789// The `post` prop is an object with title, author, and content fieldsconst enhance = flattenProp('post')const Post = enhance((&#123; title, content, author &#125;) =&gt; &lt;article&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;h2&gt;By &#123;author.name&#125;&lt;/h2&gt; &lt;div&gt;&#123;content&#125;&lt;/div&gt; &lt;/article&gt;) withState()12345withState( stateName: string, stateUpdaterName: string, initialState: any | (props: Object) =&gt; any): HigherOrderComponent Passes two additional props to the base component: a state value, and a function to update that state value. The state updater has the following signature: 12stateUpdater&lt;T&gt;((prevValue: T) =&gt; T, ?callback: Function): voidstateUpdater(newValue: any, ?callback: Function): void The first form accepts a function which maps the previous state value to a new state value. You’ll likely want to use this state updater along with withHandlers() to create specific updater functions. For example, to create a HoC that adds basic counting functionality to a component: 12345678const addCounting = compose( withState('counter', 'setCounter', 0), withHandlers(&#123; increment: (&#123; setCounter &#125;) =&gt; () =&gt; setCounter(n =&gt; n + 1), decrement: (&#123; setCounter &#125;) =&gt; () =&gt; setCounter(n =&gt; n - 1), reset: (&#123; setCounter &#125;) =&gt; () =&gt; setCounter(0) &#125;)) The second form accepts a single value, which is used as the new state. Both forms accept an optional second parameter, a callback function that will be executed once setState() is completed and the component is re-rendered. An initial state value is required. It can be either the state value itself, or a function that returns an initial state given the initial props. withStateHandlers()123456withStateHandlers( initialState: Object | (props: Object) =&gt; any, stateUpdaters: &#123; [key: string]: (state:Object, props:Object) =&gt; (...payload: any[]) =&gt; Object &#125;) Passes state object properties and immutable updater functionsin a form of (...payload: any[]) =&gt; Object to the base component. Every state updater function accepts state, props and payload and must return a new state or undefined. The new state is shallowly merged with the previous state.Returning undefined does not cause a component rerender. Example: 1234567891011121314151617181920212223const Counter = withStateHandlers( (&#123; initialCounter = 0 &#125;) =&gt; (&#123; counter: initialCounter, &#125;), &#123; incrementOn: (&#123; counter &#125;) =&gt; (value) =&gt; (&#123; counter: counter + value, &#125;), decrementOn: (&#123; counter &#125;) =&gt; (value) =&gt; (&#123; counter: counter - value, &#125;), resetCounter: (_, &#123; initialCounter = 0 &#125;) =&gt; () =&gt; (&#123; counter: initialCounter, &#125;), &#125;)( (&#123; counter, incrementOn, decrementOn, resetCounter &#125;) =&gt; &lt;div&gt; &lt;Button onClick=&#123;() =&gt; incrementOn(2)&#125;&gt;Inc&lt;/Button&gt; &lt;Button onClick=&#123;() =&gt; decrementOn(3)&#125;&gt;Dec&lt;/Button&gt; &lt;Button onClick=&#123;resetCounter&#125;&gt;Reset&lt;/Button&gt; &lt;/div&gt;) withReducer()123456withReducer&lt;S, A&gt;( stateName: string, dispatchName: string, reducer: (state: S, action: A) =&gt; S, initialState: S | (ownerProps: Object) =&gt; S): HigherOrderComponent Similar to withState(), but state updates are applied using a reducer function. A reducer is a function that receives a state and an action, and returns a new state. Passes two additional props to the base component: a state value, and a dispatch method. The dispatch method sends an action to the reducer, and the new state is applied. branch()12345branch( test: (props: Object) =&gt; boolean, left: HigherOrderComponent, right: ?HigherOrderComponent): HigherOrderComponent Accepts a test function and two higher-order components. The test function is passed the props from the owner. If it returns true, the left higher-order component is applied to BaseComponent; otherwise, the right higher-order component is applied. If the right is not supplied, it will by default render the wrapped component. renderComponent()123renderComponent( Component: ReactClass | ReactFunctionalComponent | string): HigherOrderComponent Takes a component and returns a higher-order component version of that component. This is useful in combination with another helper that expects a higher-order component, like branch(): 1234567891011121314151617181920// `isLoading()` is a function that returns whether or not the component// is in a loading stateconst spinnerWhileLoading = isLoading =&gt; branch( isLoading, renderComponent(Spinner) // `Spinner` is a React component )// Now use the `spinnerWhileLoading()` helper to add a loading spinner to any// base componentconst enhance = spinnerWhileLoading( props =&gt; !(props.title &amp;&amp; props.author &amp;&amp; props.content))const Post = enhance((&#123; title, author, content &#125;) =&gt; &lt;article&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;h2&gt;By &#123;author.name&#125;&lt;/h2&gt; &lt;div&gt;&#123;content&#125;&lt;/div&gt; &lt;/article&gt;) renderNothing()1renderNothing: HigherOrderComponent A higher-order component that always renders null. This is useful in combination with another helper that expects a higher-order component, like branch(): 12345678910111213141516171819// `hasNoData()` is a function that returns true if the component has// no dataconst hideIfNoData = hasNoData =&gt; branch( hasNoData, renderNothing )// Now use the `hideIfNoData()` helper to hide any base componentconst enhance = hideIfNoData( props =&gt; !(props.title &amp;&amp; props.author &amp;&amp; props.content))const Post = enhance((&#123; title, author, content &#125;) =&gt; &lt;article&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;h2&gt;By &#123;author.name&#125;&lt;/h2&gt; &lt;div&gt;&#123;content&#125;&lt;/div&gt; &lt;/article&gt;) shouldUpdate()123shouldUpdate( test: (props: Object, nextProps: Object) =&gt; boolean): HigherOrderComponent Higher-order component version of shouldComponentUpdate(). The test function accepts both the current props and the next props. pure()1pure: HigherOrderComponent Prevents the component from updating unless a prop has changed. Uses shallowEqual() to test for changes. onlyUpdateForKeys()123onlyUpdateForKeys( propKeys: Array&lt;string&gt;): HigherOrderComponent Prevents the component from updating unless a prop corresponding to one of the given keys has updated. Uses shallowEqual() to test for changes. This is a much better optimization than the popular approach of using PureRenderMixin, shouldPureComponentUpdate(), or Recompose’s own pure() helper, because those tools compare every prop, whereas onlyUpdateForKeys() only cares about the props that you specify. Example: 123456789101112131415/** * If the owner passes unnecessary props (say, an array of comments), it will * not lead to wasted render cycles. * * Goes well with destructuring because it's clear which props the component * actually cares about. */const enhance = onlyUpdateForKeys(['title', 'content', 'author'])const Post = enhance((&#123; title, content, author &#125;) =&gt; &lt;article&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;h2&gt;By &#123;author.name&#125;&lt;/h2&gt; &lt;div&gt;&#123;content&#125;&lt;/div&gt; &lt;/article&gt;) onlyUpdateForPropTypes()1onlyUpdateForPropTypes: HigherOrderComponent Works like onlyUpdateForKeys(), but prop keys are inferred from the propTypes of the base component. Useful in conjunction with setPropTypes(). If the base component does not have any propTypes, the component will never receive any updates. This probably isn’t the expected behavior, so a warning is printed to the console. 123456789101112131415161718import PropTypes from 'prop-types'; // You need to import prop-types. See https://facebook.github.io/react/docs/typechecking-with-proptypes.htmlconst enhance = compose( onlyUpdateForPropTypes, setPropTypes(&#123; title: PropTypes.string.isRequired, content: PropTypes.string.isRequired, author: PropTypes.object.isRequired &#125;))const Post = enhance((&#123; title, content, author &#125;) =&gt; &lt;article&gt; &lt;h1&gt;&#123;title&#125;&lt;/h1&gt; &lt;h2&gt;By &#123;author.name&#125;&lt;/h2&gt; &lt;div&gt;&#123;content&#125;&lt;/div&gt; &lt;/article&gt;) withContext()1234withContext( childContextTypes: Object, getChildContext: (props: Object) =&gt; Object): HigherOrderComponent Provides context to the component’s children. childContextTypes is an object of React prop types. getChildContext() is a function that returns the child context. Use along with getContext(). getContext()123getContext( contextTypes: Object): HigherOrderComponent Gets values from context and passes them along as props. Use along with withContext(). lifecycle()123lifecycle( spec: Object,): HigherOrderComponent A higher-order component version of React.Component(). It supports the entire Component API, except the render() method, which is implemented by default (and overridden if specified; an error will be logged to the console). You should use this helper as an escape hatch, in case you need to access component lifecycle methods. Any state changes made in a lifecycle method, by using setState, will be propagated to the wrapped component as props. Example:1234567891011const PostsList = (&#123; posts &#125;) =&gt; ( &lt;ul&gt;&#123;posts.map(p =&gt; &lt;li&gt;&#123;p.title&#125;&lt;/li&gt;)&#125;&lt;/ul&gt;)const PostsListWithData = lifecycle(&#123; componentDidMount() &#123; fetchPosts().then(posts =&gt; &#123; this.setState(&#123; posts &#125;); &#125;) &#125;&#125;)(PostsList); toClass()1toClass: HigherOrderComponent Takes a function component and wraps it in a class. This can be used as a fallback for libraries that need to add a ref to a component, like Relay. If the base component is already a class, it returns the given component. Static property helpersThese functions look like higher-order component helpers — they are curried and component-last. However, rather than returning a new component, they mutate the base component by setting or overriding a static property. setStatic()1234setStatic( key: string, value: any): HigherOrderComponent Assigns a value to a static property on the base component. setPropTypes()123setPropTypes( propTypes: Object): HigherOrderComponent Assigns to the propTypes property on the base component. setDisplayName()123setDisplayName( displayName: string): HigherOrderComponent Assigns to the displayName property on the base component. UtilitiesRecompose also includes some additional helpers that aren’t higher-order components, but are still useful. compose()1compose(...functions: Array&lt;Function&gt;): Function Use to compose multiple higher-order components into a single higher-order component. This works exactly like the function of the same name in Redux, or lodash’s flowRight(). getDisplayName()123getDisplayName( component: ReactClass | ReactFunctionalComponent): string Returns the display name of a React component. Falls back to &#39;Component&#39;. wrapDisplayName()1234wrapDisplayName( component: ReactClass | ReactFunctionalComponent, wrapperName: string): string Returns a wrapped version of a React component’s display name. For instance, if the display name of component is &#39;Post&#39;, and wrapperName is &#39;mapProps&#39;, the return value is &#39;mapProps(Post)&#39;. Most Recompose higher-order components use wrapDisplayName(). shallowEqual()1shallowEqual(a: Object, b: Object): boolean Returns true if objects are shallowly equal. isClassComponent()1isClassComponent(value: any): boolean Returns true if the given value is a React component class. createSink()1createSink(callback: (props: Object) =&gt; void): ReactClass Creates a component that renders nothing (null) but calls a callback when receiving new props. componentFromProp()1componentFromProp(propName: string): ReactFunctionalComponent Creates a component that accepts a component as a prop and renders it with the remaining props. Example: 123456const enhance = defaultProps(&#123; component: 'button' &#125;)const Button = enhance(componentFromProp('component'))&lt;Button foo=\"bar\" /&gt; // renders &lt;button foo=\"bar\" /&gt;&lt;Button component=\"a\" foo=\"bar\" /&gt; // renders &lt;a foo=\"bar\" /&gt;&lt;Button component=&#123;Link&#125; foo=\"bar\" /&gt; // renders &lt;Link foo=\"bar\" /&gt; nest()123nest( ...Components: Array&lt;ReactClass | ReactFunctionalComponent | string&gt;): ReactClass Composes components by nesting each one inside the previous. For example: 123456789101112// Given components A, B, and Cconst ABC = nest(A, B, C)&lt;ABC pass=\"through\"&gt;Child&lt;/ABC&gt;// Effectively the same as&lt;A pass=\"through\"&gt; &lt;B pass=\"through\"&gt; &lt;C pass=\"through\"&gt; Child &lt;/C&gt; &lt;/B&gt;&lt;/A&gt; hoistStatics()1hoistStatics(hoc: HigherOrderComponent): HigherOrderComponent Augments a higher-order component so that when used, it copies non-react static properties from the base component to the new component. This is helpful when using Recompose with libraries like Relay. Note that this only hoists non-react statics. The following static properties will not be hoisted: childContextTypes, contextTypes, defaultProps, displayName, getDefaultProps, mixins, propTypes, and type. The following native static methods will also be ignored: name, length, prototype, caller, arguments, and arity. Observable utilitiesIt turns out that much of the React Component API can be expressed in terms of observables: Instead of setState(), combine multiple streams together. Instead of getInitialState(), use startWith() or concat(). Instead of shouldComponentUpdate(), use distinctUntilChanged(), debounce(), etc. Other benefits include: No distinction between state and props – everything is a stream. No need to worry about unsubscribing from event listeners. Subscriptions are handled for you. Sideways data loading is trivial – just combine the props stream with an external stream. Access to an ecosystem of observable libraries, such as RxJS. Recompose’s observable utilities can be configured to work with any observable or stream-like library. See setObservableConfig() below for details. componentFromStream()123componentFromStream( propsToReactNode: (props$: Observable&lt;object&gt;) =&gt; Observable&lt;ReactNode&gt;): ReactComponent Creates a React component by mapping an observable stream of props to a stream of React nodes (vdom). You can think of propsToReactNode as a function f such that 1const vdom$ = f(props$) where props$ is a stream of props and vdom$ is a stream of React nodes. This formulation similar to the popular notion of React views as a function, often communicated as 1v = f(d) Example: 1234567891011121314151617181920const Counter = componentFromStream(props$ =&gt; &#123; const &#123; handler: increment, stream: increment$ &#125; = createEventHandler() const &#123; handler: decrement, stream: decrement$ &#125; = createEventHandler() const count$ = Observable.merge( increment$.mapTo(1), decrement$.mapTo(-1) ) .startWith(0) .scan((count, n) =&gt; count + n, 0) return props$.combineLatest( count$, (props, count) =&gt; &lt;div &#123;...props&#125;&gt; Count: &#123;count&#125; &lt;button onClick=&#123;increment&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;decrement&#125;&gt;-&lt;/button&gt; &lt;/div&gt; )&#125;) componentFromStreamWithConfig()12345678componentFromStreamWithConfig&lt;Stream&gt;( config: &#123; fromESObservable&lt;T&gt;: ?(observable: Observable&lt;T&gt;) =&gt; Stream&lt;T&gt;, toESObservable&lt;T&gt;: ?(stream: Stream&lt;T&gt;) =&gt; Observable&lt;T&gt;, &#125;) =&gt; ( propsToReactNode: (props$: Stream&lt;object&gt;) =&gt; Stream&lt;ReactNode&gt;): ReactComponent Alternative to componentFromStream() that accepts an observable config and returns a customized componentFromStream() which uses the specified observable library. This option is recommended if you want to avoid global state with setObservableConfig(). Note: The following configuration modules are not included in the main export. You must import them individually, as shown in the examples. RxJS12import rxjsConfig from 'recompose/rxjsObservableConfig'const componentFromStream = componentFromStreamWithConfig(rxjsConfig) RxJS 4 (legacy)12import rxjs4Config from 'recompose/rxjs4ObservableConfig'const componentFromStream = componentFromStreamWithConfig(rxjs4Config) most12import mostConfig from 'recompose/mostObservableConfig'const componentFromStream = componentFromStreamWithConfig(mostConfig) xstream12import xstreamConfig from 'recompose/xstreamObservableConfig'const componentFromStream = componentFromStreamWithConfig(xstreamConfig) Bacon12import baconConfig from 'recompose/baconObservableConfig'const componentFromStream = componentFromStreamWithConfig(baconConfig) Kefir12import kefirConfig from 'recompose/kefirObservableConfig'const componentFromStream = componentFromStreamWithConfig(kefirConfig) Flyd12import flydConfig from 'recompose/flydObservableConfig'const componentFromStream = componentFromStreamWithConfig(flydConfig) mapPropsStream()1234mapPropsStream( ownerPropsToChildProps: (props$: Observable&lt;object&gt;) =&gt; Observable&lt;object&gt;, BaseComponent: ReactElementType): ReactComponent A higher-order component version of componentFromStream() — accepts a function that maps an observable stream of owner props to a stream of child props, rather than directly to a stream of React nodes. The child props are then passed to a base component. You may want to use this version to interoperate with other Recompose higher-order component helpers. mapPropsStreamWithConfig()123456789mapPropsStreamWithConfig&lt;Stream&gt;( config: &#123; fromESObservable&lt;T&gt;: ?(observable: Observable&lt;T&gt;) =&gt; Stream&lt;T&gt;, toESObservable&lt;T&gt;: ?(stream: Stream&lt;T&gt;) =&gt; Observable&lt;T&gt;, &#125;,) =&gt; ( ownerPropsToChildProps: (props$: Stream&lt;object&gt;) =&gt; Stream&lt;object&gt;, BaseComponent: ReactElementType): ReactComponent Alternative to mapPropsStream() that accepts a observable config and returns a customized mapPropsStream() that uses the specified observable library. See componentFromStreamWithConfig() above. 1234567891011const enhance = mapPropsStream(props$ =&gt; &#123; const timeElapsed$ = Observable.interval(1000) return props$.combineLatest(timeElapsed$, (props, timeElapsed) =&gt; (&#123; ...props, timeElapsed &#125;))&#125;)const Timer = enhance((&#123; timeElapsed &#125;) =&gt; &lt;div&gt;Time elapsed: &#123;timeElapsed&#125;&lt;/div&gt;) createEventHandler()1234createEventHandler&lt;T&gt;(): &#123; handler: (value: T) =&gt; void, stream: Observable&lt;T&gt;&#125; Returns an object with properties handler and stream. stream is an observable sequence, and handler is a function that pushes new values onto the sequence. Useful for creating event handlers like onClick. createEventHandlerWithConfig()123456789createEventHandlerWithConfig&lt;T&gt;( config: &#123; fromESObservable&lt;T&gt;: ?(observable: Observable&lt;T&gt;) =&gt; Stream&lt;T&gt;, toESObservable&lt;T&gt;: ?(stream: Stream&lt;T&gt;) =&gt; Observable&lt;T&gt;, &#125;) =&gt; (): &#123; handler: (value: T) =&gt; void, stream: Observable&lt;T&gt;&#125; Alternative to createEventHandler() that accepts an observable config and returns a customized createEventHandler() that uses the specified observable library. See componentFromStreamWithConfig() above. setObservableConfig()1234setObservableConfig&lt;Stream&gt;(&#123; fromESObservable&lt;T&gt;: ?(observable: Observable&lt;T&gt;) =&gt; Stream&lt;T&gt;, toESObservable&lt;T&gt;: ?(stream: Stream&lt;T&gt;) =&gt; Observable&lt;T&gt;&#125;) Note: setObservableConfig() uses global state, and could break apps if used inside a package intended to be shared. See componentFromStreamWithConfig() and mapPropsStreamWithConfig() as alternatives for package authors. Observables in Recompose are plain objects that conform to the ES Observable proposal. Usually, you’ll want to use them alongside an observable library like RxJS so that you have access to its suite of operators. By default, this requires you to convert the observables provided by Recompose before applying any transforms: 12345mapPropsStream(props$ =&gt; &#123; const rxjsProps$ = Rx.Observable.from(props$) // ...now you can use map, filter, scan, etc. return transformedProps$&#125;) This quickly becomes tedious. Rather than performing this transform for each stream individually, setObservableConfig() sets a global observable transform that is applied automatically. 1234567import Rx from 'rxjs'import &#123; setObservableConfig &#125; from 'recompose'setObservableConfig(&#123; // Converts a plain ES observable to an RxJS 5 observable fromESObservable: Rx.Observable.from&#125;) In addition to fromESObservable, the config object also accepts toESObservable, which converts a stream back into an ES observable. Because RxJS 5 observables already conform to the ES observable spec, toESObservable is not necessary in the above example. However, it is required for libraries like RxJS 4 or xstream, whose streams do not conform to the ES observable spec. Fortunately, you likely don’t need to worry about how to configure Recompose for your favorite stream library, because Recompose provides drop-in configuration for you. Note: The following configuration modules are not included in the main export. You must import them individually, as shown in the examples. RxJS12import rxjsconfig from 'recompose/rxjsObservableConfig'setObservableConfig(rxjsconfig) RxJS 4 (legacy)12import rxjs4config from 'recompose/rxjs4ObservableConfig'setObservableConfig(rxjs4config) most12import mostConfig from 'recompose/mostObservableConfig'setObservableConfig(mostConfig) xstream12import xstreamConfig from 'recompose/xstreamObservableConfig'setObservableConfig(xstreamConfig) Bacon12import baconConfig from 'recompose/baconObservableConfig'setObservableConfig(baconConfig) Kefir12import kefirConfig from 'recompose/kefirObservableConfig'setObservableConfig(kefirConfig) Flyd12import flydConfig from 'recompose/flydObservableConfig'setObservableConfig(flydConfig)","categories":[{"name":"Readme","slug":"Readme","permalink":"https://React-Apollo.github.io/categories/Readme/"}],"tags":[{"name":"Recompose","slug":"Recompose","permalink":"https://React-Apollo.github.io/tags/Recompose/"},{"name":"hoc","slug":"hoc","permalink":"https://React-Apollo.github.io/tags/hoc/"}]},{"title":"翻译| Simplify your React components with Apollo and Recompose","slug":"翻译| Simplify your React components with Apollo and Recompose","date":"2018-02-02T19:14:54.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/02/02/翻译| Simplify your React components with Apollo and Recompose/","link":"","permalink":"https://React-Apollo.github.io/2018/02/02/翻译| Simplify your React components with Apollo and Recompose/","excerpt":"","text":"使用 Apollo和 Recompse 来简化 React 组件使用 hoc 保持组件的纯度Apollo client和 Apollo项目的任务之一就是和现代的 React开发者工具无缝对接.这就是卫生我们专注于higher-order components(高阶组件), server-side rendering(服务端渲染),和React Native的原因. 随着日益发展, React的开发者现在集中于开发更小巧,焦点更加集中的组件,由Andrew Clark 创建的Recompose库把这种趋势提高到了更高的高度.当 Andrew Clark 去年在 React Europe 做演讲的时候,他把 Recompose看做是类似 Underscore 和 Lodash 之类的工具集,目标是专门用于 React的组件的开发. 下面是你可以通过 Recompose 所做的事情: 通过纯粹的渲染,优化 React 组件 设定默认值 添加限制性 state 变量 通过使用 React函数式组件的语法,你可以做完成上面的任务.这么做是的代码更加直白,减少了在组件渲染时不小心引入的 state或者复杂度. 经过 React-apollo包装的的 React 高阶组件符合这种模式.这些组件只是把一件事做的非常好:即他们让你可以把 GraphQl查询和组件放在一起,并且通过 props 获得数据.其他的事情一概不做,例如管理变量的状态.这时候, React 组件组合, Recompose就可以派上用场了. 纷繁芜杂不见了,这里是第一个如何共同使用 Recompose 和 React apollo 的实例.Recompose 和 React apollo一起使拥有 GraphQl 的 UI简明,漂亮. 使用withState管理变量函数式组件最好的特征是他们是无状态的.意思是如果提供一套同样的props,你总是会得到同样的输出结果,这样就使得组件容易预测和测试.然而,有时候,你还是需要使用一些临时的 state,组好是能把这些东西放在执行渲染的组件之外,保持事情简单化. 让我们来看看如何使用withState容器构建一个具有搜索框(search box)和 Graphql 查询的 React 组件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import React from 'react';import &#123; withState, pure, compose &#125; from 'recompose';import gql from 'graphql-tag';import &#123; graphql &#125; from 'react-apollo';import &#123; Link &#125; from 'react-router';// The data prop, which is provided by the wrapper below, contains// a `loading` key while the query is in flight, and the bookSearch// results when they are readyconst BookSearchResultsPure = (&#123; data: &#123; loading, bookSearch &#125; &#125;) =&gt; &#123; if (loading) &#123; return &lt;div&gt;Loading&lt;/div&gt;; &#125; else &#123; return ( &lt;ul&gt; &#123;bookSearch.map(book =&gt; &lt;li key=&#123;book.id&#125;&gt; &lt;Link to=&#123;`/details/$&#123;book.id&#125;`&#125;&gt; &#123;book.title&#125; by &#123;book.author.name&#125; &lt;/Link&gt; &lt;/li&gt; )&#125; &lt;/ul&gt; ); &#125;&#125;;// The `graphql` wrapper executes a GraphQL query and makes the results// available on the `data` prop of the wrapped component.//// Note that if you type a search field and then hit backspace, the// Apollo cache kicks in and no actual data loading is done.const data = graphql(gql` query BookSearchQuery($keyword: String!) &#123; bookSearch(keyword: $keyword) &#123; id image title author &#123; id name &#125; &#125; &#125;`, &#123; // The variable $keyword for the query is computed from the // React props passed to this container. options: (props) =&gt; (&#123; variables: &#123; keyword: props.keyword &#125;, &#125;),&#125;);// Attach the data HoC to the pure componentconst BookSearchResults = compose( data, pure,)(BookSearchResultsPure);// Use recompose to keep the state of the input so that we// can use functional component syntaxconst keyword = withState('keyword', 'setKeyword', '');const BookSearchPure = (&#123; keyword, setKeyword &#125;) =&gt; ( &lt;div&gt; &lt;input type=\"text\" value=&#123; keyword &#125; onChange=&#123;(e) =&gt; setKeyword(e.target.value)&#125; /&gt; &lt;BookSearchResults keyword=&#123;keyword&#125; /&gt; &lt;/div&gt;);// Attach the state to the pure componentconst BookSearch = compose( keyword, pure,)(BookSearchPure);export default BookSearch; import TodoList from ‘../components/TodoList/TodoList’const Comp=(todos)=&gt; function mapStateToProps(store) { return { todos: store.todolist };} export default connect(mapStateToProps)(Comp);","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"},{"name":"Recompose","slug":"Recompose","permalink":"https://React-Apollo.github.io/tags/Recompose/"},{"name":"hoc","slug":"hoc","permalink":"https://React-Apollo.github.io/tags/hoc/"}]},{"title":"Redux-action readme","slug":"redux-actions","date":"2018-02-01T11:13:31.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/02/01/redux-actions/","link":"","permalink":"https://React-Apollo.github.io/2018/02/01/redux-actions/","excerpt":"","text":"redux-actions Flux Standard Action utilities for Redux. Installation1npm install --save redux-actions The npm package provides a CommonJS build for use in Node.js, and with bundlers like Webpack and Browserify. It also includes an ES modules build that works well with Rollup and Webpack2‘s tree-shaking. If you don’t use npm, you may grab the latest UMD build from unpkg (either a development or a production build). The UMD build exports a global called window.ReduxActions if you add it to your page via a &lt;script&gt; tag. We don’t recommend UMD builds for any serious application, as most of the libraries complementary to Redux are only available on npm. UsagecreateAction(type, payloadCreator = Identity, ?metaCreator)1import &#123; createAction &#125; from 'redux-actions'; Wraps an action creator so that its return value is the payload of a Flux Standard Action. payloadCreator must be a function, undefined, or null. If payloadCreator is undefined or null, the identity function is used. Example: 12345678let increment = createAction('INCREMENT', amount =&gt; amount);// same asincrement = createAction('INCREMENT');expect(increment(42)).to.deep.equal(&#123; type: 'INCREMENT', payload: 42&#125;); If the payload is an instance of an Errorobject,redux-actions will automatically set to true.123456789101112Example:```jsconst increment = createAction(&apos;INCREMENT&apos;);const error = new TypeError(&apos;not a number&apos;);expect(increment(error)).to.deep.equal(&#123; type: &apos;INCREMENT&apos;, payload: error, error: true&#125;); createAction also returns its type when used as type in handleAction or handleActions. Example: 1234567891011121314const increment = createAction('INCREMENT');// As parameter in handleAction:handleAction(increment, &#123; next(state, action) &#123;...&#125;, throw(state, action) &#123;...&#125;&#125;);// As object key in handleActions:const reducer = handleActions(&#123; [increment]: (state, action) =&gt; (&#123; counter: state.counter + action.payload &#125;)&#125;, &#123; counter: 0 &#125;); NOTE: The more correct name for this function is probably createActionCreator(), but that seems a bit redundant. Use the identity form to create one-off actions: 1createAction('ADD_TODO')('Use Redux'); metaCreator is an optional function that creates metadata for the payload. It receives the same arguments as the payload creator, but its result becomes the meta field of the resulting action. If metaCreator is undefined or not a function, the meta field is omitted. createActions(?actionMap, ?...identityActions)1import &#123; createActions &#125; from 'redux-actions'; Returns an object mapping action types to action creators. The keys of this object are camel-cased from the keys in actionMap and the string literals of identityActions; the values are the action creators. actionMap is an optional object and a recursive data structure, with action types as keys, and whose values must be either a function, which is the payload creator for that action an array with payload and meta functions in that order, as in createAction meta is required in this case (otherwise use the function form above) an actionMap identityActions is an optional list of positional string arguments that are action type strings; these action types will use the identity payload creator. 12345678910111213141516171819202122232425262728const &#123; actionOne, actionTwo, actionThree &#125; = createActions(&#123; // function form; payload creator defined inline ACTION_ONE: (key, value) =&gt; (&#123; [key]: value &#125;), // array form ACTION_TWO: [ (first) =&gt; [first], // payload (first, second) =&gt; (&#123; second &#125;) // meta ], // trailing action type string form; payload creator is the identity&#125;, 'ACTION_THREE');expect(actionOne('key', 1)).to.deep.equal(&#123; type: 'ACTION_ONE', payload: &#123; key: 1 &#125;&#125;);expect(actionTwo('first', 'second')).to.deep.equal(&#123; type: 'ACTION_TWO', payload: ['first'], meta: &#123; second: 'second' &#125;&#125;);expect(actionThree(3)).to.deep.equal(&#123; type: 'ACTION_THREE', payload: 3,&#125;); If actionMap has a recursive structure, its leaves are used as payload and meta creators, and the action type for each leaf is the combined path to that leaf: 123456789101112131415161718192021222324252627282930const actionCreators = createActions(&#123; APP: &#123; COUNTER: &#123; INCREMENT: [ amount =&gt; (&#123; amount &#125;), amount =&gt; (&#123; key: 'value', amount &#125;) ], DECREMENT: amount =&gt; (&#123; amount: -amount &#125;) &#125;, NOTIFY: [ (username, message) =&gt; (&#123; message: `$&#123;username&#125;: $&#123;message&#125;` &#125;), (username, message) =&gt; (&#123; username, message &#125;) ] &#125;&#125;);expect(actionCreators.app.counter.increment(1)).to.deep.equal(&#123; type: 'APP/COUNTER/INCREMENT', payload: &#123; amount: 1 &#125;, meta: &#123; key: 'value', amount: 1 &#125;&#125;);expect(actionCreators.app.counter.decrement(1)).to.deep.equal(&#123; type: 'APP/COUNTER/DECREMENT', payload: &#123; amount: -1 &#125;&#125;);expect(actionCreators.app.notify('yangmillstheory', 'Hello World')).to.deep.equal(&#123; type: 'APP/NOTIFY', payload: &#123; message: 'yangmillstheory: Hello World' &#125;, meta: &#123; username: 'yangmillstheory', message: 'Hello World' &#125;&#125;); When using this form, you can pass an object with key namespace as the last positional argument, instead of the default /. handleAction(type, reducer | reducerMap = Identity, defaultState)1import &#123; handleAction &#125; from 'redux-actions'; Wraps a reducer so that it only handles Flux Standard Actions of a certain type. If a reducer function is passed, it is used to handle both normal actions and failed actions. (A failed action is analogous to a rejected promise.) You can use this form if you know a certain type of action will never fail, like the increment example above. Otherwise, you can specify separate reducers for next() and throw() using the reducerMap form. This API is inspired by the ES6 generator interface. 1234handleAction('FETCH_DATA', &#123; next(state, action) &#123;...&#125;, throw(state, action) &#123;...&#125;&#125;, defaultState); If either next() or throw() are undefined or null, then the identity function is used for that reducer. If the reducer argument (reducer | reducerMap) is undefined, then the identity function is used. The third parameter defaultState is required, and is used when undefined is passed to the reducer. handleActions(reducerMap, defaultState)1import &#123; handleActions &#125; from 'redux-actions'; Creates multiple reducers using handleAction() and combines them into a single reducer that handles multiple actions. Accepts a map where the keys are passed as the first parameter to handleAction() (the action type), and the values are passed as the second parameter (either a reducer or reducer map). The map must not be empty. The second parameter defaultState is required, and is used when undefined is passed to the reducer. (Internally, handleActions() works by applying multiple reducers in sequence using reduce-reducers.) Example: 123456789const reducer = handleActions(&#123; INCREMENT: (state, action) =&gt; (&#123; counter: state.counter + action.payload &#125;), DECREMENT: (state, action) =&gt; (&#123; counter: state.counter - action.payload &#125;)&#125;, &#123; counter: 0 &#125;); combineActions(...types)Combine any number of action types or action creators. types is a list of positional arguments which can be action type strings, symbols, or action creators. This allows you to reduce multiple distinct actions with the same reducer. 1234567891011121314const &#123; increment, decrement &#125; = createActions(&#123; INCREMENT: amount =&gt; (&#123; amount &#125;), DECREMENT: amount =&gt; (&#123; amount: -amount &#125;),&#125;)const reducer = handleAction(combineActions(increment, decrement), &#123; next: (state, &#123; payload: &#123; amount &#125; &#125;) =&gt; (&#123; ...state, counter: state.counter + amount &#125;), throw: state =&gt; (&#123; ...state, counter: 0 &#125;),&#125;, &#123; counter: 10 &#125;)expect(reducer(undefined, increment(1)).to.deep.equal(&#123; counter: 11 &#125;)expect(reducer(undefined, decrement(1)).to.deep.equal(&#123; counter: 9 &#125;)expect(reducer(undefined, increment(new Error)).to.deep.equal(&#123; counter: 0 &#125;)expect(reducer(undefined, decrement(new Error)).to.deep.equal(&#123; counter: 0 &#125;) Here’s an example using handleActions: 123456789101112131415const &#123; increment, decrement &#125; = createActions(&#123; INCREMENT: amount =&gt; (&#123; amount &#125;), DECREMENT: amount =&gt; (&#123; amount: -amount &#125;)&#125;);const reducer = handleActions(&#123; [combineActions(increment, decrement)](state, &#123; payload: &#123; amount &#125; &#125;) &#123; return &#123; ...state, counter: state.counter + amount &#125;; &#125;&#125;, &#123; counter: 10 &#125;);expect(reducer(&#123; counter: 5 &#125;, increment(5))).to.deep.equal(&#123; counter: 10 &#125;);expect(reducer(&#123; counter: 5 &#125;, decrement(5))).to.deep.equal(&#123; counter: 0 &#125;);expect(reducer(&#123; counter: 5 &#125;, &#123; type: 'NOT_TYPE', payload: 1000 &#125;)).to.equal(&#123; counter: 5 &#125;);expect(reducer(undefined, increment(5))).to.deep.equal(&#123; counter: 15 &#125;); Usage with middlewareredux-actions is handy all by itself, however, its real power comes when you combine it with middleware. The identity form of createAction is a great way to create a single action creator that handles multiple payload types. For example, using redux-promise and redux-rx: 1234567891011121314151617const addTodo = createAction('ADD_TODO');// A single reducer...handleAction('ADD_TODO', (state = &#123; todos: [] &#125;, action) =&gt; (&#123; ...state, todos: [...state.todos, action.payload]&#125;));// ...that works with all of these forms:// (Don't forget to use `bindActionCreators()` or equivalent.// I've left that bit out)addTodo('Use Redux')addTodo(Promise.resolve('Weep with joy'));addTodo(Observable.of( 'Learn about middleware', 'Learn about higher-order stores')).subscribe(); See alsoUse redux-actions in combination with FSA-compliant libraries. redux-promise - Promise middleware redux-rx - Includes observable middleware.","categories":[{"name":"readme","slug":"readme","permalink":"https://React-Apollo.github.io/categories/readme/"}],"tags":[{"name":"react","slug":"react","permalink":"https://React-Apollo.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"https://React-Apollo.github.io/tags/redux/"}]},{"title":"React Navigation导航的模板","slug":"React-Navigation嵌套导航版本","date":"2018-02-01T10:20:45.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/02/01/React-Navigation嵌套导航版本/","link":"","permalink":"https://React-Apollo.github.io/2018/02/01/React-Navigation嵌套导航版本/","excerpt":"","text":"根据 GitPoint来的多层嵌套的导航版本大体的路径是 进入 splash 界面, componentDidMount 周期中对用于登录信息进行查找和判断,如果是为登录就跳到登录界面,如果登录就跳到主界面这个三个文件作为入口的 StackNavigator: 123456789101112131415161718192021222324252627282930//这个文件单独建立, route.js,在 app.js 中 导入 NavEntryPoint 就可以了export const NavEntryPoint = StackNavigator( &#123; Splash: &#123; screen: SplashScreen, navigationOptions: &#123; header: null, &#125;, &#125;, Login: &#123; screen: LoginScreen, navigationOptions: &#123; header: null, &#125;, &#125;, Main: &#123; screen: MainTabNavigator, navigationOptions: &#123; header: null, &#125;, &#125;, &#125;, &#123; headerMode: 'screen', URIPrefix: 'gitpoint://', cardStyle: &#123; backgroundColor: '#c397d8', &#125;, &#125;); login如果登录成功,也跳转到主界面 主界面TabNavigator主界面是 TabNavigator,由单独的 StackNavigator 构成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const MainTabNavigator=TabNavigator(&#123; Home: &#123; screen: HomeStackNavigator, navigationOptions: &#123; tabBarLabel: 'Home', tabBarIcon: (&#123; tintColor, focused &#125;) =&gt; ( &lt;Image source=&#123;focused?require('./app/assets/tabs/tab-icon1/active.png'):require('./app/assets/tabs/tab-icon1/default.png')&#125; /&gt; ),header: null, &#125;, &#125;, About:&#123; screen :AboutStackNavigator, navigationOptions: &#123; tabBarLabel: 'About', tabBarIcon: (&#123; tintColor, focused &#125;) =&gt; ( &lt;Image source=&#123;focused?require('./app/assets/tabs/tab-icon2/active.png'):require('./app/assets/tabs/tab-icon2/default.png')&#125; /&gt; ),header: null, &#125;, &#125;, Contact:&#123; screen :ContactStackNavigator, navigationOptions: &#123; tabBarLabel: 'Contact', tabBarIcon: (&#123; tintColor, focused &#125;) =&gt; ( &lt;Image source=&#123;focused?require('./app/assets/tabs/tab-icon5/active.png'):require('./app/assets/tabs/tab-icon5/default.png')&#125; /&gt; ),header: null, &#125;, &#125;, More:&#123; screen :MoreStackNavigator, navigationOptions: &#123; tabBarLabel: 'More', tabBarIcon: (&#123; tintColor, focused &#125;) =&gt; ( &lt;Image source=&#123;focused?require('./app/assets/tabs/tab-icon3/active.png'):require('./app/assets/tabs/tab-icon3/default.png')&#125; /&gt; ),header: null, &#125;, &#125;, &#125;, &#123; tabBarPosition: 'bottom', animationEnabled: false, tabBarOptions: &#123; activeTintColor: '#e91e63', &#125;, &#125;) 以上两部分,定制好以后,就可以不动了,主要的页面的添加都是在四个 StackNavigator 中进行的. 承载主要功能页面的StackNavigator123456789101112131415161718192021import &#123;tab1,list1 &#125; from './app/tab1';const HomeStackNavigator = StackNavigator( &#123; Home: &#123; screen: tab1, navigationOptions: &#123; headerTitle: 'Tab1', &#125;, &#125;, List1: &#123; screen: list1, navigationOptions: &#123; headerTitle: 'list1', &#125;, &#125;, &#125;, &#123; headerMode: 'screen', &#125;); 每个Tab 下的功能就在这里扩展,按照 GitPoint 的思路,有一些公共的页面,可以用 shareRoute 的形式,导入到单个 Tab的 StackNavigator下面. 这就是完整的 React Navigation嵌套导航的模板,基本的 APP都可以直接套用了","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React-native","slug":"React-native","permalink":"https://React-Apollo.github.io/tags/React-native/"}]},{"title":"Transducer 关键代码的解析","slug":"Transducer 原理的解释代码","date":"2018-01-31T19:05:07.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/01/31/Transducer 原理的解释代码/","link":"","permalink":"https://React-Apollo.github.io/2018/01/31/Transducer 原理的解释代码/","excerpt":"","text":"代码块12345678910111213141516171819202122const mapping = (f) =&gt; (reducing) =&gt; (result, input) =&gt; reducing(result, f(input));const filtering = (predicate ) =&gt; (reducing) =&gt; (result, input) =&gt; predicate(input) ? reducing(result, input) : result;//2 mapping((x) =&gt; x + 1)(filtering((x) =&gt; x % 2 === 0)((xs, x) =&gt; &#123; xs.push(x); return xs;&#125;));mapping(fn)(reducing) ====&gt; reducuing(result, fn(input))在flitering 中 ， fn(input)就作为filtering的 input了 predicate(fn(input))const xform = R.compose( mapping((x) =&gt; x + 1), filtering((x) =&gt; x % 2 === 0), mapping((x=&gt;x*x)) ); 解释mapping,filter 函数上例中的mapping 函数和 filter 函数都是 Reducer函数 mapping 函数的传入 fn 作为处理遍历数组值的函数,result是作为accum 变量, input作为数组的初始值. reducing就是 reducer 函数.上面的代码可以改写为:1mapping(fn)(reducing) ==可以变化为reducer的标准模式==&gt; reducuing(result, fn(input)) 传入的 fn先对输入的数组元素做一下应用.然后再执行 reduce的操作. 实际如果 reducing 函数之前 compose 了很多的函数,那个都会传入到compose时，filtering就作为 mapping 的reducing传入。和上面的方式是一样的 。这里有点绕， 还是高阶函数的问题。compose函数时， 方向从左向右， 但是 transducing中compose的最后一个函数是作为fn传递给后面的reducing函数的。这个地方就是理解transducer的难点。 compose的方向和reducing中的方向是不同的。","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"hoc","slug":"hoc","permalink":"https://React-Apollo.github.io/tags/hoc/"},{"name":"transducer","slug":"transducer","permalink":"https://React-Apollo.github.io/tags/transducer/"}]},{"title":"翻译|The Elegance Of React","slug":"The Elegance Of React","date":"2018-01-30T08:17:07.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/01/30/The Elegance Of React/","link":"","permalink":"https://React-Apollo.github.io/2018/01/30/The Elegance Of React/","excerpt":"","text":"原文参见 内容 General Compose组件 Compose和组件的限制 Reducing组件 Adding ReduxGeneral 本篇文章着眼是如何编写优雅的 React 代码.我们会结合 React和Ramda,以函数式风格来编写应用.所有的概念对于 lodash/fp其他的函数式编程库也是适合的.关键在于你使用哪种库. 本文示例使用*eslint-config-cleanjs*,来强化函数式风格,其中包括no-this和no-classes规则.这些函数式规则可以让我在开始下面的示例时采用更规范.如果你对配置感兴趣,可以到 github 仓库看看具体的规则设置 Compose组件让我们从更为容易接受的方法开始吧!看看下面的代码: 1const comp=(f,g)=&gt;x=&gt;f(g(x)) 如果是组件,实现代码是这样的: 1const TodoList=(List,mapItems)=&gt;s=&gt;List(mapItems(s)) 这么做就有意义了,可以让我们通过compose小的组件来构建更大的组件. 1234const List = c =&gt; &lt;ul&gt;&#123;c&#125;&lt;/ul&gt;const Item = todo =&gt; &lt;li key=&#123;todo.id&#125;&gt;&#123;todo.name&#125;&lt;/li&gt;const TodoList = compose(List, map(Item))const result = TodoList([&#123;id: 1, name: 'foo'&#125;]) TodoList是一个函数等待应用的 state并且根据对应的 state 返回新的组件.代码非常简洁,有意义.我们遍历了一些 todo 的条目,并由此创建Item列表.之后结果借助 props 传递给 TodoList,并且在组件内部渲染. 牢记: 1const App = state =&gt; List(map(Item, state))) 组件渲染其他子组件的想法工作良好,编写的大多数组件都不依赖JSX,只依赖传递进入的 state.所以这个方法只对小的子组件起作用. 下面是使用 Ramda map,compose,prop 方法的实例代码: 123456789import React from 'react'import &#123; render &#125; from 'react-dom'import &#123; compose, map, prop &#125; from 'ramda'const List = items =&gt; &lt;ul&gt;&#123;items&#125;&lt;/ul&gt;const Item = todo =&gt; &lt;li key=&#123;todo.id&#125;&gt;&#123;todo.text&#125;&lt;/li&gt;const getTodos = prop('todos')const TodoList = compose(List, map(Item), getTodos)const props = &#123;todos: [&#123;id: 1, text: 'foo'&#125;, &#123;id: 2, text: 'bar'&#125;]&#125;render(&lt;TodoList &#123;...props&#125; /&gt;, document.getElementById('root')) Compose和组件的限制现在我们已经可以compose 组件并渲染出 Todo list. 接下来看看更为常见的方法,也就是 props 可以自顶向下传递.这些 props可以是任何内容,包括回调函数,其他组件以及数组和对象.下面的代码和 Todo List 的代码相同,只是包含额外的 Header 组件 123const Header = title =&gt; &lt;h1&gt;A Todo List: &#123;title&#125;&lt;/h1&gt;const List = items =&gt; &lt;ul&gt;&#123;items&#125;&lt;/ul&gt;const Item = todo =&gt; &lt;li key=&#123;todo.id&#125;&gt;&#123;todo.text&#125;&lt;/li&gt; 没有什么特别的,但是看看回头看看之前的实现方法,明确的表明,在 List 中包含一个 header 是不可能的.之前的compse: 1const TodoList = compose(List, map(Item), getTodos) 实际编程中我们需要能够 compose Header 和 List 的方法, Header放在哪里合适? 我们向 TodoList 函数传递了应用的state,接着经过筛选,然后遍历筛选过的 todos创建Items 的数组,然后传递给 List.Header组件如何才能从 state 中获取到标题信息?需要更好的办法. 说的更明白一点: 1const TodoHeader = mapStateToProps =&gt; Header(mapStateProps) 订正 这里哟一个更好的实现方法(感谢Thai Pangsakulyanont) 12const TodoHeader = todoState =&gt; Header(getTitleFromTodoState(todoState)) 我们希望是传递应用的 state接着使所有的组件各取所需的 properties.为了让思路更清晰,调用 mapStateToProps 函数 1const mapStateToProps = curry((f, g) =&gt; compose(g, f)) mapStateToProps等待一个函数还有组件,之后首先针对提供的 state 应用函数,之后结果传递给组件.需要注意这一点,我们柯理化了函数,仅仅是想把筛选 state的定义和实际的组件分离开. 在这个问题上, Ramda的绝大多数函数都是自动柯理化的. 下面代码是如何在 Header组价中应用mapStateToProps. 12const TodoHeader = mapStateToProps(s =&gt; s.title, Header)const result = TodoHeader(state) 这看起来和 react-redux 的connect()函数和类似了.我们使用mapStateToProps把state的特定部分转化为 props. 现在 Header 和之前的 List组价可以分别获取各自的 state信息了. 12const TodoList = mapStateToProps(getTodos, compose(List, map(Item))const result = TodoList(state) 显然,mapStateToProps只解决了一部分问题,我们仍然需要 compose TodoList 和 Header来创建整个应用的能力. 使用 compose 不能解决这个问题.所以来实现我们自己的工具函数combine.需要两个组件并返回一个新的组件. 1const combine = curry((c, o) =&gt; x =&gt; (&lt;div&gt;&#123;c(x)&#125; &#123;o(x)&#125;&lt;/div&gt;)) 使用 combine函数可以 compose Header 和 List创建新的函数. 1234const TodoHeader = mapStateToProps(s =&gt; s.title, Header)const TodoList = mapStateToProps(getTodos, compose(List, map(Item)))const App = combine(TodoHeader, TodoList)render(&lt;App &#123;...state&#125; /&gt;, document.getElementById('root')) 现在 compose 两个分别获取特定state 的方式已经有了.接着更进一步看看怎么 compose 更多的组件 Reducing组件如果需要在应用中添加一个显示当前年份的 Footer 组件.怎么才能做到这一点? 首先想到的办法是: 1const App = combine(TodoHeader, combine(TodoList, TodoFooter)) 首先Combine TodoList 和 TodoFooter,接着再 combine 之前的结果和 TodoHeader.这么做是可行的,但是如果组件再多一点,代码就不太好懂了. 可以考虑像下面一样操作: 1234// array of components const comps = [TodoHeader, TodoList, TodoFooter]const App = comps =&gt; reduce((acc, x) =&gt; combine(acc, x), init, comps) 有了想法,看看实际的实现 1234const combineComponents = (...args) =&gt; &#123; const [first, ...rest] = args return reduce((acc, c) =&gt; combine(acc, c), first, rest)&#125; 参考 redux中的combineReducers,我们把自己的 reducer 称为combineComponents, combineComponents 接收一组组件,并 Reduce为等待组件 state 的单个函数. 12const App = combineComponents(TodoHeader, TodoList, TodoFooter)render(&lt;App &#123;...state&#125; /&gt;, document.getElementById('root')) 有了mapStateToProps, combine, combineComponents 的协助,我们现在就可以 compose 组件了.考虑到 mapStateToProps, 我们可以最一下最后的提炼.看看刚开始的实现方法 1const mapStateToProps = curry((f, g) =&gt; compose(g, f)) 实际上,我们完全没有必要自己实现它.Ramda或者 lodash/fp 已经提供了一个函数:pipe. pipe函数从左至右运行所有的函数.看看下面的例子 123456const add = x =&gt; x + 1const multiplyByFour = x =&gt; x * 4// pipe === flip(compose)const rCompose = flip(compose)rCompose(add, multiplyByFour)(1) === compose(multiplyByFour, add)(1)rCompose(add, multiplyByFour)(1) === pipe(add, multiplyByFour)(1) 所以pipe和 compose很像,只不过参数方向是相反的. 我们使用了 Ramda的flip函数,这个函数在本实例中 翻转两个参数的方向.意味着,我们现在可以重构 mapStatToProps为: 1const mapStateToProps = pipe 或者直接使用pipe函数,让 Ramda 担起全责.这么做以后,留给我们两个函数combine和combineRedcers需要处理.甚至combine 函数都可以隐藏起来,但是为了推理清晰一点,还是保留吧! 完整的代码如下: 1234567891011121314151617181920212223242526272829import React from 'react'import &#123; render &#125; from 'react-dom'import &#123; compose, map, prop, curry, reduce, pipe &#125; from 'ramda'const combine = curry((c, o) =&gt; x =&gt; (&lt;div&gt;&#123;c(x)&#125; &#123;o(x)&#125;&lt;/div&gt;))const combineComponents = (...args) =&gt; &#123; const [first, ...rest] = args return reduce((acc, c) =&gt; combine(acc, c), first, rest)&#125;const state = &#123; year: '2016', title: 'Random stuff', todos: [&#123;id:1, text: 'foo'&#125;, &#123; id:2, text: 'bar'&#125;]&#125;const getTodos = prop('todos')const Header = title =&gt; &lt;h1&gt;A Todo List: &#123;title&#125;&lt;/h1&gt;const List = items =&gt; &lt;ul&gt;&#123;items&#125;&lt;/ul&gt;const Item = todo =&gt; &lt;li key=&#123;todo.id&#125;&gt;&#123;todo.text&#125;&lt;/li&gt;const Footer = text =&gt; &lt;div&gt;&#123;text&#125;&lt;/div&gt;const TodoHeader = pipe(s =&gt; s.title, Header)const TodoList = pipe(getTodos, compose(List, map(Item)))const TodoFooter = pipe(s =&gt; s.year, Footer)const App = combineComponents(TodoHeader, TodoList, TodoFooter)const result = render(&lt;App &#123;...state&#125; /&gt;, document.getElementById('root')) Adding Redux Reduce一切组件? 下面的伪代码,帮助我们创建要达成目标的心里模型 1const App=(state,action)=&gt;TodoList 上面的代码看起来有点像典型的 Redux reducers,不同点是我们在这里返回的是一个 React 组件,并不是经过计算的state.如果要借助 Readux 来完成这个目标? 试试看 我们仍然来构建一个 TodoList,并且保持清晰明了,会使用译注 redux todomvc 的actions 和 todo reducer. 12345678910111213141516// constantsconst ADD_TODO = 'ADD_TODO'const DELETE_TODO = 'DELETE_TODO'// actionsconst addTodo = text =&gt; (&#123;type: ADD_TODO, text &#125;)const deleteTodo = id =&gt; (&#123; type: DELETE_TODO, id &#125;)// reducersconst todos = createReducer([], &#123; [ADD_TODO]: (state, action) =&gt; [ &#123; id: getNextId(state), completed: false, text: action.text &#125;, ...state ], [DELETE_TODO]:(state, action) =&gt; reject(propEq('id', action.id), state),&#125;) 部分原始的reducer 代码通过使用 Ramda的 reject和propEq重构来过滤已经删除掉的 todo条目.万一你想知道reject是什么函数,reject是 filter的补集.我们可以编写一组助手函数: 123456789// redux utils// alternative is to use defaultTo instead propOrconst createReducer = (init, handlers) =&gt; (state = init, action) =&gt; propOr(identity, prop('type', action), handlers)(state, action)const addOne = add(1)const getAllIds = pluck('id')const getMax = reduce(max, 0)const getNextId = compose(addOne, getMax, getAllIds) getNextId是用于获取下一个 id 的函数,在添加新的条目是,需要用到它.createReducer已经在在 Redux的顶层输出中出现了,但是这里的是使用 Ramda重写的版本.现在我们已经有了 reducers和 Action.现在需要适配他们和我们的组件以便于处理添加和删除组件.为了保持简单,我们用一个 add 按钮来代替输入文本添加 todo项文本的操作. 12345const Add = onSave =&gt; ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; onSave('foobar')&#125;&gt;Add&lt;/button&gt; &lt;/div&gt;) 最后还需要一个删除按钮.在 Item组件中添加一个删除按钮就足够了. 12345const Item = (&#123;todo, removeTodo &#125;) =&gt; ( &lt;li key=&#123;todo.id&#125;&gt; &#123;todo.text&#125; &lt;button onClick=&#123;removeTodo&#125;&gt;Remove&lt;/button&gt; &lt;/li&gt;) 需要的部分都已经就绪了.这里仍然有一些部分需要澄清:removeTodo应该 dispatch deleteTodo action. 另一个需要考虑的方面是,我们需要一个方法定义必须要提供的 dispatcher. 现在我们还仅仅是映射 state 到 props. 来添加一个 getRender函数,等待输入应用入口节点,返回一个等待 React 组件的函数. 123const getRender = node =&gt; app =&gt; ReactDOM.render(app, node)const render = getRender(document.getElementById('root'))render(&lt;App &#123;...state&#125; /&gt;) 接下来编写一个 bindActionCreator. 1234// define a bindActionCreatorconst bindAction = curry((dispatch, actionCreator) =&gt; compose(dispatch, actionCreator))const bindActionCreator = bindAction(store.dispatch) 接着隐藏掉 dispatch方法,同时传递bindActionCreator 和 state 到应用,并且订阅到 Redux 的 store,当代触发渲染. 要声明一下, Redux 已经有可以直接使用的 bindActionCreators 函数. 12345const run = store.subscribe(() =&gt; render( &lt;App &#123;...store.getState()&#125; dispatch=&#123;bindActionCreator&#125; /&gt; )) 最后的一些收尾工作是适配 Item和 TodoList 组件, Items 期待 todo条目还有 onDelete函数 123456const Item = (&#123;todo, onDelete&#125;) =&gt; ( &lt;li key=&#123;todo.id&#125;&gt; &#123;todo.text&#125; &lt;button onClick=&#123;() =&gt; onDelete(todo.id)&#125;&gt;Remove&lt;/button&gt; &lt;/li&gt;) 因为现在 Item组件也需要onDelete函数,我们需要适配map to props函数.我们已经获取了 dispatch,所以返回一个todo items 的数组了,需要范湖一个包含 todo数组和onDelete函数的对象. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// for clearer understanding extracted mapItemsconst mapItems = (&#123;todos, onDelete&#125;) =&gt; map(todo =&gt; Item(&#123;todo, onDelete&#125;), todos)const TodoList = pipe(props =&gt; (&#123;todos: props.todos, onDelete: props.dispatch(deleteTodo)&#125;), compose(List, mapItems))``` 下面就是最终的代码,也可以查看[`实例代码`](https://plnkr.co/edit/adPsyH9r6OIjsu9fDhgz?p=preview)```jsimport React from 'react'import ReactDOM from 'react-dom'import &#123; createStore, combineReducers &#125; from 'redux'import * as R from 'ramda'// composition helperconst combine = R.curry((c, o) =&gt; x =&gt; (&lt;div&gt;&#123;c(x)&#125; &#123;o(x)&#125;&lt;/div&gt;))const combineComponents = (...args) =&gt; &#123; const [first, ...rest] = args return R.reduce((acc, c) =&gt; combine(acc, c), first, rest)&#125;// helpersconst targetValue = e =&gt; e.target.valueconst getTodos = R.prop('todos')// redux utilsconst createReducer = (init, handlers) =&gt; (state = init, action) =&gt; R.propOr(R.identity, R.prop('type', action), handlers)(state, action)const addOne = R.add(1)const getAllIds = R.pluck('id')const getMax = R.reduce(R.max, 0)const getNextId = R.compose(addOne, getMax, getAllIds)// constantsconst ADD_TODO = 'ADD_TODO'const DELETE_TODO = 'DELETE_TODO'// actionsconst addTodo = text =&gt; (&#123;type: ADD_TODO, text &#125;)const deleteTodo = id =&gt; (&#123; type: DELETE_TODO, id &#125;)// reducersconst todos = createReducer([], &#123; [ADD_TODO]: (state, action) =&gt; [ &#123; id: getNextId(state), completed: false, text: action.text &#125;, ...state ], [DELETE_TODO]:(state, action) =&gt; R.reject(R.propEq('id', action.id), state),&#125;)const year = createReducer('', &#123;&#125;)const title = createReducer('', &#123;&#125;)// combine reducer and create storeconst reducers = combineReducers(&#123;todos, year, title&#125;)const initialState = &#123; year: '2016', title: 'Random stuff', todos: [&#123;id:1, text: 'foo'&#125;, &#123; id:2, text: 'bar'&#125;]&#125;const store = createStore(reducers, initialState)// componentsconst Header = title =&gt; &lt;h1&gt;A Todo List: &#123;title&#125;&lt;/h1&gt;const Add = (&#123;onSave&#125;) =&gt; ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; onSave('foobar')&#125;&gt;Add&lt;/button&gt; &lt;/div&gt;)const List = items =&gt; &lt;ul&gt;&#123;items&#125;&lt;/ul&gt;const Item = (&#123;todo, onDelete&#125;) =&gt; ( &lt;li key=&#123;todo.id&#125;&gt; &#123;todo.text&#125; &lt;button onClick=&#123;() =&gt; onDelete(todo.id)&#125;&gt;Remove&lt;/button&gt; &lt;/li&gt;)const Footer = text =&gt; &lt;div&gt;&#123;text&#125;&lt;/div&gt;// define a bindActionCreatorconst bindAction = R.curry((dispatch, actionCreator) =&gt; R.compose(dispatch, actionCreator))const bindActionCreator = bindAction(store.dispatch)// map state to propsconst TodoHeader = R.pipe(props =&gt; props.title, Header)const TodoAdd = R.pipe(props =&gt; (&#123;onSave: props.dispatch(addTodo)&#125;), Add)const mapItems = (&#123;todos, onDelete&#125;) =&gt; R.map(todo =&gt; Item(&#123;todo, onDelete&#125;), todos)const TodoList = R.pipe(props =&gt; (&#123;todos: props.todos, onDelete: props.dispatch(deleteTodo)&#125;), R.compose(List, mapItems))const TodoFooter = R.pipe(props =&gt; props.year, Footer)// combine all componentsconst App = combineComponents(TodoHeader, TodoAdd, TodoList, TodoFooter)// we could also have used curry...const getRender = node =&gt; app =&gt; ReactDOM.render(app, node)const render = getRender(document.getElementById('root'))const run = store.subscribe(() =&gt; render(&lt;App &#123;...store.getState()&#125; dispatch=&#123;bindActionCreator&#125; /&gt;))// startconst init = store.dispatch(&#123;type: '@@INIT'&#125;) Outro这篇文章的目的是介绍如何联合 Ramda,React和 Redux来编写更加优雅的代码.例子只是用来说明如何在React 或者 Redux 中使用 Ramda.在实际的编程中,你可以在应用的某些部分借助Ramda或者 lodash/fp 来编写优雅的代码. 例如可以重构mapDispatchToProps函数,根据定义好的 propTypes自动映射 state到应用的props,代替手动输入. 12345const getPropTypes = prop('propTypes')const pickKeys = compose(pick, keys)const mapStateToProps = compose(pickKeys, getPropTypes)// map state to defined propTypes.export default connect(mapStateToProps(App))(App) 也可以使用 Ramda 的 pick函数替代 mapDispatchToProps 函数. 1export default connect(pick(['todos']))(App) If you have any questions or feedback don’t hesitate to leave feedback @ twitter. 这篇文章受到Brian Lonsdorf 在 React Rally上演讲的启发.","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"javascript","slug":"javascript","permalink":"https://React-Apollo.github.io/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"hoc","slug":"hoc","permalink":"https://React-Apollo.github.io/tags/hoc/"}]},{"title":"Cnoder 项目列表","slug":"Cnoder 项目列表","date":"2018-01-29T12:21:07.000Z","updated":"2018-04-07T02:42:18.247Z","comments":true,"path":"2018/01/29/Cnoder 项目列表/","link":"","permalink":"https://React-Apollo.github.io/2018/01/29/Cnoder 项目列表/","excerpt":"","text":"内容 项目内容 文件结构 项目内容文件结构根据 F8APP的文件结构做了文件夹重新安排, 从导航触发,这里不会提前登陆, 只有导航到my Tab时点击登录才会通过github登录.每个 tab 下面是 StackNavigator,这样导航就是树形结构, 每个 tab作为父节点, 下面的导航是专项的, 有公用的作为 publicRoute的形式,导入每个 tab下面.例如几个地方会用到 detail页面,这个作为公共的导航页面,放到 common文件夹下.还有 Utils工具,commonent组件","categories":[{"name":"Readme","slug":"Readme","permalink":"https://React-Apollo.github.io/categories/Readme/"}],"tags":[{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"},{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"node.js","slug":"node-js","permalink":"https://React-Apollo.github.io/tags/node-js/"},{"name":"expo","slug":"expo","permalink":"https://React-Apollo.github.io/tags/expo/"}]},{"title":"Prisma|GraphQL Server Basics-networklayer","slug":"Prisma|GraphQL Server Baiscs:Network layer","date":"2018-01-28T08:17:07.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/01/28/Prisma|GraphQL Server Baiscs:Network layer/","link":"","permalink":"https://React-Apollo.github.io/2018/01/28/Prisma|GraphQL Server Baiscs:Network layer/","excerpt":"","text":"","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphql","slug":"Graphql","permalink":"https://React-Apollo.github.io/tags/Graphql/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"博客模板","slug":"博客模板","date":"2018-01-28T08:17:07.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/01/28/博客模板/","link":"","permalink":"https://React-Apollo.github.io/2018/01/28/博客模板/","excerpt":"","text":"","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"Prisma服务器构建","slug":"Prisma远程服务器部署问题备忘","date":"2018-01-27T13:18:28.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/01/27/Prisma远程服务器部署问题备忘/","link":"","permalink":"https://React-Apollo.github.io/2018/01/27/Prisma远程服务器部署问题备忘/","excerpt":"","text":"缘由 准备使用Prisma的服务，本来觉得是Graphcool的升级版本，没有什么问题，但是碰到很多问题，奋战一晚，都要睡着了，node.js服务器的报错信息一条都没有了。还是很值得的 在stackflow一搜，有同样问题的人很多。 其实问题很简单，主要的祸首就是Prisma引入的token,原来graphcool没遇到过要toke的情况。 流程安装步骤 全局安装prisma — prisma init projectName 进入server目录 — cd server. 部署 ———— prisma deploy 获得endpoint地址 启动本地服务——- 回到项目目录 ，yarn start 获得本地服务 获取token——– prisma token 最坑人的地方是获取token， 用playground的时候需要token，stackflow中很多人遇到这个问题。要在header中设置.12&#123; \"Authorization\": \"Bearer --token放这里，并删掉短杠--\"&#125; 后面在使用node服务器的时候也要配置 schema的配置这里还是不太熟悉，新的版本是有优势，但是还没发挥出来，在选择部署的时候，如果是全栈的full stack 的模式，很容易误导人,在movie这个服务器里干脆放弃了，直接使用服务器，结果没有产生歧义，在database中的data.model.graphql中添加shcema从某网站抓取数据的保存的schema123456789101112131415type ReactScript &#123; id:ID! @unique title:String url: String funcCat:String platformCat:String dateUpdate:String comments:String img: String excerpt:String demoUrl: String tag1: String tag2: String tag3: String&#125; 添加完成后，重新部署，然后，使用地址登录graphiql服务。 这个就遇到为了。要输入上面的token,才行。 输入以后token以后， 如果在右端的schema中看到有 ReactScript出现，配置就算完成了， 牢记以shcma为中心，schema中有什么数据结构才可以查询，有什么方法才可使用。配置的方法和结构和预期不一样，根本没有必要进行下去，只会让问题更加的复杂。 schema是一个分水岭，昨天东查查，西看看，浪费不少时间，先在这里把问题做切割。 然后使用手工配置的参数，完成CRUD的操作，看看发方法，模型等是否正常。 如果这里都正常了，但是服务端还有问题，那么根源在后面，prisma就没有什么问题了。 node.js graphql-request的使用这里要配置查询的标签，对着prisma的schema逐个查看，就没有什么问题。 node.js中可能会出现两种错误提示 无法访问服务器， tokent，无效，需要配置，还有现在的endpoint都有/dev后缀， 使用时要留心。 提示查询类型不对， 查询的标签有问题，一定对着查看。 在prisma的版本中，带参数的查询，有点改动，参数之前带了一个data:{}， 使用也要注意检查。 这样基本就没有什么问题了node.js的代码段","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"},{"name":"Prisma","slug":"Prisma","permalink":"https://React-Apollo.github.io/tags/Prisma/"}]},{"title":"使用Expo,Apollo-client,graphcool构建Cnode APP","slug":"使用Expo,Apollo-client,graphcool构建Cnode APP","date":"2018-01-26T08:53:28.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/01/26/使用Expo,Apollo-client,graphcool构建Cnode APP/","link":"","permalink":"https://React-Apollo.github.io/2018/01/26/使用Expo,Apollo-client,graphcool构建Cnode APP/","excerpt":"","text":"项目起因 技术流程已经建立了，这几天在构建express-mongodb-graqhql的服务器器，花了很长时间，回过头来看又快忘了，感觉到了现在的阶段，人老了，理解能力还是有的，但是记忆力确实不行了。千万要详细记录，要不然就白学很多东西了。 记录越详细越好。 项目缘由主要是三大块，中间始终贯穿函数式编程的想法，但是有些没有实现 Graphcool(Prisma）在Medium网站查找Ramda的文章，结果首页给我推送，apollo,graphcool的文章，graphcool的图标是绿色的，天生有好感，就想看看到是干什么的，因为前面想着手翻译, 这两个技术也很新，所以花了很长时间研究，但是最终没有翻译，感觉到Relay的前景并不是很好，但是最近看Relay还在不断的演化，背靠FB,的确在人才上面和技术上有很大的优势。 但是这个月最终Apollo-Graphcool的构架已经彻底征服了我。 其实选择什么框架并不是什么大问题，没有涉及到核心的问题。这些框架的核心是所有的东西都围绕着GraphQL的Schema来展开。刚开始在使用graphcool的Resolver(解析函数)包装Cnode的api的时候，觉得在定义的时候添加schema一项是多余的。但是随着学习，我发现，GraphQL的威力就在schema上，有了schema，数据的查询就很厉害了。 所有后边的学习重点就围绕schema展开。Graphcool 1.0版本，代号已经改为Prisma.最终要在这里导入CNODE 的API. 根据Graphcool服务器的schema来进行各项操作 ApolloApollo 这个构架是在看meteor的时候就已经知道，所以在Medium网站推送时，相关内容也来来，随便看了一下，没有什么概念， 突然就在SegmentFault网上看到一个系列的文章，突然感觉就入门了，这个系列的文章，提到Apollo的客户端在执行异步请求是，是从网络层抽象的，幸运，CCNA满分，很快理解这个构架的优势。Redux中异步请求时的flag突然就没有了，因为这个flag可以直接从请求的网络状态获得，网络层的请求本来就有几个状态。 这个地方解决的太巧妙。 由此就开始了Apollo构架的学习，这个构架实际也包括server，但是所有的server和graphcool相比都逊色不少，配置graphcool的服务器几乎没有花费任何的学习时间，除了resolver的编程。 后面又看到这篇文章未来的状态管理技术.的确是有未来状态管理的潜力，Redux与之相比有点啰嗦了。其实Redux的技术构架核心，我认为有三个： 单一事实来源(数据单向流动)， Reducer函数(数据Immutable)， Container(数据注入方式) 衍生出的Action和很多中间件都是为之服务的。 所以只要具有核心可以了，在未来状态的管理技术中提到的apollo-link-state这个技术就是依次而生， 本地20%的state和80%的远程数据合二为一，React组件中的所有Action(函数)都依据graphql的shcema干活，如果是本地数据@Client指令就会阻止Action执行远程的请求，只能用于本地的数据访问。 可以简单理解，在Apollo的Store中只加了一个标记就解决了这个问题。 Apollo的技术构架还在不断的演化，前面我的思想中强烈的Redux正统思想和Apollo的进步思想一直打架，毕竟在Redux上花了太多的时间和精力，收获还不大。 要舍弃Reducx太难，没办法技术进步太快，要勇于学习新的知识。 说道这里，看到有的文章简介说什么javascript疲劳，现在来看根本没有这回事情。 应该称之为选择性疲劳，除了为了框架而框架的项目，但凡GitHub评价很高的项目诞生都是有原因的。了解了技术诞生的原因，就学习就比较简单了。比如前面看了一下Eixlir的东西，没什么概念，为什么会有这么一个语言会存活呢？ 原因就是为了处理高并发和稳定性。 这几天突然想，我已经建了好几个graphcool的服务器，那么如果是我想把这几个服务器用在一个项目呢？例如：从一组关键字[‘js’,’ramda’,’redux’,’react’]中查询结果，那么可以不可以用一个总的服务器来接受查询项目，然后下发给子graphcool.这样效果是不是会更好？ 总的服务器用’Express’可以，Eixlir是不是就是为此而生的？ 所以学习Eixlir的缘由和目标就有了。 Expo RN的启动项目RN本机的配置实在是太麻烦，iOS还好一点，直接装Xcode就可以了，安卓的就不好搞，Expo就是为此而生。 直接create-react-naive-app就生成 Expo-RN项目，手机安装Expo软件，扫码就可以进行调试了。实在是简化了操作。 但是Expo也有自己的问题，它打包了一些子代服务，你用不用都有，所以即使hello world项目也有二十多兆，很大。 我的想法是在expo里使用和调试，但是不用expo自己封装到组件，直接自己安装， 需要的时候可以迁移JS文件的正式的RN项目中。 CNODE的这个expo项目已经有了一些内容实现，所以趁还没忘，记录一下流程和代码。 项目流程Graphcool服务构建服务器初始化这个实在是太简单. graphcool init :安装依赖包 graphcool deploy ：部署，本地部署需要docker,mac下的docker用抢先版就可以，远程部署，直接选择就可以了新的版本Prisma命令稍微有点改动 获取数据库endpoint。随时可以在项目文件夹中用graphcool info查看部署信息 创建schemagraphql服务器是以shcema为核心的，schema对于字段类型，和执行方法都有严格的约束，这里严格后面的操作就轻松。参照Graphcool-framework 的做法 定义scheme123456789101112131415161718//对于查询cnode api的信息字段的约束条件type AllCnodePayload &#123; id: String! tab: String title: String! visit: Int! aurl: String! author_id: String!&#125;input QueryInput &#123; page: Int! tab: String!&#125;extend type Query &#123; allCnode(page: Int!, tab: String!): [AllCnodePayload!]!&#125; 在type定义里并没有返回cnode API的 content字段信息。 如果在前端显示列表，content基本是不需要的，或者有需求需要显示摘要， 可以在resolver的时候，做处理。这样做，graphcool 服务器从api获取的数据虽然包含有content,但是我们用schema过滤掉了。 客户端请求时的数据量就减少了。这个地方体现的就是graphql的灵活性。 在Query,中定义了查询时可以传递的参数。这里没有做关联，实际是可以做关联的。在Hotel-GeoData的项目中有数据的关联操作。 tab参数是用于分类查询的，page这个参数用于分页，由于apollo-client做了很多工作，客户端的分页变得很简单，实际只要处理这个一个参数既可以了，返回的数据和原先的数据拼接在一起就可以了。有一点要注意：如果是client,schema和这里的还不太一样，例如 123456789101112131415161718192021222324query getFirstPageInformation&#123; all: allCnode(page:1,tab:\"\")&#123; id, title &#125;, share: allCnode(page:1,tab:\"share\")&#123; id, title &#125;, job: allCnode(page:1,tab:\"job\")&#123; id, title &#125;, dev: allCnode(page:1,tab:\"dev\")&#123; id, title &#125; getWeatherByCity(city:\"Beijing\")&#123; temperature, humidity, &#125; &#125; 上面内容拷贝到下面左侧框中，点击执行就可以看到结果 客户端的schema可以集各家之大成，一次查询获取所有数据，http只需要做一次请求。 Resolver函数对于放在REST API之前的 graphcool 服务器， Resolver是核心， 从API获取的信息，在这里根据shcema做处理， 之后就可以使用graphql的各种优点来进行操作。如果认为Graphcool只是做了REST API的代理，认识是非常肤浅的。从Cnode REST API 获取数据并处理的Resolver函数 1234567891011121314151617181920212223242526272829303132require('isomorphic-fetch');const R = require('ramda');const url = 'https://cnodejs.org/api/v1/topics';module.exports = (event) =&gt; &#123; const &#123; tab, page &#125; = event.data;//这里就是查询的参数， //在graphiql，在查询关键词后添加参数，客户端通过apollo-client传递 urlWithParams = `$&#123;url&#125;?tab=$&#123;tab&#125;&amp;page=$&#123;page&#125;`; let options = &#123; method: 'GET' &#125;; return fetch(urlWithParams, options).then((response) =&gt; response.json()).then((responseData) =&gt; &#123; const NodeList = responseData.data; const allCnode = []; //去毛处理 const selectPropertyX = (x) =&gt; (&#123; id: x.id, tab: x.tab, aurl: 'https://randomuser.me/api/portraits/thumb/men/97.jpg', visit: x.visit_count, title: x.title, author_id: x.author_id &#125;); const allCnode = R.map(selectPropertyX, NodeList); //const getIdcollections=R.curry(R.map(selectPropertyX,data)); //const allCnode=getIdcollections(NodeList); return &#123; data: allCnode &#125;; &#125;);&#125;; graqhiQL测试graphql优点是带有一个GraphiQL的可视化界面，可以在这里测试一下查询，用上面的代码块可以获得数据 1234567891011121314151617181920212223&#123; \"data\": &#123; \"getWeatherByCity\": &#123; \"temperature\": -4.87, \"humidity\": 93 &#125;, \"all\": [ &#123; \"id\": \"5a2403226190c8912ebaceeb\", \"title\": \"企业级 Node.js 框架 Egg 发布 2.0，性能提升 30%，拥抱 Async\" &#125;, &#123; \"id\": \"5a54a8a4afa0a121784a8ab0\", \"title\": \"玉伯《从前端技术到体验科技（附演讲视频）》\" &#125;, &#123; \"id\": \"592917b59e32cc84569a7458\", \"title\": \"测试请发到客户端测试专区，违规影响用户的，直接封号\" &#125;, &#123; \"id\": \"5a6a47119d371d4a059eee66\", \"title\": \"北京求推荐一个好的node线下培训课程\" &#125;, 上面这个的结果实际是来自两个api的，一个是cnode客户端，一个是天气查询的api.一次查询就返回了结果。 这就是graphql的魅力所在。 Expo RN APP 编程使用Create-react-native-app方法构建导入组件有 导航 react-navigation 组件库 react-elements 样式库 styled-components 太牛了，这实际也是函数式编程库 函数式编程库： Ramda, recompose库 主要的思想上的变化是使用函数式编程库。 styled-components的作者问了一个问题，如果函数式编程风格的React组件是无状态组件(函数)，样式也是函数呢？ 由于刚好在学习函数式编程，感觉到黑暗中找到了明灯。 这不就是高阶函数吗？， 样式也可以通过函数传递了。 背后的英雄还是闭包。自从学习了Ramada的规范，即每个函数只解决一个问题， 函数链从右向左，数据从右边开始传递，之后，感觉以前一团乱麻的想法，慢慢清晰了。 在这个地方，思考问题自动分解了，其实从整体看一团乱麻， 单个函数处理问题并不乱。 引入函数式编程的好处真是无可比拟。 在编程中处理的核心数据结构是数组(Ramda叫List)和对象。围绕这个这两个方面，Ramda有一堆的工具可供使用。 R.curry,R.compose,R.reduce是绝对的核心。 思想方法是分解问题，制造和配置生产零件，然后compose成工厂。 在Ramda模式下 compose成的工厂会给在右边留下一个入口，从右边输入猪肉，左边就会后香肠出来。 柯理化和js的闭包在制造和配置生产函数时时直观重要的。我一再的强调配置性 由于高阶函数的特性，函数可以作为参数传递，所以可以传递行使不同功能的函数来配置成执行不同功能的零件，在背后是js函数闭包负责把配置给你保存起来，备用。 js的函数可配置性使得js中可以使用函数组合成各种不同的工厂，只需要传递数据给它即可工作。 APP 中引入Apollo-client数据层入口文件引入apollo-client的包和Graphql的 endpointExpo/app.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import React from 'react'import &#123; StyleSheet &#125; from 'react-native'import &#123;TabNavigator, StackNavigator, DrawerNavigator&#125; from 'react-navigation'import &#123; ApolloProvider &#125; from 'react-apollo'import &#123; ApolloClient, HttpLink, InMemoryCache &#125; from 'apollo-client-preset'import My from './app/My'import Message from './app/Message'import Post from './app/Post'import Editor from './app/Editor'import &#123;MyNotificationsScreen, MyHomeScreen&#125; from './app/Drawer'import Topic from './app/Topic'import Collection from './app/Collection'const Drawer = DrawerNavigator(&#123; Home: &#123; screen: MyHomeScreen , &#125;, Notifications: &#123; screen: MyNotificationsScreen , &#125;,&#125;)const tabNavigator=TabNavigator(&#123; 主题: &#123; screen: Collection, &#125;, Notifications: &#123; screen: Message, &#125;, Add:&#123; screen: Editor, &#125;, My:&#123; screen: My, &#125;, 收藏:&#123; screen :Topic &#125;&#125;, &#123; tabBarPosition: 'bottom', animationEnabled: true, tabBarOptions: &#123; activeTintColor: '#e91e63', &#125;,&#125;)const Navigator = StackNavigator(&#123; Home: &#123; screen: tabNavigator, navigationOptions: &#123; title: 'Info', &#125;, &#125;, Detail: &#123; screen: Post &#125;, //Setting: &#123; sreen: Drawer&#125;, &#125;)//graphcool 服务器的urlconst httpLink = new HttpLink(&#123; uri: 'https://api.graph.cool/simple/v1/cjaxudkum2ugf0127kok921bc' &#125;)//构建client对象const client = new ApolloClient(&#123; link: httpLink, cache: new InMemoryCache(), connectToDevTools: false&#125;)//包装对象注入顶层组件，如果你还要使用Redux,在包装一下，也没有问题。//分别是两个不同的对象而已。export default class App extends React.Component &#123; render() &#123; return ( &lt;ApolloProvider client=&#123;client&#125;&gt; &lt;Navigator /&gt; &lt;/ApolloProvider&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, backgroundColor: '#fff', alignItems: 'center', justifyContent: 'center' &#125;&#125;) 配置其实很简单， 在顶层组件注入apollo-client的对象就可以了。redux的其他的文件夹全没有了。apollo-client可以和Redux一起工作， 在顶层组件中再次引入Redux的store,也没有问题。因为这两者是独立的。 像是同一个写字楼里的两家公司，虽然在一起，但是各干个的工作，但是也有使用相同组件的地方，例如两家公司可以同时使用一个卫生间。公家的东西显然大家都不太爱惜，很不好。如果两个公司合二为一呢？ 那就好了。 Apollo的团队想到了这个问题。apollo-link-state就把两拨统一了。 不详细讲，准备翻译apollo的文档了。 组件中的apollo-client的使用cnode列表组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import React, &#123; Component &#125; from 'react';import &#123; View, Text, FlatList,Button&#125; from 'react-native';import &#123; List, ListItem ,Header&#125; from 'react-native-elements';import Dropdown from './Drowdown';//导入graphql组件，具体使用在代码最后import &#123; graphql &#125; from 'react-apollo';//tag 用于拼接graphql的语句import gql from 'graphql-tag';//拼接的语句，这个语句的效果和在graqhiQL中使用效果是一样的//查询所有文章的id,title等，schema定义什么就可以返回什么const allNodesQuery = gql` query($page:Int!,$tab:String!) &#123; allCnode(page:$page,tab:$tab) &#123; id title tab aurl &#125; &#125;`;//文章列表组件 class Topic extends Component &#123; state = &#123; page: 1, tab: \"\", &#125; render() &#123; const &#123;navigate&#125; = this.props.navigation;//react- //navigation的导航对象，其实这个就和Redux的store一样，顶层导入的 //所有的子组件可以使用 console.log(this.props) //props会有需要的数据 //apollo-client神奇的地方， 请求数据的flag借用的是网络层的数据 //由于这里天然就带有各种状态标记，直接使用就可以了 //networkStatus===1表示正在请求数据 if(this.props.networkStatus===1)&#123; return ( &lt;View&gt; &lt;Text&gt;Loading...&lt;/Text&gt;&lt;/View&gt; ) &#125; return ( &lt;View&gt; &lt;Header outerContainerStyles=&#123;&#123;marginTop:0,zIndex:9999&#125;&#125; leftComponent=&#123;&lt;Button title=&#123;'setting'&#125; onPress=&#123;(props)=&gt; this.props.refetch(&#123; page:1, tab:\"job\" &#125;) &#125; /&gt;&#125; centerComponent=&#123;&#123; text: 'MY TITLE', style: &#123; color: '#fff' &#125; &#125;&#125; rightComponent=&#123;&lt;Dropdown refetch=&#123;this.props.refetch&#125;/&gt;&#125; /&gt; &#123;(this.props.networksStatus===2)&amp;&amp;&lt;View style=&#123;&#123;flex:1,alignItems:'center',justifyContent:'center',zIndex:999,opacity:0.8&#125;&#125;&gt; &lt;Text&gt;Loading...&lt;/Text&gt; &lt;/View&gt;&#125; &lt;List containerStyle=&#123;&#123; borderTopWidth: 0, borderBottomWidth: 0,marginTop:0 &#125;&#125;&gt; &lt;FlatList data=&#123;this.props.allCnode&#125; renderItem=&#123;(&#123; item &#125;) =&gt; ( &lt;ListItem roundAvatar refreshing=&#123;this.props.networkStatus === 4&#125; onRefresh=&#123;() =&gt; this.props.refetch()&#125; title=&#123;`$&#123;item.title&#125;`&#125; subtitle=&#123;`$&#123;item.tab&#125;`&#125; avatar=&#123;&#123; uri: item.aurl &#125;&#125; containerStyle=&#123;&#123; borderBottomWidth: 0 &#125;&#125; onPress=&#123;() =&gt; navigate('Detail',&#123;id:`$&#123;item.id&#125;`&#125;)&#125; /&gt; )&#125; keyExtractor=&#123;item =&gt; item.id&#125; onEndReachedThreshold=&#123;0.5&#125; onEndReached=&#123;() =&gt; &#123; // The fetchMore method is used to load new data and add it // to the original query we used to populate the list this.props.fetchMore(&#123; variables: &#123; page: this.props.allCnode.length + 1,tab:\"share\"&#125;, updateQuery: (previousResult, &#123; fetchMoreResult &#125;) =&gt; &#123; // Don't do anything if there weren't any new items //console.log(fetchMoreResult) if (!fetchMoreResult || fetchMoreResult.allCnode.length === 0) &#123; return previousResult; &#125; return &#123; // Concatenate the new feed results after the old ones allCnode: previousResult.allCnode.concat(fetchMoreResult.allCnode), &#125;; &#125;, &#125;); &#125;&#125; /&gt; &lt;/List&gt; &lt;/View&gt; ); &#125; &#125;//这里是graphql注入组件的位置//options就是初始的参数//props可以用map方法进行筛选aooNodesQuery是查询语句export default graphql(allNodesQuery,&#123; options: &#123; variables: &#123; page:1, tab:\"\" &#125;, &#125;, props: (&#123; ownProps, data: &#123; loading, allCnode, refetch,fetchMore,networkStatus,updateQuery&#125; &#125;) =&gt; (&#123; Loading: loading, allCnode: allCnode, refetch: refetch, fetchMore: fetchMore, networkStatus: networkStatus, updateQuer: updateQuery &#125;),&#125; )(Topic); 上面代码的要点是 使用了网络层的状态来表示请求的状态 组件传递了apollo 对象子代的属性方法，refetch用于重新设定 查询的tab. &lt;FlatList data={this.props.allCnode} 列表组件只需要传入这个数据属性 Item组件解析对象属性,点击即可进入下一页。 具体内容的schema和列表是一差不多的 12345678910&lt;ListItem roundAvatar refreshing=&#123;this.props.networkStatus === 4&#125; onRefresh=&#123;() =&gt; this.props.refetch()&#125; title=&#123;`$&#123;item.title&#125;`&#125; subtitle=&#123;`$&#123;item.tab&#125;`&#125; avatar=&#123;&#123; uri: item.aurl &#125;&#125; containerStyle=&#123;&#123; borderBottomWidth: 0 &#125;&#125; onPress=&#123;() =&gt; navigate('Detail',&#123;id:`$&#123;item.id&#125;`&#125;)&#125; /&gt; 如果列表到了末端.page变量加 1 variables: { page: this.props.allCnode.length + 1,tab:&quot;share&quot;} 数据返回以后和之前的数据拼接就可以了 allCnode: previousResult.allCnode.concat(fetchMoreResult.allCnode) 1234567891011121314151617onEndReached=&#123;() =&gt; &#123; // The fetchMore method is used to load new data and add it // to the original query we used to populate the list this.props.fetchMore(&#123; variables: &#123; page: this.props.allCnode.length + 1,tab:\"share\"&#125;, updateQuery: (previousResult, &#123; fetchMoreResult &#125;) =&gt; &#123; // Don't do anything if there weren't any new items //console.log(fetchMoreResult) if (!fetchMoreResult || fetchMoreResult.allCnode.length === 0) &#123; return previousResult; &#125; return &#123; // Concatenate the new feed results after the old ones allCnode: previousResult.allCnode.concat(fetchMoreResult.allCnode), &#125;; &#125;, 整个数据数据流程就建立完成了","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"},{"name":"cnode","slug":"cnode","permalink":"https://React-Apollo.github.io/tags/cnode/"},{"name":"expo","slug":"expo","permalink":"https://React-Apollo.github.io/tags/expo/"},{"name":"graphcool","slug":"graphcool","permalink":"https://React-Apollo.github.io/tags/graphcool/"}]},{"title":"Rename key of Object","slug":"Rename keys of  Obj","date":"2018-01-26T07:25:28.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/01/26/Rename keys of  Obj/","link":"","permalink":"https://React-Apollo.github.io/2018/01/26/Rename keys of  Obj/","excerpt":"","text":"函数签名：{a:b}-&gt;{a:*}-&gt;{b:*}关键点是{oldkey: newkey} 步骤是： 使用R.key(obj) 取出对象的键作为数组 使用R.assoc把要转换键名的对象复制空对象中 使用R.reduce函数遍历函数，改变键名 难点： R.assoc可以改变或者添加新属性，第一个参数为要改变或者添加的属性，第二个参数为属性值，第三个为对象 1R.assoc('c', 3, &#123;a: 1, b: 2&#125;); //=&gt; &#123;a: 1, b: 2, c: 3&#125; reduce的使用，reduce是Ramda中应用最广泛的函数 1R.reduce((acc, key) =&gt; R.assoc(keysMap[key] || key, obj[key], acc), &#123;&#125;, R.keys(obj)) R.keys取出对象的键名(属性名)最为遍历的数组，原始对象并没有通过参数传递，通过键名几可以访问属性值 R.reduce函数中的三个位置，一是R.assoc函数,用于转换的函数，{}为初始值，R.key(obj)为原始对象的键名组成的数组 刚开始第一步，对象为空， R.assoc第一个参数为keysMap[key]，keyMap的定义为{oldkey:newkey}，所以keysMap[key]取出的就是新的键名，obj[key]就是原对象中的属性值， 复制到空对象中。key在keyMap中出现，就用旧的键(keyMap[key]||key).第一步可以分解为：1R.assoc(newKey, value, &#123;&#125;) 这样就把第一个对象属性名改变，并存入到新的空对象中接下来的方式就是Reduce的标准模式了。 这个方法有点绕，绕着绕着就明白了。","categories":[{"name":"Ramda-cookbook","slug":"Ramda-cookbook","permalink":"https://React-Apollo.github.io/categories/Ramda-cookbook/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://React-Apollo.github.io/tags/javascript/"},{"name":"Ramda","slug":"Ramda","permalink":"https://React-Apollo.github.io/tags/Ramda/"},{"name":"fp","slug":"fp","permalink":"https://React-Apollo.github.io/tags/fp/"}]},{"title":"从jb51抓取数据并存入mlab数据库","slug":"从jb51抓取数据并存入mlab数据库","date":"2018-01-25T22:18:28.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/01/25/从jb51抓取数据并存入mlab数据库/","link":"","permalink":"https://React-Apollo.github.io/2018/01/25/从jb51抓取数据并存入mlab数据库/","excerpt":"","text":"目标从jb51抓取数据，并且存入到mlab数据库。 这里没有经过graphql服务器，后面马上会改进","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"fp","slug":"fp","permalink":"https://React-Apollo.github.io/tags/fp/"},{"name":"Express","slug":"Express","permalink":"https://React-Apollo.github.io/tags/Express/"},{"name":"mongodb","slug":"mongodb","permalink":"https://React-Apollo.github.io/tags/mongodb/"}]},{"title":"使用函数式异步compose方法给graphcool数据库批量导入数据(2)","slug":"使用函数式异步compose方法给graphcool数据库批量导入数据(2)","date":"2018-01-24T17:20:28.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/01/24/使用函数式异步compose方法给graphcool数据库批量导入数据(2)/","link":"","permalink":"https://React-Apollo.github.io/2018/01/24/使用函数式异步compose方法给graphcool数据库批量导入数据(2)/","excerpt":"","text":"异步compose方法批量导入数据流程 解决链式数据流程的异步流程同步化办法 问题在https://react-apollo.github.io/2018/01/24/构建基于MongoDB的%20graphql%20服务器(四)/)已经实现了了数据的流程，但是具体的处理方法上很不Ramda,经过连夜奋战，但是问题存在：对于async/await的基础流程不太清楚，所以绕了弯路，console.log会报错，但是结果是插入数据库了，问题在刚开始console.log，抓取的事件还没有完成在获取函数之后打印是没问题的，但是在获取函数之内就出问题，原因在于远程获取函数之内的打印并没有受到async的控制。 解决办法 终于在网上找到一个异步版本的compose函数，解决了这个问题。comopse函数组合的子函数都要是添加await关键字的，这样做，从流程：远程数据=&gt;数据去毛=&gt;插入数据库的路程才可以顺序执行。正常的流程是这样。因为js的事件轮训机制， 数据去毛的过程可能在数据没有返回(网络请求有延迟)的情况下就会执行，这样就获取不到数据，但是在远程数据回来以后就会有结果了，所以这里的数据去毛，还有数据库插入数据的操作会提示输入参数undefined,但是结果是可以运行的。异步版本的compose函数 12345 // Async composeconst compose = （...functions) =&gt; input =&gt; functions.reduceRight((chain, func) =&gt; chain.then(func), Promise.resolve(input));// Functions fn1, fn2, fn3 can be standard synchronous functions or return a Promisecompose(fn3, fn2, fn1)(input).then(result =&gt; console.log(`Do with the $&#123;result&#125; as you please`)) 异步版本的compose的关键点是使用reduce函数组合子函数时，reduce是异步版本，简单说给就是把每个函数都变为promise对象 直接从json文件获取的数据批量插入现在这个版本是使用了Gdom-基于graphql和python的页面抓取工具 从medium网站获取数据的查询语句(具体细节省略了，不能作为实际的使用，类型大致如此)12345678910111213&#123; page(url: \"https://mediumq=graphcool\") &#123; items: query(selector: \"div\") &#123; title: text(selector: \"div h3\") subTitle: text(selector: \"div h4\") url:attr(selector:\"div a\",name:\"href\") shortPassage: text(selector: \"div p\") avatarImage:attr(selector:\".postMetaInline-avatar img\"name:\"src\") authorName: text(selector: \"postMetaInline:first-child\") clap: text(selector: \"div .js-actionMultirecommendCount \") &#125; &#125;&#125; 异步版本的数据操作流程实际是和前面的版本是相同的，只是compose函数是异步的。第一步从网站抓取数据是异步的，第三步插入graphcool数据库是异步的。所以传统的compose函数就不能使用了。需要使用异步的compose。 获取数据的方法简单讲就是graphql 版本的get和post方法1234567//柯理化版本以便于后面构造composeconst handleGrqphcoolDataTemplate = R.curry((api, template, variables) =&gt; ( request(api, template, variables).then(data =&gt; &#123; //console.log(data.page.items); return data &#125;))) 具体的数据流代码12345678910111213141516171819202122232425262728// #获取数据的方法-简单描述就是graphql版的get和post方法，只要是和const handleGrqphcoolDataTemplate = R.curry((api, template, variables) =&gt; ( request(api, template, variables).then(data =&gt; &#123; //console.log(data.page.items); return data &#125;)))/** ++第一步构建从medium网站通过grapql查询获取方法的工厂++从Medium 网站获取数据的方法是一样的的，柯理化是处理参数不同,抓取变量是网站地址抓取后的数据作为insertDataWaitForData的数据工厂组装完成，只等待传入medium的网址就可以工作了 **/const getDataFromMediumWaitForUrl = handleGrqphcoolDataTemplate(graphqlUrlForRemoteData, schemaForGetDataFromRemote)/* ++第二步构建的工厂专门拔猪毛 毛🐽变光🐷，等待光🐽 */const getArray = (obj) =&gt; obj.page.items// 柯理化 等待抓取的数据const graphqlRequestMethodWaitForData = handleGrqphcoolDataTemplate(api, qu)/*++第三步插入数据的graphcool操作++ 由于是从数组获取的数据，这里就使用map方法进行遍历处理*/const insertDataWaitForData = R.map(graphqlRequestMethodWaitForData)//异步的compose函数const compose = (...functions) =&gt; input =&gt; functions.reduceRight((chain, func) =&gt; chain.then(func), Promise.resolve(input))//构建的整个流程的工厂const insertData = compose(insertDataWaitForData, getArray, getDataFromMediumWaitForUrl)","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"Ramda","slug":"Ramda","permalink":"https://React-Apollo.github.io/tags/Ramda/"}]},{"title":"构建基于MongoDB的 graphql 服务器(四)","slug":"构建基于MongoDB的 graphql 服务器(四)","date":"2018-01-24T04:50:28.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/01/24/构建基于MongoDB的 graphql 服务器(四)/","link":"","permalink":"https://React-Apollo.github.io/2018/01/24/构建基于MongoDB的 graphql 服务器(四)/","excerpt":"","text":"构建基于MongoDB的 graphql 服务器(四) 设想是给graphcool数据库提供一些数据，考虑最近看Medium网站较多，所以抓取这里边的信息. 方法和前面的大同小异， 这里实际算是一个完整的流程了。 使用gDom的grqhql方法选择dom元素。 根据Dom元素来定graphql查询中shcema 数据消毒处理 通过graphcool的方法，插入数据库 难点是schema的建立，和两个主操作的异步处理问题，使用了flow方法，让以异步流程转为类似compose的以异步方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/***************** * 从medium抓取一下感兴趣的内容，放到app中 * *******************/'use strict'import express from 'express'// import bodyParser from 'body-parser'import cors from 'cors'import * as R from 'ramda'import &#123; request &#125; from 'graphql-request'import mediumData from '../dist/mediumData'// 导入的数据// import new_hotel from '../dist/new_hotel'// var fs = require('fs')// var path = require('path')const mediumUrl='https://medium.com/search?q=React-native';const variables = &#123; url: 'https://medium.com/search?q=hoc',&#125;const gDomApi='http://gdom.graphene-python.org/graphql';const URL = 'http://localhost'const PORT = 3001// graphcool endpointconst api = 'https://api.graph.cool/simple/v1/cjcrwz0tg3jyf0153l824cpyh'var _ = require('lodash');var flow=require('nimble');var Promise = require(\"bluebird\");// graphql模板const mu = `mutation getMediumList( $title:String!, $subTitle:String!, $authorName:String!, $avatarImage: String!, $shortPassage:String!, $url: String!, $clap: String!)&#123; createMedium( title:$title, subTitle:$subTitle, authorName:$authorName, avatarImage:$avatarImage, shortPassage:$shortPassage, url: $url, clap:$clap, )&#123; id, title &#125;&#125;`const que =`query getMedium($url:String!)&#123; page(url: $url) &#123; items: query(selector: \"div.js-postListHandle .js-block\")&#123; title: text(selector: \"div h3\") subTitle: text(selector: \"div h4\") url:attr(selector:\"div .postArticle-content a\",name:\"href\") shortPassage: text(selector: \"div p\") avatarImage:attr(selector:\".postMetaInline-avatar img\"name:\"src\") authorName: text(selector: \"div .postMetaInline:first-child\") clap: text(selector: \"div .js-actionMultirecommendCount \") &#125; &#125;&#125;`export const start = async () =&gt; &#123; try &#123; const app = express() app.use(cors()) app.use(express.static(__dirname)) app.listen(PORT, () =&gt; &#123; console.log(`Visit $&#123;URL&#125;:$&#123;PORT&#125;`) &#125;) Promise.try(insertData(variables)).then( console.log(\"done\") ); &#125; catch (e) &#123; console.log(e) &#125;;&#125;// 获取数据的方法const handleGrqphcoolDataTemplate = R.curry((api, template, variables) =&gt; ( request(api, template, variables).then(data =&gt; &#123; //console.log(data.page.items); return data; &#125;)))// 柯理化 等待抓取的数据const graphqlRequestMethodWaitForData = handleGrqphcoolDataTemplate(api, mu);const insertDataWaitForData = R.map(graphqlRequestMethodWaitForData);// 从Medium 网站获取数据的方法是一样的的，柯理化是处理参数不同,抓取是变量是网站地址//抓取后的数据作为insertDataWaitForData的数据const getDataFromMediumWaitForUrl = handleGrqphcoolDataTemplate(gDomApi, que);//const xHeadYLens = R.lensPath(['page', 'items']);//const getArray = R.view(xHeadYLens);// 这是从reddit中找的异步执行的方法const _wrapFlowAsync = (fn) =&gt; (arg) =&gt; Promise .try(() =&gt; arg) .then(fn);const flowAsync = (...fns) =&gt; &#123; const wrappedFns = fns.map(fn =&gt; _wrapFlowAsync(fn)) return _.flow(wrappedFns)&#125;const getArray = (obj) =&gt; obj.page.items;//这里的的流顺序是从左至右const insertData = flowAsync( getDataFromMediumWaitForUrl, getArray , insertDataWaitForData)","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"}]},{"title":"使用函数式方法批量导入数据","slug":"在graqhcool 数据库批量插入数据","date":"2018-01-23T05:24:28.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/01/23/在graqhcool 数据库批量插入数据/","link":"","permalink":"https://React-Apollo.github.io/2018/01/23/在graqhcool 数据库批量插入数据/","excerpt":"","text":"从数据源来的数据，json文件格式，或者是数组， 批量导入到graphcool数据库中。 使用了函数式编程中的ramda.js 和tranducers-js.js的方法， 问题分解 遍历数组，采用map方法 映射单个对象属性到variable 单个对象的变量插入到数据库中 解决办法这里使用函数式编程来处理问题，函数式并不是高深的技术，只是简化了处理问题的流程常规的处理流程transducer的处理流程 数据结构：1234567&#123; ratingStars: 4, name: 'Hotel Europe', streetAddress: 'Dufourstrasse 4', postalCode: '8008', cityLocalized: 'Zürich', geolocation: &#123;latitude: 47.364185, longitude: 8.547145&#125;&#125; 这里有嵌套的结构，在graphql-request要使用扁平的结构，所以需要对数组对象中的的单个对象做映射处理，然后再插入数据库。使用transducer原理，不在先处理映射，然后函子，接着再map方法，插入的数组。 对单个对象的处理可以通过tranducer方式放到一起一并处理。 这里的思想是很精妙的。 具体的操作方法在express服务器上运行 请求函数柯理化1234567//首先传入API，template,等待数据//变量放在最后，有可能用于compose函数const func = R.curry((api, template, variables) =&gt; ( request(api, template, variables).then(data =&gt; &#123; console.log(data) &#125;) )) 扁平化对象数据123456789101112var flattenData = function (n) &#123; return &#123; name: n.name, ratingStars: n.ratingStars, streetAddress: n.streetAddress, postalCode: n.postalCode, cityLocalized: n.cityLocalized, latitude: n.geolocation.latitude, longitude: n.geolocation.longitude, &#125;&#125;; 函数式方法的一些处理过程123456789101112const waitForData = func(api, mu); //柯理化//xf是transducer的过程，对于单个对象的连续处理可以在这里实现// 方向是从左=&gt;右，var xf = t.comp(R.map(flattenData), R.map(waitForData));//这个中间函数有做了柯理化，等待作用的数组数据，这里不是对象了//流程就是接受数组对象，取出`单个对象`，使用tranducer进行处理const mediateFunc=R.curry((xf,data)=&gt;(t.into([], xf, data)));const getFinalRes=mediateFunc(xf);getFinalRes(data); 整个代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102'use strict'// 从hotel 文件获取json数据然后写入到graphcool数据库import express from 'express'import bodyParser from 'body-parser'import cors from 'cors'import * as R from 'ramda'var fs = require('fs')var path = require('path')require('es6-promise').polyfill()require('isomorphic-fetch')import fetch from 'node-fetch'import &#123; request &#125; from 'graphql-request'import hotelData from '../dist/hotelData'//导入的数据const URL = 'http://localhost'const PORT = 3001const api = 'https://api.graph.cool/simple/v1/cjaxudkum2ugf0127kok921bc'; //graphcool API//graphql模板const mu = `mutation createOneHotel( $name:String!, $ratingStars:Int!, $streetAddress:String!, $postalCode: String!, $cityLocalized:String!, $longitude: Float!, $latitude: Float!)&#123;createHotel( name:$name, ratingStars:$ratingStars,streetAddress:$streetAddress, postalCode:$postalCode, cityLocalized:$cityLocalized,geolocation:&#123;latitude:$latitude, longitude: $longitude&#125;)&#123;idgeolocation&#123; longitude latitude&#125;&#125;&#125;`var t = require('transducers-js');//导入transducers-js执行tranducer操作export const start = async () =&gt; &#123; try&#123; const app = express() app.use(cors()) app.use(express.static(__dirname)) app.listen(PORT, () =&gt; &#123; console.log(`Visit $&#123;URL&#125;:$&#123;PORT&#125;`) &#125;); //直接从文件读取，不成功，但是导入是可以的,说明数据的操作是没有问题的，继续再试s // fs.readFile(path.resolve(__dirname,'hotel.json'), function(err,data)&#123; // if(err) throw err; // //console.log(data.toString()); // const hotelData=data.toString(); // //console.log(typeof(data); // //const Data=data.toString(); // //InsertData(Data); // console.log(typeof(hotelData)); // &#125;); InsertData(hotelData); &#125; catch (e) &#123; console.log(e) &#125;;&#125;;var InsertData =(data) =&gt; &#123; // console.log(data); //请求方法的柯理化，首先传入api和template，等待变量 const func = R.curry((api, template, variables) =&gt; ( request(api, template, variables).then(data =&gt; &#123; console.log(data) &#125;) )) var flattenData = function (n) &#123; return &#123; name: n.name, ratingStars: n.ratingStars, streetAddress: n.streetAddress, postalCode: n.postalCode, cityLocalized: n.cityLocalized, latitude: n.geolocation.latitude, longitude: n.geolocation.longitude, &#125;&#125;;const waitForData = func(api, mu);var xf = t.comp(R.map(flattenData), R.map(waitForData)); const mediateFunc=R.curry((xf,data)=&gt;(t.into([], xf, data)));const getFinalRes=mediateFunc(xf);getFinalRes(data);&#125;;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"express","slug":"express","permalink":"https://React-Apollo.github.io/tags/express/"},{"name":"ramda","slug":"ramda","permalink":"https://React-Apollo.github.io/tags/ramda/"},{"name":"tranducer","slug":"tranducer","permalink":"https://React-Apollo.github.io/tags/tranducer/"}]},{"title":"构建基于MongoDB的 graphql 服务器(三)","slug":"构建基于MongoDB的 graphql 服务器(三)","date":"2018-01-22T20:18:28.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/01/22/构建基于MongoDB的 graphql 服务器(三)/","link":"","permalink":"https://React-Apollo.github.io/2018/01/22/构建基于MongoDB的 graphql 服务器(三)/","excerpt":"","text":"graphql-request的使用 graphql是graphcool的的client端，可以用于express服务器中请求数据，在resolver中也可以使用。apollo-client就只能用在在前端。 对于前端使用apollo-client绝对是最好的选择。目前没有对手。 做mutate处理，遇到不少问题，主要函数函数第一次接触，参数没有拼接对。一直以为是js对象转json的问题，早上一直在解决这个问题。结果还是参数的问题，模拟的数据是hotel的数据，其中嵌套有geolocation信息。 为这个嵌套，改了不同的组合，多没有出来， 结果正确拼接好以后，所有问题都没有了，数据是js对象还是json数据都可处理。 接下来要遍历对象数组的时候问题依然是变量的拼接。 代码如下，直接启动文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186//从hotel 文件获取json数据然后写入到graphcool数据库import express from 'express'import bodyParser from 'body-parser'import &#123;graphqlExpress, graphiqlExpress&#125; from 'graphql-server-express'import &#123;makeExecutableSchema&#125; from 'graphql-tools'import cors from 'cors'import * as R from 'ramda'var fs= require('fs');var path=require('path')require('es6-promise').polyfill();require('isomorphic-fetch');import fetch from 'node-fetch';import &#123; request &#125; from 'graphql-request'const URL = 'http://localhost'const PORT = 3001export const start = async () =&gt; &#123; try &#123; const typeDefs = [` type geoData&#123; longitude: Float!, latitude: Float!, &#125; type Hotel&#123; id: ID! ratingStars: Int! name: String! streetAddress: String! postalCode: String!, cityLocalized: String!, geolocation:[geoData!]! &#125; type Mutation &#123; insertData( name: String ): Hotel &#125; type Query&#123; getHotels: [Hotel] geoDatas: geoData &#125; `]; const resolvers =&#123; Mutation: &#123; insertData:async (parent,args,context)=&gt;&#123; const query = `&#123; allHotels(name:$name, streetAddress: $streetAddress, postalCode: $postalCode, cityLocalized: $cityLocalized, geolocation:&#123;$longitude:longitude,$latitude:latitude&#125;)&#123; name, geolocation&#123; longitude, latitude &#125; &#125; &#125;`; const variables=&#123; ratingStars: 8, name: \"vvafo\", streetAddress: \"Hruggerstrasse 56\", postalCode: \"8400\", cityLocalized: \"Paden\", geolocation: &#123;latitude: 47.343960, longitude: 7.304224&#125; &#125;; request('https://api.graph.cool/simple/v1/cjaxudkum2ugf0127kok921bc', query,variables).then(data =&gt; &#123; console.log(data); return data &#125;) &#125; &#125;, Query:&#123; getHotels:async (parent,args,context)=&gt;&#123; const query = `&#123; allHotels&#123; id, name, geolocation&#123; longitude, latitude &#125; &#125; &#125;` request('https://api.graph.cool/simple/v1/cjaxudkum2ugf0127kok921bc', query).then(data =&gt; &#123; console.log(data); return data &#125;) &#125;, &#125;&#125; const schema = makeExecutableSchema(&#123; typeDefs, resolvers &#125;) const app = express() app.use(cors()) app.use(express.static(__dirname)) app.use('/graphql', bodyParser.json(), graphqlExpress(&#123;schema: schema&#125;)) const homePath = '/graphiql' app.use(homePath, graphiqlExpress(&#123; endpointURL: '/graphql' &#125;)) app.listen(PORT, () =&gt; &#123; console.log(`Visit $&#123;URL&#125;:$&#123;PORT&#125;$&#123;homePath&#125;`) &#125;) InsertData(); &#125; catch (e) &#123; console.log(e) &#125;&#125;//使用的是这个函数var InsertData=()=&gt;&#123; const mu= `mutation createOneHotel( $name:String!, $ratingStars:Int!, $streetAddress:String!, $postalCode: String!, $cityLocalized:String!, $longitude: Float!, $latitude: Float! )&#123; createHotel( name:$name, ratingStars:$ratingStars, streetAddress:$streetAddress, postalCode:$postalCode, cityLocalized:$cityLocalized, geolocation:&#123;latitude:$latitude, longitude: $longitude&#125;)&#123; id geolocation&#123; longitude latitude &#125; &#125; &#125;`; const Variables=&#123; name:\"sdfsdlfrererjsldjfsl\", ratingStars:11, streetAddress:\"fdgtetwerwgeg\", postalCode:\"Hakerer ddome\", cityLocalized:\"Lordan\", latitude: 47.343964, longitude: 7.30424, &#125;; request('https://api.graph.cool/simple/v1/cjaxudkum2ugf0127kok921bc', mu,Variables).then(data =&gt; &#123; console.log(data); return data &#125;) &#125;;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"}]},{"title":"构建基于MongoDB的 graphql 服务器(二)。","slug":"构建基于MongoDB的 graphql 服务器(二) ","date":"2018-01-22T11:40:28.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/01/22/构建基于MongoDB的 graphql 服务器(二) /","link":"","permalink":"https://React-Apollo.github.io/2018/01/22/构建基于MongoDB的 graphql 服务器(二) /","excerpt":"","text":"#构建基于MongoDB的 graphql 服务器(二) 项目起因：想包装一下cnode的api,可以使用graphql的mutate方法实现收藏cnode帖子功能，在resolvers中对api包装，用query就可以，因为具体的数据获取并没有使用Graphql的功能。 只不过套用了其中的模式。 但是定义好了mutate或者query在后面比较好理解。这里可以用了，但是不是太规范。项目版本由此 衍生而来 graphql-mongodb-example作者是：”author”: “Nicola Marcacci Rossi &#x6e;&#105;&#x63;&#x6f;&#x6c;&#x61;&#109;&#114;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109; (http://nmr.io)”这个版本在express-server中对es7的支持很好，语法检查也很完备所以可以作为很好的初始版本。 整理好了之后，考虑向作者提出提交申请。 还有几个类似的服务器也在文件夹中，需要修改index.js的文件名 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import &#123;MongoClient, ObjectId&#125; from 'mongodb'import express from 'express'import bodyParser from 'body-parser'import &#123;graphqlExpress, graphiqlExpress&#125; from 'graphql-server-express'import &#123;makeExecutableSchema&#125; from 'graphql-tools'import cors from 'cors'import fetch from 'node-fetch'require('es6-promise').polyfill()require('isomorphic-fetch')const URL = 'http://localhost'const PORT = 3001const MONGO_URL = 'mongodb://php-smarter:&lt;password,去掉尖括号&gt;@ds239097.mlab.com:39097/recompose'const api = 'https://cnodejs.org/api/v1/topic_collect/collect'// const request = require('superagent');export const start = async () =&gt; &#123; try &#123; const typeDefs = [` type collectTopic &#123; topic_id: String accesstoken: String success: Boolean &#125; type Query &#123; getCollectionTopic(topic_id: String!, accesstoken: String!): collectTopic, createCollectionTopic(topic_id: String!, accesstoken: String!): collectTopic &#125;, schema &#123; query: Query &#125; `] const resolvers = &#123; Query: &#123; createCollectionTopic: async (parent, args, context) =&gt; &#123; const &#123;accesstoken, topic_id&#125; = args const body = &#123;accesstoken: accesstoken, topic_id: topic_id&#125; const ress = await fetch(api, &#123; method: 'POST', body: JSON.stringify(body), headers: &#123; 'Content-Type': 'application/json' &#125; &#125;) .then(res =&gt; res.json()) .then(json =&gt; json) console.log(ress) const success = &#123;'success': ress.success&#125; return success &#125; &#125; &#125; const schema = makeExecutableSchema(&#123; typeDefs, resolvers &#125;) const app = express() app.use(cors()) app.use('/graphql', bodyParser.json(), graphqlExpress(&#123;schema: schema&#125;)) const homePath = '/graphiql' app.use(homePath, graphiqlExpress(&#123; endpointURL: '/graphql' &#125;)) app.listen(PORT, () =&gt; &#123; console.log(`Visit $&#123;URL&#125;:$&#123;PORT&#125;$&#123;homePath&#125;`) &#125;) &#125; catch (e) &#123; console.log(e) &#125;&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://React-Apollo.github.io/tags/MongoDB/"}]},{"title":"构建基于MongoDB的 graphql 服务器(一)。","slug":"构建基于MongoDB的 graphql 服务器(一)","date":"2018-01-22T11:18:28.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/01/22/构建基于MongoDB的 graphql 服务器(一)/","link":"","permalink":"https://React-Apollo.github.io/2018/01/22/构建基于MongoDB的 graphql 服务器(一)/","excerpt":"","text":"#构建基于MongoDB的 graphql 服务器(一) 项目起因：本来想在后端使用graphcool服务器，在后端定义好了schema之后，其他的工作就由graphcool 自动生成了CURD的各种方法，很好用，因为graphql的自省功能，可以在graphiql查询时根据定义好的schma给你提供很好的提示但是如果要批量导入数据，就比较麻烦。所以尝试使用mongodb+graphql的方法自建一个服务器，根据下面版本建立了一个服务器。项目版本由此 衍生而来 graphql-mongodb-example作者是：”author”: “Nicola Marcacci Rossi &#x6e;&#105;&#99;&#111;&#x6c;&#97;&#x6d;&#114;&#x40;&#x67;&#x6d;&#97;&#x69;&#108;&#46;&#x63;&#111;&#x6d; (http://nmr.io)”这个版本在express-server中对es7的支持很好，语法检查也很完备所以可以作为很好的初始版本。 整理好了之后，考虑向作者提出提交申请。 ####步骤： 构建express服务器 连接mongodb 构建graphql的schema 查询数据 这里做了一个很傻的决定，要在resolver中再从graphcool服务器取数据，取出来是没有问题，问题是数据 js对象和Json对象转换，很麻烦，取出的数据的转化在graphcool-framework 的rest-wrapper中 cnode API的数据获取中有模板文件遇到嵌套数据比较难处理。还有几个类似的服务器也在文件夹中，需要修改index.js的文件名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import &#123;MongoClient, ObjectId&#125; from 'mongodb'import express from 'express'import bodyParser from 'body-parser'import &#123;graphqlExpress, graphiqlExpress&#125; from 'graphql-server-express'import &#123;makeExecutableSchema&#125; from 'graphql-tools'import cors from 'cors'const URL = 'http://localhost'const PORT = 3001const MONGO_URL = 'mongodb://php-smarter:&lt;password&gt;@ds239097.mlab.com:39097/recompose'const prepare = (o) =&gt; &#123; o._id = o._id.toString() return o&#125;function fromMongo(item) &#123; item.id=(item._id).toString(); return item &#125;export const start = async () =&gt; &#123; try &#123; const db = await MongoClient.connect(MONGO_URL) //const context=await db.collection('books') //console.log(context); const typeDefs = [` type Book &#123; id: ID! isbn: String! title: String! author: Author! &#125; type Author &#123; id: ID! name: String! &#125; type Query &#123; books(keyword:String): [Book] book(id: ID!): Book &#125; schema &#123; query: Query &#125; `]; const resolvers = &#123; Query: &#123; books: async (root,args, context) =&gt; &#123; let findParams = &#123;&#125;; console.log(args); if (args.keyword) &#123; findParams.title = new RegExp(args.keyword, 'i') &#125; //console.log('2:',db); const res=await context.db.collection('books').find(findParams).map(fromMongo).toArray(); //console.log(context); return res; &#125;, book: async (root,&#123;id, title&#125;, context) =&gt; &#123; //console.log(id); const result = await context.db.collection('books') .findOne(&#123;_id: new ObjectId(id) &#125;) return fromMongo(result) &#125; &#125; &#125; const schema = makeExecutableSchema(&#123; typeDefs, resolvers &#125;) const app = express() app.use(cors()) app.use('/graphql', bodyParser.json(), graphqlExpress(&#123;schema: schema, context: &#123; db: db &#125;&#125;)) const homePath = '/graphiql' app.use(homePath, graphiqlExpress(&#123; endpointURL: '/graphql' &#125;)) app.listen(PORT, () =&gt; &#123; console.log(`Visit $&#123;URL&#125;:$&#123;PORT&#125;$&#123;homePath&#125;`) &#125;) &#125; catch (e) &#123; console.log(e) &#125;&#125;","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://React-Apollo.github.io/tags/MongoDB/"}]},{"title":"Apollo-github第三方登录的实现","slug":"Apollo-github第三方登录的实现","date":"2018-01-21T22:30:28.000Z","updated":"2018-04-07T02:42:18.247Z","comments":true,"path":"2018/01/21/Apollo-github第三方登录的实现/","link":"","permalink":"https://React-Apollo.github.io/2018/01/21/Apollo-github第三方登录的实现/","excerpt":"","text":"graphcool-github第三方登录的实现 OAuth 协议的认证和授权的过程如下： 1.用户打开我的博客后，我想要通过GitHub获取改用户的基本信息2.在转跳到GitHub的授权页面后，用户同意我获取他的基本信息3.博客获得GitHub提供的授权码，使用该授权码向GitHub申请一个令牌4.GitHub对博客提供的授权码进行验证，验证无误后，发放一个 令牌给博客端5.博客端使用令牌，向GitHub获取用户信息6.GitHub 确认令牌无误，返回给我基本的用户信息 基本的流程就是如此。在Graphcool的官方路程中跑不通这个过程，好像是fetch的异步操作有问题。所我用了单独的graphql服务器来实现，官方流程中需要把数据存到graphcool的库中，这一步没有做。 获得授权码这要用一个登陆页面，有github的脚本，和你我申请的ID。共同去服务端获得一个githubUserCode,这个就是要使用的查询参数。 html网页通过http-server本地服务器加载，主要的是这个服务的的端口要和github申请时的回调地址和端口一致。光放文档是使用的是python的http服务，我没用，端口可能是8000.用http-server时端口是8080，和文档描述不一致的时候，要知道为什么。官方的文件为template仓库html文件12345678910111213141516171819202122&lt;html&gt;&lt;body&gt; &lt;script&gt; // Github client id const client_id = '842e83a0329b156b0a5b' // Will extract code from current url const githubCode = window.location.search.substring(1).split('&amp;')[0].split('code=')[1] if (githubCode) &#123; // call Graphcool authenticateGithubUser mutation console.log(githubCode) &#125; function getgithubCode() &#123; window.location = `https://github.com/login/oauth/authorize?client_id=$&#123;client_id&#125;&amp;scope=user` &#125; &lt;/script&gt; &lt;button onclick=\"getgithubCode();\"&gt;Authenticate with Github&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 这里是一个静态的html页面，如果是webapp或者APP的话，这里点击后，从github网站请求到githubUserCode，以后可以执行换取用户信息的工作了。这里为了方便，通过console.log的方式在终端中打印出gitHubUser的值，然后我在graqhiql界面执行一个查询操作，如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import express from 'express'import bodyParser from 'body-parser'import &#123;graphqlExpress, graphiqlExpress&#125; from 'graphql-server-express'import &#123;makeExecutableSchema&#125; from 'graphql-tools'import cors from 'cors'require('es6-promise').polyfill();require('isomorphic-fetch');import fetch from 'node-fetch';const URL = 'http://localhost'const PORT = 3001export const start = async () =&gt; &#123; try &#123; const typeDefs = [` type AuthenticateUserPayload &#123; id: ID! token: String! &#125; type Query &#123; getGithubToken(githubCode: String!): AuthenticateUserPayload &#125; schema &#123; query: Query &#125; `]; const resolvers =&#123; Query :&#123; /*test start area*/ getGithubToken:async (parent,args,context)=&gt;&#123; console.log(args); const endpoint = 'https://github.com/login/oauth/access_token' const &#123;githubCode&#125; =args; const client_id= '842e83a0329b156b0a5b' const client_secret = '0a25a9f3c5cb3d47eece0b54e58163a188834bf9' const data = await fetch(endpoint, &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json', 'Accept': 'application/json' &#125;, body: JSON.stringify(&#123; client_id, client_secret, code: githubCode, &#125;) &#125;) .then(response =&gt; response.json()) if (data.error) &#123; throw new Error(JSON.stringify(data.error)) &#125; console.log(\"data,\",data); const res=await getGithubUser(data.access_token) console.log(res); return &#123;token:data.access_token,id:res.id&#125;; &#125; /*test end area*/ &#125; &#125; const getGithubUser=async (githubToken)=&gt;&#123; const endpoint = `https://api.github.com/user?access_token=$&#123;githubToken&#125;` const data = await fetch(endpoint).then(response =&gt; response.json()) if (data.error) &#123; throw new Error(JSON.stringify(data.error)) &#125; return data &#125; const schema = makeExecutableSchema(&#123; typeDefs, resolvers &#125;) const app = express() //app.use(cors()) app.use('/graphql', bodyParser.json(), graphqlExpress(&#123;schema: schema&#125;)) const homePath = '/graphiql' app.use(homePath, graphiqlExpress(&#123; endpointURL: '/graphql' &#125;)) app.listen(PORT, () =&gt; &#123; console.log(`Visit $&#123;URL&#125;:$&#123;PORT&#125;$&#123;homePath&#125;`) &#125;) &#125; catch (e) &#123; console.log(e) &#125;&#125; 在这个服务器的resolver中post请求发送githubUser信息到github.实际的代码是很简单的。 注意异步操作的问题，在这个问题上绕了很久，才摸索出上面的方法。 ResT-Wrapper中的实现在Graphcool rest-wrapper实例代码中也实现了这个操作。 graphcool的起始配置很复杂，但是实际使用时很方便的。rest-wrapper的库提交到bitbucket上.文件目录 src/github/ 文件结构已经重新整理过resolver’的代码如下：建了两个数据模型但是没有使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import &#123;fromEvent, FunctionEvent&#125; from 'graphcool-lib'import &#123;GraphQLClient&#125; from 'graphql-request'import * as fetch from 'isomorphic-fetch'interface User &#123; id : string&#125;interface GithubUser &#123; id : string html_url: string gists_url: string avatar_url: string&#125;interface EventData &#123; githubCode : string&#125;// read Github credentials from environment variablesexport default async(event : FunctionEvent &lt; EventData &gt;) =&gt; &#123; console.log(event) // if (!process.env.GITHUB_CLIENT_ID || !process.env.GITHUB_CLIENT_SECRET) &#123; // console.log('Please provide a valid client id and secret!') return &#123; error: // 'Github Authentication not configured correctly.' &#125; &#125; try &#123; const &#123;githubCode&#125; = event.data // get github token const githubToken : string = await getGithubToken(githubCode) // call github API to obtain user data const githubUser: any= await getGithubUser(githubToken) // get graphcool user by github id return &#123; data: &#123; id: githubUser.id.toString(), token: githubToken, html_url: githubUser.html_url, avatar_url: githubUser.avatar_url, gists_url: githubUser.gists_url &#125; &#125; &#125; catch (e) &#123; console.log(e) return &#123;error: 'An unexpected error occured during authentication.'&#125; &#125;&#125;async function getGithubToken(githubCode) &#123; const client_id = '842e83a0329b156b0a5b' const client_secret = '0a25a9f3c5cb3d47eece0b54e58163a188834bf9' const endpoint = 'https://github.com/login/oauth/access_token' const data = await fetch(endpoint, &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json', 'Accept': 'application/json' &#125;, body: JSON.stringify(&#123;client_id, client_secret, code: githubCode&#125;) &#125;).then(response =&gt; response.json()) if (data.error) &#123; throw new Error(JSON.stringify(data.error)) &#125; return data.access_token //const res=await getGithubUser(data.access_token) //console.log(res); //return &#123;token:data.access_token,id:res.id&#125;;&#125;async function getGithubUser(githubToken : string) : Promise &lt; GithubUser &gt; &#123; const endpoint = `https://api.github.com/user?access_token=$&#123;githubToken&#125;` const data = await fetch(endpoint).then(response =&gt; response.json())if (data.error) &#123; throw new Error(JSON.stringify(data.error)) &#125; return data&#125; 方法和流程其实是一样的。 如果在node.js下要想执行grapql操作，最好是使用graph-lib库来实现。方法和客户端一样， 都是执行异步操作。","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Apollo-client","slug":"Apollo-client","permalink":"https://React-Apollo.github.io/tags/Apollo-client/"},{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"}]},{"title":"GraphQL Playground 列表","slug":"GraphQL Playground List","date":"2018-01-21T13:55:28.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/01/21/GraphQL Playground List/","link":"","permalink":"https://React-Apollo.github.io/2018/01/21/GraphQL Playground List/","excerpt":"","text":"#GraphQL playground graphql-api地址 Gdom 通过grphql爬取dom元素 Mongodb_todo demotodo 更据查询要求来绘图 电影数据库查询","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"Github","slug":"Github","permalink":"https://React-Apollo.github.io/tags/Github/"}]},{"title":"SNACK  playground","slug":"xde-snack","date":"2018-01-21T11:18:28.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/01/21/xde-snack/","link":"","permalink":"https://React-Apollo.github.io/2018/01/21/xde-snack/","excerpt":"","text":"","categories":[{"name":"工具","slug":"工具","permalink":"https://React-Apollo.github.io/categories/工具/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://React-Apollo.github.io/tags/javascript/"},{"name":"RN","slug":"RN","permalink":"https://React-Apollo.github.io/tags/RN/"}]},{"title":"SNACK  playground","slug":"xde-snack 2","date":"2018-01-21T11:18:28.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/01/21/xde-snack 2/","link":"","permalink":"https://React-Apollo.github.io/2018/01/21/xde-snack 2/","excerpt":"","text":"","categories":[{"name":"工具","slug":"工具","permalink":"https://React-Apollo.github.io/categories/工具/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://React-Apollo.github.io/tags/javascript/"},{"name":"RN","slug":"RN","permalink":"https://React-Apollo.github.io/tags/RN/"}]},{"title":"create-react-app,Apollo-client,graphcool的模板","slug":"create-react-app,Apollo-client,graphcool的模板","date":"2018-01-20T16:18:28.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/01/20/create-react-app,Apollo-client,graphcool的模板/","link":"","permalink":"https://React-Apollo.github.io/2018/01/20/create-react-app,Apollo-client,graphcool的模板/","excerpt":"","text":"create-react-app,Apollo-client,graphcool的模板初步的使用方法，很简单，组要是打通数据线路 代码：index.js中的标准配置123456789101112131415161718192021import React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';import registerServiceWorker from './registerServiceWorker';import &#123; ApolloClient &#125; from 'apollo-client';import &#123; HttpLink &#125; from 'apollo-link-http';import &#123; InMemoryCache &#125; from 'apollo-cache-inmemory';import &#123; ApolloProvider &#125; from 'react-apollo';const client = new ApolloClient(&#123; link: new HttpLink(&#123; uri: 'https://api.graph.cool/simple/v1/cjaxudkum2ugf0127kok921bc' &#125;), cache: new InMemoryCache(), connectToDevTools: true&#125;);ReactDOM.render( &lt;ApolloProvider client=&#123;client&#125;&gt; &lt;App /&gt; &lt;/ApolloProvider&gt;, document.getElementById('root'),); React-Native中配置和这个是一样的， 添加了react-navigation时候，完全一样， 所有的路由包装完以后，在用apollo的client包装。Apollo使用时的好处是，虽然数据是单一来源，但是每个容器包装的组件都有查询方法为属性的属性值。 这个很好，相当于有了命名空间， 每个从endpoint获取数据的组件，就等于隔离开了。如果是本地数据考霸是app-link-state的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; graphql&#125; from 'react-apollo';import gql from 'graphql-tag';const getOneNode = gql` query ($id: String!)&#123; OneNode(id:$id) &#123; id, tab, content, &#125; &#125;`;class App extends Component &#123; render() &#123; console.log(this.props.data); if(!this.props.data.loading)&#123; var content=this.props.data.OneNode.content; console.log(typeof(content)) &#125;else&#123; var content = \"\"; &#125; return ( &lt;div className=\"App\"&gt; &lt;div className=\"App-intro\"&gt; &lt;div&gt;&#123;ReactHtmlParser(content)&#125;&lt;/div&gt;; &lt;/div&gt; &lt;/div&gt; ); &#125;&#125;export default graphql(getOneNode, &#123;options: () =&gt; &#123; return (&#123; variables: &#123; id: '5433d5e4e737cbe96dcef312', &#125; &#125;);&#125;&#125;)(App) 定要好schema,这个刚开始觉得很难，其实打开graphiql，对着来写是很简单，直观的的 ，可以在graphiql中先获取想要的结果，然后就获得查询的方法了。 剩下就是获取数据了。 这一步已经在Rn-cnode的项目中实现了。 mutate的方法完全相同。","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"},{"name":"cra","slug":"cra","permalink":"https://React-Apollo.github.io/tags/cra/"},{"name":"graphcool","slug":"graphcool","permalink":"https://React-Apollo.github.io/tags/graphcool/"}]},{"title":"翻译计划列表","slug":"翻译文章计划列表","date":"2018-01-20T13:18:28.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2018/01/20/翻译文章计划列表/","link":"","permalink":"https://React-Apollo.github.io/2018/01/20/翻译文章计划列表/","excerpt":"","text":"styles-components 1.Writing Scalable React Apps with the Component Folder Pattern 2.how to build a simple HackerNews feed with styled-componentes React&amp;RN FP&amp;Ramda 1. Apollo&amp;Graphcool 1. javascript Basic 1.","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"Ramda","slug":"Ramda","permalink":"https://React-Apollo.github.io/tags/Ramda/"},{"name":"RN","slug":"RN","permalink":"https://React-Apollo.github.io/tags/RN/"},{"name":"styles-components","slug":"styles-components","permalink":"https://React-Apollo.github.io/tags/styles-components/"}]},{"title":"Prisma简介(翻译)","slug":"Prisma介绍","date":"2018-01-20T13:18:28.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/01/20/Prisma介绍/","link":"","permalink":"https://React-Apollo.github.io/2018/01/20/Prisma介绍/","excerpt":"","text":"#Prima简介 用于数据库的开源GraphQL API抽象层.本来准备翻译 medium上面的简介,但是最后感觉也太简单了,说明不了太多问题. 总体上, Prisma 是位于 grpqh-client 和传统数据库或者 REST API 之间的应用层, 利用了 graphQL的强类型和 schema 的优点.在这个系统中, 核心是围绕Schema展开. 最终构建了灵活可用数据的CRUD 方法. Prisma是GraphQL 数据库的代理，它可以把你的数据库转化为GraphQL API. 你可以使用 基础构架 客户端作为数据的消费者, 可以使用 apollo-client 或者 relay Graphql sever 是基于 graphql-yoga 的 webserver, 内核是 express Prisma &amp; Prisma bindings Database","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"Graphcool","slug":"Graphcool","permalink":"https://React-Apollo.github.io/tags/Graphcool/"}]},{"title":"TodoList-graphql-model","slug":"TodoList-graphql-schema-method","date":"2018-01-20T06:30:28.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/01/20/TodoList-graphql-schema-method/","link":"","permalink":"https://React-Apollo.github.io/2018/01/20/TodoList-graphql-schema-method/","excerpt":"","text":"基础的graphql数据模型网址是：grapiql ### 数据模型123id: IDtitle: Stringcompleted: Boolean query :todos{id, title, complete} mutation:123456- add(title: String!): todo- toggle(id: String!): todo- toggleAll(checked: Boolean!): [todo]- destroy(id: String!): todo- clearCompleted: [todo]- save(id: String!title: String!): todoTodoList DemoTodoList Demo runkit graphql playground","categories":[{"name":"Data Model","slug":"Data-Model","permalink":"https://React-Apollo.github.io/categories/Data-Model/"}],"tags":[{"name":"graphql","slug":"graphql","permalink":"https://React-Apollo.github.io/tags/graphql/"},{"name":"data-Model","slug":"data-Model","permalink":"https://React-Apollo.github.io/tags/data-Model/"}]},{"title":"Public GraphQL APIs","slug":"Public GraphQL APIs","date":"2018-01-20T05:18:28.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/01/20/Public GraphQL APIs/","link":"","permalink":"https://React-Apollo.github.io/2018/01/20/Public GraphQL APIs/","excerpt":"","text":"Public GraphQL APIs graphql-apis/README.md at master · APIs-guru/graphql-apisA collective list of public GraphQL APIs. PRs are welcome :smile:If you are interested in GraphQL in general, check out awesome-graphql. Official APIs API Description GraphiQL Docs/Repo Brandfolder Digital asset management platform Try it! Repo Buildkite Continuous integration and deployments Try it! Docs Deutsche Bahn Infrastructure Data, like realtime facility status, stations, timetables and more Try it! DocsRepo Digitransit HSL Transit routes and realtime schedules from Helsinki Regional Transport Authority, Finland Try it! Docs EHRI Holocaust-related archival materials Try it! Docs EtMDB Ethopian Movie Database Try it!%20%7B%0A%20%20%20%20edges%20%7B%0A%20%20%20%20%20%20node%20%7B%0A%20%20%20%20%20%20%20%20slug%0A%20%20%20%20%20%20%20%20hallName%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A) Docs Gdom DOM Traversing and Scraping using GraphQL Try it! Repo GitHub Web-based Git repository hosting service Try it! Docs GraphLoc Find a geolocation of an IP address including latitude, longitude, city, country, time zone and area code. Free to use, SSL supported Try it! Docs GraphQL Community Graph This is an Graph Database full of activity of the GraphQL community, including Twitter, StackOverflow, GitHub, Meetups, Slack. Try it! Repo GraphQL Europe Europe’s first GraphQL conference Try it! GraphQL Fake Fake is a tool for generating fake data using GraphQL queries. Try it! GraphQL World The fastest growing community of GraphQL developers Try it! DocsSite HIVDB A curated database to represent, store and analyze HIV drug resistance data Try it! Docs Hollowverse The religions and political views of the influentials. Try it! DocsRepo melodyRepo Fast and reliable dependency manager for Go Try it! Docs Microsoft Graph (DEMO) Connect to the data that drives productivity – mail, calendar, contacts, documents, directory, devices, and more. Try it! Repo Shopify Storefront The Storefront API gives you full creative control to build customized purchasing experiences for your customers. Try it! DocsExamples SuperChargers Locations of Tesla Stores, Superchargers, Destination Chargers and Service centers Try it! DocsRepo Universe Check what your friends are doing &amp; find unique events near you using our filter. Try it! Docs Yelp User Reviews and Recommendations of Top Restaurants, Shopping, Nightlife, Entertainment, Services and More Try it! Docs Unofficial API proxies API Description GraphiQL Docs/Repo Contentful “CMS as a Service”. GraphiQL demo allows to query a simple blog, but the library itself generates a schema automatically for any content model you store in Contentful. Try it! Repo Hacker NewsRedditTwitterGiphy GraphQL Hub Try HN!Try Reddit!Try Twitter!Try Giphy! DocsRepo MusicBrainz Open music encyclopedia that collects music metadata Try it!%20%7B%0A%20%20%20%20%20%20name%0A%20%20%20%20%20%20releaseGroups(type%3A%20ALBUM)%20%7B%0A%20%20%20%20%20%20%20%20edges%20%7B%0A%20%20%20%20%20%20%20%20%20%20node%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20title%0A%20%20%20%20%20%20%20%20%20%20%20%20firstReleaseDate%0A%20%20%20%20%20%20%20%20%20%20%20%20relationships%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20releaseGroups(type%3A%20%22single%20from%22)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20edges%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20node%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20target%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20…%20on%20ReleaseGroup%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20title%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20firstReleaseDate%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A&amp;operationName=NirvanaAlbumSingles) Repo NYC Restaurant Grades NYC Restaurant Inspection Results data (letter ratings for restaurants) Try it! Docs PokeAPI Pokémon Data API Try it! Repo Spotify Spotify gives you instant access to millions of songs - from old favorites to the latest hits. Try it! RepoExamples SWAPI Star Wars API Try it! Repo Demonstration-only APIs API Description GraphiQL Docs/Repo GraphQL Pokémon Get information of a Pokémon with GraphQL or Demo App! Try it!%20%7B%0A%20%20%20%20id%0A%20%20%20%20number%0A%20%20%20%20name%0A%20%20%20%20attacks%20%7B%0A%20%20%20%20%20%20special%20%7B%0A%20%20%20%20%20%20%20%20name%0A%20%20%20%20%20%20%20%20type%0A%20%20%20%20%20%20%20%20damage%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20evolutions%20%7B%0A%20%20%20%20%20%20id%0A%20%20%20%20%20%20number%0A%20%20%20%20%20%20name%0A%20%20%20%20%20%20weight%20%7B%0A%20%20%20%20%20%20%20%20minimum%0A%20%20%20%20%20%20%20%20maximum%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20attacks%20%7B%0A%20%20%20%20%20%20%20%20fast%20%7B%0A%20%20%20%20%20%20%20%20%20%20name%0A%20%20%20%20%20%20%20%20%20%20type%0A%20%20%20%20%20%20%20%20%20%20damage%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D) RepoClientRepo MongoDB Northwind demo Demo App build on top of graphql-compose and mongoose Try it!Try Relay version! DocsServerRepoClientRepo MongoDB TODO-List TODO List using GraphQL and MongoDb Try it! DocsRepo Scaphold Slackr Real-time API to power Scaphold Slackr Try it! DocsRepo Spotify GraphQL Server This demonstrates how to build a GraphQL server which fetches data from an external API (Spotify) Try it!%20%7B%0A%20%20%20%20name%0A%20%20%20%20id%0A%20%20%20%20image%0A%20%20%7D%0A%7D%0A) Docs Repo Three.js demo Declare a Three.js program with GraphQL Try it! Repo UFC GraphQL Server Public UFC API turned into a GraphQL server. It’s hosted by now.sh then, sometimes, it gets freeze. Try it! Repo","categories":[{"name":"source","slug":"source","permalink":"https://React-Apollo.github.io/categories/source/"}],"tags":[{"name":"Graphql","slug":"Graphql","permalink":"https://React-Apollo.github.io/tags/Graphql/"},{"name":"Github","slug":"Github","permalink":"https://React-Apollo.github.io/tags/Github/"},{"name":"API","slug":"API","permalink":"https://React-Apollo.github.io/tags/API/"}]},{"title":"未来的状态管理技术","slug":"the future of state mangement","date":"2018-01-04T04:01:45.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2018/01/04/the future of state mangement/","link":"","permalink":"https://React-Apollo.github.io/2018/01/04/the future of state mangement/","excerpt":"","text":"未来的状态管理技术使用apollo-link-state在Apollo client管理本地状态**随着应用规模的增长，它的状态也日趋复杂化。作为一个开发者我们的任务不仅要从多个远程服务器获取五花八门的数据，同时还要处理与UI交互有关的本地数据。最糟糕的是，我们不得不考略怎么存储这些数据，以便于应用中的组件可以轻松访问数据。很多的开发者的诉求是Apollo client在远程数据的管理上非常优秀，远程数据大概占据了他们80%的数据需求。但是本地数据(例如：全局标记，设备API反馈结果)怎么才能满足剩下的20%需求？在以前(其实也不算久)，Apollo用户在独立的Redux或者Mobx store(两种数据构架存储数据的对象)中管理20%的本地数据需求。对于apollo client 1.0这么做是可行的解决办法，但是Apollo client 2.0已经完全从Redux构建中迁移出来，结果是在如果要在Apollo的store和本地管理构建的store之间同步本地，远程数据会变得非常棘手。最终用户的诉求是希望能在Apollo client中封装本地和远程数据，保持单一数据来源(one source of truth)。 依靠坚实的基础Apollo开发者知道，必须要解决这个迫在眉睫的问题，所谓我们提出了问题：在Apollo client中管理状态到底应该是什么样子？刚开始，我们认为应该具有类似Redux的特征，例如Redux的dev tools以及通过connect函数把state注入到组件中。但是我们也考虑到了Redux自身的缺陷，例如模板的问题，还有DIY的问题，核心的特性，例如异步action creator(asyncchronous action creator,Redux执行异步操作时的action的函数一般都有三个)，缓存(caching),以及optimistic UI。 为了创建理想的state管理方案，我们想依据Redux构建，但是又避免它的备受批评的方面。同时还要使用GraphQL的强大的能力：也就是一次查询，从多个数据源返回数据。 一次学习，到处编写GraphQL查询对于GraphQL的一个常见误解是：它和特定的服务器实现耦合在一起。实际上，GraphQL非常灵活。不管你是从gRPC,REST或者客户端缓存查询数据都可以实现-GraphQL就是数据通用查询语言，操作与数据来源无关。这就是GraphQL查询和突变(query,mutation)完美契合应用状态改变需求的原因。不再使用Redux的分发动作(dispatching action，Redux中触发状态改变的函数),我们使用GraphQL mutation来表现状态的改变。可以通过GraphQL的query来表明组件的数据需求，从而可以访问到相应的数据。GraphQL的最大优点是它可以聚合来自多个数据来源的数据，不管是本地还是远程数据，只要在一个查询里通过指令(directive,graphQL里的语法，可以灵活的构建查询).定制需要的字段。 🎉好吧！来看看怎么实现 通过Apollo Client管理状态在Apollo Ｃlient中管理本地数据通过Apollo Link实现，Apollo Link是client中的网络技术栈，可以让你在任何地点接入到GraphQL的请求周期中。为了从GraphQL服务器请求远程数据，我们可以使用HttpLink,但是为了从缓存中请求本地数据，我们需要安装新的link:apollo-link-state。 12345678910111213141516import &#123; ApolloClient &#125; from 'apollo-client';import &#123; InMemoryCache &#125; from 'apollo-cache-inmemory';import &#123; ApolloLink &#125; from 'apollo-link';import &#123; withClientState &#125; from 'apollo-link-state';import &#123; HttpLink &#125; from 'apollo-link-http';import &#123; defaults, resolvers &#125; from './resolvers/todos';const cache = new InMemoryCache();const stateLink = withClientState(&#123; resolvers, cache, defaults &#125;);const client = new ApolloClient(&#123; cache, link: ApolloLink.from([stateLink, new HttpLink()]),&#125;); 使用apollo-link-state初始化Apollo Client为了创建state link,可以使用withClientState函数，传递的具有resolvers,defaults和Apollocache属性的对象。接着拼接本地sate link到整个link链中。state link应该在HttpLink之前出现，因此本地查询和突变到达网络成之前就会被拦截。 ####默认配置(Defaults)defaults对象代表着写入缓存时创建的state link的初始状态。在没有需求时，传递defaults对象给cache热个身是非常重要的，这样做组件在查询状态数据时才不会出错(译注：这里和Redux的reducer中返回默认的initailState是一个意思，可以返回空对象，但是不能undefined)。定义的defaults对象外观应该可以反映出在应用中计划实现的查询方案。 1234export const defaults = &#123; visibilityFilter: 'SHOW_ALL', todos: [],&#125;; 默认对象代表着想读写cache的初始化状态 Resolvers(查询解析函数)如果使用Apollo Client来管理state,Apollo cache就称为应用中所有远程数据和本地数据的单一来源。怎么访问和更新cache中的数据？resolvers应运而生。如果你在服务器端使用过graph-tools，client端的resolver类型签名与之相同： 1fieldName: (obj, args, context, info) =&gt; result; 如果不熟悉resolvers，也不用担心，这里要注意的两个重点是查询或者突变的变量在第二个参数中传递，cache会在context中自动添加(在服务端，需要在context中手动指定查询的配置，可以是rest地址，也可以是数据库配置)。 123456789101112131415161718192021222324252627282930313233export const defaults = &#123; // same as before &#125; export const resolvers = &#123; Mutation: &#123; visibilityFilter: (_, &#123; filter &#125;, &#123; cache &#125;) =&gt; &#123; cache.writeData(&#123; data: &#123; visibilityFilter: filter &#125; &#125;); return null; &#125;, addTodo: (_, &#123; text &#125;, &#123; cache &#125;) =&gt; &#123; const query = gql` query GetTodos &#123; todos @client &#123; id text completed &#125; &#125; `; const previous = cache.readQuery(&#123; query &#125;); const newTodo = &#123; id: nextTodoId++, text, completed: false, __typename: 'TodoItem', &#125;; const data = &#123; todos: previous.todos.concat([newTodo]), &#125;; cache.writeData(&#123; data &#125;); return newTodo; &#125;, &#125;&#125; Resolvers是访问和更新cache中数据的函数 为了把数据写到cache的根下，调用cache.writeData函数，并传递自己的数据。有时候，我们写入到cache的数据是和之前的数据有关的，例如上面实例中的mutation操作addTodo。在这种情况下，需要在执行写操作之前使用cache.readQuery函数从cache中读取之前的数据，如果你只是对cache中已经存在的对象写入部分数据，可以选择性传入一个id，这个id代表着相应对象在cache中的key.因为我们在apollo client store中使用的是InMemoryCache，key是_.typename:id. @client directive(@client指令)如果我们从UI中触发一个mutation.Apollo client需要知道这个动作到底是要更新服务器的数据，还是客户端本地数据。apollo-link-state使用@client指令来界定只能用于客户端数据的操作。接着apollo-link-state调用resolvser来处理相关字段。 1234567891011const SET_VISIBILITY = gql` mutation SetFilter($filter: String!) &#123; visibilityFilter(filter: $filter) @client &#125;`;const setVisibilityFilter = graphql(SET_VISIBILITY, &#123; props: (&#123; mutate, ownProps &#125;) =&gt; (&#123; onClick: () =&gt; mutate(&#123; variables: &#123; filter: ownProps.filter &#125; &#125;), &#125;),&#125;); 通过@client指令针对本地数据执行mutation操作 query操作和mutation操作类似。如果你在查询中正在执行异步操作，Apollo Client将会为你跟踪loading和error状态。对React而言，你可以在this.props.data中找到这些状态，其中还包括很多的助手函数，包括refetching(刷新)，pagination(分页)和polling(轮询)。 最令人心动的特性是你可以在一次查询中从多个数据源请求数据！😍在这个例子中，我们可以从GraphQL服务器远程请求user信息，同时从Apollo cache中请求本地的visiblityFilter数据。 12345678910111213141516const GET_USERS_ACTIVE_TODOS = gql` &#123; visibilityFilter @client user(id: 1) &#123; name address &#125; &#125;`;const withActiveState = graphql(GET_USERS_ACTIVE_TODOS, &#123; props: (&#123; ownProps, data &#125;) =&gt; (&#123; active: ownProps.filter === data.visibilityFilter, data, &#125;),&#125;); 通过@client指令请求本地数据，user没有@client指令，是远程请求数据。更多有关在应用中整合apollo-link-state的示例和技巧，请关注我们的文档更新页面 到1.0版本的技术路线现在，尽管apollo-link-state已经足够稳定，可以在应用使用了，但是还有几个特性，我们很快会解决： Client-side schema(客户端图式)：现在，客户端还不支持根据客户端schema所做的类型验证。这是因为在运行时包含用于构建和验证schema会显著的增加打包文件的大小。替换方案是，我们希望把schema构建转移到构建阶段，通过对GraphQL内省(introspection)的支持，你可以获取GraphiQL中所有很酷的特征。 Helper组件：我们的目标是尽可能的使apollo中的状态管理无差别。我们编写一些React组件，从而减少执行普通任务时的多余代码，例如在执行mutation时，在幕后传递参数，需用考虑细节配置。 如果你你对这些问题感兴趣，可以加入github 或者是 Apollo Slack的#local-state频道。我们很感激你可以帮助塑造下一代的状态管理方案！🚀 React,GraphQL,JavaScript,Redux,API","categories":[],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://React-Apollo.github.io/tags/GraphQL/"},{"name":"Apollo","slug":"Apollo","permalink":"https://React-Apollo.github.io/tags/Apollo/"},{"name":"Apollo-Client","slug":"Apollo-Client","permalink":"https://React-Apollo.github.io/tags/Apollo-Client/"},{"name":"javacript","slug":"javacript","permalink":"https://React-Apollo.github.io/tags/javacript/"},{"name":"app-link","slug":"app-link","permalink":"https://React-Apollo.github.io/tags/app-link/"},{"name":"app-link-state","slug":"app-link-state","permalink":"https://React-Apollo.github.io/tags/app-link-state/"}]},{"title":"Javascript Reducer函数实战","slug":"Disssection-Twitter-s-Redux-Store","date":"2017-06-09T04:01:45.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2017/06/09/Disssection-Twitter-s-Redux-Store/","link":"","permalink":"https://React-Apollo.github.io/2017/06/09/Disssection-Twitter-s-Redux-Store/","excerpt":"","text":"javascript Reduce函数是比较强大的一个函数,在简书上看到有个作者写了这个函数的文章,也是看到有个问题就向他请教,大神很忙,但是仍然在github上做了答复,我对那个问题搞明白了,所以写了下面这个文章,但是没有写完,现在陪老娘在医院,又把这个问题翻出来看,又不懂了,还是拉锯战啊. javascript的编程中,我开始感到看别人的源码最难的地方实际还是两个,一个是数组方法的灵活应用,另一个是对象的浅拷贝和深拷贝的问题.这两个问题要是有深刻的体会,看源码的难度会降低很多.reduce,slice,splice,concat函数是明星.遇到这几个函数的时候就有些看不懂,所以掌握这几个函数是非常重要的. 深拷贝和浅拷贝的问题其实和javascript的对象和函数都是传引用赋值息息相关,一句话解决对象的共享还是独享的问题.javascript的设计模式很多都是利用对象很函数的传引用赋值的特点来完成的.所以这儿地方也是非常的重要.javascript的数组元素也可以是对象的引用. 本人是新手,最大的体会是学到的两个简单原则:1 对象是用来组织数据和相关方法的,所以组织方式越简单,越灵活越好,由于js的对象和函数都可以传引用赋值,所以在js中,以对象字面量和数组的组织方式真的是非常的强大,之所以这么讲,就是要把学习数组的方法提到新的高度.2 编程到底是在干什么？ 我逐渐体会到编程也就是解决信息的传递，存储和处理的问题. 所以很多问题其实稍微抽象一下,问题可能会简单一点. 我简单的写了一个东西,在学习React/Redux的时候,总是掌握不了实质,就是Redux中的state的实质是什么.前面学习的时候,总是言必称state,想了各种办法去了解什么是state，为什么要这样设计.其实再抽象一下,这不就是一个小型的数据库吗？可以这样说吗？当然可以了,我看了一本介绍React的书,有点确认了,当我这几天再读F8 app的代码官方文档的时候,facebook直接就是把Redux称为数据层.我还想了一些办法来理解Redux，比如说借用中介者模式,MVC解耦和模式,但是如果抽象为数据层,那么还有什么问题解决不了的吗？ 如果接触过任何一种web框架语言,例如php/mysql,node/mongodb.每种都是解耦和,每种都是中介者模式.所以在理解这些概念的时候最基础的内容可能是最解决问题的条件.你可以梳理一下这些框架中与数据库操作都有哪些? 连接数据库,数据库操作语句,数据库文件,返回值等等.这些东西在react/redux中都能找到一摸一样的内容.web框架里的数据库操作和redux的操作是完全一样的,有什么奇怪的吗？都是数据库. Redux的文档中有个redo,undo的例子,我最近又重新看redux文档的时候，感觉这一部分讲的真是好,以前怎么没有理解呢？ 有三个缺陷一个是对于state的数据结构的理解,一个是堆栈方法使用理解,另一个就是js的浅拷贝的问题。前面看那本数据结构的书,也不得法,但是硬着头皮把几种数据结构拿下以后,突然觉得好多问题都找到了解决办法,计算机中对于数据结构和算法的重视不是白来的.state如果作为一个简单数据库,他里面就是一些键值对. 由于js中对象可以传引用,所以可以很容易的建立一个类数据库的结构.其他语言可以吗？ #####下面我们就贯彻以上的理念,来研究一些基础的内容。第一个就是Reducer函数,参考 MDN 文档 直接看代码例子 1234//accumulator是累加值,currentValue是当前遍历的值[0,1,2,3,4].reduce( (accumulator, currentValue, currentIndex, array) =&gt; &#123; return accumulator + currentValue;&#125;, 10); callback accumulate currentValue currentIndex array return 第一次调用 10 0 0 [0,1,2,3,4] 10 第二次调用 10 1 1 [0,1,2,3,4] 11 第三次调用 11 2 2 [0,1,2,3,4] 13 第四次调用 13 3 3 [0,1,2,3,4] 16 第五次调用 16 4 4 [0,1,2,3,4] 20 第一个遍历，accumulate等于10.遍历的数组元素是0，index是0.这是巧合。数组还是[0,1,2,3,4]。返回的值是初始值加当前的数组元素值，也就是返回accumulate+array[currentIndex]。return的就是 10+array[0]=10. 第二个遍历，accumulate就是10，遍历的数组元素是1，index是1.这也是巧合。数组还是[0,1,2,3,4]。返回的值是accumulate加当前的数组值，accumulate+array[currentIndex]。也就是返回 10+array[1]=11. 第二个遍历和第一个遍历的区别就是初始值来源不同。第一个遍历的是reduce带进来的数据。第二个遍历使用的是第一个遍历返回的值。后面的几个遍历就和第二个遍历一样了。 数组扁平化12345var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) &#123; return a.concat(b); //要了解concat的使用,返回的是 //数组合并的返回对象&#125;, []); //起始是空数组// flattened is [0, 1, 2, 3, 4, 5] 就这么简单,但是灵活变动起来也不是太好理解啊看这个计算器的React-Native的代码,在UI组件中渲染出计算器的几个按键的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 var Types = &#123; //类型 NUMBER: 'NUMBER', DECIMAL: 'DECIMAL', SIGN: 'SIGN'&#125;;var inputs = [ &#123;value: 1, type: Types.NUMBER&#125;, &#123;value: 2, type: Types.NUMBER&#125;, &#123;value: 3, type: Types.NUMBER&#125;, &#123;value: 4, type: Types.NUMBER&#125;, &#123;value: 5, type: Types.NUMBER&#125;, &#123;value: 6, type: Types.NUMBER&#125;, &#123;value: 7, type: Types.NUMBER&#125;, &#123;value: 8, type: Types.NUMBER&#125;, &#123;value: 9, type: Types.NUMBER&#125;, &#123;value: '+/-', type: Types.SIGN&#125;, &#123;value: 0, type: Types.NUMBER&#125;, &#123;value: '.', type: Types.DECIMAL&#125;,];//操作符的配置var operations = [ &#123;value: '/', color: '#c77ccc', altColor: '#b16eb7', operation: OPERATION_DIVIDE&#125;, &#123;value: '-', color: '#f8b055', altColor: '#dc9c4c', operation: OPERATION_SUBTRACT&#125;, &#123;value: '+', color: '#f796d2', altColor: '#e088be', operation: OPERATION_ADD&#125;, &#123;value: 'x', color: '#6fcdf4', altColor: '#65badd', operation: OPERATION_MULTIPLY&#125;];renderInputRows() &#123; var &#123;inputNumber, inputSigned, inputDecimal&#125; = this.props;//注意在redux中那个地方返回了这三个函数的名字 return inputs.reduce((collection, input) =&gt; &#123;//这里的reduce是怎么用的呢？ if (collection[collection.length - 1].length === 3) &#123;//为什么等于3 collection.push([]); &#125; collection[collection.length-1].push(input); return collection; &#125;, [[]]).map((group, rowIndex) =&gt; &#123; var columns = group.map((item, columnIndex) =&gt; &#123;//看看map的方法 return ( &lt;TouchableHighlight key=&#123;'inputRow_' + rowIndex + '_inputCol_' + columnIndex&#125; underlayColor=\"#ededed\" style=&#123;styles.input&#125; onPress=&#123;() =&gt; &#123; //dispatch方法 if (item.type === Types.NUMBER) &#123; inputNumber(item.value); &#125; else if (item.type === Types.DECIMAL) &#123; inputDecimal(); &#125; else if (item.type === Types.SIGN) &#123; inputSigned(); &#125; &#125;&#125;&gt; &lt;Text style=&#123;styles.inputText&#125;&gt;&#123;item.value&#125;&lt;/Text&gt; &lt;/TouchableHighlight&gt; ); &#125;); 看看这个数组的reducer方法的使用.源代码在这里 这个我稍后再补充,会补充大神给我的解答. 1234567891011121314151617181920212223242526272829303132 var Types = &#123; NUMBER: 'NUMBER', DECIMAL: 'DECIMAL', SIGN: 'SIGN'&#125;var inputs = [ &#123;value: 1, type: Types.NUMBER&#125;, &#123;value: 2, type: Types.NUMBER&#125;, &#123;value: 3, type: Types.NUMBER&#125;, &#123;value: 4, type: Types.NUMBER&#125;, &#123;value: 5, type: Types.NUMBER&#125;, &#123;value: 6, type: Types.NUMBER&#125;, &#123;value: 7, type: Types.NUMBER&#125;, &#123;value: 8, type: Types.NUMBER&#125;, &#123;value: 9, type: Types.NUMBER&#125;, &#123;value: '+/-', type: Types.SIGN&#125;, &#123;value: 0, type: Types.NUMBER&#125;, &#123;value: '.', type: Types.DECIMAL&#125;,];//这里其实是有一维数组转为二维数组，打印结构可以看到.//注意reduce的起始值就是一个二维数组.var result = inputs.reduce((collection, input) =&gt; &#123; if (collection[collection.length - 1].length === 3) &#123; collection.push([]); &#125; collection[collection.length-1].push(input); return collection; &#125;, [[]])console.log(result)console.table(result) 再看看下面这里两段代码12345678let str = `name, age, hair\\nMerble, 35, red\\nBob, 64, blonde`;function lameCSV(str) &#123; return str.split('\\n').reduce(function(table, row)&#123; table.push(row.split(',').map(function(c) &#123;return c.trim();&#125;)); return table &#125;, [[]]);&#125;;lameCSV(str); 123456789var arr=[0,1,2,3,4,5,6,7,8]; var result = arr.reduce((collection, input) =&gt; &#123; if (collection[collection.length - 1].length === 3) &#123; collection.push([]); &#125; collection[collection.length-1].push(input); console.log(collection); return collection; &#125;, [[]]); 感谢大神的帮助,大神的githubreduce这个方法还能演变出什么花样来呢？数组的操作真的是一个需要好好学习的内容.","categories":[],"tags":[{"name":"javacript","slug":"javacript","permalink":"https://React-Apollo.github.io/tags/javacript/"},{"name":"array","slug":"array","permalink":"https://React-Apollo.github.io/tags/array/"}]},{"title":"Dissecting Twitter's Redux Store","slug":"JavaScript  Reducer  practice","date":"2017-06-04T04:01:45.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2017/06/04/JavaScript  Reducer  practice/","link":"","permalink":"https://React-Apollo.github.io/2017/06/04/JavaScript  Reducer  practice/","excerpt":"","text":"摘编|Dissecting Twitter’s Redux Store原文请见 剖析mobile.twitter.com的store结构.大公司的移动网站,可以借鉴的东西很多,twitter的mobile已经使用了React/Redux技术,所以如果你的web网站也想要采用React/Redux构架,这篇文章要好好看看. 原文我现在不想翻译.列出来可能遇到的问题和需要用到的技术 可能要自己翻墙 记住是Twitter’s mobile website移动网站,不是pc端网站,网址是mobileTwitter 要使用chrome浏览器打开 申请一个twitter账号，登录,否则store中的信息很少 需要在chrome安装 React Developer Tools (RDT) 工具. chrome的调试界面下可以看到点击，打开console. 输入 $r.store.getState(); twitter在你应用中store的 state结构就展现出来了. 现在你可以看看大公司的应用是怎么来设计state的结构的. 由于人家的网站很复杂，所以state很像一个数据库，可以先看看数据库的范式化和 React/Redux中的实现方案 normalizr.了解如何减少巢状结构和冗余数据. 其他有兴趣的再深挖吧.总之一句话,当React应用中引入了Redux以后,应用的控制权就交到了Redux的手中,所以不要局限于React组件和页面的,需要更过的考虑数据的组织问题. 这一篇算是工具篇。 相关的开发工具后redux-logger, dev-tools, React-native Debugger ,Reactotron工具.好像还有一个可视化的工具","categories":[],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"}]},{"title":"使用React,Redux,redux-sage构建图片库(翻译)","slug":"使用React-Redux-redux-sage构建图片库-翻译","date":"2017-04-04T13:18:28.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2017/04/04/使用React-Redux-redux-sage构建图片库-翻译/","link":"","permalink":"https://React-Apollo.github.io/2017/04/04/使用React-Redux-redux-sage构建图片库-翻译/","excerpt":"","text":"看到这篇文章build an image gallery using redux saga，觉得写的不错，长短也适中. 文后有注释版的github代码库,请使用comment分枝. Flickr API可能需要有fQ的基本能力.可以使用google的翻译作为参考，这篇文章google翻译版的中文水平让我吃了一惊.翻译已经完成. 使用React,Redux和reudx-saga构建一个图像浏览程序(翻译)Joel Hooks ,2016年3月 构建一个图片长廊图像长廊是一个简单的程序，从Flicker API 加载图片URLs,允许用户查看图片详情。 后续我们会使用React,Redux和redux-saga.React作为核心框架，优势是虚拟dom(virtual-dom)的实现。Redux在程序内负责state的管理。最后，我们会使用redux-saga来执行javascript的异步操作步骤。 我们会使用ES6(箭头函数，模块，和模板字符串)，所以我们首先需要做一些项目的配置工作。 #####项目配置和自动化 如果要开始一个React项目，须有有一系列的配置选项。对于一个简单的项目，我想把配置选项尽可能缩减。考虑到浏览器的版本问题，使用Babel把ES6编译为ES5。 首先使用npm init 创建一个package.json文件 package.json 123456789101112131415161718192021222324252627282930313233343536 &#123; \"name\": \"egghead-react-redux-image-gallery\", \"version\": \"0.0.1\", \"description\": \"Redux Saga beginner tutorial\", \"main\": \"src/main.js\", \"scripts\": &#123; \"test\": \"babel-node ./src/saga.spec.js | tap-spec\", \"start\": \"budo ./src/main.js:build.js --dir ./src --verbose --live -- -t babelify\" &#125;, \"repository\": &#123; \"type\": \"git\", \"url\": \"git+https://github.com/joelhooks/egghead-react-redux-image-gallery.git\" &#125;, \"author\": \"Joel Hooks &lt;joelhooks@gmail.com&gt;\", \"license\": \"MIT\", \"dependencies\": &#123; \"babel-polyfill\": \"6.3.14\", \"react\": \"^0.14.3\", \"react-dom\": \"^0.14.3\", \"react-redux\": \"^4.4.1\", \"redux\": \"^3.3.1\", \"redux-saga\": \"^0.8.0\" &#125;, \"devDependencies\": &#123; \"babel-cli\": \"^6.1.18\", \"babel-core\": \"6.4.0\", \"babel-preset-es2015\": \"^6.1.18\", \"babel-preset-react\": \"^6.1.18\", \"babel-preset-stage-2\": \"^6.1.18\", \"babelify\": \"^7.2.0\", \"browserify\": \"^13.0.0\", \"budo\": \"^8.0.4\", \"tap-spec\": \"^4.1.1\", \"tape\": \"^4.2.2\" &#125;&#125; 有了package.json, 可以在项目文件夹命令行运行 npm install 安装程序需要的依赖项。 .babelrc 123&#123; \"presets\": [\"es2015\", \"react\", \"stage-2\"] &#125; 这个文件告诉babel,我们将会使用ES2015(ES6),React以及ES2106的stage-2的一些特征。 package.json有两个标准的script脚本配置：start和test.现在我们想通过start脚本加载程序，start会使用src目录的一些文件，所以西药先创建src文件夹.在src文件夹添加下面的一些文： index.html 12345678910111213141516171819 &lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;egghead: React Redux Image Gallery&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"styles.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"title\"&gt; ![](http://cloud.egghead.io/2G021h3t2K10/download/egghead-logo-head-only.svg) &lt;h3&gt;Egghead Image Gallery&lt;/h3&gt;&lt;/div&gt;&lt;div id=\"root\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"build.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; main.js 123456789import \"babel-polyfill\"import React from 'react'import ReactDOM from 'react-dom'ReactDOM.render( &lt;h1&gt;Hello React!&lt;/h1&gt;, document.getElementById('root')); style.css 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 body &#123; font-family: Helvetica, Arial, Sans-Serif, sans-serif; background: white;&#125;.title &#123; display: flex; padding: 2px;&#125;.egghead &#123; width: 30px; padding: 5px;&#125;.image-gallery &#123; width: 300px; display: flex; flex-direction: column; border: 1px solid darkgray;&#125;.gallery-image &#123; height: 250px; display: flex; align-items: center; justify-content: center;&#125;.gallery-image img &#123; width: 100%; max-height: 250px;&#125;.image-scroller &#123; display: flex; justify-content: space-around; overflow: auto; overflow-y: hidden;&#125;.image-scroller img &#123; width: 50px; height: 50px; padding: 1px; border: 1px solid black;&#125; index.html文件加载style.css文件提供一些基本的布局样式，同时也加载build.js文件，这是一个生成出来的文件.main.js是一个最基础的React程序，他在index.html的#root元素中渲染一个h1元素。创建这些文件以后，在项目文件夹中命令行运行npm start。在浏览器打开http://10.11.12.1:9966.就可以看到index.html中渲染的页面 现在我们来构建基础的Gallery React 组件 在Gallery中显示一些图片 首先我们需要尽可能快的获得一个可以显示的图片素材.在项目文件夹中创建一个文件Gallery.js Gallery.js 1234567891011121314151617181920212223242526272829303132333435363738 import React, &#123;Component&#125; from 'react'const flickrImages = [ \"https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg\", \"https://farm2.staticflickr.com/1581/25283151224_50f8da511e.jpg\", \"https://farm2.staticflickr.com/1653/25265109363_f204ea7b54.jpg\", \"https://farm2.staticflickr.com/1571/25911417225_a74c8041b0.jpg\", \"https://farm2.staticflickr.com/1450/25888412766_44745cbca3.jpg\"];export default class Gallery extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; images: flickrImages, selectedImage: flickrImages[0] &#125; &#125; render() &#123; const &#123;images, selectedImage&#125; = this.state; return ( &lt;div className=\"image-gallery\"&gt; &lt;div className=\"gallery-image\"&gt; &lt;div&gt; &lt;img src=&#123;selectedImage&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"image-scroller\"&gt; &#123;images.map((image, index) =&gt; ( &lt;div key=&#123;index&#125;&gt; &lt;img src=&#123;image&#125;/&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 我们直接在组件中硬编码了一个提供数据的数组，让项目尽快的工作起来.Gallery组件继承Component组件,在构造函数中创建一些组件的出事状态.最后我们利用一些样式标记渲染一下文件。image-scroller元素遍历(map方法)图片数组,生成摘要小图片。 123456789101112 import \"babel-polyfill\"import React from 'react'import ReactDOM from 'react-dom'+ import Gallery from './Gallery'ReactDOM.render(- &lt;h1&gt;Hello React!&lt;/h1&gt;,+ &lt;Gallery /&gt;, document.getElementById('root')); 到现在，我们使用硬编码的图片URLs(通过fickrImages)数组,第一张图片作为selectedImage.这些属性在Gallery组件的构造函数缺省配置中，通过初始状态(initial)来设定. 接下来在组件中添加一个和组件进行交互操作的方法，方法具体内容是操做setSate. Gallery.js 12345678910111213141516171819202122232425262728293031323334export default class Gallery extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; images: flickrImages, selectedImage: flickrImages[0] &#125; &#125;+ handleThumbClick(selectedImage) &#123;+ this.setState(&#123;+ selectedImage+ &#125;)+ &#125; render() &#123; const &#123;images, selectedImage&#125; = this.state; return ( &lt;div className=\"image-gallery\"&gt; &lt;div className=\"gallery-image\"&gt; &lt;div&gt; &lt;img src=&#123;selectedImage&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"image-scroller\"&gt; &#123;images.map((image, index) =&gt; (- &lt;div key=&#123;index&#125;&gt;+ &lt;div key=&#123;index&#125; onClick=&#123;this.handleThumbClick.bind(this,image)&#125;&gt; &lt;img src=&#123;image&#125;/&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 在Gallery组件添加handleThumbClick方法,任何元素都可用通过onClick属性调用这个方法.image作为第二个参数传递，元素自身作为第一个参数传递.bind方法传递javascript函数调用上下文对象是非常便捷。 看起来不错!现在我们有了一些交互操作的方法，有点“APP”的意思了。截止目前，我们已经让app运行起来了，接下来要考虑怎么加载远程数据。最容易加载远程数据的地方是一个React组件生命周期方法,我们使用componentDidMount方法,通过他从Flikr API请求并加载一些图片. Gallery.js 1234567891011121314151617181920212223 export default class Gallery extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; images: flickrImages, selectedImage: flickrImages[0] &#125; &#125;+ componentDidMount() &#123;+ const API_KEY = 'a46a979f39c49975dbdd23b378e6d3d5';+ const API_ENDPOINT = `https://api.flickr.com/services/rest/?method=flickr.interestingness.+getList&amp;api_key=$&#123;API_KEY&#125;&amp;format=json&amp;nojsoncallback=1&amp;per_page=5`;+++ fetch(API_ENDPOINT).then((response) =&gt; &#123;+ return response.json().then((json) =&gt; &#123;+ const images = json.photos.photo.map((&#123;farm, server, id, secret&#125;) =&gt; &#123; + return `https://farm$&#123;farm&#125;.staticflickr.com/$&#123;server&#125;/$&#123;id&#125;_$&#123;secret&#125;.jpg`+ &#125;);++ this.setState(&#123;images, selectedImage: images[0]&#125;);+ &#125;)+ &#125;)+ &#125;[...] 我们在Gallery类中添加了一个新的方法,通过React的componentDidMount生命周期方法触发Flickr图片数据的获取。 在React组件运行的不同时间点，组件会调用不同的生命周期函数。在这段代码中，当组件被渲染到DOM中的时间点,componentDidMount函数就会被调用。需要注意的是:Gallery组件只有一次渲染到DOM的机会，所以这个函数可以提供一些初始化图片.考虑到在APP的整个生命周期中,有更多的动态组件的加载和卸载,这可能会造成一些多余的调用和无法考虑到的结果。 我们使用浏览器接口(browser API)的fetch方法执行请求.Fetch返回一个promise对象解析response对象.调用response.json()方法,返回另一个promise对象，这就是我们实际需要的json格式的数据.遍历这个对象以后就可以获取图片的url地址. 坦白讲，这个应用目前还很简单.我们还需要在这里花费更多的时间，还有一些基础的需求需要完成.或许我们应该在promise处理流程中添加错误处理方法,如果图片数据获取成功也需要一些处理逻辑.在这个地方，你需要发挥一些想象力考虑一下更多的逻辑.在生产实践中简单的需求是很少见的.很快,应用中就会添加更多的需求。认证,滚动橱窗,加载不同图片库的能力和图片的设置等等.仅仅这些还远远不够. 我们已经使用React构建了一个加载图片库的程序。接下来我们需要考虑到随着程序功能的添加，到底需要哪些基础的模式.首先考虑到的一个问题就是要把应用的状态(state)控制从Gallery组件中分离出来. 我们通过引入Redux来完成应用的状态管理工作。 使用Redux来管理状态在你的应用中只要使用了setState方法都会让一个组件从无状态变为有状态的组件.糟糕的是这个方法会导致应用中出现一些令人困惑的代码,这些代码会在应用中到处蔓延。 Flux构架来减轻这个问题.Flux把逻辑(logic)和状态(state)迁移到Store中.应用中的动作(Actions)被Dispatch的时候,Stores会做相应的更新.Stores的更新会触发View根据新状态的渲染. 那么我们为什么要舍弃Flux?他竟然还是“官方”构建的.好吧！Redux是基于Flux构架的,但是他有一些独特的优势.下面是Dan Abramov(Redux创建者)的一些话： Redux和Flux没有什么不同.总体来讲他们是相同的构架,但是Redux通过功能组合把Flux使用回调注册的复杂点给屏蔽掉了.两个构架从更本上讲没有什么不同，但是我发现Redux使一些在Flux比较难实现的逻辑更容易实现. Redux文档非常棒.如果你还没有读过代码的卡通教程或者Dan的系列文章.赶快去看看吧！ 启动Redux第一件需要做的事事初始化Redux,让他在我们的程序中运行起来.现在不需要做安装工作，刚开始运行npm install的时候已经安装好了依赖项，我们需要做一些导入和配置工作.reducer函数是Redux的大脑. 每当应用分发(或派遣,dispatch)一个操作(action)的时候,reducer函数会接受操作(action)并且依据这个动作(action)创建reducer自己的state.因为reducers是纯函数，他们可以组合到一起，创建应用的一个完整state.让我们在src中创建一个简单的reducer: reducer.js 1234export default function images(state, action) &#123; console.log(state, action) return state;&#125; 一个reducer函数接受两个参数(arguments). [x] state-这个数据代表应用的状态(state).reducer函数使用这个状态来构建一个reducer自己可以管理的状态.如果状态没有发生改变,reducer会返回输入的状态. [x] action-这是触发reducer的事件.Actions通过store派发(dispatch),由reducer处理.action需要一个type属性来告诉reducer怎么处理state. 目前,images reuducer在终端中打印出日志记录，表明工作流程是正常的，可以做接下来的工作了.为了使用reducer，需要在main.js中做一些配置工作: main.js 123456789101112131415161718192021import \"babel-polyfill\";import React from 'react';import ReactDOM from 'react-dom';import Gallery from './Gallery';+ import &#123; createStore &#125; from 'redux'+ import reducer from './reducer'+ const store = createStore(reducer);+ import &#123;Provider&#125; from 'react-redux';ReactDOM.render(+ &lt;Provider store=&#123;store&#125;&gt; &lt;Gallery /&gt;+ &lt;/Provider&gt;, document.getElementById('root'));&#125; 我们从Redux库中导入createStore组件.creatStore用来创建Redux的store.大多数情况下,我们不会和store直接交互,store在Redux中做幕后管理工作. 也需要导入刚才创建的reducer函数,以便于他可以被发送到store. 我们将通过createStore(reducer)操作，利用reducer来配置应用的store.这个示例仅仅只有一个reducer,但是createStore可以接收多个reducer作为参数.稍后我们会看到这一点. 最后我们导入高度集成化的组件Provider,这个组件用来包装Gallery,以便于我们在应用中使用Redux.我们需要把刚刚创建的store传递给Provider.你也可以不使用Provider,实际上Redux可以不需要React.但是我们将会使用Provider,因为他非常便于使用. 这张图可能有点古怪，但是展示了Redux的一个有意思的地方.所有的reducers接收在应用中的全部actions(动作或操作).在这个例子中我们可以看到Redux自己派发的一个action. 连接Gallery组件 借助Redux,我们将使用”connected”和“un-connected”组件.一个connected组件被连线到store.connected组件使控制动作事件(controls action event)和store协作起来.通常,一个connected组件有子组件,子组件具有单纯的接收输入和渲染功能，当数据更新时执行调用.这个子组件就是unconnected组件. 提示:当Rect和Redux配合是工作的非常好,但是Redux不是非要和React在一起才能工作.没有React,Redux其实可以和其他框架配合使用. 在应用中需要关联React组件和Redux Store 的时候，react-redux提供了便捷的包装器.我们把react-redux添加进Gallery中,从而使Gallery成为首要的关联组件. Gallery.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 import React, &#123;Component&#125; from 'react'+import &#123;connect&#125; from 'react-redux';-export default class Gallery extends Component &#123;+export class Gallery extends Component &#123; constructor(props) &#123; super(props);+ console.log(props); this.state = &#123; images: [] &#125; &#125; componentDidMount() &#123; const API_KEY = 'a46a979f39c49975dbdd23b378e6d3d5'; const API_ENDPOINT = `https://api.flickr.com/services/rest/?method=flickr.interestingness.getList&amp;api_key=$&#123;API_KEY&#125;&amp;format=json&amp;nojsoncallback=1&amp;per_page=5`; fetch(API_ENDPOINT).then((response) =&gt; &#123; return response.json().then((json) =&gt; &#123; const images = json.photos.photo.map((&#123;farm, server, id, secret&#125;) =&gt; &#123; return `https://farm$&#123;farm&#125;.staticflickr.com/$&#123;server&#125;/$&#123;id&#125;_$&#123;secret&#125;.jpg` &#125;); this.setState(&#123;images, selectedImage: images[0]&#125;); &#125;) &#125;) &#125; handleThumbClick(selectedImage) &#123; this.setState(&#123; selectedImage &#125;) &#125; render() &#123; const &#123;images, selectedImage&#125; = this.state; return ( &lt;div className=\"image-gallery\"&gt; &lt;div className=\"gallery-image\"&gt; &lt;div&gt; &lt;img src=&#123;selectedImage&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"image-scroller\"&gt; &#123;images.map((image, index) =&gt; ( &lt;div key=&#123;index&#125; onClick=&#123;this.handleThumbClick.bind(this,image)&#125;&gt; &lt;img src=&#123;image&#125;/&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;+export default connect()(Gallery) 从react-redux导入connect函数,可以在导出组件的时候把他变为链接组件(connected component).请注意,connect()(Gallery)代码把Gallery组件放在第二个形参中,这是因为connect()返回一个函数，这个函数接受一个React组件作为参数(argument).调用connect()函数时需要配置项.后面我们将会传递配置我们应用的actions和state参数.我们也把connect作为默认配置到处模块.这一点非常重要！现在当我们import Gallery的时候,就不是一个单纯的React组件了,而是一个和Redux关联的组件了. 如果你观察我们添加进构造器的console.log的输出,就可以看到Gallery组件的属性现在包括了一个dispatch函数.这个地方是connect为我们的应用修改的,这个改动赋予了组件把自己的动作对象(action objects)派发到reducers的能力. 123456789 export class Gallery extends Component &#123; constructor(props) &#123; super(props);+ this.props.dispatch(&#123;type: 'TEST'&#125;); this.state = &#123; images: [] &#125; &#125;[...] 我们可以在组件的构造器中调用派发功能.你可以在开发者的终端中看到来自reducer的日志声明.看到声明表示我们已经派发了第一个action!.Actions是一个单一的javascript对象,必需有type属性.Actions可以拥有任意数量和种类的其他属性.但是type可以让reducers理解这些动作到底是做什么用的(意译，意思是只有拥有type属性，reducers才知道对state做什么样的修改). 12345678export default function images(state, action) &#123;- console.log(state, action)+ switch(action.type) &#123;+ case 'TEST':+ console.log('THIS IS ONLY A TEST')+ &#125; return state;&#125; 总的reducers使用switch代码块过滤有关的消息,Switch语句使用actions的type属性,当一个action和case分支吻合以后,相应的单个reducer就会执行他的具体工作. 我们的应用现在关联到接收的动作.现在我们需要把Redux-Store提供的state关联到应用中. 默认的应用状态(state) reducer.js123456789101112131415 const defaultState = &#123; images: []&#125;export default function images(state = defaultState, action) &#123; switch(action.type) &#123; case 'TEST':- console.log('THIS IS ONLY A TEST')+ console.log(state, action)+ return state;+ default:+ return state; &#125;- return state;&#125; 我们创建一个defaultState对象,这个对象返回一个空数组作为images的属性.我们把images函数的参数state设置为默认.如果在test分支中输出日志,将会看到state不是undefined(空数组不是undefined)!reducer需要返回应用的当前state.这点很重要!现在我们没有做任何改变,所以仅仅返回state.注意我们在case中添加了default分支,reducer必须要返回一个state. 在Gallery组件中，我们也可以把state做一定的映射(map)以后再连接到应用. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 import React, &#123;Component&#125; from 'react'import &#123;connect&#125; from 'react-redux';export class Gallery extends Component &#123; constructor(props) &#123; super(props); this.props.dispatch(&#123;type: 'TEST'&#125;);+ console.log(props);- this.state = &#123;- images: []- &#125; &#125;- componentDidMount() &#123;- const API_KEY = 'a46a979f39c49975dbdd23b378e6d3d5';- const API_ENDPOINT = `https://api.flickr.com/services/rest/?method=flickr.interestingness.-getList&amp;api_key=$&#123;API_KEY&#125;&amp;format=json&amp;nojsoncallback=1&amp;per_page=5`;--- fetch(API_ENDPOINT).then((response) =&gt; &#123;- return response.json().then((json) =&gt; &#123;- const images = json.photos.photo.map((&#123;farm, server, id, secret&#125;) =&gt; &#123; - return `https://farm$&#123;farm&#125;.staticflickr.com/$&#123;server&#125;/$&#123;id&#125;_$&#123;secret&#125;.jpg`- &#125;);-- this.setState(&#123;images, selectedImage: images[0]&#125;);- &#125;)- &#125;)- &#125;- handleThumbClick(selectedImage) &#123;- this.setState(&#123;- selectedImage- &#125;)- &#125; render() &#123;- const &#123;images, selectedImage&#125; = this.state;+ const &#123;images, selectedImage&#125; = this.props; return ( &lt;div className=\"image-gallery\"&gt; &lt;div className=\"gallery-image\"&gt; &lt;div&gt; &lt;img src=&#123;selectedImage&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"image-scroller\"&gt; &#123;images.map((image, index) =&gt; (- &lt;div key=&#123;index&#125; onClick=&#123;this.handleThumbClick.bind(this,image)&#125;&gt;+ &lt;div key=&#123;index&#125;&gt; &lt;img src=&#123;image&#125;/&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;+function mapStateToProps(state) &#123;+ return &#123;+ images: state.images+ selectedImage: state.selectedImage+ &#125;+&#125;-export default connect()(Gallery)+export default connect(mapStateToProps)(Gallery)``` 我们将移除连接组件中的所有图片加载和交互逻辑代码,如果你注意看`Gallery`组件的底部代码,你会注意到，我们创建了一个`mapStateToProps`函数,接收一个`state`作为参数,返回一个对象,把`state.images`映射为`images`属性.`mapStateToProps`做为参数传递给`connect`. 正如名字暗示的一样,`mapStateToProps`函数接收当前应用的state,然后把state转变为组件的属性(propertys).如果在构造器中输出props,将会看到images数组是`reducer`返回的默认state. const defaultState = { images: [] images: [ “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg“, “https://farm2.staticflickr.com/1581/25283151224_50f8da511e.jpg“, “https://farm2.staticflickr.com/1653/25265109363_f204ea7b54.jpg“, “https://farm2.staticflickr.com/1571/25911417225_a74c8041b0.jpg“, “https://farm2.staticflickr.com/1450/25888412766_44745cbca3.jpg“ ], selectedImage: “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg“} export default function images(state = defaultState, action) { switch(action.type) { case ‘TEST’: console.log(state, action) return state; default: return state; }}1234567 如果在`defaultState`中更新images数组,你将可以看到一些图片重新出现在gallery中!现在当用户点击缩略图的时候,我们可以反馈选择动作,返回对应的大图. #### 更新state 怎么操作才能根据新选择的图片更新state? 需要配置reducer监听`IMAGE_SELECTED`动作,借助action携带的信息(payload,有的文章翻译为载荷,载荷怎么理解？手机载荷就是声音，短信和流量数据。如果是卡车就是拉的货物,如果是客车就乘载的乘客,action的载荷就是要让reducer明白你要干什么，需要什么)来更新state. const defaultState = { images: [ “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg“, “https://farm2.staticflickr.com/1581/25283151224_50f8da511e.jpg“, “https://farm2.staticflickr.com/1653/25265109363_f204ea7b54.jpg“, “https://farm2.staticflickr.com/1571/25911417225_a74c8041b0.jpg“, “https://farm2.staticflickr.com/1450/25888412766_44745cbca3.jpg“ ], selectedImage: “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg“} export default function images(state = defaultState, action) { switch(action.type) { case ‘TEST’:case ‘IMAGE_SELECTED’: return state; return {…state, selectedImage: action.image};default:return state;}} 12现在reducer已经准备接收`IMAGE_SELECTED` action了.在`IMAGE_SELECTED`分支选项内,我们在展开(spreading,ES6的对象操作方法),并重写`selectedImage`属性后,返回一个新state对象.了解更多的`...state`对象操作可以看`ruanyifeng`的书. import React, {Component} from ‘react’import {connect} from ‘react-redux’; export class Gallery extends Component { constructor(props) { super(props); this.props.dispatch({type: ‘TEST’}); console.log(props); }render() { const {images, selectedImage} = this.props; const {images, selectedImage, dispatch} = this.props; return ( &lt;div&gt; &lt;img src={selectedImage} /&gt; &lt;/div&gt; {images.map((image, index) =&gt; ( dispatch({type:’IMAGE_SELECTED’, image})}&gt; ))})}} function mapStateToProps(state) { return { images: state.images, selectedImage: state.selectedImage }} export default connect(mapStateToProps)(Gallery)12345678 在`Gallery`组件中,我们将会在组件的属性中定义`dispatch`在`onClick`函数体中调用他,现在我们从便利角度考虑把他们放在一起,但是两者功能是一样的.一旦我们点击了缩略图,他将会通过reducer更新大图. 使用dispatch可以很方便的创建通用actions,但是很快我们会需要重用命名好的actions.为了这样做,可以使用”action creators”. #### Action Creators Action creators函数返回配置好的action对象.我们在`action.js`中添加第一个action creator. `action.js` export const IMAGE_SELECTED = ‘IMAGE_SELECTED’; export function selectImage(image) { return { type: IMAGE_SELECTED, image }}1234这个方法经过export以后,可以直接在任何需要创建`selectImage` action地方导入!`selectImage`是纯函数，只能返回数据.他接收一个image作为参数,把image添加到action对象中，并返回.&gt;注意:我们正在返回一个单纯的javascript object,但是`image`的属性可能很古怪，如果你以前没有碰到这样的样式.从ES6的角度出发,如果你给一个对象传递一个类似这样的属性,隐含的意思是把`image:'任何image包含的值'`添加到最终返回的对象.超级好用! import * as GalleryActions from ‘./actions.js’;[…]onClick={() =&gt; dispatch(GalleryActions.selectImage(image))}1234this isn’t much than just using `dispatch` though.幸运的是,这个模式很普遍,Redux在`bindActionCreators`函数里提供了一个更好的办法来完成这个功能. import React, {Component} from ‘react’import {connect} from ‘react-redux’; import {bindActionCreators} from ‘redux’; import * as GalleryActions from ‘./actions.js’; export class Gallery extends Component { constructor(props) { super(props); this.props.dispatch({type: ‘TEST’}); console.log(props); } handleThumbClick(selectedImage) { this.setState({ selectedImage }) } render() { const {images, selectedImage, dispatch} = this.props; const {images, selectedImage, selectImage} = this.props;return ( &lt;div&gt; &lt;img src={selectedImage} /&gt; &lt;/div&gt; {images.map((image, index) =&gt; ( dispatch({type:’IMAGE_SELECTED’, image})}&gt; selectImage(image)}&gt; ))})}} function mapStateToProps(state) { return { images: state.images, selectedImage: state.selectedImage }} +function mapActionCreatorsToProps(dispatch) { return bindActionCreators(GalleryActions, dispatch);+} -export default connect(mapStateToProps)(Gallery)+export default connect(mapStateToProps, mapActionCreatorsToProps)(Gallery)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 我们已经添加了`mapActionCreatorsToProps`函数,他接收`dispatch`函数作为参数.返回`bindActionCreators`的调用结果,`GalleryActions`作为`bindActionCreators`的参数.现在如果你输出属性日志,就看不到`dispatch`作为参数,`selectImage`直接可以使用了.(这里相当于对dispatch和action进行了包装). 现在回顾一下,我们做了几件事: - 创建了一个reducer包含应用的默认初始状态(initial state),并且监听actions的执行. - 创建了一个store,把reducer具体化,提供一个分发器(dispatcher)可以分发action. - 把我们的Gallery组件关联到store的state. - 把store的state映射为属性(property)，传递给Gallery. - 映射一个动作创建器,Gallery可以简单的调用`selectImage(image)`,分发动作,应用状态将会更新.那么，我们怎么才能使用这些模式从远程资源加载数据呢？这个过程将会非常有趣!#### 异步活动？你可能在参加函数式编程的时候听说过”副作用”(side effects)这个名词,side effects是发生在应用的范围之外的东西.在我们舒适的肥皂泡里,side effect根本不是问题,但是当我们要到达一个远程资源,肥皂泡就被穿透了.有些事情我们就控制不了了,我们必须接受这个事实.(根据这段话，side effect 翻译为意想不到的事情，出乎意料的不受控制的事情更好)在Redux里,reducer没有Side effects.这意味着reducers不处理我们应用中的异步活动.我们不能使用reducers加载远程数据,因为reducers是纯函数,没有side effects.Redux很棒,如果你的应用里没有任何异步活动，你可以停下来,不用再往下看了.如果你创建的应用比较大,可能你会从服务端加载数据,这时,当然要使用异步方式.&gt;**注意**： Redux其中一个最酷的地方是他非常小巧.他试图解决有限范围内的问题.大多数的应用需要解决很多问题!万幸,Reduc提供中间件概念,中间件存在于action-&gt;reducer-&gt;store的三角关系中,通过中间件的方式,可以导入诸如远程数据异步加载类似的功能.其中一个方法是使用`thunks`对象,在Redux中有 redux-thunk 中间件.Thunks非常厉害，但是可能会导致actions的序列很复杂,测试起来也是很大的挑战.考虑到我们的 图片浏览程序.当应用加载是,需要做:- 从服务器请求图片数组- 当图片加载完毕,显示提示消息- 当远程数据返回以后,选择初始图片显示- 处理可能出现的错误这些事件都要在用户点击应用里的任何元素之前完成!我们该怎么做呢？redux-saga就是为此而诞生,为我们的应用提供绝佳的服务.redux-sageredux-sage可以在Redux应用中操作异步actions.他提供中间件和趁手的方法使构建复杂的异步操作流程轻而易举.一个saga是一个Generator(生成器),Generator函数是ES2015新添加的特性.可能是你第一次遇到Generator函数,这样你会觉得有点古怪,可以参考(ruanyifeng文章).不要苦恼，如果你对此仍然很抓耳挠腮.使用redux-sage你不需要javascript异步编程的博士学位.因为使用了generators的缘故,我们能创建一个顺序执行的命令序列，用来描述复杂的异步操作流程(workflows).整个图片的加载流程序列如下： export function* loadImages() { try { const images = yield call(fetchImages); yield put({type: ‘IMAGES_LOADED’, images}) yield put({type: ‘IMAGE_SELECTED’, image: images[0]}) } catch(error) { yield put({type: ‘IMAGE_LOAD_FAILURE’, error}) }} export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield call(loadImages); }}123456 #### 第一个saga我们将开始一个简单的saga实例,然后配置他连接到我们的应用.在`src`创建一个文件`saga.js` export function* sayHello() { console.log(‘hello’);} 1234___我们的saga是一个简单的generator函数.函数后面的`*`作为标志,他也被叫做”super star”.现在在`main.js`文件中导入新函数,并且执行他. import “babel-polyfill”; import React from ‘react’;import ReactDOM from ‘react-dom’; import Gallery from ‘./Gallery’; import { createStore } from ‘redux’import {Provider} from ‘react-redux’;import reducer from ‘./reducer’ +import {sayHello} from ‘./sagas’;+sayHello(); const store = createStore(reducer); ReactDOM.render( , document.getElementById(‘root’));12345不管你盯住终端多长时间,“hello”永远不会出现.这是因为`sayHello`是一个generator！Generator 不会立即执行.如果你把代码该为`sayHello().next();`你的“hello”就出现了.不用担心,我们不会总是调用`next`.正如Redux,redux-saga用来消除应用开发中的痛苦.配置 redux-sage import “babel-polyfill”; import React from ‘react’;import ReactDOM from ‘react-dom’; import Gallery from ‘./Gallery’; -import { createStore } from ‘redux’+import { createStore, applyMiddleware } from ‘redux’+import createSagaMiddleware from ‘redux-saga’import {Provider} from ‘react-redux’;import reducer from ‘./reducer’ import {sayHello} from ‘./sagas’;-sayHello() -const store = createStore(reducer);+const store = createStore( reducer, applyMiddleware(createSagaMiddleware(sayHello))+); ReactDOM.render( , document.getElementById(‘root’));123456789 我们已从Redux导入了`applyMiddleware`函数.从redux-saga导入`createSagaMiddleware`函数.当我们创建store的时候,我们需要通过中间件提供Redux需要的功能.在这个实例中,我们会调用`applyMiddleware`函数,这个函数返回`createSagaMiddleware(sayHello)`的结果.在幕后,redux-saga加载`sayHello`函数,仪式性的调用`next`函数. 应该可以在终端中看到提示消息了. 现在让我们构建加载图片的saga #### 通过Saga加载图片数据我们将删除出sayHello saga,使用`loadImages` saga -export function* sayHello() { console.log(‘hello’);-} +export function* loadImages() { console.log(‘load some images please’)+}12不要忘了更新`main.js` import “babel-polyfill”; import React from ‘react’;import ReactDOM from ‘react-dom’; import Gallery from ‘./Gallery’; import { createStore, applyMiddleware } from ‘redux’import {Provider} from ‘react-redux’;import createSagaMiddleware from ‘redux-saga’import reducer from ‘./reducer’ -import {sayHello} from ‘./sagas’;+import {loadImages} from ‘./sagas’; const store = createStore( reducer, applyMiddleware(createSagaMiddleware(sayHello)) applyMiddleware(createSagaMiddleware(loadImages))); ReactDOM.render( , document.getElementById(‘root’));12现在saga已经加载,在`saga.js`中添加`fetchImages`方法 const API_KEY = &apos;a46a979f39c49975dbdd23b378e6d3d5&apos;; const API_ENDPOINT = https://api.flickr.com/services/rest/?method=flickr.interestingness.getList&amp;api_key=${API_KEY}&amp;format=json&amp;nojsoncallback=1&amp;per_page=5; const fetchImages = () =&gt; { return fetch(APIENDPOINT).then(function (response) { return response.json().then(function (json) { return json.photos.photo.map( ({farm, server, id, secret}) =&gt; `https://farm${farm}.staticflickr.com/${server}/${id}${secret}.jpg` ); }) })}; export function* loadImages() { const images = yield fetchImages(); console.log(images)}12345678 `fetchImages`方法返回一个promise对象.我们将调用`fetchImages`,但是现在我们要使用`yield`关键字.通过黑暗艺术和巫术,generators理解Promise对象,正如终端输出的日志显示,我们已经收获了一个图片URLs的数组.看看`loadImages`的代码,他看起来像是典型的同步操作代码.`yield`关键字是秘制调味酱,让我们的代码用同步格式执行异步操作活动. #### 封装我们的异步API请求. 首先来定义一下需要使用的api.他没有什么特殊的地方,实际上他和早先加载Flickr images的代码是相同的.我们创建`flickr.js`文件 const API_KEY = ‘a46a979f39c49975dbdd23b378e6d3d5’;const API_ENDPOINT = https://api.flickr.com/services/rest/?method=flickr.interestingness.getList&amp;api_key=${API_KEY}&amp;format=json&amp;nojsoncallback=1&amp;per_page=5; export const fetchImages = () =&gt; { return fetch(APIENDPOINT).then(function (response) { return response.json().then(function (json) { return json.photos.photo.map( ({farm, server, id, secret}) =&gt; `https://farm${farm}.staticflickr.com/${server}/${id}${secret}.jpg` ); }) })};123456 严格意义上来说,不需要这么做,但是这会带来一定的好处.我们处在应用的边缘(boundaries of our application,意思是说在这里的代码可能是很多和远程服务器交互的代码，可能逻辑会很复杂),事情都有点乱.通过封装和远程API交互的逻辑,我们的代码将会很整洁,很容易更新.如果需要抹掉图片服务也会出奇的简单.我们的`saga.js`看起来是这个样子： import {fetchImages} from ‘./flickr’; export function* loadImages() { const images = yield fetchImages(); console.log(images)}1234567我们仍然需要在saga外获取数据,并且进入应用的state(使用异步获取的远程数据更新state).为了处理这个问题,我们将使用”effects”.#### 从saga来更新应用我们可以通过`dispatch`或者store作为参数来调用saga,但是这个方法时间一长就会给人造成些许的困扰.我们选择采用redux-saga提供的`put`方法.首先我们更新`reducer.js`操作一个新的action类型`IMAGES_LOADED`. const defaultState = { images: []} export default function images(state = defaultState, action) { switch(action.type) { case ‘IMAGE_SELECTED’: return {…state, selectedImage: action.image}; case ‘IMAGES_LOADED’: return {…state, images: action.images};default:return state;}} 1234我们添加了新的分支,并从`defaultState`中删除了硬编码的URLs数据.`IMAGES_LOADED`分支现在返回一个更新的state,包含action的image数据.下一步我们更新saga: import {fetchImages} from ‘./flickr’;+import {put} from ‘redux-saga/effects’; export function* loadImages() { const images = yield fetchImages(); yield put({type: ‘IMAGES_LOADED’, images})}1234567导入`put`以后,我们在`loadImages`添加另外一行.他`yield` `put`函数调用的返回结果.在幕后,redux-saga 分发这些动作,reducer接收到了消息! 怎样才能使用特定类型的action来触发一个saga? #### 使用actions来触发saga工作流Sagas变得越来越有用,因为我们有能力使用redux actions来触发工作流.当我们这样做,saga会在我们的应用中表现出更大的能力.首先我们创建一个新的saga.`watchForLoadImages`. import {fetchImages} from ‘./flickr’;-import {put} from ‘redux-saga/effects’;+import {put, take} from ‘redux-saga/effects’; export function* loadImages() { const images = yield fetchImages(); yield put({type: ‘IMAGES_LOADED’, images})} +export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield loadImages(); }+}12新的saga使用的是while来保持一直激活和等待调用状态.在循环的内部,我们生成(yield)一个redux-sage调用方法:`take`.Take方法监听任何类型的actions,他也会使saga接受下一个yield.在上面的例子中我们调用了一个方法`loadImages`,初始化图片加载. import “babel-polyfill”; import React from ‘react’;import ReactDOM from ‘react-dom’; import Gallery from ‘./Gallery’; import { createStore, applyMiddleware } from ‘redux’import {Provider} from ‘react-redux’;import createSagaMiddleware from ‘redux-saga’import reducer from ‘./reducer’ -import {loadImages} from ‘./sagas’;+import {loadImages} from ‘./watchForLoadImages’; const store = createStore( reducer, applyMiddleware(createSagaMiddleware(loadImages)) applyMiddleware(createSagaMiddleware(watchForLoadImages))); ReactDOM.render( , document.getElementById(‘root’));12更新了`main.js`以后,应用不再加载图片,我们需要在action creators中添加`loadImages`的`action`. export const IMAGE_SELECTED = ‘IMAGE_SELECTED’;+const LOAD_IMAGES = ‘LOAD_IMAGES’; export function selectImage(image) { return { type: IMAGE_SELECTED, image }} +export function loadImages() { return { type: LOAD_IMAGES }+}1234567因为我们已经绑定了action creators(Action创建器),我们只需要在`Gallery`组件中调用这个action就可以了.#### block(阻塞)和no-blocking(非阻塞)效应现在我们的引用工作的足够好了,但是可能还有更多的问题需要考虑.`watchForLoadImages` saga包含 block effects.那么这到底是什么意思呢？这意味着在工作流中我们只能执行一次`LOAD_IMAGES`!在诸如我们现在构建的小型应用一样,这一点不太明显,实际上我们也仅仅加载了一次图片集.实际上，普遍的做法是使用`fork` effect 代替 `yield` 来加载图片. export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield loadImages(); yield fork(loadImages); //be sure to import it!}}12345使用`fork`助手(helper)函数,`watchForLoadImages`就变成了非阻塞saga了,再也不用考虑他是不是以前掉用过.redux-sagas 提供两个helpers,`takeEvery`和`takeLastest`（takeEvery监听多次action，不考虑是不是同一种action type,takeLatest只处理同一种action type的最后一次调用）.####选择默认的图片Sagas按照队列来执行acitons,所以添加更多的saga也很容易. import {fetchImages} from ‘./flickr’;import {put, take, fork} from ‘redux-saga/effects’; export function* loadImages() { const images = yield fetchImages(); yield put({type: ‘IMAGES_LOADED’, images}) yield put({type: ‘IMAGE_SELECTED’, image: images[0]})} export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield fork(loadImages); }}1234在 `loadImages`工作流上,我们可以yield put函数调用,action type是`IMAGE_SELECTED`.发送我们选择的图片(在这个例子中，发送的仅仅是图片的url的字符串).#### 错误处理如果在saga循环内部出现错误,我们要考虑提醒应用做出合理的回应.所有流程包装到try/catch语句块里就可以实现,捕获错误以后`put`一个提示信息作为`IMAGE_LOAD_FAILURE` action的内容. import {fetchImages} from ‘./flickr’;import {put, take, fork} from ‘redux-saga/effects’; export function* loadImages() { try { const images = yield fetchImages(); yield put({type: ‘IMAGES_LOADED’, images}) yield put({type: ‘IMAGE_SELECTED’, image: images[0]}) } catch(error) { yield put({type: ‘IMAGE_LOAD_FAILURE’, error}) }} export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield fork(loadImages); }}123456#### Sagas的测试在应用中使用Redux,测试变得相当的舒服. 看看我们的[鹅蛋头系列课程](https://egghead.io/series/react-testing-cookbook),可以了解到很多React的测试技术.使用Redux-saga在棒的一个方面就是异步代码测试很容易.测试javascript异步代码真是一件苦差事.有了saga,我们不需要跳出引用的核心代码.Saga把javascript的痛点都抹掉了.是不是意味着我们要写更多的测试?对的.我们会使用`tape`组件,首先做一些配置工作. import test from ‘tape’;import {put, take} from ‘redux-saga/effects’import {watchForLoadImages, loadImages} from ‘./sagas’;import {fetchImages} from ‘./flickr’; test(‘watchForLoadImages’, assert =&gt; { const generator = watchForLoadImages(); assert.end();});12添加所有需要的组件,现在我们添加一个测试.这个测试接收一个名称和一个函数作为形参.在测试的函数体内部代码块,我们创建了一个saga生成器代码实例.在这个实例里面我们尅是测试saga的每一个动作. import test from ‘tape’;import {put, take} from ‘redux-saga/effects’import {watchForLoadImages, loadImages} from ‘./sagas’;import {fetchImages} from ‘./flickr’; test(‘watchForLoadImages’, assert =&gt; { const generator = watchForLoadImages(); assert.deepEqual( generator.next().value, false, ‘watchForLoadImages should be waiting for LOAD_IMAGES action’ ); assert.end();}); 123`assert.deepEqual`方法接收两个值,检查一下他们是不是深度相同(js对象的概念).第一行代码是`generator.next().value`的调用,这个调用使生成器从暂停中恢复,得到值.下一个值单单是一个`false`.我想看到他失败,最后一个参数描述了测试期待的行为.在项目文件夹中命令行运行`npm test`看看结果: import test from ‘tape’;import {put, take} from ‘redux-saga/effects’import {watchForLoadImages, loadImages} from ‘./sagas’;import {fetchImages} from ‘./flickr’; test(‘watchForLoadImages’, assert =&gt; { const generator = watchForLoadImages(); assert.deepEqual( generator.next().value, false, ‘watchForLoadImages should be waiting for LOAD_IMAGES action’ ); assert.end();}); 12测试结果和预期的一样失败,结果有点意思.实际的结论是`&#123;TAKE:'LOAD_IMAGES'&#125;`,这是我们调用`take('LOAD_IMAGES')`受到的结果.实际上,我们的saga’可以yield一个对象来代替调用`take`.但是`take`添加了一些代码,让我们少敲些代码. import test from ‘tape’;import {put, take} from ‘redux-saga/effects’import {watchForLoadImages, loadImages} from ‘./sagas’;import {fetchImages} from ‘./flickr’; test(‘watchForLoadImages’, assert =&gt; { const generator = watchForLoadImages(); assert.deepEqual( generator.next().value, false take(‘LOAD_IMAGES’),‘watchForLoadImages should be waiting for LOAD_IMAGES action’); assert.end();}); 12我们简单的调用`take`函数,就可以得到期待的结果了. import test from ‘tape’;import {put, take} from ‘redux-saga/effects’import {watchForLoadImages, loadImages} from ‘./sagas’;import {fetchImages} from ‘./flickr’; test(‘watchForLoadImages’, assert =&gt; { const generator = watchForLoadImages(); assert.deepEqual( generator.next().value, take(‘LOAD_IMAGES’), ‘watchForLoadImages should be waiting for LOAD_IMAGES action’ ); assert.deepEqual( gen.next().value, false, ‘watchForLoadImages should call loadImages after LOAD_IMAGES action is received’ ); assert.end();}); 1234下一个测试使我们确信`loadImages`saga在流程的下一个阶段会被自动调用.我们需要一个 false来检查结果.更新一下saga代码,yield一个`loadImages` saga: export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield loadImages(); yield fork(loadImages); //be sure to import it!}}12现在运行测试,将会看到下面结果： ✖ watchForLoadImages should call loadImages after LOAD_IMAGES action is received operator: deepEqual expected: |- false actual: |- { _invoke: [Function: invoke] }1234哼！`&#123; _invoke: [Function: invoke] &#125;`绝对不是我们yield take想要的结果.有问题.幸运的是redux-saga可以使用诸如`fork`一样的`effects`来解决这个问题.`fork`,`take`和其他的effect方法返容易满足测试要求的简单对象.这些effects返回的对象是一个指导redux-saga进行任务执行的集合.这一点对于测试来说非常的优雅,因为我们不用担心类似远程服务请求的副作用.有了redux-saga,我们把注意点放到请求执行的命令上.下面让我们更新一下saga,再一次使用`fork`. export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield loadImages(); yield fork(loadImages); }} 1234这里使用`yield fork(loadImages)`直接代替`loadImages`.需要注意的是我们还没有执行`loadImages`,而是作为参数传递给`fork`.再次运行`npm test`. ✖ watchForLoadImages should call loadImages after LOAD_IMAGES action is received operator: deepEqual expected: |- false actual: |- { FORK: { args: [], context: null, fn: [Function: loadImages] } }12结果得到了一个单纯对象而不是一个函数调用.函数在浏览器端也同时加载了,但是我们现在可以轻松的在saga 工作流里测试这个步骤. import test from ‘tape’;import {put, take} from ‘redux-saga/effects’import {watchForLoadImages, loadImages} from ‘./sagas’;import {fetchImages} from ‘./flickr’; test(‘watchForLoadImages’, assert =&gt; { const generator = watchForLoadImages(); assert.deepEqual( generator.next().value, take(‘LOAD_IMAGES’), ‘watchForLoadImages should be waiting for LOAD_IMAGES action’ ); assert.deepEqual( generator.next().value, false, yield fork(loadImages),‘watchForLoadImages should call loadImages after LOAD_IMAGES action is received’); assert.end();}); 12测试`loadImages`saga是一样的,只需要把`yield fetchImages`更新为`yield fork(fetchImages)`. test(‘loadImages’, assert =&gt; { const gen = loadImages(); assert.deepEqual( gen.next().value, call(fetchImages), ‘loadImages should call the fetchImages api’ ); const images = [0]; assert.deepEqual( gen.next(images).value, put({type: ‘IMAGES_LOADED’, images}), ‘loadImages should dispatch an IMAGES_LOADED action with the images’ ); assert.deepEqual( gen.next(images).value, put({type: ‘IMAGE_SELECTED’, image: images[0]}), ‘loadImages should dispatch an IMAGE_SELECTED action with the first image’ ); const error = ‘error’; assert.deepEqual( gen.throw(error).value, put({type: ‘IMAGE_LOAD_FAILURE’, error}), ‘loadImages should dispatch an IMAGE_LOAD_FAILURE if an error is thrown’ ); assert.end();});``` 特别注意最后一个assert.这个断言测试使用异常捕获代替生成器函数的next方法.另一个非常酷的地方是：可以传值.注意看代码,我们创建了images常量,并且传递到next函数.saga可以在接下来的任务序列中使用传递的值. 太棒了,这种方法是测试异步编程的程序员梦寐以求的技术. 接下来做什么？ 你可以fork一下这个例子的代码. 如果你想扩充这个应用,可以做一下几个方面的工作. 做一个幻灯显示下一张要显示的图片 允许使用者搜索Flickr图片 添加其他提供图片的API 允许用户选择喜欢的API进行搜索. 我们仅仅和生成器碰了一下面,但是即便如此,希望在联合使用redux-saga library,Redux和React的时候给你一些帮助.","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"saga","slug":"saga","permalink":"https://React-Apollo.github.io/tags/saga/"}]},{"title":"翻译|redux undo/redo  reducer增强组件","slug":"翻译-redux-undo-redo-reducer增强组件","date":"2017-04-04T13:18:28.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2017/04/04/翻译-redux-undo-redo-reducer增强组件/","link":"","permalink":"https://React-Apollo.github.io/2017/04/04/翻译-redux-undo-redo-reducer增强组件/","excerpt":"","text":"Redux的文档中提供一个可以做undo/redo的解决办法,实际是有previous,current,prew的对象,围绕这数据的压入和弹出来实现操作步骤的记忆,结合persist就可以实现更强大的记忆功能.今天的这个增强组件实际把这个功能给包装了一下,内部实现细节仍然没有变.只需要把reducer用这个增强组件包装一下就可以用了. redux undo/redo 提示:你可以使用redux-undo-boilerplate来开始项目. Installation1npm install --save redux-undo API123import undoable from 'redux-undo';undoable(reducer)undoable(reducer, config) 让你的reducers变得可以重做redux-undo是一个reducer增强组件,它提供了undoable函数,这个函数接收已经存在的reducer和配置对象,使用undo函数增强已经存在的reducer. 注意：如果在state.counter之前接入,你必须要在包装reducer之后接入state.coutner.present. 首先导入redux-undo1234 // Redux utility functions import &#123; combineReducers &#125; from 'redux';// redux-undo higher-order reducer import undoable from 'redux-undo'; 接着,添加undoable到你的reducer123combineReducers(&#123; counter: undoable(counter)&#125;) 配置项想这样传递12345combineReducers(&#123; counter: undoable(counter, &#123; limit: 10 // set a limit for the history &#125;)&#125;) 历史API使用reducer包装你的reducer想这样12345 &#123; past: [...pastStatesHere...], present: &#123;...currentStateHere...&#125;, future: [...futureStatesHere...]&#125; 现在你可以使用state.present获取当前的state获取所有过去的state使用state.past. Undo/Redo Actions首先导入undo/redo action creators1import &#123; ActionCreators &#125; from 'redux-undo'; 然后就可以使用store.dispatch()和undo/redo action creators来执行undo/redo操作.12345store.dispatch(ActionCreators.undo()) // undo the last action store.dispatch(ActionCreators.redo()) // redo the last action store.dispatch(ActionCreators.jumpToPast(index)) // jump to requested index in the past[] array store.dispatch(ActionCreators.jumpToFuture(index)) // jump to requested index in the future[] array 配置配置对象传递给undoable()(值是默认值) 123456789101112131415161718192021undoable(reducer, &#123; limit: false, // set to a number to turn on a limit for the history filter: () =&gt; true, // see `Filtering Actions` section undoType: ActionTypes.UNDO, // define a custom action type for this undo action redoType: ActionTypes.REDO, // define a custom action type for this redo action jumpToPastType: ActionTypes.JUMP_TO_PAST, // define custom action type for this jumpToPast action jumpToFutureType: ActionTypes.JUMP_TO_FUTURE, // define custom action type for this jumpToFuture action initialState: undefined, // initial state (e.g. for loading) initTypes: ['@@redux/INIT', '@@INIT'] // history will be (re)set upon init action type initialHistory: &#123; // initial history (e.g. for loading) past: [], present: config.initialState, future: [] &#125;, debug: false, // set to `true` to turn on debugging &#125;) 过滤Actions如果你不想包含每一步的action,可以传递一个函数到undoable123456789undoable(reducer, function filterActions(action, currentState, previousState) &#123; return action.type === SOME_ACTION; // only add to history if action is SOME_ACTION只有some_action的action才能记录 &#125;) // or you could do... undoable(reducer, function filterState(action, currentState, previousState) &#123; return currentState !== previousState; // only add to history if state changed只有state变化的才能记录重做 &#125;) 或者你可以使用distinctState,includeAction,excludeAction助手函数1import undoable, &#123; distinctState, includeAction, excludeAction &#125; from 'redux-undo'; 现在你可以使用助手函数了,相当简单123456undoable(reducer, &#123; filter: includeAction(SOME_ACTION) &#125;)undoable(reducer, &#123; filter: excludeAction(SOME_ACTION) &#125;) // or you could do... undoable(reducer, &#123; filter: distinctState() &#125;) 甚至还支持数组12 undoable(reducer, &#123; filter: includeAction([SOME_ACTION, SOME_OTHER_ACTION]) &#125;)undoable(reducer, &#123; filter: excludeAction([SOME_ACTION, SOME_OTHER_ACTION]) &#125;) 有什么魔法？怎么工作的Redux文档中的实现Undo历史的方案解释了redux-undo工作的具体细节.","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"}]},{"title":"CRA项目部署到ghpage的方法","slug":"CRA项目的Github-Page部署","date":"2017-04-04T13:18:28.000Z","updated":"2018-04-07T02:42:18.247Z","comments":true,"path":"2017/04/04/CRA项目的Github-Page部署/","link":"","permalink":"https://React-Apollo.github.io/2017/04/04/CRA项目的Github-Page部署/","excerpt":"","text":"GitHub Pages Note: this feature is available with react-scripts@0.2.0 and higher. Step 1: Add homepage to package.jsonThe step below is important!If you skip it, your app will not deploy correctly. Open your package.json and add a homepage field for your project: 1\"homepage\": \"https://myusername.github.io/my-app\", or for a GitHub user page: 1\"homepage\": \"https://myusername.github.io\", Create React App uses the homepage field to determine the root URL in the built HTML file. Step 2: Install gh-pages and add deploy to scripts in package.jsonNow, whenever you run npm run build, you will see a cheat sheet with instructions on how to deploy to GitHub Pages. To publish it at https://myusername.github.io/my-app, run: 1npm install --save gh-pages Alternatively you may use yarn: 1yarn add gh-pages Add the following scripts in your package.json: 12345 \"scripts\": &#123;+ \"predeploy\": \"npm run build\",+ \"deploy\": \"gh-pages -d build\", \"start\": \"react-scripts start\", \"build\": \"react-scripts build\", The predeploy script will run automatically before deploy is run. If you are deploying to a GitHub user page instead of a project page you&#39;ll need to make two additional modifications: First, change your repository’s source branch to be any branch other than master. Additionally, tweak your package.json scripts to push deployments to master:1234 \"scripts\": &#123; \"predeploy\": \"npm run build\",- \"deploy\": \"gh-pages -d build\",+ \"deploy\": \"gh-pages -b master -d build\", Step 3: Deploy the site by running npm run deployThen run: 1npm run deploy Step 4: Ensure your project’s settings use gh-pagesFinally, make sure GitHub Pages option in your GitHub project settings is set to use the gh-pages branch: Step 5: Optionally, configure the domainYou can configure a custom domain with GitHub Pages by adding a CNAME file to the public/ folder. Notes on client-side routingGitHub Pages doesn’t support routers that use the HTML5 pushState history API under the hood (for example, React Router using browserHistory). This is because when there is a fresh page load for a url like http://user.github.io/todomvc/todos/42, where /todos/42 is a frontend route, the GitHub Pages server returns 404 because it knows nothing of /todos/42. If you want to add a router to a project hosted on GitHub Pages, here are a couple of solutions: You could switch from using HTML5 history API to routing with hashes. If you use React Router, you can switch to hashHistory for this effect, but the URL will be longer and more verbose (for example, http://user.github.io/todomvc/#/todos/42?_k=yknaj). Read more about different history implementations in React Router. Alternatively, you can use a trick to teach GitHub Pages to handle 404 by redirecting to your index.html page with a special redirect parameter. You would need to add a 404.html file with the redirection code to the build folder before deploying your project, and you’ll need to add code handling the redirect parameter to index.html. You can find a detailed explanation of this technique in this guide.","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[{"name":"CRA","slug":"CRA","permalink":"https://React-Apollo.github.io/tags/CRA/"},{"name":"ghpage","slug":"ghpage","permalink":"https://React-Apollo.github.io/tags/ghpage/"}]},{"title":"翻译|使用React,Redux和reudx-saga构建一个图像浏览程序","slug":"using react redux and redux-saga building a app","date":"2017-03-28T08:17:07.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2017/03/28/using react redux and redux-saga building a app/","link":"","permalink":"https://React-Apollo.github.io/2017/03/28/using react redux and redux-saga building a app/","excerpt":"","text":"###使用React,Redux和reudx-saga构建一个图像浏览程序(翻译)Joel Hooks ,2016年3月 #####构建一个图片长廊 图像长廊是一个简单的程序，从Flicker API 加载图片urls,允许用户查看图片详情。 图片1 后续会使用React,Redux和redux-saga.React作为核心框架，优势是虚拟dom(virtual-dom)的实现。Redux在程序内负责state的管理。最后，我们会使用redux-saga来操作javascript的异步操作步骤。 我会是用ES6(箭头函数，模块，和模板字符串)，所以我们首先需要做一些项目的配置工作。 项目配置和自动化 如果要开始一个React项目，须有有一系列的配置选项。对于一个简单的项目，我想把配置选项尽可能缩减。考虑到浏览器的版本问题，我会使用Babel把ES6编译为ES5。后面这一句不懂 首先使用npm init 创建一个package.json文件 package.json 123456789101112131415161718192021222324252627282930313233343536 &#123; \"name\": \"egghead-react-redux-image-gallery\", \"version\": \"0.0.1\", \"description\": \"Redux Saga beginner tutorial\", \"main\": \"src/main.js\", \"scripts\": &#123; \"test\": \"babel-node ./src/saga.spec.js | tap-spec\", \"start\": \"budo ./src/main.js:build.js --dir ./src --verbose --live -- -t babelify\" &#125;, \"repository\": &#123; \"type\": \"git\", \"url\": \"git+https://github.com/joelhooks/egghead-react-redux-image-gallery.git\" &#125;, \"author\": \"Joel Hooks &lt;joelhooks@gmail.com&gt;\", \"license\": \"MIT\", \"dependencies\": &#123; \"babel-polyfill\": \"6.3.14\", \"react\": \"^0.14.3\", \"react-dom\": \"^0.14.3\", \"react-redux\": \"^4.4.1\", \"redux\": \"^3.3.1\", \"redux-saga\": \"^0.8.0\" &#125;, \"devDependencies\": &#123; \"babel-cli\": \"^6.1.18\", \"babel-core\": \"6.4.0\", \"babel-preset-es2015\": \"^6.1.18\", \"babel-preset-react\": \"^6.1.18\", \"babel-preset-stage-2\": \"^6.1.18\", \"babelify\": \"^7.2.0\", \"browserify\": \"^13.0.0\", \"budo\": \"^8.0.4\", \"tap-spec\": \"^4.1.1\", \"tape\": \"^4.2.2\" &#125;&#125; 有了package.json, 可以在项目文件夹命令行运行 npm install 安装程序需要的依赖项。 .babelrc 12345678910&#123; \"presets\": [\"es2015\", \"react\", \"stage-2\"] &#125; ``` 这个文件告诉babel,我们将会使用ES2015(ES6),React以及ES2106的stage-2的一些特征。`package.json`有两个标准的script脚本配置：`start`和`test`.现在我们想通过start脚本加载程序，start会使用`src`目录的一些文件，所以西药先创建`src`文件夹.在`src`文件夹添加下面的一些文：`index.html` &lt;!doctype html&gt; egghead: React Redux Image Gallery Egghead Image Gallery 1234___`main.js` import &quot;babel-polyfill&quot; import React from ‘react’import ReactDOM from ‘react-dom’ ReactDOM.render( Hello React!, document.getElementById(‘root’));12`style.css` body { font-family: Helvetica, Arial, Sans-Serif, sans-serif; background: white; } .title { display: flex; padding: 2px;} .egghead { width: 30px; padding: 5px;} .image-gallery { width: 300px; display: flex; flex-direction: column; border: 1px solid darkgray;} .gallery-image { height: 250px; display: flex; align-items: center; justify-content: center;} .gallery-image img { width: 100%; max-height: 250px;} .image-scroller { display: flex; justify-content: space-around; overflow: auto; overflow-y: hidden;} .image-scroller img { width: 50px; height: 50px; padding: 1px; border: 1px solid black;} 12345678910111213`index.html`文件加载`style.css`文件提供一些基本的布局样式，同时也加载`build.js`文件，这是一个生成出来的文件.`main.js`是一个最基础的React程序，他在`index.html`的`#root`元素中渲染一个`h1`元素。创建这些文件以后，在项目文件夹中命令行运行`npm start`。在浏览器打开`http://10.11.12.1:9966`.就可以看到`index.html`中渲染的页面图2现在我们来构建基础的`Gallery` React 组件#####在Gallery中显示一些图片___ 首先我们需要尽可能快的获得一个可以显示的图片素材.在项目文件夹中创建一个文件`Gallery.js``Gallery.js` import React, {Component} from &apos;react&apos; const flickrImages = [ “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg“, “https://farm2.staticflickr.com/1581/25283151224_50f8da511e.jpg“, “https://farm2.staticflickr.com/1653/25265109363_f204ea7b54.jpg“, “https://farm2.staticflickr.com/1571/25911417225_a74c8041b0.jpg“, “https://farm2.staticflickr.com/1450/25888412766_44745cbca3.jpg“]; export default class Gallery extends Component { constructor(props) { super(props); this.state = { images: flickrImages, selectedImage: flickrImages[0] } } render() { const {images, selectedImage} = this.state; return ( {images.map((image, index) =&gt; ( ))} ) }}123我们直接在组件中硬编码了一个提供数据的数组，能让项目尽快的工作起来.`Gallery组件`继承`Component组件`,在构造函数中创建一些组件的出事状态.最后我们利用一些样式标记渲染一下文件。`image-scroller`元素遍历(`map`方法)图片数组,生成摘要图片。 import &quot;babel-polyfill&quot; import React from ‘react’import ReactDOM from ‘react-dom’ import Gallery from ‘./Gallery’ ReactDOM.render( Hello React!, ,document.getElementById(‘root’));12345678910111213141516171819202122232425262728293031323334353637383940414243 到现在，我们使用硬编码的图片URLs(通过fickrImages)数组,第一张图片作为`selectedImage`.这些属性在`Gallery`组件的构造函数缺省配置中，通过初始状态(initial)来设定. 图片3 接下来在组件中添加一个和组件进行交互操作的方法，方法具体内容是操做`setSate`. `Gallery.js` ```js export default class Gallery extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; images: flickrImages, selectedImage: flickrImages[0] &#125; &#125;+ handleThumbClick(selectedImage) &#123;+ this.setState(&#123;+ selectedImage+ &#125;)+ &#125; render() &#123; const &#123;images, selectedImage&#125; = this.state; return ( &lt;div className=\"image-gallery\"&gt; &lt;div className=\"gallery-image\"&gt; &lt;div&gt; &lt;img src=&#123;selectedImage&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"image-scroller\"&gt; &#123;images.map((image, index) =&gt; (- &lt;div key=&#123;index&#125;&gt;+ &lt;div key=&#123;index&#125; onClick=&#123;this.handleThumbClick.bind(this,image)&#125;&gt; &lt;img src=&#123;image&#125;/&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 在Gallery组件添加handleThumbClick方法,任何元素都可用通过onClick属性调用这个方法.image作为第二个参数传递，元素自身作为第一个参数传递.bind方法传递javascript函数调用上下文对象是非常便捷。 看起来错!现在我们有了一些交互操作，有点“APP”的意思了。截止目前，我们已经让app运行起来了，接下来要考虑加载远程数据。最容易加载远程数据的地方是一个React组件生命周期方法,我们使用componentDidMount方法,通过他从Flikr API请求并加载一些图片. Gallery.js 1234567891011121314151617181920212223 export default class Gallery extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; images: flickrImages, selectedImage: flickrImages[0] &#125; &#125;+ componentDidMount() &#123;+ const API_KEY = 'a46a979f39c49975dbdd23b378e6d3d5';+ const API_ENDPOINT = `https://api.flickr.com/services/rest/?method=flickr.interestingness.+getList&amp;api_key=$&#123;API_KEY&#125;&amp;format=json&amp;nojsoncallback=1&amp;per_page=5`;+++ fetch(API_ENDPOINT).then((response) =&gt; &#123;+ return response.json().then((json) =&gt; &#123;+ const images = json.photos.photo.map((&#123;farm, server, id, secret&#125;) =&gt; &#123; + return `https://farm$&#123;farm&#125;.staticflickr.com/$&#123;server&#125;/$&#123;id&#125;_$&#123;secret&#125;.jpg`+ &#125;);++ this.setState(&#123;images, selectedImage: images[0]&#125;);+ &#125;)+ &#125;)+ &#125;[...] 我们在Gallery类中添加了一个新的方法,通过React的componentDidMount生命周期方法触发Flickr图片数据的获取。 在React组件运行的不同时间点，组件会调用不同的生命周期函数。在这段代码中，当组件被渲染到DOM中的时间点,componentDidMount函数就会被调用。需要注意的是:Gallery组件只有一次渲染到DOM的机会，所以这个函数可以提供一些初始化图片.考虑到在APP的整个生命周期中,有更多的动态组件的加载和卸载,这可能会造成一些多余的调用和无法考虑到的结果。 我们使用浏览器接口(browser API)的fetch方法执行请求.Fetch返回一个promise对象解析response对象.调用response.json()方法,返回另一个promise对象，这就是我们实际需要的json格式的数据.遍历这个对象以后就可以获取图片的url地址. 坦白讲，这个应用很简单.我们还需要在这里花费更多的时间，还有一些基础的需求需要完成.或许我们应该在promise处理流程中添加错误处理方法,如果图片数据获取成功也需要一些处理逻辑.在这个地方，你需要发挥一些想象力.在生产实践中简单的需求是很少见的.很快,应用中就会添加更多的需求。认证,滚动橱窗,加载不同图片库的能力和图片的设置等等.仅仅这些还还不够. 我们已经使用React构建了一个加载图片库的程序。接下来我们需要考虑到随着程序功能的添加，到底需要哪些基础的模式.首先考虑到的一个问题就是要把应用的状态(state)控制从Gallery组件中分离出来. 我们通过引入Redux来完成应用的状态管理工作。 使用Redux来管理状态在你的应用中只要使用了setState方法都会让一个组件从无状态变为有状态的组件.糟糕的是这个方法会导致应用中出现一些令人困惑的代码,这些代码会在应用中到处蔓延。 Flux构架来减轻这个问题.Flux把逻辑(logic)和状态(state)迁移到Store中.应用中的动作(Actions)被Dispatch的时候,Stores会做相应的更新.Stores的更新会触发View根据新状态的渲染. 那么我们为什么要舍弃Flux?他竟然还是“官方”构建的.好吧！Redux是基于Flux构架的,但是他有一些独特的优势.下面是Dan Abramov(Redux创建者)的一些话： Redux和Flux没有什么不同.总体来讲他们是相同的构架,但是Redux通过功能组合把Flux使用回调注册的复杂点给屏蔽掉了.两个构架从更本上讲没有什么不同，但是我发现Redux使一些在Flux比较难实现的逻辑更容易实现. Redux文档非常棒.Dan(这句话不知道怎么翻译了)如果你还没有读过代码的卡通教程或者Dan的系列文章.赶快去看看吧！ ###启动Redux 第一件需要做的事事初始化Redux,让他在我们的程序中运行起来.现在不需要做安装工作，刚开始运行npm install的时候已经安装好了依赖项，我们需要做一些导入和配置工作.reducer函数是Redux的大脑. 每当应用分发(或派遣,dispatch)一个操作(action)的时候,reducer函数会接受操作(action)并且依据这个动作(action)创建reducer自己的state.因为reducers是纯函数，他们可以组合到一起，创建应用的一个完整state.让我们在src中创建一个简单的reducer: reducer.js 1234export default function images(state, action) &#123; console.log(state, action) return state;&#125; 一个reducer函数接受两个参数(arguments). [x] state-这个数据代表应用的状态(state).reducer函数使用这个状态来构建一个reducer自己可以管理的状态.如果状态没有发生改变,reducer会返回输入的状态. [x] action-这是触发reducer的事件.Actions通过store派发(dispatch),由reducer处理.action需要一个type属性来告诉reducer怎么处理state. 目前,images reuducer在终端中打印出日志记录，表明工作流程是正常的，可以做接下来的工作了.为了使用reducer，需要在main.js中做一些配置工作:main.js 123456789101112131415161718192021import \"babel-polyfill\";import React from 'react';import ReactDOM from 'react-dom';import Gallery from './Gallery';+ import &#123; createStore &#125; from 'redux'+ import reducer from './reducer'+ const store = createStore(reducer);+ import &#123;Provider&#125; from 'react-redux';ReactDOM.render(+ &lt;Provider store=&#123;store&#125;&gt; &lt;Gallery /&gt;+ &lt;/Provider&gt;, document.getElementById('root'));&#125; 我们从Redux库中导入createStore组件.creatStore用来创建Redux的store.大多数情况下,我们不会和store直接交互,store在Redux中做幕后管理工作. 也需要导入刚才创建的reducer函数,以便于他可以被发送到store. 我们将通过createStore(reducer)操作，利用reducer来配置应用的store.这个示例仅仅只有一个reducer,但是createStore可以接收多个reducer作为参数.稍后我们会看到这一点. 最后我们导入高度集成化的组件Provider,这个组件用来包装Gallery,以便于我们在应用中使用Redux.我们需要把刚刚创建的store传递给Provider.你也可以不使用Provider,实际上Redux可以不需要React.但是我们将会使用Provider,因为他非常便于使用. 图3 这张图可能有点古怪，但是展示了Redux的一个有意思的地方.所有的reducers接收在应用中的全部actions(动作或操作).在这个例子中我们可以看到Redux自己派发的一个action. 连接Gallery组件 借助Redux,我们将使用”connected”和“un-connected”组件.一个connected组件被连线到store.connected组件使控制动作事件(controls action event)和store协作起来.通常,一个connected组件有子组件,子组件具有单纯的接收输入和渲染功能，当数据更新时执行调用.这个子组件就是unconnected组件. 提示:当Rect和Redux配合是工作的非常好,但是Redux不是非要和React在一起才能工作.没有React,Redux其实可以和其他框架配合使用. 在应用中需要关联React组件和Redux Store 的时候，react-redux提供了便捷的包装器.我们把react-redux添加进Gallery中,从而使Gallery成为首要的关联组件. Gallery.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 import React, &#123;Component&#125; from 'react'+import &#123;connect&#125; from 'react-redux';-export default class Gallery extends Component &#123;+export class Gallery extends Component &#123; constructor(props) &#123; super(props);+ console.log(props); this.state = &#123; images: [] &#125; &#125; componentDidMount() &#123; const API_KEY = 'a46a979f39c49975dbdd23b378e6d3d5'; const API_ENDPOINT = `https://api.flickr.com/services/rest/?method=flickr.interestingness.getList&amp;api_key=$&#123;API_KEY&#125;&amp;format=json&amp;nojsoncallback=1&amp;per_page=5`; fetch(API_ENDPOINT).then((response) =&gt; &#123; return response.json().then((json) =&gt; &#123; const images = json.photos.photo.map((&#123;farm, server, id, secret&#125;) =&gt; &#123; return `https://farm$&#123;farm&#125;.staticflickr.com/$&#123;server&#125;/$&#123;id&#125;_$&#123;secret&#125;.jpg` &#125;); this.setState(&#123;images, selectedImage: images[0]&#125;); &#125;) &#125;) &#125; handleThumbClick(selectedImage) &#123; this.setState(&#123; selectedImage &#125;) &#125; render() &#123; const &#123;images, selectedImage&#125; = this.state; return ( &lt;div className=\"image-gallery\"&gt; &lt;div className=\"gallery-image\"&gt; &lt;div&gt; &lt;img src=&#123;selectedImage&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"image-scroller\"&gt; &#123;images.map((image, index) =&gt; ( &lt;div key=&#123;index&#125; onClick=&#123;this.handleThumbClick.bind(this,image)&#125;&gt; &lt;img src=&#123;image&#125;/&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;+export default connect()(Gallery) 从react-redux导入connect函数,可以在导出组件的时候把他变为链接组件(connected component).请注意,connect()(Gallery)代码把Gallery组件放在第二个形参中,这是因为connect()返回一个函数，这个函数接受一个React组件作为参数(argument).调用connect()函数时需要配置项.后面我们将会传递配置我们应用的actions和state参数.我们也把connect作为默认配置到处模块.这一点非常重要！现在当我们import Gallery的时候,就不是一个单纯的React组件了,而是一个和Redux关联的组件了. 图4 如果你观察我们添加进构造器的console.log的输出,就可以看到Gallery组件的属性现在包括了一个dispatch函数.这个地方是connect为我们的应用修改的,这个改动赋予了组件把自己的动作对象(action objects)派发到reducers的能力. 123456789 export class Gallery extends Component &#123; constructor(props) &#123; super(props);+ this.props.dispatch(&#123;type: 'TEST'&#125;); this.state = &#123; images: [] &#125; &#125;[...] 我们可以在组件的构造器中调用派发功能.你可以在开发者的终端中看到来自reducer的日志声明.看到声明表示我们已经派发了第一个action!.Actions是一个单一的javascript对象,必需有type属性.Actions可以拥有任意数量和种类的其他属性.但是type可以让reducers理解这些动作到底是做什么用的(意译，意思是只有拥有type属性，reducers才知道对state做什么样的修改). 12345678export default function images(state, action) &#123;- console.log(state, action)+ switch(action.type) &#123;+ case 'TEST':+ console.log('THIS IS ONLY A TEST')+ &#125; return state;&#125; 总的reducers使用switch代码块过滤有关的消息,Switch语句使用actions的type属性,当一个action和case分支吻合以后,相应的单个reducer就会执行他的具体工作. 我们的应用现在关联到接收的动作.现在我们需要把Redux-Store提供的state关联到应用中. 默认的应用状态(state)reducer.js 123456789101112131415 const defaultState = &#123; images: []&#125;export default function images(state = defaultState, action) &#123; switch(action.type) &#123; case 'TEST':- console.log('THIS IS ONLY A TEST')+ console.log(state, action)+ return state;+ default:+ return state; &#125;- return state;&#125; 我们创建一个defaultState对象,这个对象返回一个空数组作为images的属性.我们把images函数的参数state设置为默认.如果在test分支中输出日志,将会看到state不是undefined(空数组不是undefined)!reducer需要返回应用的当前state.这点很重要!现在我们没有做任何改变,所以仅仅返回state.注意我们在case中添加了default分支,reducer必须要返回一个state. 在Gallery组件中，我们也可以把state做一定的映射(map)以后再连接到应用. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 import React, &#123;Component&#125; from 'react'import &#123;connect&#125; from 'react-redux';export class Gallery extends Component &#123; constructor(props) &#123; super(props); this.props.dispatch(&#123;type: 'TEST'&#125;);+ console.log(props);- this.state = &#123;- images: []- &#125; &#125;- componentDidMount() &#123;- const API_KEY = 'a46a979f39c49975dbdd23b378e6d3d5';- const API_ENDPOINT = `https://api.flickr.com/services/rest/?method=flickr.interestingness.-getList&amp;api_key=$&#123;API_KEY&#125;&amp;format=json&amp;nojsoncallback=1&amp;per_page=5`;--- fetch(API_ENDPOINT).then((response) =&gt; &#123;- return response.json().then((json) =&gt; &#123;- const images = json.photos.photo.map((&#123;farm, server, id, secret&#125;) =&gt; &#123; - return `https://farm$&#123;farm&#125;.staticflickr.com/$&#123;server&#125;/$&#123;id&#125;_$&#123;secret&#125;.jpg`- &#125;);-- this.setState(&#123;images, selectedImage: images[0]&#125;);- &#125;)- &#125;)- &#125;- handleThumbClick(selectedImage) &#123;- this.setState(&#123;- selectedImage- &#125;)- &#125; render() &#123;- const &#123;images, selectedImage&#125; = this.state;+ const &#123;images, selectedImage&#125; = this.props; return ( &lt;div className=\"image-gallery\"&gt; &lt;div className=\"gallery-image\"&gt; &lt;div&gt; &lt;img src=&#123;selectedImage&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"image-scroller\"&gt; &#123;images.map((image, index) =&gt; (- &lt;div key=&#123;index&#125; onClick=&#123;this.handleThumbClick.bind(this,image)&#125;&gt;+ &lt;div key=&#123;index&#125;&gt; &lt;img src=&#123;image&#125;/&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;+function mapStateToProps(state) &#123;+ return &#123;+ images: state.images+ selectedImage: state.selectedImage+ &#125;+&#125;-export default connect()(Gallery)+export default connect(mapStateToProps)(Gallery)``` 我们将移除连接组件中的所有图片加载和交互逻辑代码,如果你注意看`Gallery`组件的底部代码,你会注意到，我们创建了一个`mapStateToProps`函数,接收一个`state`作为参数,返回一个对象,把`state.images`映射为`images`属性.`mapStateToProps`做为参数传递给`connect`. 正如名字暗示的一样,`mapStateToProps`函数接收当前应用的state,然后把state转变为组件的属性(propertys).如果在构造器中输出props,将会看到images数组是`reducer`返回的默认state. const defaultState = { images: [] images: [ “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg“, “https://farm2.staticflickr.com/1581/25283151224_50f8da511e.jpg“, “https://farm2.staticflickr.com/1653/25265109363_f204ea7b54.jpg“, “https://farm2.staticflickr.com/1571/25911417225_a74c8041b0.jpg“, “https://farm2.staticflickr.com/1450/25888412766_44745cbca3.jpg“ ], selectedImage: “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg“} export default function images(state = defaultState, action) { switch(action.type) { case ‘TEST’: console.log(state, action) return state; default: return state; }}1234567 如果在`defaultState`中更新images数组,你将可以看到一些图片重新出现在gallery中!现在当用户点击缩略图的时候,我们可以反馈选择动作,返回对应的大图. #### 更新state 怎么操作才能根据新选择的图片更新state? 需要配置reducer监听`IMAGE_SELECTED`动作,借助action携带的信息(payload,有的文章翻译为载荷,载荷怎么理解？手机载荷就是声音，短信和流量数据。如果是卡车就是拉的货物,如果是客车就乘载的乘客,action的载荷就是要让reducer明白你要干什么，需要什么)来更新state. const defaultState = { images: [ “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg“, “https://farm2.staticflickr.com/1581/25283151224_50f8da511e.jpg“, “https://farm2.staticflickr.com/1653/25265109363_f204ea7b54.jpg“, “https://farm2.staticflickr.com/1571/25911417225_a74c8041b0.jpg“, “https://farm2.staticflickr.com/1450/25888412766_44745cbca3.jpg“ ], selectedImage: “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg“} export default function images(state = defaultState, action) { switch(action.type) { case ‘TEST’:case ‘IMAGE_SELECTED’: return state; return {…state, selectedImage: action.image};default:return state;}} 12现在reducer已经准备接收`IMAGE_SELECTED` action了.在`IMAGE_SELECTED`分支选项内,我们在展开(spreading,ES6的对象操作方法),并重写`selectedImage`属性后,返回一个新state对象.了解更多的`...state`对象操作可以看`ruanyifeng`的书. import React, {Component} from ‘react’import {connect} from ‘react-redux’; export class Gallery extends Component { constructor(props) { super(props); this.props.dispatch({type: ‘TEST’}); console.log(props); }render() { const {images, selectedImage} = this.props; const {images, selectedImage, dispatch} = this.props; return ( &lt;div&gt; &lt;img src={selectedImage} /&gt; &lt;/div&gt; {images.map((image, index) =&gt; ( dispatch({type:’IMAGE_SELECTED’, image})}&gt; ))})}} function mapStateToProps(state) { return { images: state.images, selectedImage: state.selectedImage }} export default connect(mapStateToProps)(Gallery)12345678 在`Gallery`组件中,我们将会在组件的属性中定义`dispatch`在`onClick`函数体中调用他,现在我们从便利角度考虑把他们放在一起,但是两者功能是一样的.一旦我们点击了缩略图,他将会通过reducer更新大图. 使用dispatch可以很方便的创建通用actions,但是很快我们会需要重用命名好的actions.为了这样做,可以使用”action creators”. #### Action Creators Action creators函数返回配置好的action对象.我们在`action.js`中添加第一个action creator. `action.js` export const IMAGE_SELECTED = ‘IMAGE_SELECTED’; export function selectImage(image) { return { type: IMAGE_SELECTED, image }}1234这个方法经过export以后,可以直接在任何需要创建`selectImage` action地方导入!`selectImage`是纯函数，只能返回数据.他接收一个image作为参数,把image添加到action对象中，并返回.&gt;注意:我们正在返回一个单纯的javascript object,但是`image`的属性可能很古怪，如果你以前没有碰到这样的样式.从ES6的角度出发,如果你给一个对象传递一个类似这样的属性,隐含的意思是把`image:'任何image包含的值'`添加到最终返回的对象.超级好用! import * as GalleryActions from ‘./actions.js’;[…]onClick={() =&gt; dispatch(GalleryActions.selectImage(image))}1234this isn’t much than just using `dispatchti` though.幸运的是,这个模式很普遍,Redux在`bindActionCreators`函数里提供了一个更好的办法来完成这个功能. import React, {Component} from ‘react’import {connect} from ‘react-redux’; import {bindActionCreators} from ‘redux’; import * as GalleryActions from ‘./actions.js’; export class Gallery extends Component { constructor(props) { super(props); this.props.dispatch({type: ‘TEST’}); console.log(props); } handleThumbClick(selectedImage) { this.setState({ selectedImage }) } render() { const {images, selectedImage, dispatch} = this.props; const {images, selectedImage, selectImage} = this.props;return ( &lt;div&gt; &lt;img src={selectedImage} /&gt; &lt;/div&gt; {images.map((image, index) =&gt; ( dispatch({type:’IMAGE_SELECTED’, image})}&gt; selectImage(image)}&gt; ))})}} function mapStateToProps(state) { return { images: state.images, selectedImage: state.selectedImage }} +function mapActionCreatorsToProps(dispatch) { return bindActionCreators(GalleryActions, dispatch);+} -export default connect(mapStateToProps)(Gallery)+export default connect(mapStateToProps, mapActionCreatorsToProps)(Gallery)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 我们已经添加了`mapActionCreatorsToProps`函数,他接收`dispatch`函数作为参数.返回`bindActionCreators`的调用结果,`GalleryActions`作为`bindActionCreators`的参数.现在如果你输出属性日志,就看不到`dispatch`作为参数,`selectImage`直接可以使用了.(这里相当于对dispatch和action进行了包装). 现在回顾一下,我们做了几件事: - 创建了一个reducer包含应用的默认初始状态(initial state),并且监听actions的执行. - 创建了一个store,把reducer具体化,提供一个分发器(dispatcher)可以分发action. - 把我们的Gallery组件关联到store的state. - 把store的state映射为属性(property)，传递给Gallery. - 映射一个动作创建器,Gallery可以简单的调用`selectImage(image)`,分发动作,应用状态将会更新.那么，我们怎么才能使用这些模式从远程资源加载数据呢？这个过程将会非常有趣!#### 异步活动？你可能在参加函数式编程的时候听说过”副作用”(side effects)这个名词,side effects是发生在应用的范围之外的东西.在我们舒适的肥皂泡里,side effect根本不是问题,但是当我们要到达一个远程资源,肥皂泡就被穿透了.有些事情我们就控制不了了,我们必须接受这个事实.(根据这段话，side effect 翻译为意想不到的事情，出乎意料的不受控制的事情更好)在Redux里,reducer没有Side effects.这意味着reducers不处理我们应用中的异步活动.我们不能使用reducers加载远程数据,因为reducers是纯函数,没有side effects.Redux很棒,如果你的应用里没有任何异步活动，你可以停下来,不用再往下看了.如果你创建的应用比较大,可能你会从服务端加载数据,这时,当然要使用异步方式.&gt;**注意**： Redux其中一个最酷的地方是他非常小巧.他试图解决有限范围内的问题.大多数的应用需要解决很多问题!万幸,Reduc提供中间件概念,中间件存在于action-&gt;reducer-&gt;store的三角关系中,通过中间件的方式,可以导入诸如远程数据异步加载类似的功能.其中一个方法是使用`thunks`对象,在Redux中有 redux-thunk 中间件.Thunks非常厉害，但是可能会导致actions的序列很复杂,测试起来也是很大的挑战.考虑到我们的 图片浏览程序.当应用加载是,需要做:- 从服务器请求图片数组- 当图片加载完毕,显示提示消息- 当远程数据返回以后,选择初始图片显示- 处理可能出现的错误这些事件都要在用户点击应用里的任何元素之前完成!我们该怎么做呢？redux-saga就是为此而诞生,为我们的应用提供绝佳的服务.`redux-sage`redux-sage可以在Redux应用中操作异步actions.他提供中间件和趁手的方法使构建复杂的异步操作流程轻而易举.一个saga是一个Generator(生成器),Generator函数是ES2015新添加的特性.可能是你第一次遇到Generator函数,这样你会觉得有点古怪,可以参考(ruanyifeng文章).不要苦恼，如果你对此仍然很抓耳挠腮.使用redux-sage你不需要javascript异步编程的博士学位.因为使用了generators的缘故,我们能创建一个顺序执行的命令序列，用来描述复杂的异步操作流程(workflows).整个图片的加载流程序列如下： export function* loadImages() { try { const images = yield call(fetchImages); yield put({type: ‘IMAGES_LOADED’, images}) yield put({type: ‘IMAGE_SELECTED’, image: images[0]}) } catch(error) { yield put({type: ‘IMAGE_LOAD_FAILURE’, error}) }} export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield call(loadImages); }}12345 #### 第一个saga我们将开始一个简单的saga实例,然后配置他连接到我们的应用.在`src`创建一个文件`saga.js` export function* sayHello() { console.log(‘hello’);}1234 我们的saga是一个简单的generator函数.函数后面的`*`作为标志,他也被叫做”super star”.现在在`main.js`文件中导入新函数,并且执行他. import “babel-polyfill”; import React from ‘react’;import ReactDOM from ‘react-dom’; import Gallery from ‘./Gallery’; import { createStore } from ‘redux’import {Provider} from ‘react-redux’;import reducer from ‘./reducer’ +import {sayHello} from ‘./sagas’;+sayHello(); const store = createStore(reducer); ReactDOM.render( , document.getElementById(‘root’));123456不管你盯住终端多长时间,“hello”永远不会出现.这是因为`sayHello`是一个generator！Generator 不会立即执行.如果你把代码该为`sayHello().next();`你的“hello”就出现了.不用担心,我们不会总是调用`next`.正如Redux,redux-saga用来消除应用开发中的痛苦.配置 redux-sage import “babel-polyfill”; import React from ‘react’;import ReactDOM from ‘react-dom’; import Gallery from ‘./Gallery’; -import { createStore } from ‘redux’+import { createStore, applyMiddleware } from ‘redux’+import createSagaMiddleware from ‘redux-saga’import {Provider} from ‘react-redux’;import reducer from ‘./reducer’ import {sayHello} from ‘./sagas’;-sayHello() -const store = createStore(reducer);+const store = createStore( reducer, applyMiddleware(createSagaMiddleware(sayHello))+); ReactDOM.render( , document.getElementById(‘root’));123456789 我们已从Redux导入了`applyMiddleware`函数.从redux-saga导入`createSagaMiddleware`函数.当我们创建store的时候,我们需要通过中间件提供Redux需要的功能.在这个实例中,我们会调用`applyMiddleware`函数,这个函数返回`createSagaMiddleware(sayHello)`的结果.在幕后,redux-saga加载`sayHello`函数,仪式性的调用`next`函数. 应该可以在终端中看到提示消息了. 现在让我们构建加载图片的saga #### 通过Saga加载图片数据我们将删除出sayHello saga,使用`loadImages` saga -export function* sayHello() { console.log(‘hello’);-} +export function* loadImages() { console.log(‘load some images please’)+}12不要忘了更新`main.js` import “babel-polyfill”; import React from ‘react’;import ReactDOM from ‘react-dom’; import Gallery from ‘./Gallery’; import { createStore, applyMiddleware } from ‘redux’import {Provider} from ‘react-redux’;import createSagaMiddleware from ‘redux-saga’import reducer from ‘./reducer’ -import {sayHello} from ‘./sagas’;+import {loadImages} from ‘./sagas’; const store = createStore( reducer, applyMiddleware(createSagaMiddleware(sayHello)) applyMiddleware(createSagaMiddleware(loadImages))); ReactDOM.render( , document.getElementById(‘root’));12 现在saga已经加载,在`saga.js`中添加`fetchImages`方法 const API_KEY = &apos;a46a979f39c49975dbdd23b378e6d3d5&apos;; const API_ENDPOINT = https://api.flickr.com/services/rest/?method=flickr.interestingness.getList&amp;api_key=${API_KEY}&amp;format=json&amp;nojsoncallback=1&amp;per_page=5; const fetchImages = () =&gt; { return fetch(APIENDPOINT).then(function (response) { return response.json().then(function (json) { return json.photos.photo.map( ({farm, server, id, secret}) =&gt; `https://farm${farm}.staticflickr.com/${server}/${id}${secret}.jpg` ); }) })}; export function* loadImages() { const images = yield fetchImages(); console.log(images)}123456789 `fetchImages`方法返回一个promise对象.我们将调用`fetchImages`,但是现在我们要使用`yield`关键字.通过黑暗艺术和巫术,generators理解Promise对象,正如终端输出的日志显示,我们已经收获了一个图片URLs的数组.看看`loadImages`的代码,他看起来像是典型的同步操作代码.`yield`关键字是秘制调味酱,让我们的代码用同步格式执行异步操作活动. #### 封装我们的异步API请求. 首先来定义一下需要使用的api.他没有什么特殊的地方,实际上他和早先加载Flickr images的代码是相同的.我们创建`flickr.js`文件 const API_KEY = ‘a46a979f39c49975dbdd23b378e6d3d5’;const API_ENDPOINT = https://api.flickr.com/services/rest/?method=flickr.interestingness.getList&amp;api_key=${API_KEY}&amp;format=json&amp;nojsoncallback=1&amp;per_page=5; export const fetchImages = () =&gt; { return fetch(APIENDPOINT).then(function (response) { return response.json().then(function (json) { return json.photos.photo.map( ({farm, server, id, secret}) =&gt; `https://farm${farm}.staticflickr.com/${server}/${id}${secret}.jpg` ); }) })};123456 严格意义上来说,不需要这么做,但是这会带来一定的好处.我们处在应用的边缘(boundaries of our application,意思是说在这里的代码可能是很多和远程服务器交互的代码，可能逻辑会很复杂),事情都有点乱.通过封装和远程API交互的逻辑,我们的代码将会很整洁,很容易更新.如果需要抹掉图片服务也会出奇的简单.我们的`saga.js`看起来是这个样子： import {fetchImages} from ‘./flickr’; export function* loadImages() { const images = yield fetchImages(); console.log(images)}1234567我们仍然需要在saga外获取数据,并且进入应用的state(使用异步获取的远程数据更新state).为了处理这个问题,我们将使用”effects”.#### 从saga来更新应用我们可以通过`dispatch`或者store作为参数来调用saga,但是这个方法时间一长就会给人造成些许的困扰.我们选择采用redux-saga提供的`put`方法.首先我们更新`reducer.js`操作一个新的action类型`IMAGES_LOADED`. const defaultState = { images: []} export default function images(state = defaultState, action) { switch(action.type) { case ‘IMAGE_SELECTED’: return {…state, selectedImage: action.image}; case ‘IMAGES_LOADED’: return {…state, images: action.images};default:return state;}} 1234我们添加了新的分支,并从`defaultState`中删除了硬编码的URLs数据.`IMAGES_LOADED`分支现在返回一个更新的state,包含action的image数据.下一步我们更新saga: import {fetchImages} from ‘./flickr’;+import {put} from ‘redux-saga/effects’; export function* loadImages() { const images = yield fetchImages(); yield put({type: ‘IMAGES_LOADED’, images})} 1234567 导入`put`以后,我们在`loadImages`添加另外一行.他`yield` `put`函数调用的返回结果.在幕后,redux-saga 分发这些动作,reducer接收到了消息! 怎样才能使用特定类型的action来触发一个saga? #### 使用actions来触发saga工作流 Sagas变得越来越有用,因为我们有能力使用redux actions来触发工作流.当我们这样做,saga会在我们的应用中表现出更大的能力.首先我们创建一个新的saga.`watchForLoadImages`. import {fetchImages} from ‘./flickr’;-import {put} from ‘redux-saga/effects’;+import {put, take} from ‘redux-saga/effects’; export function* loadImages() { const images = yield fetchImages(); yield put({type: ‘IMAGES_LOADED’, images})} +export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield loadImages(); }+}``` 这个新saga使用while循环,因此他总是处于激活和等待状态.","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"Redux-Saga","slug":"Redux-Saga","permalink":"https://React-Apollo.github.io/tags/Redux-Saga/"}]},{"title":"翻译|Getting Started with React, Redux and Immutable a Test-Driven Tutorial (Part 2)","slug":"翻译|Getting Started with React, Redux and Immutable- a Test-Driven","date":"2017-03-26T15:01:24.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2017/03/26/翻译|Getting Started with React, Redux and Immutable- a Test-Driven/","link":"","permalink":"https://React-Apollo.github.io/2017/03/26/翻译|Getting Started with React, Redux and Immutable- a Test-Driven/","excerpt":"","text":"翻译版本,原文请见 这是第二部分的内容. 在第一部分,我们罗列了app的UI,开发和单元测试的基础. 我们看到了app的state通过React的props向下传递到单个的组件,用户的actions声明为回调函数,因此app的逻辑和UI分离开来了. Redux的工作流介绍在这一点上,我们的UI是没有交互操作的:尽管我们已经测试了如果一个item如果被设定为completed,它将给文本划线,但是这里还没有方法邀请用户来完成它: state tree通过props定义了UI和action回调函数. 用户的actions,例如点击,被发送到action creator,action被它范式化. redux action被传递到reducer实现实际的app逻辑 reducer更新state tree,dispatch state到store. UI根据store里的新state tree来更新UI 设定初始化state这部分的代码提交在这里 我们的第一个action将会允许我们在Redux store里正确的设置初始化state,我们将会创建store. Redux中的action是一个信息的载体(payload).action由一个JSON对象有一个type属性,描述action到底是做什么的,还有一部分是app需要的信息.在我们的实例中,type被设定为SET_STATE,我们可以添加一个state对象包含需要的state:1234567891011&#123; type: 'SET_STATE', state: &#123; todos: [ &#123;id: 1, text: 'React', status: 'active', editing: false&#125;, &#123;id: 2, text: 'Redux', status: 'active', editing: false&#125;, &#123;id: 3, text: 'Immutable', status: 'active', editing: false&#125;, ], filter: 'all' &#125;&#125; 这个action会被dispatch到一个reducer,reducer角色的是识别和实施和action对应的逻辑代码. 让我们为reducer来写单元测试代码test/reducer_spec.js1234567891011121314151617181920212223242526272829303132 import &#123;List, Map, fromJS&#125; from 'immutable';import &#123;expect&#125; from 'chai';import reducer from '../src/reducer';describe('reducer', () =&gt; &#123; it('handles SET_STATE', () =&gt; &#123; const initialState = Map(); const action = &#123; type: 'SET_STATE', state: Map(&#123; todos: List.of( Map(&#123;id: 1, text: 'React', status: 'active'&#125;), Map(&#123;id: 2, text: 'Redux', status: 'active'&#125;), Map(&#123;id: 3, text: 'Immutable', status: 'completed'&#125;) ) &#125;) &#125;; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'active'&#125;, &#123;id: 3, text: 'Immutable', status: 'completed'&#125; ] &#125;)); &#125;);&#125;); 为了方便一点,state使用单纯JS对象,而不是使用Immutable数据结构.让我们的reducer来处理转变.最后,reducer将会优雅的处理undefined初始化state:test/reducer_spec.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546 // ...describe('reducer', () =&gt; &#123; // ... it('handles SET_STATE with plain JS payload', () =&gt; &#123; const initialState = Map(); const action = &#123; type: 'SET_STATE', state: &#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'active'&#125;, &#123;id: 3, text: 'Immutable', status: 'completed'&#125; ] &#125; &#125;; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'active'&#125;, &#123;id: 3, text: 'Immutable', status: 'completed'&#125; ] &#125;)); &#125;); it('handles SET_STATE without initial state', () =&gt; &#123; const action = &#123; type: 'SET_STATE', state: &#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'active'&#125;, &#123;id: 3, text: 'Immutable', status: 'completed'&#125; ] &#125; &#125;; const nextState = reducer(undefined, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'active'&#125;, &#123;id: 3, text: 'Immutable', status: 'completed'&#125; ] &#125;)); &#125;);&#125;); 我们的reducer将会匹配接收的actions的type,如果type是SET_STATE,当前的state和action运载的state融合在一起:src/reducer.js12345678910111213import &#123;Map&#125; from 'immutable';function setState(state, newState) &#123; return state.merge(newState);&#125;export default function(state = Map(), action) &#123; switch (action.type) &#123; case 'SET_STATE': return setState(state, action.state); &#125; return state;&#125; 现在我们不得不把reducer连接到我们的app,所以当app启动初始化state.这里实际是第一次使用Redux库,安装一下npm install —save redux@3.3.1 react-redux@4.4.1 src/index.jsx1234567891011121314151617181920212223242526272829303132 import React from 'react';import ReactDOM from 'react-dom';import &#123;List, Map&#125; from 'immutable';import &#123;createStore&#125; from 'redux';import &#123;Provider&#125; from 'react-redux';import reducer from './reducer';import &#123;TodoAppContainer&#125; from './components/TodoApp';// We instantiate a new Redux storeconst store = createStore(reducer);// We dispatch the SET_STATE action holding the desired statestore.dispatch(&#123; type: 'SET_STATE', state: &#123; todos: [ &#123;id: 1, text: 'React', status: 'active', editing: false&#125;, &#123;id: 2, text: 'Redux', status: 'active', editing: false&#125;, &#123;id: 3, text: 'Immutable', status: 'active', editing: false&#125;, ], filter: 'all' &#125;&#125;);require('../node_modules/todomvc-app-css/index.css');ReactDOM.render( // We wrap our app in a Provider component to pass the store down to the components &lt;Provider store=&#123;store&#125;&gt; &lt;TodoAppContainer /&gt; &lt;/Provider&gt;, document.getElementById('app')); 如果你看看上面的代码段,你可以注意到我们的TodoApp组件实际是被TodoAppContainer代替.在Redux里,有两种类型的组件:展示组件和容器.我推荐你阅读一下由Dan Abramov(Redux的作者)写作的高信息量的文章,强调了展示组件和容器的差异性. 如果我想总结得快一点,我将引用Redux 文档的内容： “展示组件是关于事件的样子(模板和样式),容器组件是关于事情是怎么工作的(数据获取,state更新)”. 所以我们创建store,传递给TodoAppContainer.然而为了子组件可以使用store,我们把state映射成为React组件TodoApp的props.src/components/TodoApp.jsx1234567891011121314 // ...import &#123;connect&#125; from 'react-redux';export class TodoApp extends React.Component &#123;// ...&#125;function mapStateToProps(state) &#123; return &#123; todos: state.get('todos'), filter: state.get('filter') &#125;;&#125;export const TodoAppContainer = connect(mapStateToProps)(TodoApp); 如果你在浏览器中重新加载app,你应该可以看到它初始化和之前一样,不过现在使用Redux tools. Redux dev 工具这一部分的提交代码 现在我们已经配置了redux store和reducer.我们可以配置Redux dev tools来展现数据流开发. 首先,获取Redux dev tools Chrome extension dev tools可以在Store创建的时候可以加载. src/index.jsx12345678 // ...import &#123;compose, createStore&#125; from 'redux';const createStoreDevTools = compose( window.devToolsExtension ? window.devToolsExtension() : f =&gt; f)(createStore);const store = createStoreDevTools(reducer);// ... 重新加载app,点击Redux图标,有了. 有三个不同的监视器可以使用:Diff监视器,日志监视器,Slider监视器. 使用Action Creators配置我们的actions切换item的不同状态. 这部分的提交代码在这里 下一步是允许用户在active和completed之前切换状态：test/reducer_spec.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 import &#123;List, Map, fromJS&#125; from 'immutable';import &#123;expect&#125; from 'chai';import reducer from '../src/reducer';describe('reducer', () =&gt; &#123;// ... it('handles TOGGLE_COMPLETE by changing the status from active to completed', () =&gt; &#123; const initialState = fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'active'&#125;, &#123;id: 3, text: 'Immutable', status: 'completed'&#125; ] &#125;); const action = &#123; type: 'TOGGLE_COMPLETE', itemId: 1 &#125; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'completed'&#125;, &#123;id: 2, text: 'Redux', status: 'active'&#125;, &#123;id: 3, text: 'Immutable', status: 'completed'&#125; ] &#125;)); &#125;); it('handles TOGGLE_COMPLETE by changing the status from completed to active', () =&gt; &#123; const initialState = fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'active'&#125;, &#123;id: 3, text: 'Immutable', status: 'completed'&#125; ] &#125;); const action = &#123; type: 'TOGGLE_COMPLETE', itemId: 3 &#125; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'active'&#125;, &#123;id: 3, text: 'Immutable', status: 'active'&#125; ] &#125;)); &#125;);&#125;); 为了通过这些测试,我们更新reducer:src/reducer.js123456789101112131415161718192021222324// ...function toggleComplete(state, itemId) &#123; // We find the index associated with the itemId const itemIndex = state.get('todos').findIndex( (item) =&gt; item.get('id') === itemId ); // We update the todo at this index const updatedItem = state.get('todos') .get(itemIndex) .update('status', status =&gt; status === 'active' ? 'completed' : 'active'); // We update the state to account for the modified todo return state.update('todos', todos =&gt; todos.set(itemIndex, updatedItem));&#125;export default function(state = Map(), action) &#123; switch (action.type) &#123; case 'SET_STATE': return setState(state, action.state); case 'TOGGLE_COMPLETE': return toggleComplete(state, action.itemId); &#125; return state;&#125; 和SET_STATE的action同一个地方,我们需要让TodoAppContainer组件感知到action,所以toggleComplete回调函数会被传递到TodoItem组件(实际调用函数的地方). 在Redux中,有标准的方法来做这件事：Action Creators. action creators是简单的函数,返回合适的action，这些韩式是React的props的一些映射之一.让我们创建第一个action creator:src/action_creators.js 123456export function toggleComplete(itemId) &#123; return &#123; type: 'TOGGLE_COMPLETE', itemId &#125;&#125; 现在,尽管TodoAppcontainer组件中的connect函数的调用可以用来获取store,我们告诉组件使用映射props的回调函数:src/components/TodoApp.jsx123456789101112131415// ...import * as actionCreators from '../action_creators';export class TodoApp extends React.Component &#123; // ... render() &#123; return &lt;div&gt; // ... // We use the spread operator for better lisibility &lt;TodoList &#123;...this.props&#125; /&gt; // ... &lt;/div&gt; &#125;&#125;;export const TodoAppContainer = connect(mapStateToProps, actionCreators)(TodoApp); 重启你的webserver,刷新一下你的浏览器:当当.在条目上点击现在可以切换它的状态.如果你查看Redux dev tools,你可以看到触发的action和后继的更新. 改变目前的过滤器相关代码在在这里 现在每件事情都已经配置完毕,写其他的action是件小事.我们继续创建你希望的CHANGE_FILTERaction,改变当前state的filter,由此仅仅显示过滤过的条目.开始创建action creator：src/action_creators.js1234567 // ...export function changeFilter(filter) &#123; return &#123; type: 'CHANGE_FILTER', filter &#125;&#125; 现在写reducer的单元测试:test/reducer_spec.js1234567891011121314151617181920212223// ...describe('reducer', () =&gt; &#123; // ... it('handles CHANGE_FILTER by changing the filter', () =&gt; &#123; const initialState = fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, ], filter: 'all' &#125;); const action = &#123; type: 'CHANGE_FILTER', filter: 'active' &#125; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, ], filter: 'active' &#125;)); &#125;);&#125;); 关联的reducer函数:src/reducer.js12345678910111213141516 // ...function changeFilter(state, filter) &#123; return state.set('filter', filter);&#125;export default function(state = Map(), action) &#123; switch (action.type) &#123; case 'SET_STATE': return setState(state, action.state); case 'TOGGLE_COMPLETE': return toggleComplete(state, action.itemId); case 'CHANGE_FILTER': return changeFilter(state, action.filter); &#125; return state;&#125; 最后我们把changeFilter回调函数传递给TodoTools组件:TodoApp.jsx123456789101112131415// ...export class TodoApp extends React.Component &#123; // ... render() &#123; return &lt;div&gt; &lt;section className=\"todoapp\"&gt; // ... &lt;TodoTools changeFilter=&#123;this.props.changeFilter&#125; filter=&#123;this.props.filter&#125; nbActiveItems=&#123;this.getNbActiveItems()&#125; /&gt; &lt;/section&gt; &lt;Footer /&gt; &lt;/div&gt; &#125;&#125;; 完成了,第一个filter selector工作完美 Item编辑代码在这里 当用户编辑一个条目,实际上是两个actions触发的三个可能性: 用户输入编辑模式:EDIT_ITEM 用户退出编辑模式(不保存变化):CANCEL_EDITING 用户验证他的编辑(保存变化):DONE_EDITING 我们可以为三个actions编写action creators：src/action_creators.js12345678910111213141516171819202122// ...export function editItem(itemId) &#123; return &#123; type: 'EDIT_ITEM', itemId &#125;&#125;export function cancelEditing(itemId) &#123; return &#123; type: 'CANCEL_EDITING', itemId &#125;&#125;export function doneEditing(itemId, newText) &#123; return &#123; type: 'DONE_EDITING', itemId, newText &#125;&#125; 现在为这些actions编写单元测试:test/reducer_spec.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// ...describe('reducer', () =&gt; &#123; // ... it('handles EDIT_ITEM by setting editing to true', () =&gt; &#123; const initialState = fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active', editing: false&#125;, ] &#125;); const action = &#123; type: 'EDIT_ITEM', itemId: 1 &#125; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active', editing: true&#125;, ] &#125;)); &#125;); it('handles CANCEL_EDITING by setting editing to false', () =&gt; &#123; const initialState = fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active', editing: true&#125;, ] &#125;); const action = &#123; type: 'CANCEL_EDITING', itemId: 1 &#125; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active', editing: false&#125;, ] &#125;)); &#125;); it('handles DONE_EDITING by setting by updating the text', () =&gt; &#123; const initialState = fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active', editing: true&#125;, ] &#125;); const action = &#123; type: 'DONE_EDITING', itemId: 1, newText: 'Redux', &#125; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'Redux', status: 'active', editing: false&#125;, ] &#125;)); &#125;);&#125;); 现在我们可以开发reducer函数,实际操作三个actions:src/reducer.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function findItemIndex(state, itemId) &#123; return state.get('todos').findIndex( (item) =&gt; item.get('id') === itemId );&#125;// We can refactor the toggleComplete function to use findItemIndexfunction toggleComplete(state, itemId) &#123; const itemIndex = findItemIndex(state, itemId); const updatedItem = state.get('todos') .get(itemIndex) .update('status', status =&gt; status === 'active' ? 'completed' : 'active'); return state.update('todos', todos =&gt; todos.set(itemIndex, updatedItem));&#125;function editItem(state, itemId) &#123; const itemIndex = findItemIndex(state, itemId); const updatedItem = state.get('todos') .get(itemIndex) .set('editing', true); return state.update('todos', todos =&gt; todos.set(itemIndex, updatedItem));&#125;function cancelEditing(state, itemId) &#123; const itemIndex = findItemIndex(state, itemId); const updatedItem = state.get('todos') .get(itemIndex) .set('editing', false); return state.update('todos', todos =&gt; todos.set(itemIndex, updatedItem));&#125;function doneEditing(state, itemId, newText) &#123; const itemIndex = findItemIndex(state, itemId); const updatedItem = state.get('todos') .get(itemIndex) .set('editing', false) .set('text', newText); return state.update('todos', todos =&gt; todos.set(itemIndex, updatedItem));&#125;export default function(state = Map(), action) &#123; switch (action.type) &#123; // ... case 'EDIT_ITEM': return editItem(state, action.itemId); case 'CANCEL_EDITING': return cancelEditing(state, action.itemId); case 'DONE_EDITING': return doneEditing(state, action.itemId, action.newText); &#125; return state;&#125; 清除完成,添加和删除条目代码在这里 三个剩下的action是: CLEAR_COMPLETED,在TodoTools组件中触发,从列表中清除完成的条目 ADD_ITEM,在TodoHeader中触发,根据用户的的输入文本来添加条目 DELETE_ITEM,相似TodoItem中调用,删除一个条目 我们现在使用的工作流是:添加action creators,单元测试reducer和代码逻辑,最终通过props传递回调函数:src/action_creators.js 1234567891011121314151617181920// ...export function clearCompleted() &#123; return &#123; type: 'CLEAR_COMPLETED' &#125;&#125;export function addItem(text) &#123; return &#123; type: 'ADD_ITEM', text &#125;&#125;export function deleteItem(itemId) &#123; return &#123; type: 'DELETE_ITEM', itemId &#125;&#125; test/reducer_spec.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 // ...describe('reducer', () =&gt; &#123; // ... it('handles CLEAR_COMPLETED by removing all the completed items', () =&gt; &#123; const initialState = fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'completed'&#125;, ] &#125;); const action = &#123; type: 'CLEAR_COMPLETED' &#125; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, ] &#125;)); &#125;); it('handles ADD_ITEM by adding the item', () =&gt; &#123; const initialState = fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125; ] &#125;); const action = &#123; type: 'ADD_ITEM', text: 'Redux' &#125; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'active'&#125;, ] &#125;)); &#125;); it('handles DELETE_ITEM by removing the item', () =&gt; &#123; const initialState = fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, &#123;id: 2, text: 'Redux', status: 'completed'&#125;, ] &#125;); const action = &#123; type: 'DELETE_ITEM', itemId: 2 &#125; const nextState = reducer(initialState, action); expect(nextState).to.equal(fromJS(&#123; todos: [ &#123;id: 1, text: 'React', status: 'active'&#125;, ] &#125;)); &#125;);&#125;); src/reducer.js12345678910111213141516171819202122232425262728293031323334function clearCompleted(state) &#123; return state.update('todos', (todos) =&gt; todos.filterNot( (item) =&gt; item.get('status') === 'completed' ) );&#125;function addItem(state, text) &#123; const itemId = state.get('todos').reduce((maxId, item) =&gt; Math.max(maxId,item.get('id')), 0) + 1; const newItem = Map(&#123;id: itemId, text: text, status: 'active'&#125;); return state.update('todos', (todos) =&gt; todos.push(newItem));&#125;function deleteItem(state, itemId) &#123; return state.update('todos', (todos) =&gt; todos.filterNot( (item) =&gt; item.get('id') === itemId ) );&#125;export default function(state = Map(), action) &#123; switch (action.type) &#123; // ... case 'CLEAR_COMPLETED': return clearCompleted(state); case 'ADD_ITEM': return addItem(state, action.text); case 'DELETE_ITEM': return deleteItem(state, action.itemId); &#125; return state;&#125; src/components/TodoApp.jsx12345678910111213141516171819 // ...export class TodoApp extends React.Component &#123; // ... render() &#123; return &lt;div&gt; &lt;section className=\"todoapp\"&gt; // We pass down the addItem callback &lt;TodoHeader addItem=&#123;this.props.addItem&#125;/&gt; &lt;TodoList &#123;...this.props&#125; /&gt; // We pass down the clearCompleted callback &lt;TodoTools changeFilter=&#123;this.props.changeFilter&#125; filter=&#123;this.props.filter&#125; nbActiveItems=&#123;this.getNbActiveItems()&#125; clearCompleted=&#123;this.props.clearCompleted&#125;/&gt; &lt;/section&gt; &lt;Footer /&gt; &lt;/div&gt; &#125;&#125;; 我们的TodoMVC app现在完成了. 包装起来这我们的测试驱动的React,Redux&amp;Immutable 技术栈 如果你想了解更多内容,有更多的事情等着你去挖掘例如: React Redux router创建完全的单页面应用 是由Redux在后台同构Redux,看这1教程,2教程 Gambie,简单的包装器简化到API的连接 系列视频,作者是Dan Abramov(Redux的创建者) Redux 网站上更多的内容!","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"redux","slug":"redux","permalink":"https://React-Apollo.github.io/tags/redux/"},{"name":"Immutable.js","slug":"Immutable-js","permalink":"https://React-Apollo.github.io/tags/Immutable-js/"}]},{"title":"翻译|在 react-redux 中使用中间件","slug":"翻译|中间件和React Redux 生命周期","date":"2017-03-25T15:30:43.000Z","updated":"2018-04-07T02:42:18.255Z","comments":true,"path":"2017/03/25/翻译|中间件和React Redux 生命周期/","link":"","permalink":"https://React-Apollo.github.io/2017/03/25/翻译|中间件和React Redux 生命周期/","excerpt":"","text":"原文请参看. 如果你使用过类似Express.js框架构建Node.js程序,你就可能在使用中间件,并且知道他们怎么工作.Redux给前端引入同样的概念. 什么是中间件？中间件是可以被框架自动调用的函数,在框架中数据流结束之前,在数据流中加强或者改变输出.例如:如果框架里面没有中间件是这个样子的: funcA — calls→ funcB — calls→ funcC 添加了中间件以后,控制流就变为:funcA — calls→ funcB — calls→ funcMiddleWare1 — back to →funcB. funcB → then calls→ funcMiddleWare2 — back to→ funcB. funcB — finally calls→ funcC 注意：funcB最终调用funcC但是在调用funcC之前要调用两个中间件. 没有中间件的Redux生命周期让我们想看看Redux app生命周期,来更好的理解它. 场景:点击”Click Me”按钮,更新”Clicked xyz times” 文本. 场景：现在,当用户点击按钮的时候,我们想把点击的数目保存到服务器,并且在debugg中展示state的变化日志.让我们看看现在的控制流. 在Redux中,中间件函数一个接一个的被调用,直到所有的中间件被调用,然后“Action”对象呗发送到“Reducer”. 注意:这就允许中间件有修改Action对象的潜力,在最终调用Reducers之前,解析AJAX调用,还可以做其他事情比如日志.Reeucers将会更新state,在app需要的时候渲染组件. 使用中间件Redux有个巨大的社区,已经构建了大量可以完成各种任务的中间件. 所有你需要做的就是: 通过npm 安装 配置或者添加到Redux 例如：在我前面的blog：创建React Redux CRUD程序指南,app为CRUD操作做AJAX请求.在里面,我使用AXios的库来做AJAX调用.但是Axios返回一个Promise对象.但是Actions需要传递给Reducers的是一个纯粹的JSON对象.所以在在数据到达Reducers之前使用redux-promise解析Action中的Promise对象. 为了使用,首先安装. npm install — save redux-promise 再做一点配置工作: 123456789101112 import React from ‘react’;...import &#123; createStore, applyMiddleware &#125; from ‘redux’;import rp from ‘redux-promise’; // &lt;------------ MIDDLEWARE...//add middlewaresconst createStoreWithMiddleware = applyMiddleware(rp)(createStore);ReactDOM.render( &lt;Provider store=&#123;createStoreWithMiddleware(reducers)&#125;&gt; &lt;Router history=&#123;browserHistory&#125; routes=&#123;routes&#125; /&gt; &lt;/Provider&gt; , document.getElementById(‘body’)); 中间件是怎么工作的？如果你看了redux-promise,你就可以看到他是怎么工作的. 这里是伪代码: Redux调用中间件,“dispatch(函数)”,“next(函数)”和”action“JSON对象. 中间件检查”action”对象,看看是否有Promise对象 如果没有Promise对象,调用”next“函数返回到Redux. 如果这样做,他会附加上成功或者失败的回调函数,等待服务器的响应. 1234567891011121314151617181920212223//redux-promise middleware source codeimport &#123; isFSA &#125; from 'flux-standard-action';function isPromise(val) &#123; return val &amp;&amp; typeof val.then === 'function';&#125;export default function promiseMiddleware(&#123; dispatch &#125;) &#123; return next =&gt; action =&gt; &#123; if (!isFSA(action)) &#123; return isPromise(action) ? action.then(dispatch) : next(action); &#125; return isPromise(action.payload) ? action.payload.then( result =&gt; dispatch(&#123; ...action, payload: result &#125;), error =&gt; dispatch(&#123; ...action, payload: error, error: true &#125;) ) : next(action); &#125;;&#125; 更多内容请看: 官方Redux 中间件文档 中间件列表 到A Guide For Building A React Redux CRUD APP. 结束","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"redux","slug":"redux","permalink":"https://React-Apollo.github.io/tags/redux/"}]},{"title":"Immutable-collections","slug":"Immutable collections for JavaScript","date":"2017-03-22T00:04:10.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2017/03/22/Immutable collections for JavaScript/","link":"","permalink":"https://React-Apollo.github.io/2017/03/22/Immutable collections for JavaScript/","excerpt":"","text":"Immutable collections for JavaScript Immutable data cannot be changed once created, leading to much simplerapplication development, no defensive copying, and enabling advanced memoizationand change detection techniques with simple logic. Persistent data presentsa mutative API which does not update the data in-place, but instead alwaysyields new updated data. Immutable.js provides many Persistent Immutable data structures including:List, Stack, Map, OrderedMap, Set, OrderedSet and Record. These data structures are highly efficient on modern JavaScript VMs by usingstructural sharing via hash maps tries and vector tries as popularizedby Clojure and Scala, minimizing the need to copy or cache data. Immutable also provides a lazy Seq, allowing efficientchaining of collection methods like map and filter without creatingintermediate representations. Create some Seq with Range and Repeat. Want to hear more? Watch the presentation about Immutable.js: Getting startedInstall immutable using npm. 1npm install immutable Then require it into any module. 12345var Immutable = require('immutable');var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var map2 = map1.set('b', 50);map1.get('b'); // 2map2.get('b'); // 50 BrowserTo use immutable from a browser, download dist/immutable.min.jsor use a CDN such as CDNJSor jsDelivr. Then, add it as a script tag to your page: 1234567&lt;script src=\"immutable.min.js\"&gt;&lt;/script&gt;&lt;script&gt; var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;); var map2 = map1.set('b', 50); map1.get('b'); // 2 map2.get('b'); // 50&lt;/script&gt; Or use an AMD loader (such as RequireJS): 123456require(['./immutable.min.js'], function (Immutable) &#123; var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;); var map2 = map1.set('b', 50); map1.get('b'); // 2 map2.get('b'); // 50&#125;); If you’re using browserify, the immutable npm modulealso works from the browser. TypeScriptUse these Immutable collections and sequences as you would use nativecollections in your TypeScript programs while still takingadvantage of type generics, error detection, and auto-complete in your IDE. Just add a reference with a relative path to the type declarations at the topof your file. 1234567///&lt;reference path='./node_modules/immutable/dist/immutable.d.ts'/&gt;import Immutable = require('immutable');var map1: Immutable.Map&lt;string, number&gt;;map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var map2 = map1.set('b', 50);map1.get('b'); // 2map2.get('b'); // 50 The case for ImmutabilityMuch of what makes application development difficult is tracking mutation andmaintaining state. Developing with immutable data encourages you to thinkdifferently about how data flows through your application. Subscribing to data events throughout your application creates a huge overhead ofbook-keeping which can hurt performance, sometimes dramatically, and createsopportunities for areas of your application to get out of sync with each otherdue to easy to make programmer error. Since immutable data never changes,subscribing to changes throughout the model is a dead-end and new data can onlyever be passed from above. This model of data flow aligns well with the architecture of Reactand especially well with an application designed using the ideas of Flux. When data is passed from above rather than being subscribed to, and you’re onlyinterested in doing work when something has changed, you can use equality. Immutable collections should be treated as values rather than objects. Whileobjects represent some thing which could change over time, a value representsthe state of that thing at a particular instance of time. This principle is mostimportant to understanding the appropriate use of immutable data. In order totreat Immutable.js collections as values, it’s important to use theImmutable.is() function or .equals() method to determine value equalityinstead of the === operator which determines object reference identity. 12345var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var map2 = map1.set('b', 2);assert(map1.equals(map2) === true);var map3 = map1.set('b', 50);assert(map1.equals(map3) === false); Note: As a performance optimization Immutable attempts to return the existingcollection when an operation would result in an identical collection, allowingfor using === reference equality to determine if something definitely has notchanged. This can be extremely useful when used within a memoization functionwhich would prefer to re-run the function if a deeper equality check couldpotentially be more costly. The === equality check is also used internally byImmutable.is and .equals() as a performance optimization. If an object is immutable, it can be “copied” simply by making another referenceto it instead of copying the entire object. Because a reference is much smallerthan the object itself, this results in memory savings and a potential boost inexecution speed for programs which rely on copies (such as an undo-stack). 12var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var clone = map1; JavaScript-first APIWhile immutable is inspired by Clojure, Scala, Haskell and other functionalprogramming environments, it’s designed to bring these powerful concepts toJavaScript, and therefore has an Object-Oriented API that closely mirrors thatof ES6 Array, Map, and Set. The difference for the immutable collections is that methods which would mutatethe collection, like push, set, unshift or splice instead return a newimmutable collection. Methods which return new arrays like slice or concatinstead return new immutable collections. 123456789var list1 = Immutable.List.of(1, 2);var list2 = list1.push(3, 4, 5);var list3 = list2.unshift(0);var list4 = list1.concat(list2, list3);assert(list1.size === 2);assert(list2.size === 5);assert(list3.size === 6);assert(list4.size === 13);assert(list4.get(0) === 1); Almost all of the methods on Array will be found in similar form onImmutable.List, those of Map found on Immutable.Map, and those of Setfound on Immutable.Set, including collection operations like forEach()and map(). 123var alpha = Immutable.Map(&#123;a:1, b:2, c:3, d:4&#125;);alpha.map((v, k) =&gt; k.toUpperCase()).join();// 'A,B,C,D' Accepts raw JavaScript objects.Designed to inter-operate with your existing JavaScript, immutableaccepts plain JavaScript Arrays and Objects anywhere a method expects anIterable with no performance penalty. 12345var map1 = Immutable.Map(&#123;a:1, b:2, c:3, d:4&#125;);var map2 = Immutable.Map(&#123;c:10, a:20, t:30&#125;);var obj = &#123;d:100, o:200, g:300&#125;;var map3 = map1.merge(map2, obj);// Map &#123; a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 &#125; This is possible because immutable can treat any JavaScript Array or Objectas an Iterable. You can take advantage of this in order to get sophisticatedcollection methods on JavaScript Objects, which otherwise have a very sparsenative API. Because Seq evaluates lazily and does not cache intermediateresults, these operations can be extremely efficient. 123var myObject = &#123;a:1,b:2,c:3&#125;;Immutable.Seq(myObject).map(x =&gt; x * x).toObject();// &#123; a: 1, b: 4, c: 9 &#125; Keep in mind, when using JS objects to construct Immutable Maps, thatJavaScript Object properties are always strings, even if written in a quote-lessshorthand, while Immutable Maps accept keys of any type. 12345678var obj = &#123; 1: \"one\" &#125;;Object.keys(obj); // [ \"1\" ]obj[\"1\"]; // \"one\"obj[1]; // \"one\"var map = Immutable.fromJS(obj);map.get(\"1\"); // \"one\"map.get(1); // undefined Property access for JavaScript Objects first converts the key to a string, butsince Immutable Map keys can be of any type the argument to get() isnot altered. Converts back to raw JavaScript objects.All immutable Iterables can be converted to plain JavaScript Arrays andObjects shallowly with toArray() and toObject() or deeply with toJS().All Immutable Iterables also implement toJSON() allowing them to be passed toJSON.stringify directly. 12345var deep = Immutable.Map(&#123; a: 1, b: 2, c: Immutable.List.of(3, 4, 5) &#125;);deep.toObject() // &#123; a: 1, b: 2, c: List [ 3, 4, 5 ] &#125;deep.toArray() // [ 1, 2, List [ 3, 4, 5 ] ]deep.toJS() // &#123; a: 1, b: 2, c: [ 3, 4, 5 ] &#125;JSON.stringify(deep) // '&#123;\"a\":1,\"b\":2,\"c\":[3,4,5]&#125;' Embraces ES6Immutable takes advantage of features added to JavaScript in ES6,the latest standard version of ECMAScript (JavaScript), including Iterators,Arrow Functions, Classes, and Modules. It’s also inspired by theMap and Set collections added to ES6. The library is “transpiled” to ES3in order to support all modern browsers. All examples are presented in ES6. To run in all browsers, they need to betranslated to ES3. 1234// ES6foo.map(x =&gt; x * x);// ES3foo.map(function (x) &#123; return x * x; &#125;); Nested StructuresThe collections in immutable are intended to be nested, allowing for deeptrees of data, similar to JSON. 12var nested = Immutable.fromJS(&#123;a:&#123;b:&#123;c:[3,4,5]&#125;&#125;&#125;);// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5 ] &#125; &#125; &#125; A few power-tools allow for reading and operating on nested data. Themost useful are mergeDeep, getIn, setIn, and updateIn, found on List,Map and OrderedMap. 12345678910var nested2 = nested.mergeDeep(&#123;a:&#123;b:&#123;d:6&#125;&#125;&#125;);// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5 ], d: 6 &#125; &#125; &#125;nested2.getIn(['a', 'b', 'd']); // 6var nested3 = nested2.updateIn(['a', 'b', 'd'], value =&gt; value + 1);// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5 ], d: 7 &#125; &#125; &#125;var nested4 = nested3.updateIn(['a', 'b', 'c'], list =&gt; list.push(6));// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5, 6 ], d: 7 &#125; &#125; &#125; Lazy SeqSeq describes a lazy operation, allowing them to efficiently chainuse of all the Iterable methods (such as map and filter). Seq is immutable — Once a Seq is created, it cannot bechanged, appended to, rearranged or otherwise modified. Instead, any mutativemethod called on a Seq will return a new Seq. Seq is lazy — Seq does as little work as necessary to respond to anymethod call. For example, the following does not perform any work, because the resultingSeq is never used: var oddSquares = Immutable.Seq.of(1,2,3,4,5,6,7,8) .filter(x =&gt; x % 2).map(x =&gt; x * x); Once the Seq is used, it performs only the work necessary. In thisexample, no intermediate arrays are ever created, filter is called three times,and map is only called once: console.log(oddSquares.get(1)); // 9 Any collection can be converted to a lazy Seq with .toSeq(). var seq = Immutable.Map({a:1, b:1, c:1}).toSeq(); Seq allows for the efficient chaining of sequence operations, especially whenconverting to a different concrete type (such as to a JS object): seq.flip().map(key =&gt; key.toUpperCase()).flip().toObject(); // { A: 1, B: 1, C: 1 } As well as expressing logic that would otherwise seem memory-limited: Immutable.Range(1, Infinity) .skip(1000) .map(n =&gt; -n) .filter(n =&gt; n % 2 === 0) .take(2) .reduce((r, n) =&gt; r * n, 1); // 1006008 Note: An iterable is always iterated in the same order, however that order maynot always be well defined, as is the case for the Map. Equality treats Collections as DataImmutable provides equality which treats immutable data structures as puredata, performing a deep equality check if necessary. 12345var map1 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);var map2 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);assert(map1 !== map2); // two different instancesassert(Immutable.is(map1, map2)); // have equivalent valuesassert(map1.equals(map2)); // alternatively use the equals method Immutable.is() uses the same measure of equality as Object.isincluding if both are immutable and all keys and values are equalusing the same measure of equality. Batching Mutations If a tree falls in the woods, does it make a sound? If a pure function mutates some local data in order to produce an immutablereturn value, is that ok? — Rich Hickey, Clojure Applying a mutation to create a new immutable object results in some overhead,which can add up to a minor performance penalty. If you need to apply a seriesof mutations locally before returning, Immutable gives you the ability tocreate a temporary mutable (transient) copy of a collection and apply a batch ofmutations in a performant manner by using withMutations. In fact, this isexactly how Immutable applies complex mutations itself. As an example, building list2 results in the creation of 1, not 3, newimmutable Lists. 123456var list1 = Immutable.List.of(1,2,3);var list2 = list1.withMutations(function (list) &#123; list.push(4).push(5).push(6);&#125;);assert(list1.size === 3);assert(list2.size === 6); Note: immutable also provides asMutable and asImmutable, but onlyencourages their use when withMutations will not suffice. Use caution to notreturn a mutable copy, which could result in undesired behavior. Important!: Only a select few methods can be used in withMutations includingset, push and pop. These methods can be applied directly against apersistent data-structure where other methods like map, filter, sort,and splice will always return new immutable data-structures and never mutatea mutable collection. DocumentationRead the docs and eat your vegetables. Docs are automatically generated from Immutable.d.ts.Please contribute! Also, don’t miss the Wiki whichcontains articles on specific topics. Can’t find something? Open an issue. TestingIf you are using the Chai Assertion Library, Chai Immutable provides a set of assertions to use against Immutable collections. ContributionUse Github issues for requests. We actively welcome pull requests, learn how to contribute. ChangelogChanges are tracked as Github releases. ThanksPhil Bagwell, for his inspirationand research in persistent data structures. Hugh Jackson, for providing the npm packagename. If you’re looking for his unsupported package, see this repository. LicenseImmutable is BSD-licensed. We also provide an additional patent grant.","categories":[{"name":"Readme","slug":"Readme","permalink":"https://React-Apollo.github.io/categories/Readme/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://React-Apollo.github.io/tags/javascript/"}]},{"title":"Immutable-collections","slug":"Immutable collections for JavaScript copy","date":"2017-03-22T00:04:10.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2017/03/22/Immutable collections for JavaScript copy/","link":"","permalink":"https://React-Apollo.github.io/2017/03/22/Immutable collections for JavaScript copy/","excerpt":"","text":"Immutable collections for JavaScript Immutable data cannot be changed once created, leading to much simplerapplication development, no defensive copying, and enabling advanced memoizationand change detection techniques with simple logic. Persistent data presentsa mutative API which does not update the data in-place, but instead alwaysyields new updated data. Immutable.js provides many Persistent Immutable data structures including:List, Stack, Map, OrderedMap, Set, OrderedSet and Record. These data structures are highly efficient on modern JavaScript VMs by usingstructural sharing via hash maps tries and vector tries as popularizedby Clojure and Scala, minimizing the need to copy or cache data. Immutable also provides a lazy Seq, allowing efficientchaining of collection methods like map and filter without creatingintermediate representations. Create some Seq with Range and Repeat. Want to hear more? Watch the presentation about Immutable.js: Getting startedInstall immutable using npm. 1npm install immutable Then require it into any module. 12345var Immutable = require('immutable');var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var map2 = map1.set('b', 50);map1.get('b'); // 2map2.get('b'); // 50 BrowserTo use immutable from a browser, download dist/immutable.min.jsor use a CDN such as CDNJSor jsDelivr. Then, add it as a script tag to your page: 1234567&lt;script src=\"immutable.min.js\"&gt;&lt;/script&gt;&lt;script&gt; var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;); var map2 = map1.set('b', 50); map1.get('b'); // 2 map2.get('b'); // 50&lt;/script&gt; Or use an AMD loader (such as RequireJS): 123456require(['./immutable.min.js'], function (Immutable) &#123; var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;); var map2 = map1.set('b', 50); map1.get('b'); // 2 map2.get('b'); // 50&#125;); If you’re using browserify, the immutable npm modulealso works from the browser. TypeScriptUse these Immutable collections and sequences as you would use nativecollections in your TypeScript programs while still takingadvantage of type generics, error detection, and auto-complete in your IDE. Just add a reference with a relative path to the type declarations at the topof your file. 1234567///&lt;reference path='./node_modules/immutable/dist/immutable.d.ts'/&gt;import Immutable = require('immutable');var map1: Immutable.Map&lt;string, number&gt;;map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var map2 = map1.set('b', 50);map1.get('b'); // 2map2.get('b'); // 50 The case for ImmutabilityMuch of what makes application development difficult is tracking mutation andmaintaining state. Developing with immutable data encourages you to thinkdifferently about how data flows through your application. Subscribing to data events throughout your application creates a huge overhead ofbook-keeping which can hurt performance, sometimes dramatically, and createsopportunities for areas of your application to get out of sync with each otherdue to easy to make programmer error. Since immutable data never changes,subscribing to changes throughout the model is a dead-end and new data can onlyever be passed from above. This model of data flow aligns well with the architecture of Reactand especially well with an application designed using the ideas of Flux. When data is passed from above rather than being subscribed to, and you’re onlyinterested in doing work when something has changed, you can use equality. Immutable collections should be treated as values rather than objects. Whileobjects represent some thing which could change over time, a value representsthe state of that thing at a particular instance of time. This principle is mostimportant to understanding the appropriate use of immutable data. In order totreat Immutable.js collections as values, it’s important to use theImmutable.is() function or .equals() method to determine value equalityinstead of the === operator which determines object reference identity. 12345var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var map2 = map1.set('b', 2);assert(map1.equals(map2) === true);var map3 = map1.set('b', 50);assert(map1.equals(map3) === false); Note: As a performance optimization Immutable attempts to return the existingcollection when an operation would result in an identical collection, allowingfor using === reference equality to determine if something definitely has notchanged. This can be extremely useful when used within a memoization functionwhich would prefer to re-run the function if a deeper equality check couldpotentially be more costly. The === equality check is also used internally byImmutable.is and .equals() as a performance optimization. If an object is immutable, it can be “copied” simply by making another referenceto it instead of copying the entire object. Because a reference is much smallerthan the object itself, this results in memory savings and a potential boost inexecution speed for programs which rely on copies (such as an undo-stack). 12var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var clone = map1; JavaScript-first APIWhile immutable is inspired by Clojure, Scala, Haskell and other functionalprogramming environments, it’s designed to bring these powerful concepts toJavaScript, and therefore has an Object-Oriented API that closely mirrors thatof ES6 Array, Map, and Set. The difference for the immutable collections is that methods which would mutatethe collection, like push, set, unshift or splice instead return a newimmutable collection. Methods which return new arrays like slice or concatinstead return new immutable collections. 123456789var list1 = Immutable.List.of(1, 2);var list2 = list1.push(3, 4, 5);var list3 = list2.unshift(0);var list4 = list1.concat(list2, list3);assert(list1.size === 2);assert(list2.size === 5);assert(list3.size === 6);assert(list4.size === 13);assert(list4.get(0) === 1); Almost all of the methods on Array will be found in similar form onImmutable.List, those of Map found on Immutable.Map, and those of Setfound on Immutable.Set, including collection operations like forEach()and map(). 123var alpha = Immutable.Map(&#123;a:1, b:2, c:3, d:4&#125;);alpha.map((v, k) =&gt; k.toUpperCase()).join();// 'A,B,C,D' Accepts raw JavaScript objects.Designed to inter-operate with your existing JavaScript, immutableaccepts plain JavaScript Arrays and Objects anywhere a method expects anIterable with no performance penalty. 12345var map1 = Immutable.Map(&#123;a:1, b:2, c:3, d:4&#125;);var map2 = Immutable.Map(&#123;c:10, a:20, t:30&#125;);var obj = &#123;d:100, o:200, g:300&#125;;var map3 = map1.merge(map2, obj);// Map &#123; a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 &#125; This is possible because immutable can treat any JavaScript Array or Objectas an Iterable. You can take advantage of this in order to get sophisticatedcollection methods on JavaScript Objects, which otherwise have a very sparsenative API. Because Seq evaluates lazily and does not cache intermediateresults, these operations can be extremely efficient. 123var myObject = &#123;a:1,b:2,c:3&#125;;Immutable.Seq(myObject).map(x =&gt; x * x).toObject();// &#123; a: 1, b: 4, c: 9 &#125; Keep in mind, when using JS objects to construct Immutable Maps, thatJavaScript Object properties are always strings, even if written in a quote-lessshorthand, while Immutable Maps accept keys of any type. 12345678var obj = &#123; 1: \"one\" &#125;;Object.keys(obj); // [ \"1\" ]obj[\"1\"]; // \"one\"obj[1]; // \"one\"var map = Immutable.fromJS(obj);map.get(\"1\"); // \"one\"map.get(1); // undefined Property access for JavaScript Objects first converts the key to a string, butsince Immutable Map keys can be of any type the argument to get() isnot altered. Converts back to raw JavaScript objects.All immutable Iterables can be converted to plain JavaScript Arrays andObjects shallowly with toArray() and toObject() or deeply with toJS().All Immutable Iterables also implement toJSON() allowing them to be passed toJSON.stringify directly. 12345var deep = Immutable.Map(&#123; a: 1, b: 2, c: Immutable.List.of(3, 4, 5) &#125;);deep.toObject() // &#123; a: 1, b: 2, c: List [ 3, 4, 5 ] &#125;deep.toArray() // [ 1, 2, List [ 3, 4, 5 ] ]deep.toJS() // &#123; a: 1, b: 2, c: [ 3, 4, 5 ] &#125;JSON.stringify(deep) // '&#123;\"a\":1,\"b\":2,\"c\":[3,4,5]&#125;' Embraces ES6Immutable takes advantage of features added to JavaScript in ES6,the latest standard version of ECMAScript (JavaScript), including Iterators,Arrow Functions, Classes, and Modules. It’s also inspired by theMap and Set collections added to ES6. The library is “transpiled” to ES3in order to support all modern browsers. All examples are presented in ES6. To run in all browsers, they need to betranslated to ES3. 1234// ES6foo.map(x =&gt; x * x);// ES3foo.map(function (x) &#123; return x * x; &#125;); Nested StructuresThe collections in immutable are intended to be nested, allowing for deeptrees of data, similar to JSON. 12var nested = Immutable.fromJS(&#123;a:&#123;b:&#123;c:[3,4,5]&#125;&#125;&#125;);// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5 ] &#125; &#125; &#125; A few power-tools allow for reading and operating on nested data. Themost useful are mergeDeep, getIn, setIn, and updateIn, found on List,Map and OrderedMap. 12345678910var nested2 = nested.mergeDeep(&#123;a:&#123;b:&#123;d:6&#125;&#125;&#125;);// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5 ], d: 6 &#125; &#125; &#125;nested2.getIn(['a', 'b', 'd']); // 6var nested3 = nested2.updateIn(['a', 'b', 'd'], value =&gt; value + 1);// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5 ], d: 7 &#125; &#125; &#125;var nested4 = nested3.updateIn(['a', 'b', 'c'], list =&gt; list.push(6));// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5, 6 ], d: 7 &#125; &#125; &#125; Lazy SeqSeq describes a lazy operation, allowing them to efficiently chainuse of all the Iterable methods (such as map and filter). Seq is immutable — Once a Seq is created, it cannot bechanged, appended to, rearranged or otherwise modified. Instead, any mutativemethod called on a Seq will return a new Seq. Seq is lazy — Seq does as little work as necessary to respond to anymethod call. For example, the following does not perform any work, because the resultingSeq is never used: var oddSquares = Immutable.Seq.of(1,2,3,4,5,6,7,8) .filter(x =&gt; x % 2).map(x =&gt; x * x); Once the Seq is used, it performs only the work necessary. In thisexample, no intermediate arrays are ever created, filter is called three times,and map is only called once: console.log(oddSquares.get(1)); // 9 Any collection can be converted to a lazy Seq with .toSeq(). var seq = Immutable.Map({a:1, b:1, c:1}).toSeq(); Seq allows for the efficient chaining of sequence operations, especially whenconverting to a different concrete type (such as to a JS object): seq.flip().map(key =&gt; key.toUpperCase()).flip().toObject(); // { A: 1, B: 1, C: 1 } As well as expressing logic that would otherwise seem memory-limited: Immutable.Range(1, Infinity) .skip(1000) .map(n =&gt; -n) .filter(n =&gt; n % 2 === 0) .take(2) .reduce((r, n) =&gt; r * n, 1); // 1006008 Note: An iterable is always iterated in the same order, however that order maynot always be well defined, as is the case for the Map. Equality treats Collections as DataImmutable provides equality which treats immutable data structures as puredata, performing a deep equality check if necessary. 12345var map1 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);var map2 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);assert(map1 !== map2); // two different instancesassert(Immutable.is(map1, map2)); // have equivalent valuesassert(map1.equals(map2)); // alternatively use the equals method Immutable.is() uses the same measure of equality as Object.isincluding if both are immutable and all keys and values are equalusing the same measure of equality. Batching Mutations If a tree falls in the woods, does it make a sound? If a pure function mutates some local data in order to produce an immutablereturn value, is that ok? — Rich Hickey, Clojure Applying a mutation to create a new immutable object results in some overhead,which can add up to a minor performance penalty. If you need to apply a seriesof mutations locally before returning, Immutable gives you the ability tocreate a temporary mutable (transient) copy of a collection and apply a batch ofmutations in a performant manner by using withMutations. In fact, this isexactly how Immutable applies complex mutations itself. As an example, building list2 results in the creation of 1, not 3, newimmutable Lists. 123456var list1 = Immutable.List.of(1,2,3);var list2 = list1.withMutations(function (list) &#123; list.push(4).push(5).push(6);&#125;);assert(list1.size === 3);assert(list2.size === 6); Note: immutable also provides asMutable and asImmutable, but onlyencourages their use when withMutations will not suffice. Use caution to notreturn a mutable copy, which could result in undesired behavior. Important!: Only a select few methods can be used in withMutations includingset, push and pop. These methods can be applied directly against apersistent data-structure where other methods like map, filter, sort,and splice will always return new immutable data-structures and never mutatea mutable collection. DocumentationRead the docs and eat your vegetables. Docs are automatically generated from Immutable.d.ts.Please contribute! Also, don’t miss the Wiki whichcontains articles on specific topics. Can’t find something? Open an issue. TestingIf you are using the Chai Assertion Library, Chai Immutable provides a set of assertions to use against Immutable collections. ContributionUse Github issues for requests. We actively welcome pull requests, learn how to contribute. ChangelogChanges are tracked as Github releases. ThanksPhil Bagwell, for his inspirationand research in persistent data structures. Hugh Jackson, for providing the npm packagename. If you’re looking for his unsupported package, see this repository. LicenseImmutable is BSD-licensed. We also provide an additional patent grant.","categories":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/categories/Redux/"}],"tags":[{"name":"react","slug":"react","permalink":"https://React-Apollo.github.io/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"https://React-Apollo.github.io/tags/javascript/"}]},{"title":"翻译|开启React,Redux和Immutable之旅:测试驱动教程(part1)","slug":"Translation|Getting Started with React, Redux and Immutable- a Test-Driven Tutorial (Part 1)","date":"2017-03-15T14:59:17.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2017/03/15/Translation|Getting Started with React, Redux and Immutable- a Test-Driven Tutorial (Part 1)/","link":"","permalink":"https://React-Apollo.github.io/2017/03/15/Translation|Getting Started with React, Redux and Immutable- a Test-Driven Tutorial (Part 1)/","excerpt":"","text":"翻译版本,原文请见,第一部分,第二部分 几周以前,我正在漫无目的的浏览Hacker News,读到一篇关于Redux的头条新闻,Redux的内容我是了解,但是另一个谈到的问题javascript fatigue(JavaScript 疲劳)已经困扰我了,所以我没有太关心,知道读到Redux的几个特征. 强化了函数式编程,确保app行为的可预测性 允许app的同构,客户端和服务端的大多数逻辑都可以共享 时间旅行的debugger?有可能吗？ Redux似乎是React程序state管理的优雅方法,再者谁说的时间旅行不可能？所以我读了文档和一篇非常精彩的教程@teropa:A Comprehensive Guide to Test-First Development with Redux,React,and Immutable(这一篇也是我写作的主要灵感来源). 我喜欢Redux,代码非常优雅,debugger令人疯狂的伟大.我的意思是-看看这个 接下来的教程第一部分希望引导你理解Redux运行的原则.教程的目的仅限于(客户端,没有同构,是比较简单的app)保持教程的简明扼要.如果你想发掘的更深一点,我仅建议你阅读上面提高的那个教程.对比版的Github repo在这里,共享代码贴合教程的步骤.如果你对代码或者教程有任何问题和建议,最好能留下留言. 编辑按:文章已经更新为ES2015版的句法. APP为了符合教程的目的,我们将建一个经典的TodoMVC,为了记录需要,需求如下： 每一个todo可以激活或者完成 可以添加,编辑,删除一个todo 可以根据它的status来过滤筛选todos 激活的todos的数目显示在底部 完成的Todo理解可以删除 Reudux和Immutable：使用函数编程去营救回到几个月前,我正在开发一个webapp包含仪表板. 随着app的成长,我们注意到越来越多的有害的bugs,藏在代码角落里,很难发现.类似:“如果你要导航到这一页,点击按钮,然后回到主页,喝一杯咖啡,回到这一页然后点击两次,奇怪的事情发生了.”这些bug的来源要么是异步操作(side effects)或者逻辑:一个action可能在app中有意想不到的影响,这个有时候我们还发现不了. 这就是Redux之所以存在的威力:整个app的state是一个单一的数据结构,state tree.这一点意思是说：在任何时刻,展示给用户的内容仅仅是state tree结果,这就是单一来源的真相(用户界面的显示内容是由state tree来决定的).每一个action接收state,应用相应的修改(例如,添加一个todo),输出更新的state tree.更新的结果渲染展示给用户.里面没有模糊的异步操作,没有变量的引用引起的不经意的修改.这个步骤使得app有了更好的结构,分离关注点,dubugging也更好用了. Immutable是有Facebook开发的助手函数库,提供一些工具去创建和操作immutable数据结构.尽管在Redux也不是一定要使用它,但是它通过禁止对象的修改,强化了函数式编程方法.有了immutable,当我们想更新一个对象,实际上我们修改的是一个新创建的的对象,原先的对象保持不变. 这里是“Immutable文档”里面的例子: 12345 var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var map2 = map1.set('b', 2);assert(map1 === map2); // no changevar map3 = map1.set('b', 50);assert(map1 !== map3); // change 我们更新了map1的一个值,map1对象保持不变,一个新的对象map3被创建了. Immutable在store中被用来储存我们的app的state tree.很快我们会看到Immutable提供了一下操作对象的简单和有效的方法. 配置项目声明:一些配置有@terops的教程启发. 注意事项:推荐使用Node.js&gt;=4.0.0.你可以使用nvm(node version manager)来切换不同的node.js的版本. 这里是比较版本的提交 开始配置项目: 123mkdir redux-todomvccd redux-todomvcnpm init -y 项目的目录结构如下: 12345678├── dist│ ├── bundle.js│ └── index.html├── node_modules├── package.json├── src├── test└── webpack.config.js 首先创建一个简单的HTML页面,用来运行我们的appdist/index.html1234567891011 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;React TodoMVC&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 有了这个文件,我们写一个简单的脚本文件看看包安装的情况src/index.js 1console.log('Hello world !'); 我们将会使用[Webpack]来打包成为bundle.js文件.Webpack的特性是速度,容易配置,大部分是热更新的.代码的更新不需要重新加载,意味着app的state保持热加载. 让我们安装webpack: npm install —save-dev webpack@1.12.14 webpack-dev-server@1.14.1 app使用ES2015的语法,带来一些优异的特性和一些语法糖.如果你想了解更多的ES2015内容,这个recap是一个不错的资源. Babel用来把ES2015的语法改变为普通的JS语法:npm install —save-dev babel-core@6.5.2 babel-loader@6.2.4 babel-preset-es2015@6.5.0 我们将使用JSX语法编写React组件,所以让我们安装Babel React package：npm install —save-dev babel-preset-react@6.5.0 配置webpack输出源文件:package.json123 \"babel\": &#123; \"presets\": [\"es2015\", \"react\"]&#125; webpack.config.js 1234567891011121314151617181920212223 module.exports = &#123; entry: [ './src/index.js' ], module: &#123; loaders: [&#123; test: /\\.jsx?$/, exclude: /node_modules/, loader: 'babel' &#125;] &#125;, resolve: &#123; extensions: ['', '.js', '.jsx'] &#125;, output: &#123; path: __dirname + '/dist', publicPath: '/', filename: 'bundle.js' &#125;, devServer: &#123; contentBase: './dist' &#125;&#125;; 现在添加React和React热加载组件到项目中:12npm install --save react@0.14.7 react-dom@0.14.7npm install --save-dev react-hot-loader@1.3.0 为了让热加载能运行,webpack.config.js文件中要做一些修改. webpack.config.js12345678910111213141516171819202122232425262728293031 var webpack = require('webpack'); // Requiring the webpack libmodule.exports = &#123; entry: [ 'webpack-dev-server/client?http://localhost:8080', // Setting the URL for the hot reload 'webpack/hot/only-dev-server', // Reload only the dev server './src/index.js' ], module: &#123; loaders: [&#123; test: /\\.jsx?$/, exclude: /node_modules/, loader: 'react-hot!babel' // Include the react-hot loader &#125;] &#125;, resolve: &#123; extensions: ['', '.js', '.jsx'] &#125;, output: &#123; path: __dirname + '/dist', publicPath: '/', filename: 'bundle.js' &#125;, devServer: &#123; contentBase: './dist', hot: true // Activate hot loading &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() // Wire in the hot loading plugin ]&#125;; 配置单元测试框架我们将使用Mocha和Chai来进行测试工作.这两个工具广泛的被使用,他们的输出内容对于测试驱动开发非常的好.Chai-immutable是一个chai插件,用来处理immutable数据结构. 12npm install --save immutable@3.7.6npm install --save-dev mocha@2.4.5 chai@3.5.0 chai-immutable@1.5.3 在我们的例子中,我们不会依赖浏览器为基础的测试运行器例如Karma-替代方案是我们使用jsdom库,它将会使用纯javascirpt创建一个假DOM,这样做让我们的测试更加快速. npm install —save-dev jsdom@8.0.4 我们也需要为测试写一个启动脚本,要考虑到下面的内容. 模拟document和window对象,通常是由浏览器提供 通过chia-immutable告诉chai组件我们要使用immutable数据结构 test/setup.js 1234567891011121314151617 import jsdom from 'jsdom';import chai from 'chai';import chaiImmutable from 'chai-immutable';const doc = jsdom.jsdom('&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;');const win = doc.defaultView;global.document = doc;global.window = win;Object.keys(window).forEach((key) =&gt; &#123; if (!(key in global)) &#123; global[key] = window[key]; &#125;&#125;);chai.use(chaiImmutable); 更新一下npm test脚本package.json1234 \"scripts\": &#123; \"test\": \"mocha --compilers js:babel-core/register --require ./test/setup.js 'test/**/*.@(js|jsx)'\", \"test:watch\": \"npm run test -- --watch --watch-extensions jsx\"&#125;, npm run test:watch命令在windows操作系统下似乎不能工作. 现在,如果我们运行npm run test:watch,所有test目录里的.js,.jsx文件在更新自身或者源文件的时候,将会运行mocha测试. 配置完成了：我们可以在终端中运行webpack-dev-server,打开另一个终端,npm run test:watch.在浏览器中打开localhost:8080.检查hello world!是否出现在终端中. 构建state tree之前提到过,state tree是能提供app所有信息的数据结构.这个结构需要在实际开发之前经过深思熟虑,因为它将影响一些代码的结构和交互作用. 作为示例,我们app是一个TODO list由几个条目组合而成 每一个条目有一个文本,为了便于操作,设一个id,此外每个item有两个状态之一:活动或者完成：最后一个条目需要一个可编辑的状态(当用户想编辑的文本的时候),所以我们需要保持下面的数据结构: 也有可能基于他们的状态进行筛选,所以我们天剑filter条目来获取最终的state tree: 创建UI首先我们把app分解为下面的组件: TodoHeader组件是创建新todo的输入组件 TodoList组件是todo的列表 todoItem是一个todo todoInput是编辑todo的输入框 TodoTools是显示未完成的条目数量,过滤器和清除完成的按钮 footer是显示信息的,没有具体的逻辑 我们也创建TodoApp组件组织所有的其他组件. 首次运行我们的组件 提示:运行这个版本 正如我们所见的,我们将会把所有组件放到合并成一个TodoApp组件.所以让我们添加组件到index.html文件的#appDIV中:src/index.jsx 12345678910111213141516import React from 'react';import ReactDOM from 'react-dom';import &#123;List, Map&#125; from 'immutable';import TodoApp from './components/TodoApp';const todos = List.of( Map(&#123;id: 1, text: 'React', status: 'active', editing: false&#125;), Map(&#123;id: 2, text: 'Redux', status: 'active', editing: false&#125;), Map(&#123;id: 3, text: 'Immutable', status: 'completed', editing: false&#125;));ReactDOM.render( &lt;TodoApp todos=&#123;todos&#125; /&gt;, document.getElementById('app')); 因为我们在index.jsx文件中使用JSX语法,需要在wabpack中扩展.jsx.修改如下:webpack.config.js12345 entry: [ 'webpack-dev-server/client?http://localhost:8080', 'webpack/hot/only-dev-server', './src/index.jsx' // Change the index file extension], 编写todo list UI现在我们编写第一版本的TodoApp组件,用来显示todo项目列表:src/components/TodoApp.jsx1234567891011121314151617181920212223242526272829 import React from 'react';export default class TodoApp extends React.Component &#123; getItems() &#123; return this.props.todos || []; &#125; render() &#123; return &lt;div&gt; &lt;section className=\"todoapp\"&gt; &lt;section className=\"main\"&gt; &lt;ul className=\"todo-list\"&gt; &#123;this.getItems().map(item =&gt; &lt;li className=\"active\" key=&#123;item.get('text')&#125;&gt; &lt;div className=\"view\"&gt; &lt;input type=\"checkbox\" className=\"toggle\" /&gt; &lt;label htmlFor=\"todo\"&gt; &#123;item.get('text')&#125; &lt;/label&gt; &lt;button className=\"destroy\"&gt;&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; )&#125; &lt;/ul&gt; &lt;/section&gt; &lt;/section&gt; &lt;/div&gt; &#125;&#125;; 要记住两件事情:第一个,如果你看到的结果不太好,修复它,我们将会使用todomvc-app-css包来补充一些需要的样式12npm install --save todomvc-app-css@2.0.4npm install style-loader@0.13.0 css-loader@0.23.1 --save-dev 我们需要告诉webpack去加载css 样式文件:webpack.config.js123456789101112// ...module: &#123; loaders: [&#123; test: /\\.jsx?$/, exclude: /node_modules/, loader: 'react-hot!babel' &#125;, &#123; test: /\\.css$/, loader: 'style!css' // We add the css loader &#125;]&#125;,//... 然后在inde.jsx文件中添加样式:src/index.jsx1234567 // ...require('../node_modules/todomvc-app-css/index.css');ReactDOM.render( &lt;TodoApp todos=&#123;todos&#125; /&gt;, document.getElementById('app')); 第二件事是:代码似乎很复杂,这就是我们为什么要创建两个或者多个组件的原因:TodoList和TodoItem将会分别关注条目列表和单个的条目. 这一部分的提交代码 src/components/TodoApp.jsx123456789101112 import React from 'react';import TodoList from './TodoList'export default class TodoApp extends React.Component &#123; render() &#123; return &lt;div&gt; &lt;section className=\"todoapp\"&gt; &lt;TodoList todos=&#123;this.props.todos&#125; /&gt; &lt;/section&gt; &lt;/div&gt; &#125;&#125;; 在TodoList组件中根据获取的props为每一个条目显示一个TodoItem组件. src/components/TodoList.jsx123456789101112131415 import React from 'react';import TodoItem from './TodoItem';export default class TodoList extends React.Component &#123; render() &#123; return &lt;section className=\"main\"&gt; &lt;ul className=\"todo-list\"&gt; &#123;this.props.todos.map(item =&gt; &lt;TodoItem key=&#123;item.get('text')&#125; text=&#123;item.get('text')&#125; /&gt; )&#125; &lt;/ul&gt; &lt;/section&gt; &#125;&#125;; src/components/TodoItem.jsx12345678910111213141516 import React from 'react';export default class TodoItem extends React.Component &#123; render() &#123; return &lt;li className=\"todo\"&gt; &lt;div className=\"view\"&gt; &lt;input type=\"checkbox\" className=\"toggle\" /&gt; &lt;label htmlFor=\"todo\"&gt; &#123;this.props.text&#125; &lt;/label&gt; &lt;button className=\"destroy\"&gt;&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &#125;&#125;; 在我们深入用户的交互操作之前,我们先在组件TodoItem中添加一个input用于编辑src/componensts/TodoItem.jsx1234567891011121314151617181920 import React from 'react';import TextInput from './TextInput';export default class TodoItem extends React.Component &#123; render() &#123; return &lt;li className=\"todo\"&gt; &lt;div className=\"view\"&gt; &lt;input type=\"checkbox\" className=\"toggle\" /&gt; &lt;label htmlFor=\"todo\"&gt; &#123;this.props.text&#125; &lt;/label&gt; &lt;button className=\"destroy\"&gt;&lt;/button&gt; &lt;/div&gt; &lt;TextInput /&gt; // We add the TextInput component &lt;/li&gt; &#125;&#125;; TextInput组件如下src/compoents/TextInput.jsx123456789import React from 'react';export default class TextInput extends React.Component &#123; render() &#123; return &lt;input className=\"edit\" autoFocus=&#123;true&#125; type=\"text\" /&gt; &#125;&#125;; ”纯“组件的好处：PureRenderMixin这部分的提交代码 除了允许函数式编程的样式,我们的UI是单纯的,可以使用PureRenderMixin来提升速度,正如React 文档:如果你的React的组件渲染函数是”纯“(换句话就是,如果使用相同的porps和state,总是会渲染出同样的结果),你可以使用mixin在同一个案例转给你来提升性能. 正如React文档(我们也会在第二部分看到TodoApp组件有额外的角色会阻止PureRenderMixin的使用)展示的mixin也非常容易的添加到我们的子组件中:npm install --save react-addons-pure-render-mixin@0.14.7src/components/TodoList.jsc 12345678910111213 import React from 'react';import PureRenderMixin from 'react-addons-pure-render-mixin'import TodoItem from './TodoItem';export default class TodoList extends React.Component &#123; constructor(props) &#123; super(props); this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this); &#125; render() &#123; // ... &#125;&#125;; src/components/TodoItem/jsx12345678910111213import React from 'react';import PureRenderMixin from 'react-addons-pure-render-mixin'import TextInput from './TextInput';export default class TodoItem extends React.Component &#123; constructor(props) &#123; super(props); this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this); &#125; render() &#123; // ... &#125;&#125;; src/components/TextInput.jsx123456789101112import React from 'react';import PureRenderMixin from 'react-addons-pure-render-mixin'export default class TextInput extends React.Component &#123; constructor(props) &#123; super(props); this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this); &#125; render() &#123; // ... &#125;&#125;; 在list组件中处理用户的actions好了,现在我们配置好了list组件.然而我们没有考虑添加用户的actions和怎么添加进去组件. props的力量在React中,props对象是当我们实例化一个容器(container)的时候,通过设定的attributes来设定.例如,如果我们实例化一个TodoItem元素:1&lt;TodoItem text=&#123;'Text of the item'&#125; /&gt; 然后我们在TodoItem组件中获取this.props.text变量:123 // in TodoItem.jsxconsole.log(this.props.text);// outputs 'Text of the item' Redux构架中强化使用props.基础的原理是state几乎都存在于他的props里面.换一种说法：对于同样一组props,两个元素的实例应该输出完全一样的结果.正如之前我们看到的,整个app的state都包含在一个state tree中:意思是说,state tree 如果通过props的方式传递到组件,将会完整和可预期的决定app的视觉输出. TodoList组件这一部分的代码修改 在这一部分和接下来的一部分,我们将会了解一个测试优先的方法. 为了帮助我们测试组件,React库提供了TestUtils工具插件,有一下方法: renderIntoDocument,渲染组件到附加的DOM节点 scryRenderDOMComponentsWIthTag,使用提供的标签(例如li,input)在DOM中找到所有的组件实例. scryRederDOMComponentsWithClass,同上使用的是类 Simulate,模拟用户的actions(例如 点击,按键,文本输入…) TestUtils插件没有包含在react包中,所以需要单独安装npm install --save-dev react-addons-test-utils@0.14.7 我们的第一个测试将确保Todolist组件中,如果filterprops被设置为active,将会展示所有的活动条目: test/components/TodoList_spec.jsx 123456789101112131415161718192021222324252627 import React from 'react';import TestUtils from 'react-addons-test-utils';import TodoList from '../../src/components/TodoList';import &#123;expect&#125; from 'chai';import &#123;List, Map&#125; from 'immutable';const &#123;renderIntoDocument, scryRenderedDOMComponentsWithTag&#125; = TestUtils;describe('TodoList', () =&gt; &#123; it('renders a list with only the active items if the filter is active', () =&gt; &#123; const todos = List.of( Map(&#123;id: 1, text: 'React', status: 'active'&#125;), Map(&#123;id: 2, text: 'Redux', status: 'active'&#125;), Map(&#123;id: 3, text: 'Immutable', status: 'completed'&#125;) ); const filter = 'active'; const component = renderIntoDocument( &lt;TodoList filter=&#123;filter&#125; todos=&#123;todos&#125; /&gt; ); const items = scryRenderedDOMComponentsWithTag(component, 'li'); expect(items.length).to.equal(2); expect(items[0].textContent).to.contain('React'); expect(items[1].textContent).to.contain('Redux'); &#125;);&#125;); 我们可以看到测试失败了,期待的是两个活动条目,但是实际上是三个.这是再正常不过的了,因为我们没有编写实际筛选的逻辑:src/components/TodoList.jsx1234567891011121314151617181920212223// ...export default class TodoList extends React.Component &#123; // Filters the items according to their status getItems() &#123; if (this.props.todos) &#123; return this.props.todos.filter( (item) =&gt; item.get('status') === this.props.filter ); &#125; return []; &#125; render() &#123; return &lt;section className=\"main\"&gt; &lt;ul className=\"todo-list\"&gt; // Only the filtered items are displayed &#123;this.getItems().map(item =&gt; &lt;TodoItem key=&#123;item.get('text')&#125; text=&#123;item.get('text')&#125; /&gt; )&#125; &lt;/ul&gt; &lt;/section&gt; &#125;&#125;; 第一个测试通过了.别停下来,让我们添加筛选器:all和completed: test/components/TodoList_spec.js 12345678910111213141516171819202122232425262728293031323334353637 // ...describe('TodoList', () =&gt; &#123; // ... it('renders a list with only completed items if the filter is completed', () =&gt; &#123; const todos = List.of( Map(&#123;id: 1, text: 'React', status: 'active'&#125;), Map(&#123;id: 2, text: 'Redux', status: 'active'&#125;), Map(&#123;id: 3, text: 'Immutable', status: 'completed'&#125;) ); const filter = 'completed'; const component = renderIntoDocument( &lt;TodoList filter=&#123;filter&#125; todos=&#123;todos&#125; /&gt; ); const items = scryRenderedDOMComponentsWithTag(component, 'li'); expect(items.length).to.equal(1); expect(items[0].textContent).to.contain('Immutable'); &#125;); it('renders a list with all the items', () =&gt; &#123; const todos = List.of( Map(&#123;id: 1, text: 'React', status: 'active'&#125;), Map(&#123;id: 2, text: 'Redux', status: 'active'&#125;), Map(&#123;id: 3, text: 'Immutable', status: 'completed'&#125;) ); const filter = 'all'; const component = renderIntoDocument( &lt;TodoList filter=&#123;filter&#125; todos=&#123;todos&#125; /&gt; ); const items = scryRenderedDOMComponentsWithTag(component, 'li'); expect(items.length).to.equal(3); expect(items[0].textContent).to.contain('React'); expect(items[1].textContent).to.contain('Redux'); expect(items[2].textContent).to.contain('Immutable'); &#125;);&#125;); 第三个测试失败了,因为all筛选器更新组件的逻辑稍稍有点不同 src/components/TodoList.jsx 12345678910111213 // ...export default React.Component &#123; // Filters the items according to their status getItems() &#123; if (this.props.todos) &#123; return this.props.todos.filter( (item) =&gt; this.props.filter === 'all' || item.get('status') === this.props.filter ); &#125; return []; &#125; // ...&#125;); 在这一点上,我们知道显示在app中的条目都是经过filter属性过滤的.如果在浏览器中看看结果,没有显示任何条目,因为我们还没有设置：src/index.jsx123456789101112131415 // ...const todos = List.of( Map(&#123;id: 1, text: 'React', status: 'active', editing: false&#125;), Map(&#123;id: 2, text: 'Redux', status: 'active', editing: false&#125;), Map(&#123;id: 3, text: 'Immutable', status: 'completed', editing: false&#125;));const filter = 'all';require('../node_modules/todomvc-app-css/index.css')ReactDOM.render( &lt;TodoApp todos=&#123;todos&#125; filter = &#123;filter&#125;/&gt;, document.getElementById('app')); src/components/TodoApp.jsx 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// ...export default class TodoApp extends React.Component &#123; render() &#123; return &lt;div&gt; &lt;section className=\"todoapp\"&gt; // We pass the filter props down to the TodoList component &lt;TodoList todos=&#123;this.props.todos&#125; filter=&#123;this.props.filter&#125;/&gt; &lt;/section&gt; &lt;/div&gt; &#125;&#125;;``` 使用在`index.jsc`文件中声明的`filter`常量过滤以后,我们的条目重新出现了.### TodoItem component[这部分的代码修改](https://github.com/phacks/redux-todomvc/commit/71d2835620f4ba6f3fc3665327f13ec4fba62eee)现在,让我们关注一下`TodoItem`组件.首先,我们想确信`TodoItem`组件真正渲染一个条目.我们也想测试一下还没有测试的特性,就是当一个条目完成的时候,他的文本中间有一条线`test/components/TodoItem_spec.js` ```js import React from 'react';import TestUtils from 'react-addons-test-utils';import TodoItem from '../../src/components/TodoItem';import &#123;expect&#125; from 'chai';const &#123;renderIntoDocument, scryRenderedDOMComponentsWithTag&#125; = TestUtils;describe('TodoItem', () =&gt; &#123; it('renders an item', () =&gt; &#123; const text = 'React'; const component = renderIntoDocument( &lt;TodoItem text=&#123;text&#125; /&gt; ); const todo = scryRenderedDOMComponentsWithTag(component, 'li'); expect(todo.length).to.equal(1); expect(todo[0].textContent).to.contain('React'); &#125;); it('strikes through the item if it is completed', () =&gt; &#123; const text = 'React'; const component = renderIntoDocument( &lt;TodoItem text=&#123;text&#125; isCompleted=&#123;true&#125;/&gt; ); const todo = scryRenderedDOMComponentsWithTag(component, 'li'); expect(todo[0].classList.contains('completed')).to.equal(true); &#125;);&#125;); 为了使第二个测试通过,如果条目的状态是complete我们使用了类complete,它将会通过props传递向下传递.我们将会使用classnames包来操作我们的DOM类. npm install —save classnames src/components/TodoItem.jsx 1234567891011121314151617 import React from 'react';// We need to import the classNames objectimport classNames from 'classnames';import TextInput from './TextInput';export default class TodoItem extends React.Component &#123; render() &#123; var itemClass = classNames(&#123; 'todo': true, 'completed': this.props.isCompleted &#125;); return &lt;li className=&#123;itemClass&#125;&gt; // ... &lt;/li&gt; &#125;&#125;; 一个item在编辑的时候外观应该看起来不一样,由isEditingprops来包裹.test/components/TodoItem_spec.js 1234567891011121314 // ...describe('TodoItem', () =&gt; &#123; //... it('should look different when editing', () =&gt; &#123; const text = 'React'; const component = renderIntoDocument( &lt;TodoItem text=&#123;text&#125; isEditing=&#123;true&#125;/&gt; ); const todo = scryRenderedDOMComponentsWithTag(component, 'li'); expect(todo[0].classList.contains('editing')).to.equal(true); &#125;);&#125;); 为了使测试通过,我们仅仅需要更新itemClass对象: src/components/TodoItem.jsx 12345678910111213 // ...export default class TodoItem extends React.Component &#123; render() &#123; var itemClass = classNames(&#123; 'todo': true, 'completed': this.props.isCompleted, 'editing': this.props.isEditing &#125;); return &lt;li className=&#123;itemClass&#125;&gt; // ... &lt;/li&gt; &#125;&#125;; 条目左侧的checkbox如果条目完成,应该标记位checked: test/components/TodoItem_spec.js 12345678910111213141516 // ...describe('TodoItem', () =&gt; &#123; //... it('should be checked if the item is completed', () =&gt; &#123; const text = 'React'; const text2 = 'Redux'; const component = renderIntoDocument( &lt;TodoItem text=&#123;text&#125; isCompleted=&#123;true&#125;/&gt;, &lt;TodoItem text=&#123;text2&#125; isCompleted=&#123;false&#125;/&gt; ); const input = scryRenderedDOMComponentsWithTag(component, 'input'); expect(input[0].checked).to.equal(true); expect(input[1].checked).to.equal(false); &#125;);&#125;); React有个设定checkbox输入state的方法:defaultChecked. src/components/TodoItem.jsx 1234567891011121314 // ...export default class TodoItem extends React.Component &#123; render() &#123; // ... return &lt;li className=&#123;itemClass&#125;&gt; &lt;div className=\"view\"&gt; &lt;input type=\"checkbox\" className=\"toggle\" defaultChecked=&#123;this.props.isCompleted&#125;/&gt; // ... &lt;/div&gt; &lt;/li&gt; &#125;&#125;; 我们也从TodoList组件向下传递isCompleted和isEditingprops. src/components/TodoList.jsx 123456789101112131415161718192021 // ...export default class TodoList extends React.Component &#123; // ... // This function checks whether an item is completed isCompleted(item) &#123; return item.get('status') === 'completed'; &#125; render() &#123; return &lt;section className=\"main\"&gt; &lt;ul className=\"todo-list\"&gt; &#123;this.getItems().map(item =&gt; &lt;TodoItem key=&#123;item.get('text')&#125; text=&#123;item.get('text')&#125; // We pass down the info on completion and editing isCompleted=&#123;this.isCompleted(item)&#125; isEditing=&#123;item.get('editing')&#125; /&gt; )&#125; &lt;/ul&gt; &lt;/section&gt; &#125;&#125;; 截止目前,我们已经能够在组件中反映出state：例如,完成的条目将会被划线.然而一个webapp将会处理诸如点击按钮的操作.在Redux的模式中,这个操作也通过porps来执行,稍稍特殊的是通过在props中传递回调函数来完成.通过这种方式,我们再次把UI和App的逻辑处理分离开:组件根本不需要知道按钮点击的操作具体是什么,仅仅是点击触发了一些事情. 为了描述这个原理,我们将会测试如果用户点击了delete按钮(红色X),delteItem函数将会被调用. 这部分的代码修改 test/components/TodoItem_spec.jsx 1234567891011121314151617181920212223 / ...// The Simulate helper allows us to simulate a user clickingconst &#123;renderIntoDocument, scryRenderedDOMComponentsWithTag, Simulate&#125; = TestUtils;describe('TodoItem', () =&gt; &#123; // ... it('invokes callback when the delete button is clicked', () =&gt; &#123; const text = 'React'; var deleted = false; // We define a mock deleteItem function const deleteItem = () =&gt; deleted = true; const component = renderIntoDocument( &lt;TodoItem text=&#123;text&#125; deleteItem=&#123;deleteItem&#125;/&gt; ); const buttons = scryRenderedDOMComponentsWithTag(component, 'button'); Simulate.click(buttons[0]); // We verify that the deleteItem function has been called expect(deleted).to.equal(true); &#125;);&#125;); 为了是这个测试通过,我们必须在delete按钮声明一个onClick句柄,他将会调用经过props传递的deleteItem函数. src/components/TodoItem.jsx 123456789101112131415 // ...export default class TodoItem extends React.Component &#123; render() &#123; // ... return &lt;li className=&#123;itemClass&#125;&gt; &lt;div className=\"view\"&gt; // ... // The onClick handler will call the deleteItem function given in the props &lt;button className=\"destroy\" onClick=&#123;() =&gt; this.props.deleteItem(this.props.id)&#125;&gt;&lt;/button&gt; &lt;/div&gt; &lt;TextInput /&gt; &lt;/li&gt; &#125;&#125;; 重要的一点:实际删除的逻辑还没有实施,这个将是Redux的主要作用. 在同一个model,我们可以测试和实施下面的特性: 点击checkbox将会调用toggleComplete函数 双击条目标签,将会调用editItem函数 test/components/TodoItem_spec.js 12345678910111213141516171819202122232425262728 // ...describe('TodoItem', () =&gt; &#123; // ... it('invokes callback when checkbox is clicked', () =&gt; &#123; const text = 'React'; var isChecked = false; const toggleComplete = () =&gt; isChecked = true; const component = renderIntoDocument( &lt;TodoItem text=&#123;text&#125; toggleComplete=&#123;toggleComplete&#125;/&gt; ); const checkboxes = scryRenderedDOMComponentsWithTag(component, 'input'); Simulate.click(checkboxes[0]); expect(isChecked).to.equal(true); &#125;); it('calls a callback when text is double clicked', () =&gt; &#123; var text = 'React'; const editItem = () =&gt; text = 'Redux'; const component = renderIntoDocument( &lt;TodoItem text=&#123;text&#125; editItem=&#123;editItem&#125;/&gt; ); const label = component.refs.text Simulate.doubleClick(label); expect(text).to.equal('Redux'); &#125;);&#125;); src/compoents/TodoItem.jsx 12345678910111213141516171819202122 // ...render() &#123; // ... return &lt;li className=&#123;itemClass&#125;&gt; &lt;div className=\"view\"&gt; // We add an onClick handler on the checkbox &lt;input type=\"checkbox\" className=\"toggle\" defaultChecked=&#123;this.props.isCompleted&#125; onClick=&#123;() =&gt; this.props.toggleComplete(this.props.id)&#125;/&gt; // We add a ref attribute to the label to facilitate the testing // The onDoubleClick handler is unsurprisingly called on double clicks &lt;label htmlFor=\"todo\" ref=\"text\" onDoubleClick=&#123;() =&gt; this.props.editItem(this.props.id)&#125;&gt; &#123;this.props.text&#125; &lt;/label&gt; &lt;button className=\"destroy\" onClick=&#123;() =&gt; this.props.deleteItem(this.props.id)&#125;&gt;&lt;/button&gt; &lt;/div&gt; &lt;TextInput /&gt; &lt;/li&gt; 我们也从TodoList组件借助props向下传递editItem,deleteItem和toggleComplete函数. src/components/TodoList.jsx 1234567891011121314151617181920 // ...export default class TodoList extends React.Component &#123; // ... render() &#123; return &lt;section className=\"main\"&gt; &lt;ul className=\"todo-list\"&gt; &#123;this.getItems().map(item =&gt; &lt;TodoItem key=&#123;item.get('text')&#125; text=&#123;item.get('text')&#125; isCompleted=&#123;this.isCompleted(item)&#125; isEditing=&#123;item.get('editing')&#125; // We pass down the callback functions toggleComplete=&#123;this.props.toggleComplete&#125; deleteItem=&#123;this.props.deleteItem&#125; editItem=&#123;this.props.editItem&#125;/&gt; )&#125; &lt;/ul&gt; &lt;/section&gt; &#125;&#125;; 配置其他组件现在,你可能对流程有些熟悉了.为了让本文不要太长,我邀请你看看组件的代码,TextInput(相关提交),TodoHeader(相关提交),Todotools和Footer(相关提交)组件.如果你有任何问题，请留下评论,或着在repo的issue中留下评论. 你可能主要到一些函数,例如editItem,toggleComplete诸如此类的,还没有被定义.这些内容将会在教程的下一部分作为Redux actions的组成来定义,所以如果遇到错误,不要担心. 包装起来 在这篇文章中,我已经演示了我的第一个React,Redux和Immutable webapp.我们的UI是模块化的.完全通过测试,准备和实际的app逻辑联系起来.怎么来连接？这些傻瓜组件什么都不知道,怎么让我们可以写出时间旅行的app? 教程的第二部分在这里.","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"react","slug":"react","permalink":"https://React-Apollo.github.io/tags/react/"},{"name":"redux","slug":"redux","permalink":"https://React-Apollo.github.io/tags/redux/"},{"name":"Immutable.js","slug":"Immutable-js","permalink":"https://React-Apollo.github.io/tags/Immutable-js/"}]},{"title":"Readme|Redux-awesome","slug":"Awesome Redux","date":"2017-03-08T00:04:10.000Z","updated":"2018-04-07T02:42:18.247Z","comments":true,"path":"2017/03/08/Awesome Redux/","link":"","permalink":"https://React-Apollo.github.io/2017/03/08/Awesome Redux/","excerpt":"","text":"Awesome Redux List of repositories which use Redux ReduxDocumentation of ReduxDocumentation of Redux(Simple Chinese version)Documentation of Redux(Russian version) (Work in progress)Documentation of Redux(Traditional Chinese version)Documentation of Redux(Japanese version) (Work in progress)Documentation of Redux(Portuguese version) (Work in progress)Documentation of Redux(Spanish version) (Work in progress)Documentation of Redux(Korean version)Documentation of Redux(Sinhala|සිංහල version) (Work in progress) Predictable state container for JavaScript apps Marks Universal (Isomorphic) - :metal: Hot Reload - :fire: Presentations Let’s learn React and Redux with Javascript’s new ES6 syntax, from Beginner to Intermediate to Advanced. A introduction about Redux Real World Redux The power of higher-order reducers Reactive Architecture with Redux and Angular Redux Internals Replacing Angular 1 with React and Redux A tour on the React ecosystem Redux from Twitter hype to production Resources Many tools and middlewares Redux offline docs Flux challenge Sound Redux - a simple Soundcloud client Favesound Redux - SoundCloud Client for Artists Structor - a user interface builder for React generator-redux - CLI tools for Redux: next-gen functional Flux/React with devtools generator-reactapp - Yeoman generator for react app with redux Rekit - Toolkit for building scalable web apps with React, Redux and React-router Spectacle - ReactJS based Presentation Library Notes (and partial transcription) of Dan Abramov’s Redux course videos on http://egghead.io Comprehensive Notes for Learning (how to use) Redux to manage state in your Web/Mobile Apps React Redux [RU tutorial] Redux without profanity React and Redux Single Page Applications Resources A categorized list of Redux-related addons, libraries, and utilities Building the F8 2016 App (Redux, GraphQL, React Native) The Elm Architecture in JavaScript Articles And Tutorials Building Applications with React and Redux in ES6 on Pluralsight Writing a Basic App in Redux Learn how to use Redux step by step Tutorial: Handcrafting an Isomorphic Redux Application (With Love) 0 to 1 : Getting started with Redux Redux Chinese Document Redux Document (Traditional Chinese) Relay and Routing Understanding Redux Middleware Several videos about Redux + Falcor and Example code Redux Middleware: Behind the Scenes A proposal for bundling reducers, action types and actions when using Redux Full-Stack Redux Tutorial - A Comprehensive Guide to Test-First Development with Redux, React, and Immutable Source Server + Client Redux best practices The 3REE Stack: React + Redux + RethinkDB + Express.js React Tutorial - Converting Reflux to Redux Redux example using 500px API (with ES6) Building a boilerplate for a Koa, Redux, React application including Webpack, Mocha and SASS - This article explains in detail how this koa-redux-react-boilerplate was built and the technologies it uses. Typed React and Redux A cartoon intro to Redux Join The Dark Side Of The Flux: Responding to Actions with Actors Can I dispatch multiple actions from Redux action creators? Understanding Redux (or, How I Fell in Love with a JavaScript State Container) Your First Immutable React &amp; Redux App Getting Started with Redux - Egghead’s video lessons from Dan Abramov Redux Testing Video Lessons - a few short Egghead video lessons (some free, some require a subscription) Implementing a smart Login Modal with Redux, reselect and ReactJS How to Build a Todo App Using React, Redux, and Immutable.js Rethinking Redux Managing Side Effects In React + Redux Using Sagas Secure Your React and Redux App with JWT Authentication Getting started with Redux and GraphQL Data Flows with Angular 2 and Redux Simple Routing with Redux and React Redux nowadays : From actions creators to sagas Master Complex Redux Workflows with Sagas Angular 2 Application Architecture - Building Flux Apps with Redux and Immutable.js React, Redux and Immutable.js: Ingredients for Efficient Web Applications An Introduction to React Redux (Part 1) An Introduction to React Redux (Part 2) Rules For Structuring (Redux) Applications Redux for the very beginner Redux - Calling web service asynchronously Animating with React, Redux, and d3 Build an Image Gallery Using React, Redux and redux-saga Introducing redux-operations Solving Redux’s shortcoming in 150 LOCs The Anatomy Of A React Redux App Getting Started with React, Redux and Immutable: a Test-Driven Tutorial (Part 2) Leveling Up with React: Redux Complete intro to react Recreating Redux — Behind the magic curtain Let’s Build a Redux Powered React Application Deep Introduction to Redux - Seriese 1/3 Universal Rendering with Redux and React-Router - Seriese 2/3 Unit Testing Redux Apps - Seriese 3/3 Using Aurelia and Redux together for good times all around Comparing Redux and Relay Building React Applications with Idiomatic Redux The SoundCloud Client in React + Redux 深入浅出 Redux Building Angular 2 applications with Immutable.js and Redux Tutorial: Building Redux in TypeScript with Angular 2 Improving React and Redux performance with Reselect Recipes for Redux Getting Started with Redux &amp; Angular 2 Universal/Isomorphic React+Redux on a Swift Web Backend Creating Reusable React-Redux Components Through Scoping React+Redux系列教程 书籍：《React 与 Redux 开发实例精解》 Boilerplate redux-minimal - Minimalist react-redux starter kit which let’s you build rich real world apps Modern and Scalable React/Redux Boilerplate - Flexible starter kit using Webpack 2 (tree-shaking) / React Hot Loader v3 / Code Splitting for React Router / PostCSS / CSS Modules / custom Ducks pattern app architecture / best practices / Sentry error tracking / Enzyme test environment :rocket: react-production-starter - React boilerplate with isomorphic rendering, async react-router routes, async redux reducers, async data fetching, and code-splitting. :metal: :fire: mern.io - Simple full-stack boilerplate to get started with building isomorphic/universal apps, handles api part and also offers a cli to generate the boilerplate :metal: :fire: universal-react-redux - Opinionated Universal React/Redux/Webpack with HMR. Continually updated. :metal: :fire: react-slingshot - React Redux Starter Kit with hot reloading, tests and example app react-redux-boilerplate - React Redux Boilerplate react-boilerplate - React + Typescript + Sass boilerplate react-redux-scaffold - Combination of redux, react-router and ES6+ support simple-redux-boilerplate - Simple and guided React, Redux boilerplate w/ Transform HMR! :fire: reactv - React Redux example redux-boilerplate - Boilerplate for Redux react-redux-starter-kit - Get started with React, Redux, and React-Router. simplest-redux-example - Simplest Redux + React example for beginners redux-easy-boilerplate - React Redux easy boilerplate dicty-redux - Starter kit to bootstrap React and Redux (Flux) based web application 3ree - Boilerplate &amp; Demo for Universal Realtime Apps built with React + Redux + RethinkDB + Express react_scaffolding - React + React Router 1.0 + Redux + Webpack &amp; Hot Module Replacement express-redux-sample - Express-Redux-PassportJs-MySQL Boilerplate redux-blog-example - Redux-Webpack-Babel Blog Platform boilerplate redux-undo-boilerplate - a magical boilerplate with hot reloading and awesome error handling redux500 - The Redux version of isomorphic500 redux-demo - Redux port of SurviveJS - Webpack and React Kanban app react-redux-universal-hot-example - A starter boilerplate for a universal webapp using express, react, redux, webpack, and react-hot-loader :metal: rde - Reactive Live Programming Environment React Redux Starter Kit - Yet another React and Redux based web application starter kit skeleton - A simple project-stub to show the basic ideas. Also serves you as a quick start for your project (Mori + Redux) browser-redux - Building Chrome apps and cross-browser extensions with Redux and Webpack react-for-hipsters-boilerplate - Fresh boilerplate with brand new hot reloading confing and other hipster stuff Documented Koa Redux React Webpack boilerplate- The building process of this boilerplate is deeply documented from 0 for learning purposes. You can find the docs here. err - Electron, React, Redux-devtools boilerplate for building cross-platform apps. friends-app-redux - React Redux Universal Hot Example isomorphic-redux-app - Redux Isomorphic App (with async content) starter-kit - Project boilerplate using React, Redux and Uniloc http://unicornstandard.com/packages/boilerplate.html loopback-redux-react-boilerplate - A boilerplate for a Redux-React application using LoopBack breko-hub - Babel React Koa Hot Universal Boilerplate – A simple, clean and consistent boilerplate for creating universal webapps with universal data fetching and SocketIO integration React Redux Cordova Boilerplate react-boilerplate - Performance orientated, offline-first boilerplate feat. hot-reloading, PostCSS and the best developer experience. react-webpack-node - Boilerplate for an universal React + Redux/alt Flux application using Webpack running on a node express server [Hapi React Starter Kit - Universal, Redux, Redis, Socket.io, Intl] (https://github.com/Dindaleon/hapi-react-starter-kit) [Universal Redux Template - A clean, extensible react + redux boilerplate with universal rendering, testing and more] (https://github.com/mz026/universal-redux-template) universal-js - A universal Javascript starter kit inc. React, Redux, Redux Dev Tools, Universal Redux Router, CSS Modules, hot module reloading, Babel for ES2015+ and ESLint redux-react-material-boilerplate - Simple boilerplate inc. React, Redux, Hot reload and Material-ui react-redux-starter - React Redux Starter Reduxible - The Fast and Easy way to make a React + Redux apps react-workflow - A large SPA boilerplate for web development built on top of Facebook’s React library,use redux architecture ReacToGo - A simple ES6 boilerplate with Redux architecture and ImmutableJS: Hot Reload, React UI Comp, Firebase, Router React/Redux simple CRUD with persistent state and local async actions (add a manifest file and you get an offline webapp) StarHackIt - An React/Redux Node full-stack starter kit with authentication and authorization code React Seed - A barebones scalable directory structure and package.json for facilitating new React + Redux projects. No fat to trim here! [React/Redux with Auth boilerplate - Very simple boilerplate, good for fast creating admin panels / dashboard. Included: React, Redux, ReduxForm, React-Router, Simple Authenticate, Hot Reload and Webpack (with babel) :fire:] (https://github.com/WapGeaR/react-redux-boilerplate-auth) Docker + React/Redux + Node + PostgreSQL - full stack boilerplate with fully dockerized workflows for development, deployment, testing Redux universal boilerplate - boilerplate for react universal application building on flux architecture based on redux implementation. React Redux Universal Boilerplate - An Universal ReactJS/Redux Boilerplate. react-hot-redux-firebase-starter - Starter boilerplate for using React/Redux with Firebase 3.0 API, include the new React Hot Loader 3.0 :fire: React Redux Firebase Boilerplate - Designed for quickly spin up your apps with Firebase, using bunch of awesome new front-end technologies includes webpack build system, hot reloading, routing &amp; sass support. :fire: React Universal Saga - Universal React Starter Kit ft. Redux Saga React Redux SoundCloud Client - Seed Project for a SoundCloud Client with working Login + Extension Seed Projects vortigern - A universal boilerplate for building web applications w/ TypeScript, React, Redux and more. angular2-redux-contact-list - Simple contact list built with Angular 2, Immutable.js and Redux react-redux-seed - 使用 React 与 Redux 实现 Universal 渲染的种子工程 ARc - A progressive React starter kit based on Atomic Design with redux, redux-saga and redux-form edux - fast Redux without constants and switches. Actions and reducers are generated from single source. React Native - A framework for building native apps using React Examples CarteJaune - An open source Redux/ExponentJS (React Native) app leveraging redux-saga to keep track of your vaccinations noder-react-native - The mobile app of cnodejs.org written in React Native react-native-redux-counter react-native-counter-ios-android react-native-redux-groceries - An example app using React Native, Redux, Firebase, and AsyncStorage for offline data react-native-sound-cloud snowflake - mobile app starter: Login, Logout, Reset Password, Update Profile, Hot Reload uestc-bbs-react-native - An iOS client for http://bbs.uestc.edu.cn/ written in React Native with Redux movies-redux - redux implementation of react-native movies example that is included in react-native source react-native-redux-todo-list - A sample todo list app developed by using react-native and redux React - A JavaScript library for building user interfaces Containers reapop - A React &amp; Redux notifications system Middlewares redux-cheerio - Make HTTP requests and then parse the responses with jQuery selectors using Cheerio redux-reporter - Report actions &amp; metadata to 3rd party providers, extremely useful for analytics and error handling (New Relic, Sentry, Adobe DTM, Keen, etc.) redux-transduce - Transducer utilities for Redux redux-actions - Flux Standard Action utilities for Redux redux-promise - FSA-compliant promise middleware for Redux redux-sync-promise - Middleware for writing asynchronous actions in synchronous style redux-simple-promise - FSA-compliant promise middleware for Redux with simple behaviour with minimal boilerplate declarations redux-async - FSA-compliant promise property middleware for Redux redux-async-queue - Manage queues of thunk actions redux-async-initial-state - Set initial Redux state asynchronously redux-await - Manage async redux actions sanely redux-rx - RxJS utilities for Redux reselect - Selector library for Redux like in NuclearJS react-redux - React bindings for Redux redux-react-router - Redux bindings for React Router – keep your router state inside your Redux store redux-promise-middleware - Redux middleware for resolving and rejecting promises redux-thunk - Thunk middleware for Redux redux-batched-updates - Batch React updates that occur as a result of Redux dispatches, to prevent cascading renders. redux-combine-actions - Redux middleware that allows you to easy combine actions and dispatch them sequentially redux-catch-promise - Extended replacement of redux-thunk middleware to supporting async-await functions and implement server-side rendering for React components with async state redux-delegator - Compose redux reducers in a structured way routex - Simple router for Redux universal applications. Can be used with React too redux-persist-store - Persist and rehydrate a redux store adrenaline - React bindings for Redux with Relay in mind redux-localstorage - Store enhancer that syncs (a subset) of your Redux store state to localstorage. redux-storage - Persistence layer for redux with flexible backends redux-pouchdb - sync store state to pouchdb redux-vstack-router - Helpers to bind vstack-router to redux redux-create-store redux-batched-subscribe - Batch calls to subscribe handlers with a custom function, including debouncing or React batched updates. redux-logger - Logger middleware for Redux redux-node-logger - A Redux Logger for Node Environments redux-diff-logger - Diff logger between states for Redux redux-debug - debug(…) middleware for Redux redux-requests - Avoid issuing duplicate HTTP requests redux-owl - Redux One Way Linking redux-act - An opinionated lib to create actions and reducers for Redux redux-act-async - Reducing boilerplate when creating asynchronous actions in Redux redux-raven-middleware - Redux middleware for sending error reports to Sentry through raven-js redux-routing - Universal routing built on top of redux redux-undo - Simple undo/redo functionality for redux state containers rn-redux-mixpanel - Configurable Redux middleware that sends your actions &amp; user profile data to Mixpanel redux-falcor - Connect your redux front-end to your falcor back-end redux-analytics - Trigger analytics events based on your event metadata redux-ignore - Ignore redux actions by array or filter function redux-recycle - Reset the redux state on certain actions re-notif A notification center based on React &amp; Redux. redux-lunr - Make your redux store searchable with Lunr.js redux-ensure-fsa - Development middleware to check for FSA-compliant actions redux-pagan - internationalization via redux redux-debounce - Debounce your actions! redux-future - FSA-compliant future monad middleware for redux redux-io - FSA-compliant io monad middleware for redux redux-either - FSA-compliant either monad middleware for redux redux-timeout - Trigger actions based on timeouts redux-observable-middleware - Redux middleware for subscribing to observables redux-observable - RxJS 5-based middleware for Redux. Compose and cancel actions as epics. redux-deferred - Redux middleware for jQuery Deferred Object redux-task - A simple Side Effects manager for redux redux-gen - Generator based middleware for redux redux-authentication - Authentication component for Redux socket.io-redux - Redux middleware to emit action via socket.io redux-catch - Error catcher middleware for Redux reducers and middlewares redux-elm-middleware - Elm middleware for redux redux-api-middleware - Redux API middleware based on the real-world example redux-mediaquery - Redux ActionCreator to put responsive-design breakpoints in your store redux-amrc - Redux async middleware and reducer creator redux-fetch-middleware - Redux middleware that help user to treat simple request via fetch api Tools reactotron - Control, monitor, and instrument your React Native apps from the comfort of your TTY redux-test-recorder - Redux test recorder is a redux middleware + included component for automagically generating tests for your reducers based on the actions in your app redux-devtools - DevTools for Redux with hot reloading, action replay, and customizable UI react-router-redux - Ruthlessly simple bindings to keep react-router and redux in sync redux-tiny-router - A Router made for Redux, stop using the router as a controller it’s just state! redux-devtools-gentest-plugin - Generate mocha like tests from redux-devtools session generator-redux - CLI tools for Redux: next-gen functional Flux/React with devtools generator-reactapp - Yeoman generator for react app with redux generator-redux-app - Scaffold out a redux app with counter example and react-router redux-loader - A high order component for Redux. This components loads resources and passes them to the child components via props redux-rest - Automatically create Flux action constants, action creators and Redux reducers for your REST API react-reach - A library to communicate with Graphql through Redux redux-api - Flux REST API for redux infrastructure redux-store-validator - Add validation to your Redux reducers firedux - Firebase + Redux for ReactJS vstack-router - Universal router redux-ecommerce - E-commerce flux with redux redux-form - An ES7 decorator for forms using Redux and React redux-form-validation - Form validation for controlled &amp; uncontrolled inputs simple-redux-form - A tiny redux-form alternative Higher Order Component for forms. redux-slider-monitor - A custom monitor for Redux DevTools to replay recorded Redux actions updeep - Easily update nested frozen objects and arrays in a declarative and immutable manner redux-immutable - Streamlines use of Immutable.js with Redux reducers. redux-import-export-monitor - A monitor for copying your serialized action log to the clipboard, as well as pasting it in from somewhere else icedam - Just-in-time immutability: freezes data sent to views. react-inline-grid - Predictable flexbox based grid for React using Redux and Immutable-js. redux-easy-actions - Sugar library for creating Redux or Flux actions redux-mount - Mount state data and change its state values on the fly redux-multi - Dispatch multiple actions from one action creator immu - A tiny, fail-fast, lazy, immutable Javascript objects library Generate standard action creators and reducers for CRUD applications Redux &amp; ImmutableJs - Integration of Redux &amp; ImmutableJs that 100% conforms Redux standards redux-tcomb - Immutable and type-checked state and actions for Redux redux-react-router-transitions - Attach react-router transitions to arbitrary actions redux-optimist - Optimistically apply actions that can be later commited or reverted. redux-devtools-diff-monitor - Redux DevTools – Diff Monitor redux-store-visualizer - Visualize Redux store in real time generator-redux - CLI tools for Redux: next-gen functional Flux/React with devtools generator-reactapp - Yeoman generator for react app with redux redux-viewmodel - ViewModel wrapping for Redux &amp; React redux-utils - Utility functions for Redux multireducer - A utility to wrap many copies of a single Redux reducer into a single key-based reducer subdivide - User defined UI layout: Every pane can be subdivided and any widget assigned to any pane replux - Self contained components and enhancements for Redux redux-immutable-utils - Utilities for using Immutable with Redux recompose - A microcomponentization toolkit for React redux-lift - Lifting for Redux redux-router5 - router5 integration with Redux redux-devtools-extension - Redux DevTools Extension universal-redux-router - A very simple router for Redux and React that works on both server and client redux-watch - Watch/monitor for state changes on an object path redux-devtools-filterable-log-monitor - Filterable tree view monitor for Redux DevTools redux-flash-notification - A flash notification component for Redux redux-saga - An alternative side effect model for Redux apps remote-redux-devtools - Use Redux DevTools remotely for React Native, hybrid, desktop and server side Redux apps redux-devtools-dispatch - Dispatch your actions manually to test if your app reacts well redux-loop - Sequence your effects naturally and purely by returning them from your reducers redux-orm - A small, simple and immutable ORM to manage data in your Redux store redux-bacon - Utilities for attaching Bacon.js to Redux rereduce - Reducer library for Redux redux-decorators - A ridiculously good syntax for working with Redux and TypeScript. Currently limited to Angular 2 but could potentially be used elsewhere redux-test-reducer - Simple and clean testing mechanism for Redux reducers redux-devtools-inspector - Another Redux DevTools Monitor redux-ava - Helpers for writing Redux tests in AVA redux-cli - An opinionated CLI for building redux/react apps quicker redux-saga-rxjs - RxJS implementation of Saga pattern for redux redux-actions-assertions - Assertions for redux actions testing redux-duck - Helper function to create Redux modules using the ducks-modular-redux proposal redux-dispatch-cli - A CLI tool for Redux remote dispatch. Used in remote-redux-devtools redux-immutable-reducer - Immutable reducer states with Redux redux-bootstrap - configure React + React-Router + Redux + Immutable.js with one function! redux-director - Redux bindings to director router redux-q - Provides a way to queue callbacks until an action is dispatched redux-apist - Creator API actions for redux-thunk reswitch — Write reducers with less boilerplate redux-autoform - Create Redux-Forms dynamically out of metadata redux-ship - Composable, testable and typable side effects Frameworks Jumpsuit - A powerful &amp; efficient React framework. Jump in. Zip up. Build great apps. Jumpstate - Simple and powerful state management for Redux dva - Front-end framework based on react, redux, react-redux, react-router and redux-saga. Vdux - World’s smallest framework. Stateless Virtual DOM &lt;-&gt; Redux Esex - Full-stack Universal JavaScript Framework (Redux+RxJs) Ripster Este - The most complete minimal dev stack / boilerplate for React &amp; Redux universal web apps stardux - Functional DOM containers based on starplate, IncrementalDOM, and redux nux - A Push-Based Functional Reactive Web Application Framework Keo - Plain functions for a more functional Deku approach to creating React components, with functional goodies such as compose, memoize, etc… for free plait - A minimal JavaScript framework for building reactive web components reactuate — A React/Redux stack (not a boilerplate!) with a focus on Domain-Driven Design meatier - Like meteor, but meatier relax - New generation CMS on top of React, Redux and GraphQL lovli.js - A boilerplate for developing react+redux applications with rethinkdb/horizon as realtime database and express for the server kea - Well-readable, self-documenting and easily refactorable framework that brings your data to life! Comes with scaffolding tools :bird: Feeble - A framework built on top of React/Redux/redux-saga which aims to make building React/Redux applications easier and better. Conventional-Redux - A wrapper for react-redux which provides API based on convention over configuration pattern. redux-react-i18n - An i18n solution for redux/react✌🏿✊🏽🤘🏻 Examples Similar libraries flux-ts - A small flux implementation heavily inspired by redux chopped-redux - A very small Flux implementation based on Redux fluxette - Minimalist, functional, and concise Flux rx-redux - A reimplementation of redux using RxJS understate - A simple state manager refer - Redux-like library for handling global state on functional style bobflux - Bobflux is pure functional implementation of FLUX pattern and is fitted to Bobril mobx - Simple, scalable state management Deku - Functional view library for building UI components as an alternative to React Examples Deku + Express + Redux + Crossroads Router deku-redux - Bindings for redux in deku (Standalone plugin)) Incremental DOM - Incremental DOM is a library for building up DOM trees and updating them in-place when data changes Examples Incremental DOM + Redux Flux = Todo App WinJS - Windows Library for JavaScript Examples react-redux-winjs-example Angular - HTML enhanced for web apps Examples Angular + Typescript + Redux ng-redux - Standalone plugin redux-ui-router - ngRedux middleware for Angular UI Router Todo app with ng-redux • ES6 • Webpack https://github.com/InfomediaLtd/angular2-redux-example https://github.com/tomusdrw/angular2-redux-example Angular 2 - One framework. Mobile and desktop Examples angular2-redux-example - Example project for using pure Redux with Angular 2 and TypeScript @angular-redux/store - Angular 2 bindings for Redux angular2-redux - Wrapper components for using Redux in an Angular2 application ng2redux - Angular 2 bindings for Redux implemented with TypeScript and decorators Vue - A library for building modern web interfaces Examples Revue - Redux binding for Vue Vue + Redux Meteor + Vue + Redux Polymer - Build modern apps using web components Examples polymer-redux redux-store-element Ember - A framework for creating ambitious web applications Examples Meteor - Build apps that are a delight to use, faster than you ever thought possible Examples meteor-react-redux-example meteor-flux-leaderboard Mithril - A Javascript Framework for Building Brilliant Applications Examples mithril-redux-starter-hmr Backbone - Give your JS App some Backbone with Models, Views, Collections, and Events Tools backbone-redux — The easy way to keep your backbone collections and redux store in sync Aurelia - is a next gen JavaScript client framework for mobile, desktop and web that leverages simple conventions to empower your creativity Examples aurelia-redux-todo - An implementation of the Redux todo demo app using Aurelia Managing State in Aurelia: How to Use Aurelia with Redux Riot - A React-like user interface micro-library Examples riotredux-budget app-skeleton Electron - Build cross platform desktop apps with web technologies electron-react-boilerplate (Electron + Redux + Hot Reload) A-Frame - A web framework for building VR experiences aframe-redux-component Chrome Extensions Redux Chrome Extension React Chrome Extension Boilerplate (Webpack + Redux + Babel and etc Examples Pumgrana Plugin Ruby on Rails Resources React Webpack Rails Tutorial Using Redux react_on_rails gem Other languages .NET https://github.com/GuillaumeSalles/redux.NET https://github.com/pshomov/reducto Java https://github.com/glung/redux-java https://github.com/trikita/jedux https://github.com/izumin5210/Droidux Swift https://github.com/ReSwift/reduxSwift https://github.com/Swift-Flow/Swift-Flow https://github.com/ReSwift/ReSwift and docs Purescript https://github.com/brakmic/purescript-redux https://github.com/faber/purescript-purdux","categories":[{"name":"Readme","slug":"Readme","permalink":"https://React-Apollo.github.io/categories/Readme/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"},{"name":"react","slug":"react","permalink":"https://React-Apollo.github.io/tags/react/"}]},{"title":"redux-logic","slug":"redux-logic","date":"2017-03-08T00:04:10.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2017/03/08/redux-logic/","link":"","permalink":"https://React-Apollo.github.io/2017/03/08/redux-logic/","excerpt":"","text":"redux-logic “One place for all your business logic and action side effects” Redux middleware that can: intercept (validate/transform/augment) actions AND perform async processing (fetching, I/O, side effects) tl;drWith redux-logic, you have the freedom to write your logic in your favorite JS style: plain callback code - dispatch(resultAction) promises - return axios.get(url).then(...) async/await - result = await fetch(url) observables - ob$.next(action1) Use the type of code you and your team are comfortable and experienced with. Leverage powerful declarative features by simply setting properties: filtering for action type(s) or with regular expression(s) cancellation on receiving action type(s) use only response for the latest request debouncing throttling dispatch actions - auto decoration of payloads Testing your logic is straight forward and simple. With simple code your logic can: intercept actions before they hit the reducer validate, verify, auth check actions and allow/reject or modify actions transform - augment/enhance/modify actions process - async processing and dispatching, orchestration, I/O (ajax, REST, subscriptions, GraphQL, web sockets, …) Redux-logic makes it easy to use code that is split into bundles, so you can dynamically load logic right along with your split UI. Server rendering is simplified with redux-logic since it lets you know when all your async fetching is complete without manual tracking. Inspired by redux-observable epics, redux-saga, and custom redux middleware, redux-logic combines ideas of each into a simple easy to use API. Quick ExampleThis is an example of logic which will listen for actions of type FETCH_POLLS and it will perform ajax request to fetch data for which it dispatches the results (or error) on completion. It supports cancellation by allowing anything to send an action of type CANCEL_FETCH_POLLS. It also uses take latest feature that if additional FETCH_POLLS actions come in before this completes, it will ignore the outdated requests. The developer can just declare the type filtering, cancellation, and take latest behavior, no code needs to be written for that. That leaves the developer to focus on the real business requirements which are invoked in the process hook. 12345678910111213141516171819202122const fetchPollsLogic = createLogic(&#123; // declarative built-in functionality wraps your code type: FETCH_POLLS, // only apply this logic to this type cancelType: CANCEL_FETCH_POLLS, // cancel on this type latest: true, // only take latest // your code here, hook into one or more of these execution // phases: validate, transform, and/or process process(&#123; getState, action &#125;, dispatch, done) &#123; axios.get('https://survey.codewinds.com/polls') .then(resp =&gt; resp.data.polls) .then(polls =&gt; dispatch(&#123; type: FETCH_POLLS_SUCCESS, payload: polls &#125;)) .catch(err =&gt; &#123; console.error(err); // log since could be render err dispatch(&#123; type: FETCH_POLLS_FAILED, payload: err, error: true &#125;) &#125;) .then(() =&gt; done()); // call done when finished dispatching &#125;&#125;); Since redux-logic gives you the freedom to use your favorite style of JS code (callbacks, promises, async/await, observables), it supports many features to make that easier, explained in more detail. Table of contents Goals Usage Full API Examples - JSFiddle and full examples Comparison summaries to fat action creators, thunks, redux-observable, redux-saga, custom middleware SAM/PAL pattern Other - todo, inspiration, license Goals organize business logic keeping action creators and reducers clean action creators are light and just post action objects reducers just focus on updating state intercept and perform validations, verifications, authentication intercept and transform actions perform async processing, orchestration, dispatch actions wrap your core business logic code with declarative behavior filtered - apply to one or many action types or even all actions cancellable - async work can be cancelled limiting (like taking only the latest, throttling, and debouncing) features to support business logic and large apps have access to full state to make decisions easily composable to support large applications inject dependencies into your logic, so you have everything needed in your logic code dynamic loading of logic for splitting bundles in your app your core logic code stays focussed and simple, don’t use generators or observables unless you want to. create subscriptions - streaming updates easy testing - since your code is just a function it’s easy to isolate and test Usage12npm install rxjs --savenpm install redux-logic --save 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// in configureStore.jsimport &#123; createLogic, createLogicMiddleware &#125; from 'redux-logic';import rootReducer from './rootReducer';import arrLogic from './logic';const deps = &#123; // optional injected dependencies for logic // anything you need to have available in your logic A_SECRET_KEY: 'dsfjsdkfjsdlfjls', firebase: firebaseInstance&#125;;const logicMiddleware = createLogicMiddleware(arrLogic, deps);const middleware = applyMiddleware( logicMiddleware);const enhancer = middleware; // could compose in dev tools tooexport default function configureStore() &#123; const store = createStore(rootReducer, enhancer); return store;&#125;// in logic.js - combines logic from across many files, just// a simple array of logic to be used for this appexport default [ ...todoLogic, ...pollsLogic];// in polls/logic.jsconst validationLogic = createLogic(&#123; type: ADD_USER, validate(&#123; getState, action &#125;, allow, reject) &#123; const user = action.payload; if (!getState().users[user.id]) &#123; // can also hit server to check allow(action); &#125; else &#123; reject(&#123; type: USER_EXISTS_ERROR, payload: user, error: true &#125;) &#125; &#125;&#125;);const addUniqueId = createLogic(&#123; type: '*', transform(&#123; getState, action &#125;, next) &#123; // add unique tid to action.meta of every action const existingMeta = action.meta || &#123;&#125;; const meta = &#123; ...existingMeta, tid: shortid.generate() &#125;, next(&#123; ...action, meta &#125;); &#125;&#125;);const fetchPollsLogic = createLogic(&#123; type: FETCH_POLLS, // only apply this logic to this type cancelType: CANCEL_FETCH_POLLS, // cancel on this type latest: true, // only take latest process(&#123; getState, action &#125;, dispatch, done) &#123; axios.get('https://survey.codewinds.com/polls') .then(resp =&gt; resp.data.polls) .then(polls =&gt; dispatch(&#123; type: FETCH_POLLS_SUCCESS, payload: polls &#125;)) .catch(err =&gt; &#123; console.error(err); // log since could be render err dispatch(&#123; type: FETCH_POLLS_FAILED, payload: err, error: true &#125;) &#125;) .then(() =&gt; done()); &#125;&#125;);// pollsLogicexport default [ validationLogic, addUniqueId, fetchPollsLogic]; processOptions introduced for redux-logic@0.8.2 allowing for even more streamlined codeprocessOptions has these new properties which affect the process hook behavior: dispatchReturn - the returned value of the process function will be dispatched or if it is a promise or observable then the resolve, reject, or observable values will be dispatched applying any successType or failType logic if defined. Default is determined by arity of process fn, true if dispatch not provided, false otherwise. Details successType - dispatch this action type using contents of dispatch as the payload (also would work with with promise or observable). You may alternatively provide an action creator function to use instead and it will receive the value as only parameter. Default: undefined. if successType is a string action type create action using successType and provide value as payload. ex: with successType:&#39;FOO&#39;, result would be { type: &#39;FOO&#39;, payload: value } if successType is an action creator fn receiving the value as only parameter use the return value from the action creator fn for dispatching ex: successType: x =&gt; ({ type: &#39;FOO&#39;, payload: x }) if the action creator fn returns a falsey value like undefined then nothing will be dispatched. This allows your action creator to control whether something is actually dispatched based on the value provided to it. failType - dispatch this action type using contents of error as the payload, sets error: true (would also work for rejects of promises or error from observable). You may alternatively provide an action creator function to use instead which will receive the error as the only parameter. Default: undefined. if failType is a string action type create action using failType, provide value as the payload, and set error to true. ex: with failType:&#39;BAR&#39;, result would be { type: &#39;BAR&#39;, payload: errorValue, error: true } if failType is an action creator function receiving the error value as its only parameter use the return value from the action creator fn for dispatching. ex: failType: x =&gt; ({ type: &#39;BAR&#39;, payload: x, error: true }) if the action creator fn returns a falsey value like undefined then nothing will be dispatched. This allows your action creator to control whether something is actually dispatched based on teh value provided to it. The successType and failType would enable clean code, where you can simply return a promise or observable that resolves to the payload and rejects on error. The resulting code doesn’t have to deal with dispatch and actions directly. 12345678910111213141516171819202122232425const fetchPollsLogic = createLogic(&#123; // declarative built-in functionality wraps your code type: FETCH_POLLS, // only apply this logic to this type cancelType: CANCEL_FETCH_POLLS, // cancel on this type latest: true, // only take latest processOptions: &#123; // optional since the default is true when dispatch is omitted from // the process fn signature dispatchReturn: true, // use returned/resolved value(s) for dispatching // provide action types or action creator functions to be used // with the resolved/rejected values from promise/observable returned successType: FETCH_POLLS_SUCCESS, // dispatch this success act type failType: FETCH_POLLS_FAILED, // dispatch this failed action type &#125;, // Omitting dispatch from the signature below makes the default for // dispatchReturn true allowing you to simply return obj, promise, obs // not needing to use dispatch directly process(&#123; getState, action &#125;) &#123; return axios.get('https://survey.codewinds.com/polls') .then(resp =&gt; resp.data.polls); &#125;&#125;); This is pretty nice leaving us with mainly our business logic code that could be easily extracted and called from here. Full APISee the docs for the full api ExamplesJSFiddle live examples search async axios fetch - live search using debounce and take latest functionality with axios fetch search rxjs ajax fetch - live search using debounce and take latest functionality with rxjs ajax fetch search rxjs ajax fetch - using processOptions - live search using debounce and take latest with rxjs ajax fetch using processOptions to streamline the code async axios fetch - single page - displayed using React async rxjs-ajax fetch - async fetching using RxJS ajax which supports XHR abort for cancels async axios fetch - single page redux only - just the redux and redux-logic code async axios fetch - using processOptions - using processOptions to streamline your code further with React async rxjs-ajax fetch - using processOptions - async fetch using RxJS ajax (supporting XHR abort on cancel) and processOptions for clean code. async await - react - using ES7 async functions (async/await) displaying with React async await - redux only - using ES7 async functions (async/await) - just redux and redux-logic code async await - react processOptions - using ES7 async functions (async/await) with processOptions, displayed with React Full examples search-async-fetch - search async fetch example using axios uses debouncing and take latest features async-fetch-vanilla - async fetch example using axios async-rxjs-ajax-fetch - async fetch example using RxJS ajax (supporting XHR abort on cancel) and redux-actions async-fetch-proc-options - async fetch example using axios and the new processOptions feature async-rxjs-ajax-proc-options - async RxJS ajax (with XHR abort on cancel) fetch example using axios and the new processOptions feature async-await - ES7 async functions - async fetch example using axios and ES7 async functions (async/await) async-await - ES7 async functions with processOptions - async fetch example using axios and ES7 async functions (async/await) and using the new processOptions feature countdown - a countdown timer implemented with setInterval countdown-obs - a countdown timer implemented with Rx.Observable.interval form-validation - form validation and async post to server using axios, displays updated user list notification - notification message example showing at most N messages for X amount of time, rotating queued messages in as others expire search-single-file - search async fetch example with all code in a single file and displayed with React single-file-redux - async fetch example with all code in a single file and appended to the container div. Only redux and redux-logic code. Comparison summariesFollowing are just short summaries to compare redux-logic to other approaches. For a more detailed comparison with examples, see by article in docs, Where do I put my business logic in a React-Redux application?. Compared to fat action creators no easy way to cancel or do limiting like take latest with fat action creators action creators would not have access to the full global state so you might have to pass down lots of extra data that isn’t needed for rendering. Every time business logic changes might require new data to be made available no global interception using just action creators - applying logic or transformations across all or many actions Testing components and fat action creators may require running the code (possibly mocked API calls). Compared to redux-thunk With thunks business logic is spread over action creators With thunks there is not an easy way to cancel async work nor to perform (take latest) limiting no global interception with thunks - applying logic or transformations across all or many actions Testing components and thunked action creators may require running the code (possibly mocked API calls). When you have a thunk (function or promise) you don’t know what it does unless you execute it. Compared to redux-observable redux-logic doesn’t require the developer to use rxjs observables. It uses observables under the covers to provide cancellation, throttling, etc. You simply configure these parameters to get this functionality. You can still use rxjs in your code if you want, but not a requirement. redux-logic hooks in before the reducer stack like middleware allowing validation, verification, auth, tranformations. Allow, reject, tranform actions before they hit your reducers to update your state as well as accessing state after reducers have run. redux-observable hooks in after the reducers have updated state so they have no opportuntity to prevent the updates. Compared to redux-saga redux-logic doesn’t require you to code with generators redux-saga relies on pulling data (usually in a never ending loop) while redux-logic and logic are reactive, responding to data as it is available redux-saga runs after reducers have been run, redux-logic can intercept and allow/reject/modify before reducers run also as well as after Compared to custom redux middleware Both are fully featured to do any type of business logic (validations, tranformations, processing) redux-logic already has built-in capabilities for some of the hard stuff like cancellation, limiting, dynamic loading of code. With custom middleware you have to implement all functionality. No safety net, if things break it could stop all of your future actions Testing requires some mocking or setup Implementing SAM/PAL PatternThe SAM (State-Action-Model) pattern is a pattern introduced by Jean-Jacques Dubray. Also known as the PAL (proposer, acceptor, learner) pattern based on Paxos terminology. A few of the challenging parts of implementing this with a React-Redux application are: where to perform the accept (interception) of the proposed action performing validation, verification, authentication against the current model state. Based on the current state, it might be appropriate to modify the action, dispatch a different action, or simply suppress the action. how to trigger actions based on the state after the model has finished updating, referred to as the NAP (next-action-predicate). Custom Redux middleware can be introduced to perform this logic, but you’ll be implementing most everything on your own. With redux-logic you can implement the SAM / PAL pattern easily in your React/Redux apps. Namely you can separate out your business logic from your action creators and reducers keeping them thin. redux-logic provides a nice place to accept, reject, and transform actions before your reducers are run. You have access to the full state to make decisions and you can trigger actions based on the updated state as well. Solving those SAM challenges previously identified using redux-logic: perform acceptance in redux-logic validate hooks, you have access to the full state (model) of the app to make decisions. You can perform synchronous or asynchronous logic to determine whether to accept the action and you may augment, modify, substitute actions, or suppress as desired. Perform NAP processing in redux-logic process hooks. The process hook runs after the actions have been sent down to the reducers so you have access to the full model (state) after the updates where you can make decisions and dispatch additional actions based on the updated state. Inspirationredux-logic was inspired from these projects: redux-observable epics redux-saga redux middleware Minimized/gzipped size with all deps(redux-logic only includes the modules of RxJS 5 that it uses)1redux-logic.min.js.gz 11KB Note: If you are already including RxJS 5 into your project then the resulting delta will be much smaller. TODO add typescript support more docs more examples evaulate additional features as outlined above Get involvedIf you have input or ideas or would like to get involved, you may: contact me via twitter @jeffbski - http://twitter.com/jeffbski open an issue on github to begin a discussion - https://github.com/jeffbski/redux-logic/issues fork the repo and send a pull request (ideally with tests) - https://github.com/jeffbski/redux-logic See the contributing guide SupportersThis project is supported by CodeWinds Training License - MIT MIT license","categories":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/categories/Redux/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://React-Apollo.github.io/tags/Redux/"}]},{"title":"Redux-reselect","slug":"Reselect","date":"2017-03-08T00:04:10.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2017/03/08/Reselect/","link":"","permalink":"https://React-Apollo.github.io/2017/03/08/Reselect/","excerpt":"","text":"Simple “selector” library for Redux inspired by getters in NuclearJS, subscriptions in re-frame and this proposal from speedskater. Selectors can compute derived data, allowing Redux to store the minimal possible state. Selectors are efficient. A selector is not recomputed unless one of its arguments change. Selectors are composable. They can be used as input to other selectors. 1234567891011121314151617181920212223242526272829303132333435import &#123; createSelector &#125; from 'reselect'const shopItemsSelector = state =&gt; state.shop.itemsconst taxPercentSelector = state =&gt; state.shop.taxPercentconst subtotalSelector = createSelector( shopItemsSelector, items =&gt; items.reduce((acc, item) =&gt; acc + item.value, 0))const taxSelector = createSelector( subtotalSelector, taxPercentSelector, (subtotal, taxPercent) =&gt; subtotal * (taxPercent / 100))export const totalSelector = createSelector( subtotalSelector, taxSelector, (subtotal, tax) =&gt; (&#123; total: subtotal + tax &#125;))let exampleState = &#123; shop: &#123; taxPercent: 8, items: [ &#123; name: 'apple', value: 1.20 &#125;, &#123; name: 'orange', value: 0.95 &#125;, ] &#125;&#125;console.log(subtotalSelector(exampleState)) // 2.15console.log(taxSelector(exampleState)) // 0.172console.log(totalSelector(exampleState)) // &#123; total: 2.322 &#125; Table of Contents Installation Example Motivation for Memoized Selectors Creating a Memoized Selector Composing Selectors Connecting a Selector to the Redux Store Accessing React Props in Selectors Sharing Selectors with Props Across Multiple Components API createSelector defaultMemoize createSelectorCreator createStructuredSelector FAQ Why isn’t my selector recomputing when the input state changes? Why is my selector recomputing when the input state stays the same? Can I use Reselect without Redux? The default memoization function is no good, can I use a different one? How do I test a selector? How do I create a selector that takes an argument? How do I use Reselect with Immutable.js? Can I share a selector across multiple components? Are there TypeScript typings? How can I make a curried selector? Related Projects License Installationnpm install reselect ExampleMotivation for Memoized Selectors The examples in this section are based on the Redux Todos List example. containers/VisibleTodoList.js1234567891011121314151617181920212223242526272829303132333435import &#123; connect &#125; from 'react-redux'import &#123; toggleTodo &#125; from '../actions'import TodoList from '../components/TodoList'const getVisibleTodos = (todos, filter) =&gt; &#123; switch (filter) &#123; case 'SHOW_ALL': return todos case 'SHOW_COMPLETED': return todos.filter(t =&gt; t.completed) case 'SHOW_ACTIVE': return todos.filter(t =&gt; !t.completed) &#125;&#125;const mapStateToProps = (state) =&gt; &#123; return &#123; todos: getVisibleTodos(state.todos, state.visibilityFilter) &#125;&#125;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; onTodoClick: (id) =&gt; &#123; dispatch(toggleTodo(id)) &#125; &#125;&#125;const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList)export default VisibleTodoList In the above example, mapStateToProps calls getVisibleTodos to calculate todos. This works great, but there is a drawback: todos is calculated every time the component is updated. If the state tree is large, or the calculation expensive, repeating the calculation on every update may cause performance problems. Reselect can help to avoid these unnecessary recalculations. Creating a Memoized SelectorWe would like to replace getVisibleTodos with a memoized selector that recalculates todos when the value of state.todos or state.visibilityFilter changes, but not when changes occur in other (unrelated) parts of the state tree. Reselect provides a function createSelector for creating memoized selectors. createSelector takes an array of input-selectors and a transform function as its arguments. If the Redux state tree is mutated in a way that causes the value of an input-selector to change, the selector will call its transform function with the values of the input-selectors as arguments and return the result. If the values of the input-selectors are the same as the previous call to the selector, it will return the previously computed value instead of calling the transform function. Let’s define a memoized selector named getVisibleTodos to replace the non-memoized version above: selectors/index.js123456789101112131415161718import &#123; createSelector &#125; from 'reselect'const getVisibilityFilter = (state) =&gt; state.visibilityFilterconst getTodos = (state) =&gt; state.todosexport const getVisibleTodos = createSelector( [ getVisibilityFilter, getTodos ], (visibilityFilter, todos) =&gt; &#123; switch (visibilityFilter) &#123; case 'SHOW_ALL': return todos case 'SHOW_COMPLETED': return todos.filter(t =&gt; t.completed) case 'SHOW_ACTIVE': return todos.filter(t =&gt; !t.completed) &#125; &#125;) In the example above, getVisibilityFilter and getTodos are input-selectors. They are created as ordinary non-memoized selector functions because they do not transform the data they select. getVisibleTodos on the other hand is a memoized selector. It takes getVisibilityFilter and getTodos as input-selectors, and a transform function that calculates the filtered todos list. Composing SelectorsA memoized selector can itself be an input-selector to another memoized selector. Here is getVisibleTodos being used as an input-selector to a selector that further filters the todos by keyword: 12345678const getKeyword = (state) =&gt; state.keywordconst getVisibleTodosFilteredByKeyword = createSelector( [ getVisibleTodos, getKeyword ], (visibleTodos, keyword) =&gt; visibleTodos.filter( todo =&gt; todo.text.indexOf(keyword) &gt; -1 )) Connecting a Selector to the Redux StoreIf you are using React Redux, you can call selectors as regular functions inside mapStateToProps(): containers/VisibleTodoList.js12345678910111213141516171819202122232425import &#123; connect &#125; from 'react-redux'import &#123; toggleTodo &#125; from '../actions'import TodoList from '../components/TodoList'import &#123; getVisibleTodos &#125; from '../selectors'const mapStateToProps = (state) =&gt; &#123; return &#123; todos: getVisibleTodos(state) &#125;&#125;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; onTodoClick: (id) =&gt; &#123; dispatch(toggleTodo(id)) &#125; &#125;&#125;const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList)export default VisibleTodoList Accessing React Props in Selectors This section introduces a hypothetical extension to our app that allows it to support multiple Todo Lists. Please note that a full implementation of this extension requires changes to the reducers, components, actions etc. that aren’t directly relevant to the topics discussed and have been omitted for brevity. So far we have only seen selectors receive the Redux store state as an argument, but a selector can receive props too. Here is an App component that renders three VisibleTodoList components, each of which has a listId prop: components/App.js123456789101112import React from 'react'import Footer from './Footer'import AddTodo from '../containers/AddTodo'import VisibleTodoList from '../containers/VisibleTodoList'const App = () =&gt; ( &lt;div&gt; &lt;VisibleTodoList listId=\"1\" /&gt; &lt;VisibleTodoList listId=\"2\" /&gt; &lt;VisibleTodoList listId=\"3\" /&gt; &lt;/div&gt;) Each VisibleTodoList container should select a different slice of the state depending on the value of the listId prop, so let’s modify getVisibilityFilter and getTodos to accept a props argument: selectors/todoSelectors.js1234567891011121314151617181920212223import &#123; createSelector &#125; from 'reselect'const getVisibilityFilter = (state, props) =&gt; state.todoLists[props.listId].visibilityFilterconst getTodos = (state, props) =&gt; state.todoLists[props.listId].todosconst getVisibleTodos = createSelector( [ getVisibilityFilter, getTodos ], (visibilityFilter, todos) =&gt; &#123; switch (visibilityFilter) &#123; case 'SHOW_COMPLETED': return todos.filter(todo =&gt; todo.completed) case 'SHOW_ACTIVE': return todos.filter(todo =&gt; !todo.completed) default: return todos &#125; &#125;)export default getVisibleTodos props can be passed to getVisibleTodos from mapStateToProps: 12345const mapStateToProps = (state, props) =&gt; &#123; return &#123; todos: getVisibleTodos(state, props) &#125;&#125; So now getVisibleTodos has access to props, and everything seems to be working fine. But there is a problem! Using the getVisibleTodos selector with multiple instances of the VisibleTodoList container will not correctly memoize: containers/VisibleTodoList.js1234567891011121314151617181920212223242526import &#123; connect &#125; from 'react-redux'import &#123; toggleTodo &#125; from '../actions'import TodoList from '../components/TodoList'import &#123; getVisibleTodos &#125; from '../selectors'const mapStateToProps = (state, props) =&gt; &#123; return &#123; // WARNING: THE FOLLOWING SELECTOR DOES NOT CORRECTLY MEMOIZE todos: getVisibleTodos(state, props) &#125;&#125;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; onTodoClick: (id) =&gt; &#123; dispatch(toggleTodo(id)) &#125; &#125;&#125;const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList)export default VisibleTodoList A selector created with createSelector only returns the cached value when its set of arguments is the same as its previous set of arguments. If we alternate between rendering &lt;VisibleTodoList listId=&quot;1&quot; /&gt; and &lt;VisibleTodoList listId=&quot;2&quot; /&gt;, the shared selector will alternate between receiving {listId: 1} and {listId: 2} as its props argument. This will cause the arguments to be different on each call, so the selector will always recompute instead of returning the cached value. We’ll see how to overcome this limitation in the next section. Sharing Selectors with Props Across Multiple Components The examples in this section require React Redux v4.3.0 or greater To share a selector across multiple VisibleTodoList components while passing in props and retaining memoization, each instance of the component needs its own private copy of the selector. Let’s create a function named makeGetVisibleTodos that returns a new copy of the getVisibleTodos selector each time it is called: selectors/todoSelectors.js12345678910111213141516171819202122232425import &#123; createSelector &#125; from 'reselect'const getVisibilityFilter = (state, props) =&gt; state.todoLists[props.listId].visibilityFilterconst getTodos = (state, props) =&gt; state.todoLists[props.listId].todosconst makeGetVisibleTodos = () =&gt; &#123; return createSelector( [ getVisibilityFilter, getTodos ], (visibilityFilter, todos) =&gt; &#123; switch (visibilityFilter) &#123; case 'SHOW_COMPLETED': return todos.filter(todo =&gt; todo.completed) case 'SHOW_ACTIVE': return todos.filter(todo =&gt; !todo.completed) default: return todos &#125; &#125; )&#125;export default makeGetVisibleTodos We also need a way to give each instance of a container access to its own private selector. The mapStateToProps argument of connect can help with this. If the mapStateToProps argument supplied to connect returns a function instead of an object, it will be used to create an individual mapStateToProps function for each instance of the container. In the example below makeMapStateToProps creates a new getVisibleTodos selector, and returns a mapStateToProps function that has exclusive access to the new selector: 123456789const makeMapStateToProps = () =&gt; &#123; const getVisibleTodos = makeGetVisibleTodos() const mapStateToProps = (state, props) =&gt; &#123; return &#123; todos: getVisibleTodos(state, props) &#125; &#125; return mapStateToProps&#125; If we pass makeMapStateToProps to connect, each instance of the VisibleTodosList container will get its own mapStateToProps function with a private getVisibleTodos selector. Memoization will now work correctly regardless of the render order of the VisibleTodoList containers. containers/VisibleTodoList.js1234567891011121314151617181920212223242526272829import &#123; connect &#125; from 'react-redux'import &#123; toggleTodo &#125; from '../actions'import TodoList from '../components/TodoList'import &#123; makeGetVisibleTodos &#125; from '../selectors'const makeMapStateToProps = () =&gt; &#123; const getVisibleTodos = makeGetVisibleTodos() const mapStateToProps = (state, props) =&gt; &#123; return &#123; todos: getVisibleTodos(state, props) &#125; &#125; return mapStateToProps&#125;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; onTodoClick: (id) =&gt; &#123; dispatch(toggleTodo(id)) &#125; &#125;&#125;const VisibleTodoList = connect( makeMapStateToProps, mapDispatchToProps)(TodoList)export default VisibleTodoList APIcreateSelector(…inputSelectors | [inputSelectors], resultFunc)Takes one or more selectors, or an array of selectors, computes their values and passes them as arguments to resultFunc. createSelector determines if the value returned by an input-selector has changed between calls using reference equality (===). Inputs to selectors created with createSelector should be immutable. Selectors created with createSelector have a cache size of 1. This means they always recalculate when the value of an input-selector changes, as a selector only stores the preceding value of each input-selector. 1234567891011121314const mySelector = createSelector( state =&gt; state.values.value1, state =&gt; state.values.value2, (value1, value2) =&gt; value1 + value2)// You can also pass an array of selectorsconst totalSelector = createSelector( [ state =&gt; state.values.value1, state =&gt; state.values.value2 ], (value1, value2) =&gt; value1 + value2) It can be useful to access the props of a component from within a selector. When a selector is connected to a component with connect, the component props are passed as the second argument to the selector: 12345678910111213141516const abSelector = (state, props) =&gt; state.a * props.b// props only (ignoring state argument)const cSelector = (_, props) =&gt; props.c// state only (props argument omitted as not required)const dSelector = state =&gt; state.dconst totalSelector = createSelector( abSelector, cSelector, dSelector, (ab, c, d) =&gt; (&#123; total: ab + c + d &#125;)) defaultMemoize(func, equalityCheck = defaultEqualityCheck)defaultMemoize memoizes the function passed in the func parameter. It is the memoize function used by createSelector. defaultMemoize has a cache size of 1. This means it always recalculates when the value of an argument changes. defaultMemoize determines if an argument has changed by calling the equalityCheck function. As defaultMemoize is designed to be used with immutable data, the default equalityCheck function checks for changes using reference equality: 123function defaultEqualityCheck(currentVal, previousVal) &#123; return currentVal === previousVal&#125; defaultMemoize can be used with createSelectorCreator to customize the equalityCheck function. createSelectorCreator(memoize, …memoizeOptions)createSelectorCreator can be used to make a customized version of createSelector. The memoize argument is a memoization function to replace defaultMemoize. The ...memoizeOptions rest parameters are zero or more configuration options to be passed to memoizeFunc. The selectors resultFunc is passed as the first argument to memoize and the memoizeOptions are passed as the second argument onwards: 123456789101112const customSelectorCreator = createSelectorCreator( customMemoize, // function to be used to memoize resultFunc option1, // option1 will be passed as second argument to customMemoize option2, // option2 will be passed as third argument to customMemoize option3 // option3 will be passed as fourth argument to customMemoize)const customSelector = customSelectorCreator( input1, input2, resultFunc // resultFunc will be passed as first argument to customMemoize) Internally customSelector calls the memoize function as follows: 1customMemoize(resultFunc, option1, option2, option3) Here are some examples of how you might use createSelectorCreator: Customize equalityCheck for defaultMemoize1234567891011121314import &#123; createSelectorCreator, defaultMemoize &#125; from 'reselect'import isEqual from 'lodash.isEqual'// create a \"selector creator\" that uses lodash.isEqual instead of ===const createDeepEqualSelector = createSelectorCreator( defaultMemoize, isEqual)// use the new \"selector creator\" to create a selectorconst mySelector = createDeepEqualSelector( state =&gt; state.values.filter(val =&gt; val &lt; 5), values =&gt; values.reduce((acc, val) =&gt; acc + val, 0)) Use memoize function from lodash for an unbounded cache1234567891011121314151617import &#123; createSelectorCreator &#125; from 'reselect'import memoize from 'lodash.memoize'let called = 0const hashFn = (...args) =&gt; args.reduce( (acc, val) =&gt; acc + '-' + JSON.stringify(val), '')const customSelectorCreator = createSelectorCreator(memoize, hashFn)const selector = customSelectorCreator( state =&gt; state.a, state =&gt; state.b, (a, b) =&gt; &#123; called++ return a + b &#125;) createStructuredSelector({inputSelectors}, selectorCreator = createSelector)createStructuredSelector is a convenience function for a common pattern that arises when using Reselect. The selector passed to a connect decorator often just takes the values of its input-selectors and maps them to keys in an object: 123456789101112131415const mySelectorA = state =&gt; state.aconst mySelectorB = state =&gt; state.b// The result function in the following selector// is simply building an object from the input selectorsconst structuredSelector = createSelector( mySelectorA, mySelectorB, mySelectorC, (a, b, c) =&gt; (&#123; a, b, c &#125;)) createStructuredSelector takes an object whose properties are input-selectors and returns a structured selector. The structured selector returns an object with the same keys as the inputSelectors argument, but with the selectors replaced with their values. 123456789const mySelectorA = state =&gt; state.aconst mySelectorB = state =&gt; state.bconst structuredSelector = createStructuredSelector(&#123; x: mySelectorA, y: mySelectorB&#125;)const result = structuredSelector(&#123; a: 1, b: 2 &#125;) // will produce &#123; x: 1, y: 2 &#125; Structured selectors can be nested: 12345678910const nestedSelector = createStructuredSelector(&#123; subA: createStructuredSelector(&#123; selectorA, selectorB &#125;), subB: createStructuredSelector(&#123; selectorC, selectorD &#125;)&#125;) FAQQ: Why isn’t my selector recomputing when the input state changes?A: Check that your memoization function is compatible with your state update function (i.e. the reducer if you are using Redux). For example, a selector created with createSelector will not work with a state update function that mutates an existing object instead of creating a new one each time. createSelector uses an identity check (===) to detect that an input has changed, so mutating an existing object will not trigger the selector to recompute because mutating an object does not change its identity. Note that if you are using Redux, mutating the state object is almost certainly a mistake. The following example defines a simple selector that determines if the first todo item in an array of todos has been completed: 1234const isFirstTodoCompleteSelector = createSelector( state =&gt; state.todos[0], todo =&gt; todo &amp;&amp; todo.completed) The following state update function will not work with isFirstTodoCompleteSelector: 1234567891011121314export default function todos(state = initialState, action) &#123; switch (action.type) &#123; case COMPLETE_ALL: const areAllMarked = state.every(todo =&gt; todo.completed) // BAD: mutating an existing object return state.map(todo =&gt; &#123; todo.completed = !areAllMarked return todo &#125;) default: return state &#125;&#125; The following state update function will work with isFirstTodoCompleteSelector: 12345678910111213export default function todos(state = initialState, action) &#123; switch (action.type) &#123; case COMPLETE_ALL: const areAllMarked = state.every(todo =&gt; todo.completed) // GOOD: returning a new object each time with Object.assign return state.map(todo =&gt; Object.assign(&#123;&#125;, todo, &#123; completed: !areAllMarked &#125;)) default: return state &#125;&#125; If you are not using Redux and have a requirement to work with mutable data, you can use createSelectorCreator to replace the default memoization function and/or use a different equality check function. See here and here for examples. Q: Why is my selector recomputing when the input state stays the same?A: Check that your memoization function is compatible with your state update function (i.e. the reducer if you are using Redux). For example, a selector created with createSelector that recomputes unexpectedly may be receiving a new object on each update whether the values it contains have changed or not. createSelector uses an identity check (===) to detect that an input has changed, so returning a new object on each update means that the selector will recompute on each update. 123456789101112131415161718192021import &#123; REMOVE_OLD &#125; from '../constants/ActionTypes'const initialState = [ &#123; text: 'Use Redux', completed: false, id: 0, timestamp: Date.now() &#125;]export default function todos(state = initialState, action) &#123; switch (action.type) &#123; case REMOVE_OLD: return state.filter(todo =&gt; &#123; return todo.timestamp + 30 * 24 * 60 * 60 * 1000 &gt; Date.now() &#125;) default: return state &#125;&#125; The following selector is going to recompute every time REMOVE_OLD is invoked because Array.filter always returns a new object. However, in the majority of cases the REMOVE_OLD action will not change the list of todos so the recomputation is unnecessary. 12345678910import &#123; createSelector &#125; from 'reselect'const todosSelector = state =&gt; state.todosexport const visibleTodosSelector = createSelector( todosSelector, (todos) =&gt; &#123; ... &#125;) You can eliminate unnecessary recomputations by returning a new object from the state update function only when a deep equality check has found that the list of todos has actually changed: 1234567891011121314151617181920212223import &#123; REMOVE_OLD &#125; from '../constants/ActionTypes'import isEqual from 'lodash.isEqual'const initialState = [ &#123; text: 'Use Redux', completed: false, id: 0, timestamp: Date.now() &#125;]export default function todos(state = initialState, action) &#123; switch (action.type) &#123; case REMOVE_OLD: const updatedState = state.filter(todo =&gt; &#123; return todo.timestamp + 30 * 24 * 60 * 60 * 1000 &gt; Date.now() &#125;) return isEqual(updatedState, state) ? state : updatedState default: return state &#125;&#125; Alternatively, the default equalityCheck function in the selector can be replaced by a deep equality check: 123456789101112131415161718import &#123; createSelectorCreator, defaultMemoize &#125; from 'reselect'import isEqual from 'lodash.isEqual'const todosSelector = state =&gt; state.todos// create a \"selector creator\" that uses lodash.isEqual instead of ===const createDeepEqualSelector = createSelectorCreator( defaultMemoize, isEqual)// use the new \"selector creator\" to create a selectorconst mySelector = createDeepEqualSelector( todosSelector, (todos) =&gt; &#123; ... &#125;) Always check that the cost of an alternative equalityCheck function or deep equality check in the state update function is not greater than the cost of recomputing every time. If recomputing every time does work out to be the cheaper option, it may be that for this case Reselect is not giving you any benefit over passing a plain mapStateToProps function to connect. Q: Can I use Reselect without Redux?A: Yes. Reselect has no dependencies on any other package, so although it was designed to be used with Redux it can be used independently. It is currently being used successfully in traditional Flux apps. If you create selectors using createSelector make sure its arguments are immutable.See here Q: How do I create a selector that takes an argument?A: Reselect doesn’t have built-in support for creating selectors that accepts arguments, but here are some suggestions for implementing similar functionality… If the argument is not dynamic you can use a factory function: 1234567891011const expensiveItemSelectorFactory = minValue =&gt; &#123; return createSelector( shopItemsSelector, items =&gt; items.filter(item =&gt; item.value &gt; minValue) )&#125;const subtotalSelector = createSelector( expensiveItemSelectorFactory(200), items =&gt; items.reduce((acc, item) =&gt; acc + item.value, 0)) The general consensus here and over at nuclear-js is that if a selector needs a dynamic argument, then that argument should probably be state in the store. If you decide that you do require a selector with a dynamic argument, then a selector that returns a memoized function may be suitable: 1234567891011121314import &#123; createSelector &#125; from 'reselect'import memoize from 'lodash.memoize'const expensiveSelector = createSelector( state =&gt; state.items, items =&gt; memoize( minValue =&gt; items.filter(item =&gt; item.value &gt; minValue) ))const expensiveFilter = expensiveSelector(state)const slightlyExpensive = expensiveFilter(100)const veryExpensive = expensiveFilter(1000000) Q: The default memoization function is no good, can I use a different one?A: We think it works great for a lot of use cases, but sure. See these examples. Q: How do I test a selector?A: For a given input, a selector should always produce the same output. For this reason they are simple to unit test. 12345678910111213const selector = createSelector( state =&gt; state.a, state =&gt; state.b, (a, b) =&gt; (&#123; c: a * 2, d: b * 3 &#125;))test(\"selector unit test\", () =&gt; &#123; assert.deepEqual(selector(&#123; a: 1, b: 2 &#125;), &#123; c: 2, d: 6 &#125;) assert.deepEqual(selector(&#123; a: 2, b: 3 &#125;), &#123; c: 4, d: 9 &#125;)&#125;) It may also be useful to check that the memoization function for a selector works correctly with the state update function (i.e. the reducer if you are using Redux). Each selector has a recomputations method that will return the number of times it has been recomputed: 123456789101112131415161718192021222324252627282930313233suite('selector', () =&gt; &#123; let state = &#123; a: 1, b: 2 &#125; const reducer = (state, action) =&gt; ( &#123; a: action(state.a), b: action(state.b) &#125; ) const selector = createSelector( state =&gt; state.a, state =&gt; state.b, (a, b) =&gt; (&#123; c: a * 2, d: b * 3 &#125;) ) const plusOne = x =&gt; x + 1 const id = x =&gt; x test(\"selector unit test\", () =&gt; &#123; state = reducer(state, plusOne) assert.deepEqual(selector(state), &#123; c: 4, d: 9 &#125;) state = reducer(state, id) assert.deepEqual(selector(state), &#123; c: 4, d: 9 &#125;) assert.equal(selector.recomputations(), 1) state = reducer(state, plusOne) assert.deepEqual(selector(state), &#123; c: 6, d: 12 &#125;) assert.equal(selector.recomputations(), 2) &#125;)&#125;) Additionally, selectors keep a reference to the last result function as .resultFunc. If you have selectors composed of many other selectors this can help you test each selector without coupling all of your tests to the shape of your state. For example if you have a set of selectors like this: selectors.js12345678910export const firstSelector = createSelector( ... )export const secondSelector = createSelector( ... )export const thirdSelector = createSelector( ... )export const myComposedSelector = createSelector( firstSelector, secondSelector, thirdSelector, (first, second, third) =&gt; first * second &lt; third) And then a set of unit tests like this: test/selectors.js 1234567891011121314// tests for the first three selectors...test(\"firstSelector unit test\", () =&gt; &#123; ... &#125;)test(\"secondSelector unit test\", () =&gt; &#123; ... &#125;)test(\"thirdSelector unit test\", () =&gt; &#123; ... &#125;)// We have already tested the previous// three selector outputs so we can just call `.resultFunc`// with the values we want to test directly:test(\"myComposedSelector unit test\", () =&gt; &#123; // here instead of calling selector() // we just call selector.resultFunc() assert(selector.resultFunc(1, 2, 3), true) assert(selector.resultFunc(2, 2, 1), false)&#125;) Finally, each selector has a resetRecomputations method that setsrecomputations back to 0. The intended use is for a complex selector that mayhave many independent tests and you don’t want to manually manage thecomputation count or create a “dummy” selector for each test. Q: How do I use Reselect with Immutable.js?A: Selectors created with createSelector should work just fine with Immutable.js data structures. If your selector is recomputing and you don’t think the state has changed, make sure you are aware of which Immutable.js update methods always return a new object and which update methods only return a new object when the collection actually changes. 12345678910111213141516import Immutable from 'immutable'let myMap = Immutable.Map(&#123; a: 1, b: 2, c: 3&#125;) // set, merge and others only return a new obj when update changes collectionlet newMap = myMap.set('a', 1)assert.equal(myMap, newMap)newMap = myMap.merge(&#123; 'a', 1 &#125;)assert.equal(myMap, newMap)// map, reduce, filter and others always return a new objnewMap = myMap.map(a =&gt; a * 1)assert.notEqual(myMap, newMap) If a selector’s input is updated by an operation that always returns a new object, it may be performing unnecessary recomputations. See here for a discussion on the pros and cons of using a deep equality check like Immutable.is to eliminate unnecessary recomputations. Q: Can I share a selector across multiple components?A: Selectors created using createSelector only have a cache size of one. This can make them unsuitable for sharing across multiple components if the arguments to the selector are different for each instance of the component. There are a couple of ways to get around this: Create a factory function which returns a new selector for each instance of the component. There is built-in support for factory functions in React Redux v4.3 or higher. See here for an example. Create a custom selector with a cache size greater than one. Q: Are there TypeScript Typings?A: Yes! They are included and referenced in package.json. They should Just Work™. Q: How can I make a curried selector?A: Try these helper functions courtesy of MattSPalmer Related Projects###reselect-map Can be useful when doing very expensive computations on elements of a collection because Reselect might not give you the granularity of caching that you need. Check out the reselect-maps README for examples. The optimizations in reselect-map only apply in a small number of cases. If you are unsure whether you need it, you don’t! LicenseMIT","categories":[{"name":"翻译","slug":"翻译","permalink":"https://React-Apollo.github.io/categories/翻译/"}],"tags":[]},{"title":"CheatSheet|React Native Styling Cheat Sheet","slug":"React Native Styling Cheat Sheet","date":"2017-01-28T08:17:07.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2017/01/28/React Native Styling Cheat Sheet/","link":"","permalink":"https://React-Apollo.github.io/2017/01/28/React Native Styling Cheat Sheet/","excerpt":"","text":"React Native Styling Cheat SheetMost of the React Native styling material in one page. Imported from the official docs. ContentsGeneral Flexbox ShadowPropTypesIOS Transforms Components Image ScrollView Text View Flexbox Name Type Description alignItems oneOf flex-start, flex-end, center, stretch alignItems aligns children in the cross direction. For example, if children are flowing vertically, alignItems controls how they align horizontally. It works like align-items in CSS, except the default value is stretch instead of flex-start. See https://css-tricks.com/almanac/properties/a/align-items/ for more detail. alignSelf oneOf auto, flex-start, flex-end, center, stretch controls how a child aligns in the cross direction, overriding the alignItems of the parent. It works like align-self in CSS. See https://css-tricks.com/almanac/properties/a/align-self/ for more detail. borderBottomWidth number borderBottomWidth works like border-bottom-width in CSS. See http://www.w3schools.com/cssref/pr_border-bottom_width.asp for more details. borderLeftWidth number borderLeftWidth works like border-left-width in CSS. See http://www.w3schools.com/cssref/pr_border-bottom_width.asp for more details. borderRightWidth number borderRightWidth works like border-right-width in CSS. See http://www.w3schools.com/cssref/pr_border-right_width.asp for more details. borderTopWidth number borderTopWidth works like border-top-width in CSS. See http://www.w3schools.com/cssref/pr_border-top_width.asp for more details. borderWidth number borderWidth works like border-width in CSS. See http://www.w3schools.com/cssref/pr_border-width.asp for more details. bottom number bottom is the number of logical pixels to offset the bottom edge of this component. It works similarly to bottom in CSS, but in React Native you must use logical pixel units, rather than percents, ems, or any of that. See https://developer.mozilla.org/en-US/docs/Web/CSS/bottom for more details of how top affects layout. flex number In React Native flex does not work the same way that it does in CSS. flex is a number rather than a string, and it works according to the css-layout library at https://github.com/facebook/css-layout . When flex is a positive number, it makes the component flexible and it will be sized proportional to its flex value. So a component with flex set to 2 will take twice the space as a component with flex set to 1. When flex is 0, the component is sized according to width and height and it is inflexible. When flex is -1, the component is normally sized according width and height. However, if there’s not enough space, the component will shrink to its minWidth and minHeight. flexDirection oneOf row, row-reverse, column, column-reverse flexDirection controls which directions children of a container go. row goes left to right, column goes top to bottom, and you may be able to guess what the other two do. It works like flex-direction in CSS, except the default is column. See https://css-tricks.com/almanac/properties/f/flex-direction/ for more detail. flexWrap oneOf wrap, nowrap flexWrap controls whether children can wrap around after they hit the end of a flex container. It works like flex-wrap in CSS. See https://css-tricks.com/almanac/properties/f/flex-wrap/ for more detail. height number height sets the height of this component. It works similarly to height in CSS, but in React Native you must use logical pixel units, rather than percents, ems, or any of that. See http://www.w3schools.com/cssref/pr_dim_width.asp for more details. justifyContent oneOf flex-start, flex-end, center, space-between, space-around justifyContent aligns children in the main direction. For example, if children are flowing vertically, justifyContent controls how they align vertically. It works like justify-content in CSS. See https://css-tricks.com/almanac/properties/j/justify-content/ for more detail. left number left is the number of logical pixels to offset the left edge of this component. It works similarly to left in CSS, but in React Native you must use logical pixel units, rather than percents, ems, or any of that. See https://developer.mozilla.org/en-US/docs/Web/CSS/left for more details of how left affects layout. margin number Setting margin has the same effect as setting each of marginTop, marginLeft, marginBottom, and marginRight. marginBottom number marginBottom works like margin-bottom in CSS. See http://www.w3schools.com/cssref/pr_margin-bottom.asp for more details. marginHorizontal number Setting marginHorizontal has the same effect as setting both marginLeft and marginRight. marginLeft number marginLeft works like margin-left in CSS. See http://www.w3schools.com/cssref/pr_margin-left.asp for more details. marginRight number marginRight works like margin-right in CSS. See http://www.w3schools.com/cssref/pr_margin-right.asp for more details. marginTop number marginTop works like margin-top in CSS. See http://www.w3schools.com/cssref/pr_margin-top.asp for more details. marginVertical number Setting marginVertical has the same effect as setting both marginTop and marginBottom. maxHeight number maxHeight is the maximum height for this component, in logical pixels. It works similarly to max-height in CSS, but in React Native you must use logical pixel units, rather than percents, ems, or any of that. See http://www.w3schools.com/cssref/pr_dim_max-height.asp for more details. maxWidth number maxWidth is the maximum width for this component, in logical pixels. It works similarly to max-width in CSS, but in React Native you must use logical pixel units, rather than percents, ems, or any of that. See http://www.w3schools.com/cssref/pr_dim_max-width.asp for more details. minHeight number minHeight is the minimum height for this component, in logical pixels. It works similarly to min-height in CSS, but in React Native you must use logical pixel units, rather than percents, ems, or any of that. See http://www.w3schools.com/cssref/pr_dim_min-height.asp for more details. minWidth number minWidth is the minimum width for this component, in logical pixels. It works similarly to min-width in CSS, but in React Native you must use logical pixel units, rather than percents, ems, or any of that. See http://www.w3schools.com/cssref/pr_dim_min-width.asp for more details. padding number padding works like padding in CSS. It’s like setting each of paddingTop, paddingBottom, paddingLeft, and paddingRight to the same thing. See http://www.w3schools.com/css/css_padding.asp for more details. paddingBottom number paddingBottom works like padding-bottom in CSS. See http://www.w3schools.com/cssref/pr_padding-bottom.asp for more details. paddingHorizontal number Setting paddingHorizontal is like setting both of paddingLeft and paddingRight. paddingLeft number paddingLeft works like padding-left in CSS. See http://www.w3schools.com/cssref/pr_padding-left.asp for more details. paddingRight number paddingRight works like padding-right in CSS. See http://www.w3schools.com/cssref/pr_padding-right.asp for more details. paddingTop number paddingTop works like padding-top in CSS. See http://www.w3schools.com/cssref/pr_padding-top.asp for more details. paddingVertical number Setting paddingVertical is like setting both of paddingTop and paddingBottom. position oneOf absolute, relative position in React Native is similar to regular CSS, but everything is set to relative by default, so absolute positioning is always just relative to the parent. If you want to position a child using specific numbers of logical pixels relative to its parent, set the child to have absolute position. If you want to position a child relative to something that is not its parent, just don’t use styles for that. Use the component tree. See https://github.com/facebook/css-layout for more details on how position differs between React Native and CSS. right number right is the number of logical pixels to offset the right edge of this component. It works similarly to right in CSS, but in React Native you must use logical pixel units, rather than percents, ems, or any of that. See https://developer.mozilla.org/en-US/docs/Web/CSS/right for more details of how right affects layout. top number top is the number of logical pixels to offset the top edge of this component. It works similarly to top in CSS, but in React Native you must use logical pixel units, rather than percents, ems, or any of that. See https://developer.mozilla.org/en-US/docs/Web/CSS/top for more details of how top affects layout. width number width sets the width of this component. It works similarly to width in CSS, but in React Native you must use logical pixel units, rather than percents, ems, or any of that. See http://www.w3schools.com/cssref/pr_dim_width.asp for more details. zIndex number zIndex controls which components display on top of others. Normally, you don’t use zIndex. Components render according to their order in the document tree, so later components draw over earlier ones. zIndex may be useful if you have animations or custom modal interfaces where you don’t want this behavior. It works like the CSS z-index property - components with a larger zIndex will render on top. Think of the z-direction like it’s pointing from the phone into your eyeball. See https://developer.mozilla.org/en-US/docs/Web/CSS/z-index for more detail. Shadow Prop Types IOS Name Type Description shadowColor customColorPropType Sets the drop shadow color shadowOffset customReactPropTypes.shape( {width: ReactPropTypes.number, height: ReactPropTypes.number} ) Sets the drop shadow offset shadowOpacity number Sets the drop shadow opacity (multiplied by the color’s alpha component) shadowRadius number Sets the drop shadow blur radius Transforms Name Type decomposedMatrix customDecomposedMatrixPropType transform customReactPropTypes.arrayOf( ReactPropTypes.oneOfType([ ReactPropTypes.shape({perspective: ReactPropTypes.number}), ReactPropTypes.shape({rotate: ReactPropTypes.string}), ReactPropTypes.shape({rotateX: ReactPropTypes.string}), ReactPropTypes.shape({rotateY: ReactPropTypes.string}), ReactPropTypes.shape({rotateZ: ReactPropTypes.string}), ReactPropTypes.shape({scale: ReactPropTypes.number}), ReactPropTypes.shape({scaleX: ReactPropTypes.number}), ReactPropTypes.shape({scaleY: ReactPropTypes.number}), ReactPropTypes.shape({translateX: ReactPropTypes.number}), ReactPropTypes.shape({translateY: ReactPropTypes.number}), ReactPropTypes.shape({skewX: ReactPropTypes.string}), ReactPropTypes.shape({skewY: ReactPropTypes.string}) ]) ) transformMatrix customTransformMatrixPropType Image Name Required Type Platforms Description …Flexbox …ShadowPropTypesIOS …Transforms backfaceVisibility false oneOf visible, hidden backgroundColor false ColorPropType borderBottomLeftRadius false number borderBottomRightRadius false number borderColor false ColorPropType borderRadius false number borderTopLeftRadius false number borderTopRightRadius false number borderWidth false number opacity false number overflow false oneOf visible, hidden resizeMode false oneOf Object.keys(ImageResizeMode)) tintColor false ColorPropType Changes the color of all the non-transparent pixels to the tintColor. overlayColor false string android When the image has rounded corners, specifying an overlayColor will cause the remaining space in the corners to be filled with a solid color. This is useful in cases which are not supported by the Android implementation of rounded corners: - Certain resize modes, such as ‘contain’ - Animated GIFs A typical way to use this prop is with images displayed on a solid background and setting the overlayColor to the same color as the background. For details of how this works under the hood, see http://frescolib.org/docs/rounded-corners-and-circles.html ScrollView Name Required Type Platforms Description …Flexbox …ShadowPropTypesIOS …Transforms backfaceVisibility false oneOf visible, hidden backgroundColor false ColorPropType borderBottomColor false ColorPropType borderBottomLeftRadius false number borderBottomRightRadius false number borderBottomWidth false number borderColor false ColorPropType borderLeftColor false ColorPropType borderLeftWidth false number borderRadius false number borderRightColor false ColorPropType borderRightWidth false number borderStyle false oneOf solid, dotted, dashed borderTopColor false ColorPropType borderTopLeftRadius false number borderTopRightRadius false number borderTopWidth false number borderWidth false number opacity false number overflow false oneOf visible, hidden elevation false number android (Android-only) Sets the elevation of a view, using Android’s underlying elevation API. This adds a drop shadow to the item and affects z-order for overlapping views. Only supported on Android 5.0+, has no effect on earlier versions. Text Name Required Type Platforms Description …View color false ColorPropType fontFamily false string fontSize false number fontStyle false oneOf normal, italic fontWeight false oneOf normal, bold, 100, 200, 300, 400, 500, 600, 700, 800, 900 Specifies font weight. The values ‘normal’ and ‘bold’ are supported for most fonts. Not all fonts have a variant for each of the numeric values, in that case the closest one is chosen. lineHeight false number textAlign false oneOf auto, left, right, center, justify Specifies text alignment. The value ‘justify’ is only supported on iOS and fallbacks to left on Android. textDecorationLine false oneOf none, underline, line-through, underline, line-through textShadowColor false ColorPropType textShadowOffset false ReactPropTypes.shape( {width: ReactPropTypes.number, height: ReactPropTypes.number} ) textShadowRadius false number textAlignVertical false oneOf auto, top, bottom, center android letterSpacing false number ios textDecorationColor false ColorPropType ios textDecorationStyle false oneOf solid, double, dotted, dashed ios writingDirection false oneOf auto, ltr, rtl ios View Name Required Type Platforms Description …Flexbox …ShadowPropTypesIOS …Transforms backfaceVisibility false oneOf visible, hidden backgroundColor false ColorPropType borderBottomColor false ColorPropType borderBottomLeftRadius false number borderBottomRightRadius false number borderBottomWidth false number borderColor false ColorPropType borderLeftColor false ColorPropType borderLeftWidth false number borderRadius false number borderRightColor false ColorPropType borderRightWidth false number borderStyle false oneOf solid, dotted, dashed borderTopColor false ColorPropType borderTopLeftRadius false number borderTopRightRadius false number borderTopWidth false number borderWidth false number opacity false number overflow false oneOf visible, hidden elevation false number android (Android-only) Sets the elevation of a view, using Android’s underlying elevation API. This adds a drop shadow to the item and affects z-order for overlapping views. Only supported on Android 5.0+, has no effect on earlier versions. AppendixTypesnumberReactPropTypes.number stringReactPropTypes.string oneOfReactPropTypes.oneOf([values])","categories":[{"name":"CheatSheet","slug":"CheatSheet","permalink":"https://React-Apollo.github.io/categories/CheatSheet/"}],"tags":[{"name":"React","slug":"React","permalink":"https://React-Apollo.github.io/tags/React/"},{"name":"UI","slug":"UI","permalink":"https://React-Apollo.github.io/tags/UI/"}]},{"title":"JavaScript的 this 关键字","slug":"javascript中的this关键字","date":"2017-01-10T15:04:34.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2017/01/10/javascript中的this关键字/","link":"","permalink":"https://React-Apollo.github.io/2017/01/10/javascript中的this关键字/","excerpt":"","text":"主要参考《javascrpt设计模式与开发指南》 javascript(缩写js)语言中的this和java,php中的this是完全不同的概念。js中的this是动态的，总是指向一个对象，但是这个对象是谁，需要根据函数的调用上下文来决定。 作为对象的方法调用(显示绑定) 作为普通的函数来调用(默认绑定) 作为构造器来调用 call和apply方法调用 1作为对象的方法调用12345678910var obj = &#123; a: 1, getA: function()&#123; alert ( this === obj ); // 输出：true alert ( this.a ); // 输出: 1 &#125; &#125;; obj.getA(); //函数被绑定在对象obj上，this指向obj对象 //这种方法，可以立即看到绑定的对象是那一个，所以是最简单的 2作为普通函数的调用1234567891011121314151617181920//在浏览器的JavaScript 里，这个全局对象是window 对象。 window.name = 'globalName'; var getName = function()&#123; //这个函数没有指定对象，默认绑定在window对象上 return this.name; &#125;; console.log( getName() ); // 输出：globalName //或者： window.name = 'globalName'; var myObject = &#123; name: 'sven', getName: function()&#123; return this.name; &#125; &#125;; //下面这个引用是比较迷惑人的，在用变量引用一个对象的方法时候，变量仅仅指向函数本身，和原来函数定义在哪个对象里没有任何关系，这一点要注意 var getName = myObject.getName; //getName函数任然是默认绑定在window全局对象上 console.log( getName() ); // globalName 下面这个实例，我个人认为是js this中最为迷惑的地方，需要注意，可能学了很长时间都对这个地方迷惑，没有什么原因，js就是这么规定的。 那，到底规定什么了？就是 函数内部的函数，也就是闭包函数的对象是默认绑定在全局，全局，全局 对象上的，一定，一定，一定 要记住这一点 123456789101112131415161718192021222324252627&lt;body&gt; &lt;div id=\"div1\"&gt;我是一个div&lt;/div&gt; &lt;/body&gt; &lt;script&gt; window.id = 'window'; document.getElementById( 'div1' ).onclick = function()&#123; alert ( this.id ); // 输出：'div1' var callback = function()&#123; //这个函数内部的函数，他是默认绑定在window上的 alert ( this.id ); // 输出：'window' &#125; callback(); &#125;; //那么要是内部函数要使用外部函数绑定的对象怎么办。 //好办，就是把外部函数的对象保存在一个变量中 //经常在代码中看到的 var that=this就是这个作用 //在内部函数要使用同一个对象就可以用that了。或者用 var self=this //这仅仅是变量的名字不同，道理都一样 document.getElementById( 'div1' ).onclick = function()&#123; var that = this; // 保存div 的引用 var callback = function()&#123; alert ( that.id ); // 输出：'div1' //that指向了外部函数的对象 &#125; callback(); &#125;; 在 ECMA es5的严格模式下问题又有改变了。 123use strict 这时候，内部函数的this不在默认指向window对象，而是指向undefine，实际就是没有默认绑定对象。 3构造器调用123456789101112var MyClass = function()&#123; this.name = 'sven'; &#125;; var obj = new MyClass(); //当使用构造器调用的时候，构造器返回一个对象，this就指向这个对象 alert ( obj.name ); // 输出：sven var MyClass = function()&#123; this.name = 'sven'; return &#123; // 显式地返回一个对象 name: 'anne' &#125; &#125;; 4call apply 调用硬式绑定，通过传参方式动态改变函数的绑定对象。 1234567891011121314 var obj1 = &#123; name: 'sven', getName: function()&#123; return this.name; &#125;&#125;;var obj2 = &#123; name: 'anne'&#125;;console.log( obj1.getName() ); // 输出: sven//下面这个函数硬式绑定到obj2对象上console.log( obj1.getName.call( obj2 ) ); // 输出：anne 这就是this的概念","categories":[{"name":"技术备忘","slug":"技术备忘","permalink":"https://React-Apollo.github.io/categories/技术备忘/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://React-Apollo.github.io/tags/javascript/"}]},{"title":"ReadMeKoa 框架","slug":"koa","date":"2015-04-17T00:00:00.000Z","updated":"2018-04-07T02:42:18.251Z","comments":true,"path":"2015/04/17/koa/","link":"","permalink":"https://React-Apollo.github.io/2015/04/17/koa/","excerpt":"","text":"Koa是一个类似于Express的Web开发框架，创始人也是同一个人。它的主要特点是，使用了ES6的Generator函数，进行了架构的重新设计。也就是说，Koa的原理和内部结构很像Express，但是语法和内部结构进行了升级。 官方faq有这样一个问题：”为什么koa不是Express 4.0？“，回答是这样的：”Koa与Express有很大差异，整个设计都是不同的，所以如果将Express 3.0按照这种写法升级到4.0，就意味着重写整个程序。所以，我们觉得创造一个新的库，是更合适的做法。“ Koa 应用一个Koa应用就是一个对象，包含了一个middleware数组，这个数组由一组Generator函数组成。这些函数负责对HTTP请求进行各种加工，比如生成缓存、指定代理、请求重定向等等。 12345678var koa = require('koa');var app = koa();app.use(function *()&#123; this.body = 'Hello World';&#125;);app.listen(3000); 上面代码中，变量app就是一个Koa应用。它监听3000端口，返回一个内容为Hello World的网页。 app.use方法用于向middleware数组添加Generator函数。 listen方法指定监听端口，并启动当前应用。它实际上等同于下面的代码。 1234var http = require('http');var koa = require('koa');var app = koa();http.createServer(app.callback()).listen(3000); 中间件Koa的中间件很像Express的中间件，也是对HTTP请求进行处理的函数，但是必须是一个Generator函数。而且，Koa的中间件是一个级联式（Cascading）的结构，也就是说，属于是层层调用，第一个中间件调用第二个中间件，第二个调用第三个，以此类推。上游的中间件必须等到下游的中间件返回结果，才会继续执行，这点很像递归。 中间件通过当前应用的use方法注册。 123456app.use(function* (next)&#123; var start = new Date; // （1） yield next; // （2） var ms = new Date - start; // （3） console.log('%s %s - %s', this.method, this.url, ms); // （4）&#125;); 上面代码中，app.use方法的参数就是中间件，它是一个Generator函数，最大的特征就是function命令与参数之间，必须有一个星号。Generator函数的参数next，表示下一个中间件。 Generator函数内部使用yield命令，将程序的执行权转交给下一个中间件，即yield next，要等到下一个中间件返回结果，才会继续往下执行。上面代码中，Generator函数体内部，第一行赋值语句首先执行，开始计时，第二行yield语句将执行权交给下一个中间件，当前中间件就暂停执行。等到后面的中间件全部执行完成，执行权就回到原来暂停的地方，继续往下执行，这时才会执行第三行，计算这个过程一共花了多少时间，第四行将这个时间打印出来。 下面是一个两个中间件级联的例子。 123456789app.use(function *() &#123; this.body = \"header\\n\"; yield saveResults.call(this); this.body += \"footer\\n\";&#125;);function *saveResults() &#123; this.body += \"Results Saved!\\n\";&#125; 上面代码中，第一个中间件调用第二个中间件saveResults，它们都向this.body写入内容。最后，this.body的输出如下。 123headerResults Saved!footer 只要有一个中间件缺少yield next语句，后面的中间件都不会执行，这一点要引起注意。 1234567891011121314151617app.use(function *(next)&#123; console.log('&gt;&gt; one'); yield next; console.log('&lt;&lt; one');&#125;);app.use(function *(next)&#123; console.log('&gt;&gt; two'); this.body = 'two'; console.log('&lt;&lt; two');&#125;);app.use(function *(next)&#123; console.log('&gt;&gt; three'); yield next; console.log('&lt;&lt; three');&#125;); 上面代码中，因为第二个中间件少了yield next语句，第三个中间件并不会执行。 如果想跳过一个中间件，可以直接在该中间件的第一行语句写上return yield next。 123app.use(function* (next) &#123; if (skip) return yield next;&#125;) 由于Koa要求中间件唯一的参数就是next，导致如果要传入其他参数，必须另外写一个返回Generator函数的函数。 12345678910111213function logger(format) &#123; return function *(next)&#123; var str = format .replace(':method', this.method) .replace(':url', this.url); console.log(str); yield next; &#125;&#125;app.use(logger(':method :url')); 上面代码中，真正的中间件是logger函数的返回值，而logger函数是可以接受参数的。 多个中间件的合并由于中间件的参数统一为next（意为下一个中间件），因此可以使用.call(this, next)，将多个中间件进行合并。 1234567891011121314151617181920212223242526272829function *random(next) &#123; if ('/random' == this.path) &#123; this.body = Math.floor(Math.random()*10); &#125; else &#123; yield next; &#125;&#125;;function *backwards(next) &#123; if ('/backwards' == this.path) &#123; this.body = 'sdrawkcab'; &#125; else &#123; yield next; &#125;&#125;function *pi(next) &#123; if ('/pi' == this.path) &#123; this.body = String(Math.PI); &#125; else &#123; yield next; &#125;&#125;function *all(next) &#123; yield random.call(this, backwards.call(this, pi.call(this, next)));&#125;app.use(all); 上面代码中，中间件all内部，就是依次调用random、backwards、pi，后一个中间件就是前一个中间件的参数。 Koa内部使用koa-compose模块，进行同样的操作，下面是它的源码。 123456789101112131415function compose(middleware)&#123; return function *(next)&#123; if (!next) next = noop(); var i = middleware.length; while (i--) &#123; next = middleware[i].call(this, next); &#125; yield *next; &#125;&#125;function *noop()&#123;&#125; 上面代码中，middleware是中间件数组。前一个中间件的参数是后一个中间件，依次类推。如果最后一个中间件没有next参数，则传入一个空函数。 路由可以通过this.path属性，判断用户请求的路径，从而起到路由作用。 123456789101112app.use(function* (next) &#123; if (this.path === '/') &#123; this.body = 'we are at home!'; &#125;&#125;)// 等同于app.use(function* (next) &#123; if (this.path !== '/') return yield next; this.body = 'we are at home!';&#125;) 下面是多路径的例子。 1234567891011121314151617181920212223242526272829303132let koa = require('koa')let app = koa()// normal routeapp.use(function* (next) &#123; if (this.path !== '/') &#123; return yield next &#125; this.body = 'hello world'&#125;);// /404 routeapp.use(function* (next) &#123; if (this.path !== '/404') &#123; return yield next; &#125; this.body = 'page not found'&#125;);// /500 routeapp.use(function* (next) &#123; if (this.path !== '/500') &#123; return yield next; &#125; this.body = 'internal server error'&#125;);app.listen(8080) 上面代码中，每一个中间件负责一个路径，如果路径不符合，就传递给下一个中间件。 复杂的路由需要安装koa-router插件。 123456789101112var app = require('koa')();var Router = require('koa-router');var myRouter = new Router();myRouter.get('/', function *(next) &#123; this.response.body = 'Hello World!';&#125;);app.use(myRouter.routes());app.listen(3000); 上面代码对根路径设置路由。 Koa-router实例提供一系列动词方法，即一种HTTP动词对应一种方法。典型的动词方法有以下五种。 router.get() router.post() router.put() router.del() router.patch() 这些动词方法可以接受两个参数，第一个是路径模式，第二个是对应的控制器方法（中间件），定义用户请求该路径时服务器行为。 123router.get('/', function *(next) &#123; this.body = 'Hello World!';&#125;); 上面代码中，router.get方法的第一个参数是根路径，第二个参数是对应的函数方法。 注意，路径匹配的时候，不会把查询字符串考虑在内。比如，/index?param=xyz匹配路径/index。 有些路径模式比较复杂，Koa-router允许为路径模式起别名。起名时，别名要添加为动词方法的第一个参数，这时动词方法变成接受三个参数。 123router.get('user', '/users/:id', function *(next) &#123; // ...&#125;); 上面代码中，路径模式\\users\\:id的名字就是user。路径的名称，可以用来引用对应的具体路径，比如url方法可以根据路径名称，结合给定的参数，生成具体的路径。 12345router.url('user', 3);// =&gt; \"/users/3\"router.url('user', &#123; id: 3 &#125;);// =&gt; \"/users/3\" 上面代码中，user就是路径模式的名称，对应具体路径/users/:id。url方法的第二个参数3，表示给定id的值是3，因此最后生成的路径是/users/3。 Koa-router允许为路径统一添加前缀。 123456var router = new Router(&#123; prefix: '/users'&#125;);router.get('/', ...); // 等同于\"/users\"router.get('/:id', ...); // 等同于\"/users/:id\" 路径的参数通过this.params属性获取，该属性返回一个对象，所有路径参数都是该对象的成员。 12345// 访问 /programming/how-to-noderouter.get('/:category/:title', function *(next) &#123; console.log(this.params); // =&gt; &#123; category: 'programming', title: 'how-to-node' &#125;&#125;); param方法可以针对命名参数，设置验证条件。 12345678910router .get('/users/:user', function *(next) &#123; this.body = this.user; &#125;) .param('user', function *(id, next) &#123; var users = [ '0号用户', '1号用户', '2号用户']; this.user = users[id]; if (!this.user) return this.status = 404; yield next; &#125;) 上面代码中，如果/users/:user的参数user对应的不是有效用户（比如访问/users/3），param方法注册的中间件会查到，就会返回404错误。 redirect方法会将某个路径的请求，重定向到另一个路径，并返回301状态码。 1234567router.redirect('/login', 'sign-in');// 等同于router.all('/login', function *() &#123; this.redirect('/sign-in'); this.status = 301;&#125;); redirect方法的第一个参数是请求来源，第二个参数是目的地，两者都可以用路径模式的别名代替。 context对象中间件当中的this表示上下文对象context，代表一次HTTP请求和回应，即一次访问/回应的所有信息，都可以从上下文对象获得。context对象封装了request和response对象，并且提供了一些辅助方法。每次HTTP请求，就会创建一个新的context对象。 12345app.use(function *()&#123; this; // is the Context this.request; // is a koa Request this.response; // is a koa Response&#125;); context对象的很多方法，其实是定义在ctx.request对象或ctx.response对象上面，比如，ctx.type和ctx.length对应于ctx.response.type和ctx.response.length，ctx.path和ctx.method对应于ctx.request.path和ctx.request.method。 context对象的全局属性。 request：指向Request对象 response：指向Response对象 req：指向Node的request对象 res：指向Node的response对象 app：指向App对象 state：用于在中间件传递信息。 1this.state.user = yield User.find(id); 上面代码中，user属性存放在this.state对象上面，可以被另一个中间件读取。 context对象的全局方法。 throw()：抛出错误，直接决定了HTTP回应的状态码。 assert()：如果一个表达式为false，则抛出一个错误。 123456789this.throw(403);this.throw('name required', 400);this.throw('something exploded');this.throw(400, 'name required');// 等同于var err = new Error('name required');err.status = 400;throw err; assert方法的例子。 12345// 格式ctx.assert(value, [msg], [status], [properties])// 例子this.assert(this.user, 401, 'User not found. Please login!'); 以下模块解析POST请求的数据。 co-body https://github.com/koajs/body-parser https://github.com/koajs/body-parsers 1234var parse = require('co-body');// in Koa handlervar body = yield parse(this); 错误处理机制Koa提供内置的错误处理机制，任何中间件抛出的错误都会被捕捉到，引发向客户端返回一个500错误，而不会导致进程停止，因此也就不需要forever这样的模块重启进程。 123app.use(function *() &#123; throw new Error();&#125;); 上面代码中，中间件内部抛出一个错误，并不会导致Koa应用挂掉。Koa内置的错误处理机制，会捕捉到这个错误。 当然，也可以额外部署自己的错误处理机制。 1234567app.use(function *() &#123; try &#123; yield saveResults(); &#125; catch (err) &#123; this.throw(400, '数据无效'); &#125;&#125;); 上面代码自行部署了try…catch代码块，一旦产生错误，就用this.throw方法抛出。该方法可以将指定的状态码和错误信息，返回给客户端。 对于未捕获错误，可以设置error事件的监听函数。 123app.on('error', function(err)&#123; log.error('server error', err);&#125;); error事件的监听函数还可以接受上下文对象，作为第二个参数。 123app.on('error', function(err, ctx)&#123; log.error('server error', err, ctx);&#125;); 如果一个错误没有被捕获，koa会向客户端返回一个500错误“Internal Server Error”。 this.throw方法用于向客户端抛出一个错误。 12345678910this.throw(403);this.throw('name required', 400);this.throw(400, 'name required');this.throw('something exploded');this.throw('name required', 400)// 等同于var err = new Error('name required');err.status = 400;throw err; this.throw方法的两个参数，一个是错误码，另一个是报错信息。如果省略状态码，默认是500错误。 this.assert方法用于在中间件之中断言，用法类似于Node的assert模块。 1this.assert(this.user, 401, 'User not found. Please login!'); 上面代码中，如果this.user属性不存在，会抛出一个401错误。 由于中间件是层级式调用，所以可以把try { yield next }当成第一个中间件。 12345678910111213app.use(function *(next) &#123; try &#123; yield next; &#125; catch (err) &#123; this.status = err.status || 500; this.body = err.message; this.app.emit('error', err, this); &#125;&#125;);app.use(function *(next) &#123; throw new Error('some error');&#125;) cookiecookie的读取和设置。 12this.cookies.get('view');this.cookies.set('view', n); get和set方法都可以接受第三个参数，表示配置参数。其中的signed参数，用于指定cookie是否加密。如果指定加密的话，必须用app.keys指定加密短语。 12app.keys = ['secret1', 'secret2'];this.cookies.set('name', '张三', &#123; signed: true &#125;); this.cookie的配置对象的属性如下。 signed：cookie是否加密。 expires：cookie何时过期 path：cookie的路径，默认是“/”。 domain：cookie的域名。 secure：cookie是否只有https请求下才发送。 httpOnly：是否只有服务器可以取到cookie，默认为true。 session123456789101112131415var session = require('koa-session');var koa = require('koa');var app = koa();app.keys = ['some secret hurr'];app.use(session(app));app.use(function *()&#123; var n = this.session.views || 0; this.session.views = ++n; this.body = n + ' views';&#125;)app.listen(3000);console.log('listening on port 3000'); Request对象Request对象表示HTTP请求。 （1）this.request.header 返回一个对象，包含所有HTTP请求的头信息。它也可以写成this.request.headers。 （2）this.request.method 返回HTTP请求的方法，该属性可读写。 （3）this.request.length 返回HTTP请求的Content-Length属性，取不到值，则返回undefined。 （4）this.request.path 返回HTTP请求的路径，该属性可读写。 （5）this.request.href 返回HTTP请求的完整路径，包括协议、端口和url。 12this.request.href// http://example.com/foo/bar?q=1 （6）this.request.querystring 返回HTTP请求的查询字符串，不含问号。该属性可读写。 （7）this.request.search 返回HTTP请求的查询字符串，含问号。该属性可读写。 （8）this.request.host 返回HTTP请求的主机（含端口号）。 （9）this.request.hostname 返回HTTP的主机名（不含端口号）。 （10）this.request.type 返回HTTP请求的Content-Type属性。 12var ct = this.request.type;// \"image/png\" （11）this.request.charset 返回HTTP请求的字符集。 12this.request.charset// \"utf-8\" （12）this.request.query 返回一个对象，包含了HTTP请求的查询字符串。如果没有查询字符串，则返回一个空对象。该属性可读写。 比如，查询字符串color=blue&amp;size=small，会得到以下的对象。 1234&#123; color: 'blue', size: 'small'&#125; （13）this.request.fresh 返回一个布尔值，表示缓存是否代表了最新内容。通常与If-None-Match、ETag、If-Modified-Since、Last-Modified等缓存头，配合使用。 1234567891011this.response.set('ETag', '123');// 检查客户端请求的内容是否有变化if (this.request.fresh) &#123; this.response.status = 304; return;&#125;// 否则就表示客户端的内容陈旧了，// 需要取出新内容this.response.body = yield db.find('something'); （14）this.request.stale 返回this.request.fresh的相反值。 （15）this.request.protocol 返回HTTP请求的协议，https或者http。 （16）this.request.secure 返回一个布尔值，表示当前协议是否为https。 （17）this.request.ip 返回发出HTTP请求的IP地址。 （18）this.request.subdomains 返回一个数组，表示HTTP请求的子域名。该属性必须与app.subdomainOffset属性搭配使用。app.subdomainOffset属性默认为2，则域名“tobi.ferrets.example.com”返回[“ferrets”, “tobi”]，如果app.subdomainOffset设为3，则返回[“tobi”]。 （19）this.request.is(types…) 返回指定的类型字符串，表示HTTP请求的Content-Type属性是否为指定类型。 123456789// Content-Type为 text/html; charset=utf-8this.request.is('html'); // 'html'this.request.is('text/html'); // 'text/html'this.request.is('text/*', 'text/html'); // 'text/html'// Content-Type为 application/jsonthis.request.is('json', 'urlencoded'); // 'json'this.request.is('application/json'); // 'application/json'this.request.is('html', 'application/*'); // 'application/json' 如果不满足条件，返回false；如果HTTP请求不含数据，则返回undefined。 1this.is('html'); // false 它可以用于过滤HTTP请求，比如只允许请求下载图片。 12345if (this.is('image/*')) &#123; // process&#125; else &#123; this.throw(415, 'images only!');&#125; （20）this.request.accepts(types) 检查HTTP请求的Accept属性是否可接受，如果可接受，则返回指定的媒体类型，否则返回false。 1234567891011121314151617181920212223242526272829// Accept: text/htmlthis.request.accepts('html');// \"html\"// Accept: text/*, application/jsonthis.request.accepts('html');// \"html\"this.request.accepts('text/html');// \"text/html\"this.request.accepts('json', 'text');// =&gt; \"json\"this.request.accepts('application/json');// =&gt; \"application/json\"// Accept: text/*, application/jsonthis.request.accepts('image/png');this.request.accepts('png');// false// Accept: text/*;q=.5, application/jsonthis.request.accepts(['html', 'json']);this.request.accepts('html', 'json');// \"json\"// No Accept headerthis.request.accepts('html', 'json');// \"html\"this.request.accepts('json', 'html');// =&gt; \"json\" 如果accepts方法没有参数，则返回所有支持的类型（text/html,application/xhtml+xml,image/webp,application/xml,/）。 如果accepts方法的参数有多个参数，则返回最佳匹配。如果都不匹配则返回false，并向客户端抛出一个406”Not Acceptable“错误。 如果HTTP请求没有Accept字段，那么accepts方法返回它的第一个参数。 accepts方法可以根据不同Accept字段，向客户端返回不同的字段。 123456switch (this.request.accepts('json', 'html', 'text')) &#123; case 'json': break; case 'html': break; case 'text': break; default: this.throw(406, 'json, html, or text only');&#125; （21）this.request.acceptsEncodings(encodings) 该方法根据HTTP请求的Accept-Encoding字段，返回最佳匹配，如果没有合适的匹配，则返回false。 12345// Accept-Encoding: gzipthis.request.acceptsEncodings('gzip', 'deflate', 'identity');// \"gzip\"this.request.acceptsEncodings(['gzip', 'deflate', 'identity']);// \"gzip\" 注意，acceptEncodings方法的参数必须包括identity（意为不编码）。 如果HTTP请求没有Accept-Encoding字段，acceptEncodings方法返回所有可以提供的编码方法。 123// Accept-Encoding: gzip, deflatethis.request.acceptsEncodings();// [\"gzip\", \"deflate\", \"identity\"] 如果都不匹配，acceptsEncodings方法返回false，并向客户端抛出一个406“Not Acceptable”错误。 （22）this.request.acceptsCharsets(charsets) 该方法根据HTTP请求的Accept-Charset字段，返回最佳匹配，如果没有合适的匹配，则返回false。 123456// Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5this.request.acceptsCharsets('utf-8', 'utf-7');// =&gt; \"utf-8\"this.request.acceptsCharsets(['utf-7', 'utf-8']);// =&gt; \"utf-8\" 如果acceptsCharsets方法没有参数，则返回所有可接受的匹配。 123// Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5this.request.acceptsCharsets();// [\"utf-8\", \"utf-7\", \"iso-8859-1\"] 如果都不匹配，acceptsCharsets方法返回false，并向客户端抛出一个406“Not Acceptable”错误。 （23）this.request.acceptsLanguages(langs) 该方法根据HTTP请求的Accept-Language字段，返回最佳匹配，如果没有合适的匹配，则返回false。 12345// Accept-Language: en;q=0.8, es, ptthis.request.acceptsLanguages('es', 'en');// \"es\"this.request.acceptsLanguages(['en', 'es']);// \"es\" 如果acceptsCharsets方法没有参数，则返回所有可接受的匹配。 123// Accept-Language: en;q=0.8, es, ptthis.request.acceptsLanguages();// [\"es\", \"pt\", \"en\"] 如果都不匹配，acceptsLanguages方法返回false，并向客户端抛出一个406“Not Acceptable”错误。 （24）this.request.socket 返回HTTP请求的socket。 （25）this.request.get(field) 返回HTTP请求指定的字段。 Response对象Response对象表示HTTP回应。 （1）this.response.header 返回HTTP回应的头信息。 （2）this.response.socket 返回HTTP回应的socket。 （3）this.response.status 返回HTTP回应的状态码。默认情况下，该属性没有值。该属性可读写，设置时等于一个整数。 （4）this.response.message 返回HTTP回应的状态信息。该属性与this.response.message是配对的。该属性可读写。 （5）this.response.length 返回HTTP回应的Content-Length字段。该属性可读写，如果没有设置它的值，koa会自动从this.request.body推断。 （6）this.response.body 返回HTTP回应的信息体。该属性可读写，它的值可能有以下几种类型。 字符串：Content-Type字段默认为text/html或text/plain，字符集默认为utf-8，Content-Length字段同时设定。 二进制Buffer：Content-Type字段默认为application/octet-stream，Content-Length字段同时设定。 Stream：Content-Type字段默认为application/octet-stream。 JSON对象：Content-Type字段默认为application/json。 null（表示没有信息体） 如果this.response.status没设置，Koa会自动将其设为200或204。 （7）this.response.get(field) 返回HTTP回应的指定字段。 1var etag = this.get('ETag'); 注意，get方法的参数是区分大小写的。 （8）this.response.set() 设置HTTP回应的指定字段。 1this.set('Cache-Control', 'no-cache'); set方法也可以接受一个对象作为参数，同时为多个字段指定值。 1234this.set(&#123; 'Etag': '1234', 'Last-Modified': date&#125;); （9）this.response.remove(field) 移除HTTP回应的指定字段。 （10）this.response.type 返回HTTP回应的Content-Type字段，不包括“charset”参数的部分。 12var ct = this.reponse.type;// \"image/png\" 该属性是可写的。 1234this.reponse.type = 'text/plain; charset=utf-8';this.reponse.type = 'image/png';this.reponse.type = '.png';this.reponse.type = 'png'; 设置type属性的时候，如果没有提供charset参数，Koa会判断是否自动设置。如果this.response.type设为html，charset默认设为utf-8；但如果this.response.type设为text/html，就不会提供charset的默认值。 （10）this.response.is(types…) 该方法类似于this.request.is()，用于检查HTTP回应的类型是否为支持的类型。 它可以在中间件中起到处理不同格式内容的作用。 12345678910111213var minify = require('html-minifier');app.use(function *minifyHTML(next)&#123; yield next; if (!this.response.is('html')) return; var body = this.response.body; if (!body || body.pipe) return; if (Buffer.isBuffer(body)) body = body.toString(); this.response.body = minify(body);&#125;); 上面代码是一个中间件，如果输出的内容类型为HTML，就会进行最小化处理。 （11）this.response.redirect(url, [alt]) 该方法执行302跳转到指定网址。 1234this.redirect('back');this.redirect('back', '/index.html');this.redirect('/login');this.redirect('http://google.com'); 如果redirect方法的第一个参数是back，将重定向到HTTP请求的Referrer字段指定的网址，如果没有该字段，则重定向到第二个参数或“/”网址。 如果想修改302状态码，或者修改body文字，可以采用下面的写法。 123this.status = 301;this.redirect('/cart');this.body = 'Redirecting to shopping cart'; （12）this.response.attachment([filename]) 该方法将HTTP回应的Content-Disposition字段，设为“attachment”，提示浏览器下载指定文件。 （13）this.response.headerSent 该方法返回一个布尔值，检查是否HTTP回应已经发出。 （14）this.response.lastModified 该属性以Date对象的形式，返回HTTP回应的Last-Modified字段（如果该字段存在）。该属性可写。 1this.response.lastModified = new Date(); （15）this.response.etag 该属性设置HTTP回应的ETag字段。 1this.response.etag = crypto.createHash('md5').update(this.body).digest('hex'); 注意，不能用该属性读取ETag字段。 （16）this.response.vary(field) 该方法将参数添加到HTTP回应的Vary字段。 CSRF攻击CSRF攻击是指用户的session被劫持，用来冒充用户的攻击。 koa-csrf插件用来防止CSRF攻击。原理是在session之中写入一个秘密的token，用户每次使用POST方法提交数据的时候，必须含有这个token，否则就会抛出错误。 123456789101112131415161718192021222324var koa = require('koa');var session = require('koa-session');var csrf = require('koa-csrf');var route = require('koa-route');var app = module.exports = koa();app.keys = ['session key', 'csrf example'];app.use(session(app));app.use(csrf());app.use(route.get('/token', token));app.use(route.post('/post', post));function* token () &#123; this.body = this.csrf;&#125;function* post() &#123; this.body = &#123;ok: true&#125;;&#125;app.listen(3000); POST请求含有token，可以是以下几种方式之一，koa-csrf插件就能获得token。 表单的_csrf字段 查询字符串的_csrf字段 HTTP请求头信息的x-csrf-token字段 HTTP请求头信息的x-xsrf-token字段 数据压缩koa-compress模块可以实现数据压缩。 12345app.use(require('koa-compress')())app.use(function* () &#123; this.type = 'text/plain' this.body = fs.createReadStream('filename.txt')&#125;) 源码解读每一个网站就是一个app，它由lib/application定义。 12345678910111213function Application() &#123; if (!(this instanceof Application)) return new Application; this.env = process.env.NODE_ENV || 'development'; this.subdomainOffset = 2; this.middleware = []; this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response);&#125;var app = Application.prototype;exports = module.exports = Application; app.use()用于注册中间件，即将Generator函数放入中间件数组。 123456789app.use = function(fn)&#123; if (!this.experimental) &#123; // es7 async functions are allowed assert(fn &amp;&amp; 'GeneratorFunction' == fn.constructor.name, 'app.use() requires a generator function'); &#125; debug('use %s', fn._name || fn.name || '-'); this.middleware.push(fn); return this;&#125;; app.listen()就是http.createServer(app.callback()).listen(...)的缩写。 12345678910111213141516171819202122app.listen = function()&#123; debug('listen'); var server = http.createServer(this.callback()); return server.listen.apply(server, arguments);&#125;;app.callback = function()&#123; var mw = [respond].concat(this.middleware); var fn = this.experimental ? compose_es7(mw) : co.wrap(compose(mw)); var self = this; if (!this.listeners('error').length) this.on('error', this.onerror); return function(req, res)&#123; res.statusCode = 404; var ctx = self.createContext(req, res); onFinished(res, ctx.onerror); fn.call(ctx).catch(ctx.onerror); &#125;&#125;; 上面代码中，app.callback()会返回一个函数，用来处理HTTP请求。它的第一行mw = [respond].concat(this.middleware)，表示将respond函数（这也是一个Generator函数）放入this.middleware，现在mw就变成了[respond, S1, S2, S3]。 compose(mw)将中间件数组转为一个层层调用的Generator函数。 123456789101112131415function compose(middleware)&#123; return function *(next)&#123; if (!next) next = noop(); var i = middleware.length; while (i--) &#123; next = middleware[i].call(this, next); &#125; yield *next; &#125;&#125;function *noop()&#123;&#125; 上面代码中，下一个generator函数总是上一个Generator函数的参数，从而保证了层层调用。 var fn = co.wrap(gen)则是将Generator函数包装成一个自动执行的函数，并且返回一个Promise。 123456//co packageco.wrap = function (fn) &#123; return function () &#123; return co.call(this, fn.apply(this, arguments)); &#125;;&#125;; 由于co.wrap(compose(mw))执行后，返回的是一个Promise，所以可以对其使用catch方法指定捕捉错误的回调函数fn.call(ctx).catch(ctx.onerror)。 将所有的上下文变量都放进context对象。 1234567891011121314151617app.createContext = function(req, res)&#123; var context = Object.create(this.context); var request = context.request = Object.create(this.request); var response = context.response = Object.create(this.response); context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.onerror = context.onerror.bind(context); context.originalUrl = request.originalUrl = req.url; context.cookies = new Cookies(req, res, this.keys); context.accept = request.accept = accepts(req); context.state = &#123;&#125;; return context;&#125;; 真正处理HTTP请求的是下面这个Generator函数。 123456789101112131415161718192021222324252627282930313233343536373839404142function *respond(next) &#123; yield *next; // allow bypassing koa if (false === this.respond) return; var res = this.res; if (res.headersSent || !this.writable) return; var body = this.body; var code = this.status; // ignore body if (statuses.empty[code]) &#123; // strip headers this.body = null; return res.end(); &#125; if ('HEAD' == this.method) &#123; if (isJSON(body)) this.length = Buffer.byteLength(JSON.stringify(body)); return res.end(); &#125; // status body if (null == body) &#123; this.type = 'text'; body = this.message || String(code); this.length = Buffer.byteLength(body); return res.end(body); &#125; // responses if (Buffer.isBuffer(body)) return res.end(body); if ('string' == typeof body) return res.end(body); if (body instanceof Stream) return body.pipe(res); // body: json body = JSON.stringify(body); this.length = Buffer.byteLength(body); res.end(body);&#125; 参考链接 Koa Guide William XING, Is Koa.js right for me?⬆ back to top","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://React-Apollo.github.io/categories/Node-js/"}],"tags":[]}]}