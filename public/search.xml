<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Javascript Reducer函数实战]]></title>
    <url>%2F2017%2F06%2F09%2FDisssection-Twitter-s-Redux-Store%2F</url>
    <content type="text"><![CDATA[javascript Reduce函数是比较强大的一个函数,在简书上看到有个作者写了这个函数的文章,也是看到有个问题就向他请教,大神很忙,但是仍然在github上做了答复,我对那个问题搞明白了,所以写了下面这个文章,但是没有写完,现在陪老娘在医院,又把这个问题翻出来看,又不懂了,还是拉锯战啊. javascript的编程中,我开始感到看别人的源码最难的地方实际还是两个,一个是数组方法的灵活应用,另一个是对象的浅拷贝和深拷贝的问题.这两个问题要是有深刻的体会,看源码的难度会降低很多.reduce,slice,splice,concat函数是明星.遇到这几个函数的时候就有些看不懂,所以掌握这几个函数是非常重要的. 深拷贝和浅拷贝的问题其实和javascript的对象和函数都是传引用赋值息息相关,一句话解决对象的共享还是独享的问题.javascript的设计模式很多都是利用对象很函数的传引用赋值的特点来完成的.所以这儿地方也是非常的重要.javascript的数组元素也可以是对象的引用. 本人是新手,最大的体会是学到的两个简单原则:1 对象是用来组织数据和相关方法的,所以组织方式越简单,越灵活越好,由于js的对象和函数都可以传引用赋值,所以在js中,以对象字面量和数组的组织方式真的是非常的强大,之所以这么讲,就是要把学习数组的方法提到新的高度.2 编程到底是在干什么？ 我逐渐体会到编程也就是解决信息的传递，存储和处理的问题. 所以很多问题其实稍微抽象一下,问题可能会简单一点. 我简单的写了一个东西,在学习React/Redux的时候,总是掌握不了实质,就是Redux中的state的实质是什么.前面学习的时候,总是言必称state,想了各种办法去了解什么是state，为什么要这样设计.其实再抽象一下,这不就是一个小型的数据库吗？可以这样说吗？当然可以了,我看了一本介绍React的书,有点确认了,当我这几天再读F8 app的代码官方文档的时候,facebook直接就是把Redux称为数据层.我还想了一些办法来理解Redux，比如说借用中介者模式,MVC解耦和模式,但是如果抽象为数据层,那么还有什么问题解决不了的吗？ 如果接触过任何一种web框架语言,例如php/mysql,node/mongodb.每种都是解耦和,每种都是中介者模式.所以在理解这些概念的时候最基础的内容可能是最解决问题的条件.你可以梳理一下这些框架中与数据库操作都有哪些? 连接数据库,数据库操作语句,数据库文件,返回值等等.这些东西在react/redux中都能找到一摸一样的内容.web框架里的数据库操作和redux的操作是完全一样的,有什么奇怪的吗？都是数据库. Redux的文档中有个redo,undo的例子,我最近又重新看redux文档的时候，感觉这一部分讲的真是好,以前怎么没有理解呢？ 有三个缺陷一个是对于state的数据结构的理解,一个是堆栈方法使用理解,另一个就是js的浅拷贝的问题。前面看那本数据结构的书,也不得法,但是硬着头皮把几种数据结构拿下以后,突然觉得好多问题都找到了解决办法,计算机中对于数据结构和算法的重视不是白来的.state如果作为一个简单数据库,他里面就是一些键值对. 由于js中对象可以传引用,所以可以很容易的建立一个类数据库的结构.其他语言可以吗？ #####下面我们就贯彻以上的理念,来研究一些基础的内容。第一个就是Reducer函数,参考 MDN 文档 直接看代码例子 1234//accumulator是累加值,currentValue是当前遍历的值[0,1,2,3,4].reduce( (accumulator, currentValue, currentIndex, array) =&gt; &#123; return accumulator + currentValue;&#125;, 10); callback accumulate currentValue currentIndex array return 第一次调用 10 0 0 [0,1,2,3,4] 10 第二次调用 10 1 1 [0,1,2,3,4] 11 第三次调用 11 2 2 [0,1,2,3,4] 13 第四次调用 13 3 3 [0,1,2,3,4] 16 第五次调用 16 4 4 [0,1,2,3,4] 20 第一个遍历，accumulate等于10.遍历的数组元素是0，index是0.这是巧合。数组还是[0,1,2,3,4]。返回的值是初始值加当前的数组元素值，也就是返回accumulate+array[currentIndex]。return的就是 10+array[0]=10. 第二个遍历，accumulate就是10，遍历的数组元素是1，index是1.这也是巧合。数组还是[0,1,2,3,4]。返回的值是accumulate加当前的数组值，accumulate+array[currentIndex]。也就是返回 10+array[1]=11. 第二个遍历和第一个遍历的区别就是初始值来源不同。第一个遍历的是reduce带进来的数据。第二个遍历使用的是第一个遍历返回的值。后面的几个遍历就和第二个遍历一样了。 数组扁平化12345var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) &#123; return a.concat(b); //要了解concat的使用,返回的是 //数组合并的返回对象&#125;, []); //起始是空数组// flattened is [0, 1, 2, 3, 4, 5] 就这么简单,但是灵活变动起来也不是太好理解啊看这个计算器的React-Native的代码,在UI组件中渲染出计算器的几个按键的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 var Types = &#123; //类型 NUMBER: 'NUMBER', DECIMAL: 'DECIMAL', SIGN: 'SIGN'&#125;;var inputs = [ &#123;value: 1, type: Types.NUMBER&#125;, &#123;value: 2, type: Types.NUMBER&#125;, &#123;value: 3, type: Types.NUMBER&#125;, &#123;value: 4, type: Types.NUMBER&#125;, &#123;value: 5, type: Types.NUMBER&#125;, &#123;value: 6, type: Types.NUMBER&#125;, &#123;value: 7, type: Types.NUMBER&#125;, &#123;value: 8, type: Types.NUMBER&#125;, &#123;value: 9, type: Types.NUMBER&#125;, &#123;value: '+/-', type: Types.SIGN&#125;, &#123;value: 0, type: Types.NUMBER&#125;, &#123;value: '.', type: Types.DECIMAL&#125;,];//操作符的配置var operations = [ &#123;value: '/', color: '#c77ccc', altColor: '#b16eb7', operation: OPERATION_DIVIDE&#125;, &#123;value: '-', color: '#f8b055', altColor: '#dc9c4c', operation: OPERATION_SUBTRACT&#125;, &#123;value: '+', color: '#f796d2', altColor: '#e088be', operation: OPERATION_ADD&#125;, &#123;value: 'x', color: '#6fcdf4', altColor: '#65badd', operation: OPERATION_MULTIPLY&#125;];renderInputRows() &#123; var &#123;inputNumber, inputSigned, inputDecimal&#125; = this.props;//注意在redux中那个地方返回了这三个函数的名字 return inputs.reduce((collection, input) =&gt; &#123;//这里的reduce是怎么用的呢？ if (collection[collection.length - 1].length === 3) &#123;//为什么等于3 collection.push([]); &#125; collection[collection.length-1].push(input); return collection; &#125;, [[]]).map((group, rowIndex) =&gt; &#123; var columns = group.map((item, columnIndex) =&gt; &#123;//看看map的方法 return ( &lt;TouchableHighlight key=&#123;'inputRow_' + rowIndex + '_inputCol_' + columnIndex&#125; underlayColor="#ededed" style=&#123;styles.input&#125; onPress=&#123;() =&gt; &#123; //dispatch方法 if (item.type === Types.NUMBER) &#123; inputNumber(item.value); &#125; else if (item.type === Types.DECIMAL) &#123; inputDecimal(); &#125; else if (item.type === Types.SIGN) &#123; inputSigned(); &#125; &#125;&#125;&gt; &lt;Text style=&#123;styles.inputText&#125;&gt;&#123;item.value&#125;&lt;/Text&gt; &lt;/TouchableHighlight&gt; ); &#125;); 看看这个数组的reducer方法的使用.源代码在这里 这个我稍后再补充,会补充大神给我的解答. 1234567891011121314151617181920212223242526272829303132 var Types = &#123; NUMBER: 'NUMBER', DECIMAL: 'DECIMAL', SIGN: 'SIGN'&#125;var inputs = [ &#123;value: 1, type: Types.NUMBER&#125;, &#123;value: 2, type: Types.NUMBER&#125;, &#123;value: 3, type: Types.NUMBER&#125;, &#123;value: 4, type: Types.NUMBER&#125;, &#123;value: 5, type: Types.NUMBER&#125;, &#123;value: 6, type: Types.NUMBER&#125;, &#123;value: 7, type: Types.NUMBER&#125;, &#123;value: 8, type: Types.NUMBER&#125;, &#123;value: 9, type: Types.NUMBER&#125;, &#123;value: '+/-', type: Types.SIGN&#125;, &#123;value: 0, type: Types.NUMBER&#125;, &#123;value: '.', type: Types.DECIMAL&#125;,];//这里其实是有一维数组转为二维数组，打印结构可以看到.//注意reduce的起始值就是一个二维数组.var result = inputs.reduce((collection, input) =&gt; &#123; if (collection[collection.length - 1].length === 3) &#123; collection.push([]); &#125; collection[collection.length-1].push(input); return collection; &#125;, [[]])console.log(result)console.table(result) 再看看下面这里两段代码12345678let str = `name, age, hair\nMerble, 35, red\nBob, 64, blonde`;function lameCSV(str) &#123; return str.split('\n').reduce(function(table, row)&#123; table.push(row.split(',').map(function(c) &#123;return c.trim();&#125;)); return table &#125;, [[]]);&#125;;lameCSV(str); 123456789var arr=[0,1,2,3,4,5,6,7,8]; var result = arr.reduce((collection, input) =&gt; &#123; if (collection[collection.length - 1].length === 3) &#123; collection.push([]); &#125; collection[collection.length-1].push(input); console.log(collection); return collection; &#125;, [[]]); 感谢大神的帮助,大神的githubreduce这个方法还能演变出什么花样来呢？数组的操作真的是一个需要好好学习的内容.]]></content>
      <tags>
        <tag>javacript</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dissecting Twitter's Redux Store]]></title>
    <url>%2F2017%2F06%2F04%2FJavaScript%20%20Reducer%20%20practice%2F</url>
    <content type="text"><![CDATA[摘编|Dissecting Twitter’s Redux Store原文请见 剖析mobile.twitter.com的store结构.大公司的移动网站,可以借鉴的东西很多,twitter的mobile已经使用了React/Redux技术,所以如果你的web网站也想要采用React/Redux构架,这篇文章要好好看看. 原文我现在不想翻译.列出来可能遇到的问题和需要用到的技术 可能要自己翻墙 记住是Twitter’s mobile website移动网站,不是pc端网站,网址是mobileTwitter 要使用chrome浏览器打开 申请一个twitter账号，登录,否则store中的信息很少 需要在chrome安装 React Developer Tools (RDT) 工具. chrome的调试界面下可以看到点击，打开console. 输入 $r.store.getState(); twitter在你应用中store的 state结构就展现出来了. 现在你可以看看大公司的应用是怎么来设计state的结构的. 由于人家的网站很复杂，所以state很像一个数据库，可以先看看数据库的范式化和 React/Redux中的实现方案 normalizr.了解如何减少巢状结构和冗余数据. 其他有兴趣的再深挖吧.总之一句话,当React应用中引入了Redux以后,应用的控制权就交到了Redux的手中,所以不要局限于React组件和页面的,需要更过的考虑数据的组织问题. 这一篇算是工具篇。 相关的开发工具后redux-logger, dev-tools, React-native Debugger ,Reactotron工具.好像还有一个可视化的工具]]></content>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻译|redux undo/redo reducer增强组件]]></title>
    <url>%2F2017%2F04%2F04%2F%E7%BF%BB%E8%AF%91-redux-undo-redo-reducer%E5%A2%9E%E5%BC%BA%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Redux的文档中提供一个可以做undo/redo的解决办法,实际是有previous,current,prew的对象,围绕这数据的压入和弹出来实现操作步骤的记忆,结合persist就可以实现更强大的记忆功能.今天的这个增强组件实际把这个功能给包装了一下,内部实现细节仍然没有变.只需要把reducer用这个增强组件包装一下就可以用了. redux undo/redo 提示:你可以使用redux-undo-boilerplate来开始项目. Installation1npm install --save redux-undo API123import undoable from 'redux-undo';undoable(reducer)undoable(reducer, config) 让你的reducers变得可以重做redux-undo是一个reducer增强组件,它提供了undoable函数,这个函数接收已经存在的reducer和配置对象,使用undo函数增强已经存在的reducer. 注意：如果在state.counter之前接入,你必须要在包装reducer之后接入state.coutner.present. 首先导入redux-undo1234 // Redux utility functions import &#123; combineReducers &#125; from 'redux';// redux-undo higher-order reducer import undoable from 'redux-undo'; 接着,添加undoable到你的reducer123combineReducers(&#123; counter: undoable(counter)&#125;) 配置项想这样传递12345combineReducers(&#123; counter: undoable(counter, &#123; limit: 10 // set a limit for the history &#125;)&#125;) 历史API使用reducer包装你的reducer想这样12345 &#123; past: [...pastStatesHere...], present: &#123;...currentStateHere...&#125;, future: [...futureStatesHere...]&#125; 现在你可以使用state.present获取当前的state获取所有过去的state使用state.past. Undo/Redo Actions首先导入undo/redo action creators1import &#123; ActionCreators &#125; from 'redux-undo'; 然后就可以使用store.dispatch()和undo/redo action creators来执行undo/redo操作.12345store.dispatch(ActionCreators.undo()) // undo the last action store.dispatch(ActionCreators.redo()) // redo the last action store.dispatch(ActionCreators.jumpToPast(index)) // jump to requested index in the past[] array store.dispatch(ActionCreators.jumpToFuture(index)) // jump to requested index in the future[] array 配置配置对象传递给undoable()(值是默认值) 123456789101112131415161718192021undoable(reducer, &#123; limit: false, // set to a number to turn on a limit for the history filter: () =&gt; true, // see `Filtering Actions` section undoType: ActionTypes.UNDO, // define a custom action type for this undo action redoType: ActionTypes.REDO, // define a custom action type for this redo action jumpToPastType: ActionTypes.JUMP_TO_PAST, // define custom action type for this jumpToPast action jumpToFutureType: ActionTypes.JUMP_TO_FUTURE, // define custom action type for this jumpToFuture action initialState: undefined, // initial state (e.g. for loading) initTypes: ['@@redux/INIT', '@@INIT'] // history will be (re)set upon init action type initialHistory: &#123; // initial history (e.g. for loading) past: [], present: config.initialState, future: [] &#125;, debug: false, // set to `true` to turn on debugging &#125;) 过滤Actions如果你不想包含每一步的action,可以传递一个函数到undoable123456789undoable(reducer, function filterActions(action, currentState, previousState) &#123; return action.type === SOME_ACTION; // only add to history if action is SOME_ACTION只有some_action的action才能记录 &#125;) // or you could do... undoable(reducer, function filterState(action, currentState, previousState) &#123; return currentState !== previousState; // only add to history if state changed只有state变化的才能记录重做 &#125;) 或者你可以使用distinctState,includeAction,excludeAction助手函数1import undoable, &#123; distinctState, includeAction, excludeAction &#125; from 'redux-undo'; 现在你可以使用助手函数了,相当简单123456undoable(reducer, &#123; filter: includeAction(SOME_ACTION) &#125;)undoable(reducer, &#123; filter: excludeAction(SOME_ACTION) &#125;) // or you could do... undoable(reducer, &#123; filter: distinctState() &#125;) 甚至还支持数组12 undoable(reducer, &#123; filter: includeAction([SOME_ACTION, SOME_OTHER_ACTION]) &#125;)undoable(reducer, &#123; filter: excludeAction([SOME_ACTION, SOME_OTHER_ACTION]) &#125;) 有什么魔法？怎么工作的Redux文档中的实现Undo历史的方案解释了redux-undo工作的具体细节.]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用React,Redux,redux-sage构建图片库(翻译)]]></title>
    <url>%2F2017%2F04%2F04%2F%E4%BD%BF%E7%94%A8React-Redux-redux-sage%E6%9E%84%E5%BB%BA%E5%9B%BE%E7%89%87%E5%BA%93-%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[看到这篇文章build an image gallery using redux saga，觉得写的不错，长短也适中. 文后有注释版的github代码库,请使用comment分枝. Flickr API可能需要有fQ的基本能力.可以使用google的翻译作为参考，这篇文章google翻译版的中文水平让我吃了一惊.翻译已经完成. ###使用React,Redux和reudx-saga构建一个图像浏览程序(翻译)Joel Hooks ,2016年3月 #####构建一个图片长廊 图像长廊是一个简单的程序，从Flicker API 加载图片URLs,允许用户查看图片详情。 后续我们会使用React,Redux和redux-saga.React作为核心框架，优势是虚拟dom(virtual-dom)的实现。Redux在程序内负责state的管理。最后，我们会使用redux-saga来执行javascript的异步操作步骤。 我们会使用ES6(箭头函数，模块，和模板字符串)，所以我们首先需要做一些项目的配置工作。 #####项目配置和自动化 如果要开始一个React项目，须有有一系列的配置选项。对于一个简单的项目，我想把配置选项尽可能缩减。考虑到浏览器的版本问题，使用Babel把ES6编译为ES5。 首先使用npm init 创建一个package.json文件 package.json123456789101112131415161718192021222324252627282930313233343536 &#123; "name": "egghead-react-redux-image-gallery", "version": "0.0.1", "description": "Redux Saga beginner tutorial", "main": "src/main.js", "scripts": &#123; "test": "babel-node ./src/saga.spec.js | tap-spec", "start": "budo ./src/main.js:build.js --dir ./src --verbose --live -- -t babelify" &#125;, "repository": &#123; "type": "git", "url": "git+https://github.com/joelhooks/egghead-react-redux-image-gallery.git" &#125;, "author": "Joel Hooks &lt;joelhooks@gmail.com&gt;", "license": "MIT", "dependencies": &#123; "babel-polyfill": "6.3.14", "react": "^0.14.3", "react-dom": "^0.14.3", "react-redux": "^4.4.1", "redux": "^3.3.1", "redux-saga": "^0.8.0" &#125;, "devDependencies": &#123; "babel-cli": "^6.1.18", "babel-core": "6.4.0", "babel-preset-es2015": "^6.1.18", "babel-preset-react": "^6.1.18", "babel-preset-stage-2": "^6.1.18", "babelify": "^7.2.0", "browserify": "^13.0.0", "budo": "^8.0.4", "tap-spec": "^4.1.1", "tape": "^4.2.2" &#125;&#125; 有了package.json, 可以在项目文件夹命令行运行 npm install 安装程序需要的依赖项。 .babelrc 123&#123; "presets": ["es2015", "react", "stage-2"] &#125; 这个文件告诉babel,我们将会使用ES2015(ES6),React以及ES2106的stage-2的一些特征。 package.json有两个标准的script脚本配置：start和test.现在我们想通过start脚本加载程序，start会使用src目录的一些文件，所以西药先创建src文件夹.在src文件夹添加下面的一些文：index.html12345678910111213141516171819 &lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;egghead: React Redux Image Gallery&lt;/title&gt; &lt;link rel="stylesheet" href="styles.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="title"&gt; ![](http://cloud.egghead.io/2G021h3t2K10/download/egghead-logo-head-only.svg) &lt;h3&gt;Egghead Image Gallery&lt;/h3&gt;&lt;/div&gt;&lt;div id="root"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="build.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; main.js 123456789import "babel-polyfill"import React from 'react'import ReactDOM from 'react-dom'ReactDOM.render( &lt;h1&gt;Hello React!&lt;/h1&gt;, document.getElementById('root')); style.css 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 body &#123; font-family: Helvetica, Arial, Sans-Serif, sans-serif; background: white;&#125;.title &#123; display: flex; padding: 2px;&#125;.egghead &#123; width: 30px; padding: 5px;&#125;.image-gallery &#123; width: 300px; display: flex; flex-direction: column; border: 1px solid darkgray;&#125;.gallery-image &#123; height: 250px; display: flex; align-items: center; justify-content: center;&#125;.gallery-image img &#123; width: 100%; max-height: 250px;&#125;.image-scroller &#123; display: flex; justify-content: space-around; overflow: auto; overflow-y: hidden;&#125;.image-scroller img &#123; width: 50px; height: 50px; padding: 1px; border: 1px solid black;&#125; index.html文件加载style.css文件提供一些基本的布局样式，同时也加载build.js文件，这是一个生成出来的文件.main.js是一个最基础的React程序，他在index.html的#root元素中渲染一个h1元素。创建这些文件以后，在项目文件夹中命令行运行npm start。在浏览器打开http://10.11.12.1:9966.就可以看到index.html中渲染的页面 现在我们来构建基础的Gallery React 组件 #####在Gallery中显示一些图片 首先我们需要尽可能快的获得一个可以显示的图片素材.在项目文件夹中创建一个文件Gallery.js Gallery.js 1234567891011121314151617181920212223242526272829303132333435363738 import React, &#123;Component&#125; from 'react'const flickrImages = [ "https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg", "https://farm2.staticflickr.com/1581/25283151224_50f8da511e.jpg", "https://farm2.staticflickr.com/1653/25265109363_f204ea7b54.jpg", "https://farm2.staticflickr.com/1571/25911417225_a74c8041b0.jpg", "https://farm2.staticflickr.com/1450/25888412766_44745cbca3.jpg"];export default class Gallery extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; images: flickrImages, selectedImage: flickrImages[0] &#125; &#125; render() &#123; const &#123;images, selectedImage&#125; = this.state; return ( &lt;div className="image-gallery"&gt; &lt;div className="gallery-image"&gt; &lt;div&gt; &lt;img src=&#123;selectedImage&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className="image-scroller"&gt; &#123;images.map((image, index) =&gt; ( &lt;div key=&#123;index&#125;&gt; &lt;img src=&#123;image&#125;/&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 我们直接在组件中硬编码了一个提供数据的数组，让项目尽快的工作起来.Gallery组件继承Component组件,在构造函数中创建一些组件的出事状态.最后我们利用一些样式标记渲染一下文件。image-scroller元素遍历(map方法)图片数组,生成摘要小图片。 123456789101112 import "babel-polyfill"import React from 'react'import ReactDOM from 'react-dom'+ import Gallery from './Gallery'ReactDOM.render(- &lt;h1&gt;Hello React!&lt;/h1&gt;,+ &lt;Gallery /&gt;, document.getElementById('root')); 到现在，我们使用硬编码的图片URLs(通过fickrImages)数组,第一张图片作为selectedImage.这些属性在Gallery组件的构造函数缺省配置中，通过初始状态(initial)来设定. 接下来在组件中添加一个和组件进行交互操作的方法，方法具体内容是操做setSate. Gallery.js 12345678910111213141516171819202122232425262728293031323334 export default class Gallery extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; images: flickrImages, selectedImage: flickrImages[0] &#125; &#125;+ handleThumbClick(selectedImage) &#123;+ this.setState(&#123;+ selectedImage+ &#125;)+ &#125; render() &#123; const &#123;images, selectedImage&#125; = this.state; return ( &lt;div className="image-gallery"&gt; &lt;div className="gallery-image"&gt; &lt;div&gt; &lt;img src=&#123;selectedImage&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className="image-scroller"&gt; &#123;images.map((image, index) =&gt; (- &lt;div key=&#123;index&#125;&gt;+ &lt;div key=&#123;index&#125; onClick=&#123;this.handleThumbClick.bind(this,image)&#125;&gt; &lt;img src=&#123;image&#125;/&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 在Gallery组件添加handleThumbClick方法,任何元素都可用通过onClick属性调用这个方法.image作为第二个参数传递，元素自身作为第一个参数传递.bind方法传递javascript函数调用上下文对象是非常便捷。 看起来不错!现在我们有了一些交互操作的方法，有点“APP”的意思了。截止目前，我们已经让app运行起来了，接下来要考虑怎么加载远程数据。最容易加载远程数据的地方是一个React组件生命周期方法,我们使用componentDidMount方法,通过他从Flikr API请求并加载一些图片. Gallery.js 1234567891011121314151617181920212223 export default class Gallery extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; images: flickrImages, selectedImage: flickrImages[0] &#125; &#125;+ componentDidMount() &#123;+ const API_KEY = 'a46a979f39c49975dbdd23b378e6d3d5';+ const API_ENDPOINT = `https://api.flickr.com/services/rest/?method=flickr.interestingness.+getList&amp;api_key=$&#123;API_KEY&#125;&amp;format=json&amp;nojsoncallback=1&amp;per_page=5`;+++ fetch(API_ENDPOINT).then((response) =&gt; &#123;+ return response.json().then((json) =&gt; &#123;+ const images = json.photos.photo.map((&#123;farm, server, id, secret&#125;) =&gt; &#123; + return `https://farm$&#123;farm&#125;.staticflickr.com/$&#123;server&#125;/$&#123;id&#125;_$&#123;secret&#125;.jpg`+ &#125;);++ this.setState(&#123;images, selectedImage: images[0]&#125;);+ &#125;)+ &#125;)+ &#125;[...] 我们在Gallery类中添加了一个新的方法,通过React的componentDidMount生命周期方法触发Flickr图片数据的获取。 在React组件运行的不同时间点，组件会调用不同的生命周期函数。在这段代码中，当组件被渲染到DOM中的时间点,componentDidMount函数就会被调用。需要注意的是:Gallery组件只有一次渲染到DOM的机会，所以这个函数可以提供一些初始化图片.考虑到在APP的整个生命周期中,有更多的动态组件的加载和卸载,这可能会造成一些多余的调用和无法考虑到的结果。 我们使用浏览器接口(browser API)的fetch方法执行请求.Fetch返回一个promise对象解析response对象.调用response.json()方法,返回另一个promise对象，这就是我们实际需要的json格式的数据.遍历这个对象以后就可以获取图片的url地址. 坦白讲，这个应用目前还很简单.我们还需要在这里花费更多的时间，还有一些基础的需求需要完成.或许我们应该在promise处理流程中添加错误处理方法,如果图片数据获取成功也需要一些处理逻辑.在这个地方，你需要发挥一些想象力考虑一下更多的逻辑.在生产实践中简单的需求是很少见的.很快,应用中就会添加更多的需求。认证,滚动橱窗,加载不同图片库的能力和图片的设置等等.仅仅这些还远远不够. 我们已经使用React构建了一个加载图片库的程序。接下来我们需要考虑到随着程序功能的添加，到底需要哪些基础的模式.首先考虑到的一个问题就是要把应用的状态(state)控制从Gallery组件中分离出来. 我们通过引入Redux来完成应用的状态管理工作。 #####使用Redux来管理状态 在你的应用中只要使用了setState方法都会让一个组件从无状态变为有状态的组件.糟糕的是这个方法会导致应用中出现一些令人困惑的代码,这些代码会在应用中到处蔓延。 Flux构架来减轻这个问题.Flux把逻辑(logic)和状态(state)迁移到Store中.应用中的动作(Actions)被Dispatch的时候,Stores会做相应的更新.Stores的更新会触发View根据新状态的渲染. 那么我们为什么要舍弃Flux?他竟然还是“官方”构建的.好吧！Redux是基于Flux构架的,但是他有一些独特的优势.下面是Dan Abramov(Redux创建者)的一些话： Redux和Flux没有什么不同.总体来讲他们是相同的构架,但是Redux通过功能组合把Flux使用回调注册的复杂点给屏蔽掉了.两个构架从更本上讲没有什么不同，但是我发现Redux使一些在Flux比较难实现的逻辑更容易实现. Redux文档非常棒.如果你还没有读过代码的卡通教程或者Dan的系列文章.赶快去看看吧！ #####启动Redux 第一件需要做的事事初始化Redux,让他在我们的程序中运行起来.现在不需要做安装工作，刚开始运行npm install的时候已经安装好了依赖项，我们需要做一些导入和配置工作.reducer函数是Redux的大脑. 每当应用分发(或派遣,dispatch)一个操作(action)的时候,reducer函数会接受操作(action)并且依据这个动作(action)创建reducer自己的state.因为reducers是纯函数，他们可以组合到一起，创建应用的一个完整state.让我们在src中创建一个简单的reducer:reducer.js 1234export default function images(state, action) &#123; console.log(state, action) return state;&#125; 一个reducer函数接受两个参数(arguments). [x] state-这个数据代表应用的状态(state).reducer函数使用这个状态来构建一个reducer自己可以管理的状态.如果状态没有发生改变,reducer会返回输入的状态. [x] action-这是触发reducer的事件.Actions通过store派发(dispatch),由reducer处理.action需要一个type属性来告诉reducer怎么处理state. 目前,images reuducer在终端中打印出日志记录，表明工作流程是正常的，可以做接下来的工作了.为了使用reducer，需要在main.js中做一些配置工作:main.js 123456789101112131415161718192021import "babel-polyfill";import React from 'react';import ReactDOM from 'react-dom';import Gallery from './Gallery';+ import &#123; createStore &#125; from 'redux'+ import reducer from './reducer'+ const store = createStore(reducer);+ import &#123;Provider&#125; from 'react-redux';ReactDOM.render(+ &lt;Provider store=&#123;store&#125;&gt; &lt;Gallery /&gt;+ &lt;/Provider&gt;, document.getElementById('root'));&#125; 我们从Redux库中导入createStore组件.creatStore用来创建Redux的store.大多数情况下,我们不会和store直接交互,store在Redux中做幕后管理工作. 也需要导入刚才创建的reducer函数,以便于他可以被发送到store. 我们将通过createStore(reducer)操作，利用reducer来配置应用的store.这个示例仅仅只有一个reducer,但是createStore可以接收多个reducer作为参数.稍后我们会看到这一点. 最后我们导入高度集成化的组件Provider,这个组件用来包装Gallery,以便于我们在应用中使用Redux.我们需要把刚刚创建的store传递给Provider.你也可以不使用Provider,实际上Redux可以不需要React.但是我们将会使用Provider,因为他非常便于使用. 这张图可能有点古怪，但是展示了Redux的一个有意思的地方.所有的reducers接收在应用中的全部actions(动作或操作).在这个例子中我们可以看到Redux自己派发的一个action. #####连接Gallery组件 借助Redux,我们将使用”connected”和“un-connected”组件.一个connected组件被连线到store.connected组件使控制动作事件(controls action event)和store协作起来.通常,一个connected组件有子组件,子组件具有单纯的接收输入和渲染功能，当数据更新时执行调用.这个子组件就是unconnected组件. 提示:当Rect和Redux配合是工作的非常好,但是Redux不是非要和React在一起才能工作.没有React,Redux其实可以和其他框架配合使用. 在应用中需要关联React组件和Redux Store 的时候，react-redux提供了便捷的包装器.我们把react-redux添加进Gallery中,从而使Gallery成为首要的关联组件. Gallery.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 import React, &#123;Component&#125; from 'react'+import &#123;connect&#125; from 'react-redux';-export default class Gallery extends Component &#123;+export class Gallery extends Component &#123; constructor(props) &#123; super(props);+ console.log(props); this.state = &#123; images: [] &#125; &#125; componentDidMount() &#123; const API_KEY = 'a46a979f39c49975dbdd23b378e6d3d5'; const API_ENDPOINT = `https://api.flickr.com/services/rest/?method=flickr.interestingness.getList&amp;api_key=$&#123;API_KEY&#125;&amp;format=json&amp;nojsoncallback=1&amp;per_page=5`; fetch(API_ENDPOINT).then((response) =&gt; &#123; return response.json().then((json) =&gt; &#123; const images = json.photos.photo.map((&#123;farm, server, id, secret&#125;) =&gt; &#123; return `https://farm$&#123;farm&#125;.staticflickr.com/$&#123;server&#125;/$&#123;id&#125;_$&#123;secret&#125;.jpg` &#125;); this.setState(&#123;images, selectedImage: images[0]&#125;); &#125;) &#125;) &#125; handleThumbClick(selectedImage) &#123; this.setState(&#123; selectedImage &#125;) &#125; render() &#123; const &#123;images, selectedImage&#125; = this.state; return ( &lt;div className="image-gallery"&gt; &lt;div className="gallery-image"&gt; &lt;div&gt; &lt;img src=&#123;selectedImage&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className="image-scroller"&gt; &#123;images.map((image, index) =&gt; ( &lt;div key=&#123;index&#125; onClick=&#123;this.handleThumbClick.bind(this,image)&#125;&gt; &lt;img src=&#123;image&#125;/&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;+export default connect()(Gallery) 从react-redux导入connect函数,可以在导出组件的时候把他变为链接组件(connected component).请注意,connect()(Gallery)代码把Gallery组件放在第二个形参中,这是因为connect()返回一个函数，这个函数接受一个React组件作为参数(argument).调用connect()函数时需要配置项.后面我们将会传递配置我们应用的actions和state参数.我们也把connect作为默认配置到处模块.这一点非常重要！现在当我们import Gallery的时候,就不是一个单纯的React组件了,而是一个和Redux关联的组件了. 如果你观察我们添加进构造器的console.log的输出,就可以看到Gallery组件的属性现在包括了一个dispatch函数.这个地方是connect为我们的应用修改的,这个改动赋予了组件把自己的动作对象(action objects)派发到reducers的能力. 123456789 export class Gallery extends Component &#123; constructor(props) &#123; super(props);+ this.props.dispatch(&#123;type: 'TEST'&#125;); this.state = &#123; images: [] &#125; &#125;[...] 我们可以在组件的构造器中调用派发功能.你可以在开发者的终端中看到来自reducer的日志声明.看到声明表示我们已经派发了第一个action!.Actions是一个单一的javascript对象,必需有type属性.Actions可以拥有任意数量和种类的其他属性.但是type可以让reducers理解这些动作到底是做什么用的(意译，意思是只有拥有type属性，reducers才知道对state做什么样的修改). 12345678export default function images(state, action) &#123;- console.log(state, action)+ switch(action.type) &#123;+ case 'TEST':+ console.log('THIS IS ONLY A TEST')+ &#125; return state;&#125; 总的reducers使用switch代码块过滤有关的消息,Switch语句使用actions的type属性,当一个action和case分支吻合以后,相应的单个reducer就会执行他的具体工作. 我们的应用现在关联到接收的动作.现在我们需要把Redux-Store提供的state关联到应用中. ####默认的应用状态(state) reducer.js 123456789101112131415 const defaultState = &#123; images: []&#125;export default function images(state = defaultState, action) &#123; switch(action.type) &#123; case 'TEST':- console.log('THIS IS ONLY A TEST')+ console.log(state, action)+ return state;+ default:+ return state; &#125;- return state;&#125; 我们创建一个defaultState对象,这个对象返回一个空数组作为images的属性.我们把images函数的参数state设置为默认.如果在test分支中输出日志,将会看到state不是undefined(空数组不是undefined)!reducer需要返回应用的当前state.这点很重要!现在我们没有做任何改变,所以仅仅返回state.注意我们在case中添加了default分支,reducer必须要返回一个state. 在Gallery组件中，我们也可以把state做一定的映射(map)以后再连接到应用. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 import React, &#123;Component&#125; from 'react'import &#123;connect&#125; from 'react-redux';export class Gallery extends Component &#123; constructor(props) &#123; super(props); this.props.dispatch(&#123;type: 'TEST'&#125;);+ console.log(props);- this.state = &#123;- images: []- &#125; &#125;- componentDidMount() &#123;- const API_KEY = 'a46a979f39c49975dbdd23b378e6d3d5';- const API_ENDPOINT = `https://api.flickr.com/services/rest/?method=flickr.interestingness.-getList&amp;api_key=$&#123;API_KEY&#125;&amp;format=json&amp;nojsoncallback=1&amp;per_page=5`;--- fetch(API_ENDPOINT).then((response) =&gt; &#123;- return response.json().then((json) =&gt; &#123;- const images = json.photos.photo.map((&#123;farm, server, id, secret&#125;) =&gt; &#123; - return `https://farm$&#123;farm&#125;.staticflickr.com/$&#123;server&#125;/$&#123;id&#125;_$&#123;secret&#125;.jpg`- &#125;);-- this.setState(&#123;images, selectedImage: images[0]&#125;);- &#125;)- &#125;)- &#125;- handleThumbClick(selectedImage) &#123;- this.setState(&#123;- selectedImage- &#125;)- &#125; render() &#123;- const &#123;images, selectedImage&#125; = this.state;+ const &#123;images, selectedImage&#125; = this.props; return ( &lt;div className="image-gallery"&gt; &lt;div className="gallery-image"&gt; &lt;div&gt; &lt;img src=&#123;selectedImage&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className="image-scroller"&gt; &#123;images.map((image, index) =&gt; (- &lt;div key=&#123;index&#125; onClick=&#123;this.handleThumbClick.bind(this,image)&#125;&gt;+ &lt;div key=&#123;index&#125;&gt; &lt;img src=&#123;image&#125;/&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;+function mapStateToProps(state) &#123;+ return &#123;+ images: state.images+ selectedImage: state.selectedImage+ &#125;+&#125;-export default connect()(Gallery)+export default connect(mapStateToProps)(Gallery) ``` ___ 我们将移除连接组件中的所有图片加载和交互逻辑代码,如果你注意看`Gallery`组件的底部代码,你会注意到，我们创建了一个`mapStateToProps`函数,接收一个`state`作为参数,返回一个对象,把`state.images`映射为`images`属性.`mapStateToProps`做为参数传递给`connect`. 正如名字暗示的一样,`mapStateToProps`函数接收当前应用的state,然后把state转变为组件的属性(propertys).如果在构造器中输出props,将会看到images数组是`reducer`返回的默认state. const defaultState = { images: [] images: [ “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg“, “https://farm2.staticflickr.com/1581/25283151224_50f8da511e.jpg“, “https://farm2.staticflickr.com/1653/25265109363_f204ea7b54.jpg“, “https://farm2.staticflickr.com/1571/25911417225_a74c8041b0.jpg“, “https://farm2.staticflickr.com/1450/25888412766_44745cbca3.jpg“ ], selectedImage: “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg“} export default function images(state = defaultState, action) { switch(action.type) { case ‘TEST’: console.log(state, action) return state; default: return state; }} 1234567___如果在`defaultState`中更新images数组,你将可以看到一些图片重新出现在gallery中!现在当用户点击缩略图的时候,我们可以反馈选择动作,返回对应的大图.####更新state怎么操作才能根据新选择的图片更新state?需要配置reducer监听`IMAGE_SELECTED`动作,借助action携带的信息(payload,有的文章翻译为载荷,载荷怎么理解？手机载荷就是声音，短信和流量数据。如果是卡车就是拉的货物,如果是客车就乘载的乘客,action的载荷就是要让reducer明白你要干什么，需要什么)来更新state. const defaultState = { images: [ “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg“, “https://farm2.staticflickr.com/1581/25283151224_50f8da511e.jpg“, “https://farm2.staticflickr.com/1653/25265109363_f204ea7b54.jpg“, “https://farm2.staticflickr.com/1571/25911417225_a74c8041b0.jpg“, “https://farm2.staticflickr.com/1450/25888412766_44745cbca3.jpg“ ], selectedImage: “https://farm2.staticflickr.com/1553/25266806624_fdd55cecbc.jpg“} export default function images(state = defaultState, action) { switch(action.type) { case ‘TEST’:case ‘IMAGE_SELECTED’: return state; return {…state, selectedImage: action.image};default:return state;}} 12___现在reducer已经准备接收`IMAGE_SELECTED` action了.在`IMAGE_SELECTED`分支选项内,我们在展开(spreading,ES6的对象操作方法),并重写`selectedImage`属性后,返回一个新state对象.了解更多的`...state`对象操作可以看`ruanyifeng`的书. import React, {Component} from ‘react’import {connect} from ‘react-redux’; export class Gallery extends Component { constructor(props) { super(props); this.props.dispatch({type: ‘TEST’}); console.log(props); }render() { const {images, selectedImage} = this.props; const {images, selectedImage, dispatch} = this.props; return ( &lt;div&gt; &lt;img src={selectedImage} /&gt; &lt;/div&gt; {images.map((image, index) =&gt; ( dispatch({type:’IMAGE_SELECTED’, image})}&gt; ))})}} function mapStateToProps(state) { return { images: state.images, selectedImage: state.selectedImage }} export default connect(mapStateToProps)(Gallery) 12345678 ___ 在`Gallery`组件中,我们将会在组件的属性中定义`dispatch`在`onClick`函数体中调用他,现在我们从便利角度考虑把他们放在一起,但是两者功能是一样的.一旦我们点击了缩略图,他将会通过reducer更新大图.使用dispatch可以很方便的创建通用actions,但是很快我们会需要重用命名好的actions.为了这样做,可以使用”action creators”.####Action CreatorsAction creators函数返回配置好的action对象.我们在`action.js`中添加第一个action creator.action.js export const IMAGE_SELECTED = ‘IMAGE_SELECTED’; export function selectImage(image) { return { type: IMAGE_SELECTED, image }} 1234___这个方法经过export以后,可以直接在任何需要创建`selectImage` action地方导入!`selectImage`是纯函数，只能返回数据.他接收一个image作为参数,把image添加到action对象中，并返回.&gt;注意:我们正在返回一个单纯的javascript object,但是`image`的属性可能很古怪，如果你以前没有碰到这样的样式.从ES6的角度出发,如果你给一个对象传递一个类似这样的属性,隐含的意思是把`image:'任何image包含的值'`添加到最终返回的对象.超级好用! import * as GalleryActions from ‘./actions.js’;[…]onClick={() =&gt; dispatch(GalleryActions.selectImage(image))} 1234___this isn’t much than just using `dispatchti` though.幸运的是,这个模式很普遍,Redux在`bindActionCreators`函数里提供了一个更好的办法来完成这个功能. import React, {Component} from ‘react’import {connect} from ‘react-redux’; import {bindActionCreators} from ‘redux’; import * as GalleryActions from ‘./actions.js’; export class Gallery extends Component { constructor(props) { super(props); this.props.dispatch({type: ‘TEST’}); console.log(props); } handleThumbClick(selectedImage) { this.setState({ selectedImage }) } render() { const {images, selectedImage, dispatch} = this.props; const {images, selectedImage, selectImage} = this.props;return ( &lt;div&gt; &lt;img src={selectedImage} /&gt; &lt;/div&gt; {images.map((image, index) =&gt; ( dispatch({type:’IMAGE_SELECTED’, image})}&gt; selectImage(image)}&gt; ))})}} function mapStateToProps(state) { return { images: state.images, selectedImage: state.selectedImage }} +function mapActionCreatorsToProps(dispatch) { return bindActionCreators(GalleryActions, dispatch);+} -export default connect(mapStateToProps)(Gallery)+export default connect(mapStateToProps, mapActionCreatorsToProps)(Gallery) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 ___ 我们已经添加了`mapActionCreatorsToProps`函数,他接收`dispatch`函数作为参数.返回`bindActionCreators`的调用结果,`GalleryActions`作为`bindActionCreators`的参数.现在如果你输出属性日志,就看不到`dispatch`作为参数,`selectImage`直接可以使用了.(这里相当于对dispatch和action进行了包装). 现在回顾一下,我们做了几件事: - 创建了一个reducer包含应用的默认初始状态(initial state),并且监听actions的执行. - 创建了一个store,把reducer具体化,提供一个分发器(dispatcher)可以分发action. - 把我们的Gallery组件关联到store的state. - 把store的state映射为属性(property)，传递给Gallery. - 映射一个动作创建器,Gallery可以简单的调用`selectImage(image)`,分发动作,应用状态将会更新.那么，我们怎么才能使用这些模式从远程资源加载数据呢？这个过程将会非常有趣!####异步活动？---你可能在参加函数式编程的时候听说过”副作用”(side effects)这个名词,side effects是发生在应用的范围之外的东西.在我们舒适的肥皂泡里,side effect根本不是问题,但是当我们要到达一个远程资源,肥皂泡就被穿透了.有些事情我们就控制不了了,我们必须接受这个事实.(根据这段话，side effect 翻译为意想不到的事情，出乎意料的不受控制的事情更好)在Redux里,reducer没有Side effects.这意味着reducers不处理我们应用中的异步活动.我们不能使用reducers加载远程数据,因为reducers是纯函数,没有side effects.Redux很棒,如果你的应用里没有任何异步活动，你可以停下来,不用再往下看了.如果你创建的应用比较大,可能你会从服务端加载数据,这时,当然要使用异步方式.&gt;**注意**： Redux其中一个最酷的地方是他非常小巧.他试图解决有限范围内的问题.大多数的应用需要解决很多问题!万幸,Reduc提供中间件概念,中间件存在于action-&gt;reducer-&gt;store的三角关系中,通过中间件的方式,可以导入诸如远程数据异步加载类似的功能.其中一个方法是使用`thunks`对象,在Redux中有 redux-thunk 中间件.Thunks非常厉害，但是可能会导致actions的序列很复杂,测试起来也是很大的挑战.考虑到我们的 图片浏览程序.当应用加载是,需要做:- 从服务器请求图片数组- 当图片加载完毕,显示提示消息- 当远程数据返回以后,选择初始图片显示- 处理可能出现的错误这些事件都要在用户点击应用里的任何元素之前完成!我们该怎么做呢？redux-saga就是为此而诞生,为我们的应用提供绝佳的服务.redux-sage___redux-sage可以在Redux应用中操作异步actions.他提供中间件和趁手的方法使构建复杂的异步操作流程轻而易举.一个saga是一个Generator(生成器),Generator函数是ES2015新添加的特性.可能是你第一次遇到Generator函数,这样你会觉得有点古怪,可以参考(ruanyifeng文章).不要苦恼，如果你对此仍然很抓耳挠腮.使用redux-sage你不需要javascript异步编程的博士学位.因为使用了generators的缘故,我们能创建一个顺序执行的命令序列，用来描述复杂的异步操作流程(workflows).整个图片的加载流程序列如下： export function* loadImages() { try { const images = yield call(fetchImages); yield put({type: ‘IMAGES_LOADED’, images}) yield put({type: ‘IMAGE_SELECTED’, image: images[0]}) } catch(error) { yield put({type: ‘IMAGE_LOAD_FAILURE’, error}) }} export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield call(loadImages); }} 123456 ___ ####第一个saga我们将开始一个简单的saga实例,然后配置他连接到我们的应用.在`src`创建一个文件`saga.js` export function* sayHello() { console.log(‘hello’);} 1234___我们的saga是一个简单的generator函数.函数后面的`*`作为标志,他也被叫做”super star”.现在在`main.js`文件中导入新函数,并且执行他. import “babel-polyfill”; import React from ‘react’;import ReactDOM from ‘react-dom’; import Gallery from ‘./Gallery’; import { createStore } from ‘redux’import {Provider} from ‘react-redux’;import reducer from ‘./reducer’ +import {sayHello} from ‘./sagas’;+sayHello(); const store = createStore(reducer); ReactDOM.render( , document.getElementById(‘root’)); 1234567___不管你盯住终端多长时间,“hello”永远不会出现.这是因为`sayHello`是一个generator！Generator 不会立即执行.如果你把代码该为`sayHello().next();`你的“hello”就出现了.不用担心,我们不会总是调用`next`.正如Redux,redux-saga用来消除应用开发中的痛苦.配置 redux-sage___ import “babel-polyfill”; import React from ‘react’;import ReactDOM from ‘react-dom’; import Gallery from ‘./Gallery’; -import { createStore } from ‘redux’+import { createStore, applyMiddleware } from ‘redux’+import createSagaMiddleware from ‘redux-saga’import {Provider} from ‘react-redux’;import reducer from ‘./reducer’ import {sayHello} from ‘./sagas’;-sayHello() -const store = createStore(reducer);+const store = createStore( reducer, applyMiddleware(createSagaMiddleware(sayHello))+); ReactDOM.render( , document.getElementById(‘root’)); 123456789 ___ 我们已从Redux导入了`applyMiddleware`函数.从redux-saga导入`createSagaMiddleware`函数.当我们创建store的时候,我们需要通过中间件提供Redux需要的功能.在这个实例中,我们会调用`applyMiddleware`函数,这个函数返回`createSagaMiddleware(sayHello)`的结果.在幕后,redux-saga加载`sayHello`函数,仪式性的调用`next`函数. 应该可以在终端中看到提示消息了. 现在让我们构建加载图片的saga ####通过Saga加载图片数据___我们将删除出sayHello saga,使用`loadImages` saga -export function* sayHello() { console.log(‘hello’);-} +export function* loadImages() { console.log(‘load some images please’)+}12___不要忘了更新`main.js` import “babel-polyfill”; import React from ‘react’;import ReactDOM from ‘react-dom’; import Gallery from ‘./Gallery’; import { createStore, applyMiddleware } from ‘redux’import {Provider} from ‘react-redux’;import createSagaMiddleware from ‘redux-saga’import reducer from ‘./reducer’ -import {sayHello} from ‘./sagas’;+import {loadImages} from ‘./sagas’; const store = createStore( reducer, applyMiddleware(createSagaMiddleware(sayHello)) applyMiddleware(createSagaMiddleware(loadImages))); ReactDOM.render( , document.getElementById(‘root’)); 12___现在saga已经加载,在`saga.js`中添加`fetchImages`方法 const API_KEY = &apos;a46a979f39c49975dbdd23b378e6d3d5&apos;; const API_ENDPOINT = https://api.flickr.com/services/rest/?method=flickr.interestingness.getList&amp;api_key=${API_KEY}&amp;format=json&amp;nojsoncallback=1&amp;per_page=5; const fetchImages = () =&gt; { return fetch(APIENDPOINT).then(function (response) { return response.json().then(function (json) { return json.photos.photo.map( ({farm, server, id, secret}) =&gt; `https://farm${farm}.staticflickr.com/${server}/${id}${secret}.jpg` ); }) })}; export function* loadImages() { const images = yield fetchImages(); console.log(images)} 123456789___ `fetchImages`方法返回一个promise对象.我们将调用`fetchImages`,但是现在我们要使用`yield`关键字.通过黑暗艺术和巫术,generators理解Promise对象,正如终端输出的日志显示,我们已经收获了一个图片URLs的数组.看看`loadImages`的代码,他看起来像是典型的同步操作代码.`yield`关键字是秘制调味酱,让我们的代码用同步格式执行异步操作活动. ___ ####封装我们的异步API请求. 首先来定义一下需要使用的api.他没有什么特殊的地方,实际上他和早先加载Flickr images的代码是相同的.我们创建`flickr.js`文件 const API_KEY = ‘a46a979f39c49975dbdd23b378e6d3d5’;const API_ENDPOINT = https://api.flickr.com/services/rest/?method=flickr.interestingness.getList&amp;api_key=${API_KEY}&amp;format=json&amp;nojsoncallback=1&amp;per_page=5; export const fetchImages = () =&gt; { return fetch(APIENDPOINT).then(function (response) { return response.json().then(function (json) { return json.photos.photo.map( ({farm, server, id, secret}) =&gt; `https://farm${farm}.staticflickr.com/${server}/${id}${secret}.jpg` ); }) })}; 123456 ___ 严格意义上来说,不需要这么做,但是这会带来一定的好处.我们处在应用的边缘(boundaries of our application,意思是说在这里的代码可能是很多和远程服务器交互的代码，可能逻辑会很复杂),事情都有点乱.通过封装和远程API交互的逻辑,我们的代码将会很整洁,很容易更新.如果需要抹掉图片服务也会出奇的简单.我们的`saga.js`看起来是这个样子： import {fetchImages} from ‘./flickr’; export function* loadImages() { const images = yield fetchImages(); console.log(images)}1234567___我们仍然需要在saga外获取数据,并且进入应用的state(使用异步获取的远程数据更新state).为了处理这个问题,我们将使用”effects”.####从saga来更新应用我们可以通过`dispatch`或者store作为参数来调用saga,但是这个方法时间一长就会给人造成些许的困扰.我们选择采用redux-saga提供的`put`方法.首先我们更新`reducer.js`操作一个新的action类型`IMAGES_LOADED`. const defaultState = { images: []} export default function images(state = defaultState, action) { switch(action.type) { case ‘IMAGE_SELECTED’: return {…state, selectedImage: action.image}; case ‘IMAGES_LOADED’: return {…state, images: action.images};default:return state;}} 1234___我们添加了新的分支,并从`defaultState`中删除了硬编码的URLs数据.`IMAGES_LOADED`分支现在返回一个更新的state,包含action的image数据.下一步我们更新saga: import {fetchImages} from ‘./flickr’;+import {put} from ‘redux-saga/effects’; export function* loadImages() { const images = yield fetchImages(); yield put({type: ‘IMAGES_LOADED’, images})}12345678___导入`put`以后,我们在`loadImages`添加另外一行.他`yield` `put`函数调用的返回结果.在幕后,redux-saga 分发这些动作,reducer接收到了消息! 怎样才能使用特定类型的action来触发一个saga? ####使用actions来触发saga工作流___Sagas变得越来越有用,因为我们有能力使用redux actions来触发工作流.当我们这样做,saga会在我们的应用中表现出更大的能力.首先我们创建一个新的saga.`watchForLoadImages`. import {fetchImages} from ‘./flickr’;-import {put} from ‘redux-saga/effects’;+import {put, take} from ‘redux-saga/effects’; export function* loadImages() { const images = yield fetchImages(); yield put({type: ‘IMAGES_LOADED’, images})} +export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield loadImages(); }+} 12 ___新的saga使用的是while来保持一直激活和等待调用状态.在循环的内部,我们生成(yield)一个redux-sage调用方法:`take`.Take方法监听任何类型的actions,他也会使saga接受下一个yield.在上面的例子中我们调用了一个方法`loadImages`,初始化图片加载. import “babel-polyfill”; import React from ‘react’;import ReactDOM from ‘react-dom’; import Gallery from ‘./Gallery’; import { createStore, applyMiddleware } from ‘redux’import {Provider} from ‘react-redux’;import createSagaMiddleware from ‘redux-saga’import reducer from ‘./reducer’ -import {loadImages} from ‘./sagas’;+import {loadImages} from ‘./watchForLoadImages’; const store = createStore( reducer, applyMiddleware(createSagaMiddleware(loadImages)) applyMiddleware(createSagaMiddleware(watchForLoadImages))); ReactDOM.render( , document.getElementById(‘root’));12___更新了`main.js`以后,应用不再加载图片,我们需要在action creators中添加`loadImages`的`action`. export const IMAGE_SELECTED = ‘IMAGE_SELECTED’;+const LOAD_IMAGES = ‘LOAD_IMAGES’; export function selectImage(image) { return { type: IMAGE_SELECTED, image }} +export function loadImages() { return { type: LOAD_IMAGES }+}1234567___因为我们已经绑定了action creators(Action创建器),我们只需要在`Gallery`组件中调用这个action就可以了.####block(阻塞)和no-blocking(非阻塞)效应现在我们的引用工作的足够好了,但是可能还有更多的问题需要考虑.`watchForLoadImages` saga包含 block effects.那么这到底是什么意思呢？这意味着在工作流中我们只能执行一次`LOAD_IMAGES`!在诸如我们现在构建的小型应用一样,这一点不太明显,实际上我们也仅仅加载了一次图片集.实际上，普遍的做法是使用`fork` effect 代替 `yield` 来加载图片. export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield loadImages(); yield fork(loadImages); //be sure to import it!}}12345___使用`fork`助手(helper)函数,`watchForLoadImages`就变成了非阻塞saga了,再也不用考虑他是不是以前掉用过.redux-sagas 提供两个helpers,`takeEvery`和`takeLastest`（takeEvery监听多次action，不考虑是不是同一种action type,takeLatest只处理同一种action type的最后一次调用）.####选择默认的图片Sagas按照队列来执行acitons,所以添加更多的saga也很容易. import {fetchImages} from ‘./flickr’;import {put, take, fork} from ‘redux-saga/effects’; export function* loadImages() { const images = yield fetchImages(); yield put({type: ‘IMAGES_LOADED’, images}) yield put({type: ‘IMAGE_SELECTED’, image: images[0]})} export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield fork(loadImages); }}1234___在 `loadImages`工作流上,我们可以yield put函数调用,action type是`IMAGE_SELECTED`.发送我们选择的图片(在这个例子中，发送的仅仅是图片的url的字符串).####错误处理如果在saga循环内部出现错误,我们要考虑提醒应用做出合理的回应.所有流程包装到try/catch语句块里就可以实现,捕获错误以后`put`一个提示信息作为`IMAGE_LOAD_FAILURE` action的内容. import {fetchImages} from ‘./flickr’;import {put, take, fork} from ‘redux-saga/effects’; export function* loadImages() { try { const images = yield fetchImages(); yield put({type: ‘IMAGES_LOADED’, images}) yield put({type: ‘IMAGE_SELECTED’, image: images[0]}) } catch(error) { yield put({type: ‘IMAGE_LOAD_FAILURE’, error}) }} export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield fork(loadImages); }}1234567___####Sagas的测试___在应用中使用Redux,测试变得相当的舒服. 看看我们的[鹅蛋头系列课程](https://egghead.io/series/react-testing-cookbook),可以了解到很多React的测试技术.使用Redux-saga在棒的一个方面就是异步代码测试很容易.测试javascript异步代码真是一件苦差事.有了saga,我们不需要跳出引用的核心代码.Saga把javascript的痛点都抹掉了.是不是意味着我们要写更多的测试?对的.我们会使用`tape`组件,首先做一些配置工作. import test from ‘tape’;import {put, take} from ‘redux-saga/effects’import {watchForLoadImages, loadImages} from ‘./sagas’;import {fetchImages} from ‘./flickr’; test(‘watchForLoadImages’, assert =&gt; { const generator = watchForLoadImages(); assert.end();});12___添加所有需要的组件,现在我们添加一个测试.这个测试接收一个名称和一个函数作为形参.在测试的函数体内部代码块,我们创建了一个saga生成器代码实例.在这个实例里面我们尅是测试saga的每一个动作. import test from ‘tape’;import {put, take} from ‘redux-saga/effects’import {watchForLoadImages, loadImages} from ‘./sagas’;import {fetchImages} from ‘./flickr’; test(‘watchForLoadImages’, assert =&gt; { const generator = watchForLoadImages(); assert.deepEqual( generator.next().value, false, ‘watchForLoadImages should be waiting for LOAD_IMAGES action’ ); assert.end();}); 123___`assert.deepEqual`方法接收两个值,检查一下他们是不是深度相同(js对象的概念).第一行代码是`generator.next().value`的调用,这个调用使生成器从暂停中恢复,得到值.下一个值单单是一个`false`.我想看到他失败,最后一个参数描述了测试期待的行为.在项目文件夹中命令行运行`npm test`看看结果: import test from ‘tape’;import {put, take} from ‘redux-saga/effects’import {watchForLoadImages, loadImages} from ‘./sagas’;import {fetchImages} from ‘./flickr’; test(‘watchForLoadImages’, assert =&gt; { const generator = watchForLoadImages(); assert.deepEqual( generator.next().value, false, ‘watchForLoadImages should be waiting for LOAD_IMAGES action’ ); assert.end();}); 12___测试结果和预期的一样失败,结果有点意思.实际的结论是`&#123;TAKE:'LOAD_IMAGES'&#125;`,这是我们调用`take('LOAD_IMAGES')`受到的结果.实际上,我们的saga’可以yield一个对象来代替调用`take`.但是`take`添加了一些代码,让我们少敲些代码. import test from ‘tape’;import {put, take} from ‘redux-saga/effects’import {watchForLoadImages, loadImages} from ‘./sagas’;import {fetchImages} from ‘./flickr’; test(‘watchForLoadImages’, assert =&gt; { const generator = watchForLoadImages(); assert.deepEqual( generator.next().value, false take(‘LOAD_IMAGES’),‘watchForLoadImages should be waiting for LOAD_IMAGES action’); assert.end();}); 12___我们简单的调用`take`函数,就可以得到期待的结果了. import test from ‘tape’;import {put, take} from ‘redux-saga/effects’import {watchForLoadImages, loadImages} from ‘./sagas’;import {fetchImages} from ‘./flickr’; test(‘watchForLoadImages’, assert =&gt; { const generator = watchForLoadImages(); assert.deepEqual( generator.next().value, take(‘LOAD_IMAGES’), ‘watchForLoadImages should be waiting for LOAD_IMAGES action’ ); assert.deepEqual( gen.next().value, false, ‘watchForLoadImages should call loadImages after LOAD_IMAGES action is received’ ); assert.end();}); 1234___下一个测试使我们确信`loadImages`saga在流程的下一个阶段会被自动调用.我们需要一个 false来检查结果.更新一下saga代码,yield一个`loadImages` saga: export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield loadImages(); yield fork(loadImages); //be sure to import it!}}12___现在运行测试,将会看到下面结果： ✖ watchForLoadImages should call loadImages after LOAD_IMAGES action is received operator: deepEqual expected: |- false actual: |- { _invoke: [Function: invoke] }1234___哼！`&#123; _invoke: [Function: invoke] &#125;`绝对不是我们yield take想要的结果.有问题.幸运的是redux-saga可以使用诸如`fork`一样的`effects`来解决这个问题.`fork`,`take`和其他的effect方法返容易满足测试要求的简单对象.这些effects返回的对象是一个指导redux-saga进行任务执行的集合.这一点对于测试来说非常的优雅,因为我们不用担心类似远程服务请求的副作用.有了redux-saga,我们把注意点放到请求执行的命令上.下面让我们更新一下saga,再一次使用`fork`. export function* watchForLoadImages() { while(true) { yield take(‘LOAD_IMAGES’); yield loadImages(); yield fork(loadImages); }} 1234___这里使用`yield fork(loadImages)`直接代替`loadImages`.需要注意的是我们还没有执行`loadImages`,而是作为参数传递给`fork`.再次运行`npm test`. ✖ watchForLoadImages should call loadImages after LOAD_IMAGES action is received operator: deepEqual expected: |- false actual: |- { FORK: { args: [], context: null, fn: [Function: loadImages] } }12___结果得到了一个单纯对象而不是一个函数调用.函数在浏览器端也同时加载了,但是我们现在可以轻松的在saga 工作流里测试这个步骤. import test from ‘tape’;import {put, take} from ‘redux-saga/effects’import {watchForLoadImages, loadImages} from ‘./sagas’;import {fetchImages} from ‘./flickr’; test(‘watchForLoadImages’, assert =&gt; { const generator = watchForLoadImages(); assert.deepEqual( generator.next().value, take(‘LOAD_IMAGES’), ‘watchForLoadImages should be waiting for LOAD_IMAGES action’ ); assert.deepEqual( generator.next().value, false, yield fork(loadImages),‘watchForLoadImages should call loadImages after LOAD_IMAGES action is received’); assert.end();}); 12___测试`loadImages`saga是一样的,只需要把`yield fetchImages`更新为`yield fork(fetchImages)`. test(‘loadImages’, assert =&gt; { const gen = loadImages(); assert.deepEqual( gen.next().value, call(fetchImages), ‘loadImages should call the fetchImages api’ ); const images = [0]; assert.deepEqual( gen.next(images).value, put({type: ‘IMAGES_LOADED’, images}), ‘loadImages should dispatch an IMAGES_LOADED action with the images’ ); assert.deepEqual( gen.next(images).value, put({type: ‘IMAGE_SELECTED’, image: images[0]}), ‘loadImages should dispatch an IMAGE_SELECTED action with the first image’ ); const error = ‘error’; assert.deepEqual( gen.throw(error).value, put({type: ‘IMAGE_LOAD_FAILURE’, error}), ‘loadImages should dispatch an IMAGE_LOAD_FAILURE if an error is thrown’ ); assert.end();});``` 特别注意最后一个assert.这个断言测试使用异常捕获代替生成器函数的next方法.另一个非常酷的地方是：可以传值.注意看代码,我们创建了images常量,并且传递到next函数.saga可以在接下来的任务序列中使用传递的值. 太棒了,这种方法是测试异步编程的程序员梦寐以求的技术. #####接下来做什么？ 你可以fork一下这个例子的代码. 如果你想扩充这个应用,可以做一下几个方面的工作. 做一个幻灯显示下一张要显示的图片 允许使用者搜索Flickr图片 添加其他提供图片的API 允许用户选择喜欢的API进行搜索. 我们仅仅和生成器碰了一下面,但是即便如此,希望在联合使用redux-saga library,Redux和React的时候给你一些帮助.]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Redux</tag>
        <tag>saga</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Immutable-collections]]></title>
    <url>%2F2017%2F03%2F22%2FImmutable%20collections%20for%20JavaScript%20copy%2F</url>
    <content type="text"><![CDATA[Immutable collections for JavaScript Immutable data cannot be changed once created, leading to much simplerapplication development, no defensive copying, and enabling advanced memoizationand change detection techniques with simple logic. Persistent data presentsa mutative API which does not update the data in-place, but instead alwaysyields new updated data. Immutable.js provides many Persistent Immutable data structures including:List, Stack, Map, OrderedMap, Set, OrderedSet and Record. These data structures are highly efficient on modern JavaScript VMs by usingstructural sharing via hash maps tries and vector tries as popularizedby Clojure and Scala, minimizing the need to copy or cache data. Immutable also provides a lazy Seq, allowing efficientchaining of collection methods like map and filter without creatingintermediate representations. Create some Seq with Range and Repeat. Want to hear more? Watch the presentation about Immutable.js: Getting startedInstall immutable using npm. 1npm install immutable Then require it into any module. 12345var Immutable = require('immutable');var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var map2 = map1.set('b', 50);map1.get('b'); // 2map2.get('b'); // 50 BrowserTo use immutable from a browser, download dist/immutable.min.jsor use a CDN such as CDNJSor jsDelivr. Then, add it as a script tag to your page: 1234567&lt;script src="immutable.min.js"&gt;&lt;/script&gt;&lt;script&gt; var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;); var map2 = map1.set('b', 50); map1.get('b'); // 2 map2.get('b'); // 50&lt;/script&gt; Or use an AMD loader (such as RequireJS): 123456require(['./immutable.min.js'], function (Immutable) &#123; var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;); var map2 = map1.set('b', 50); map1.get('b'); // 2 map2.get('b'); // 50&#125;); If you’re using browserify, the immutable npm modulealso works from the browser. TypeScriptUse these Immutable collections and sequences as you would use nativecollections in your TypeScript programs while still takingadvantage of type generics, error detection, and auto-complete in your IDE. Just add a reference with a relative path to the type declarations at the topof your file. 1234567///&lt;reference path='./node_modules/immutable/dist/immutable.d.ts'/&gt;import Immutable = require('immutable');var map1: Immutable.Map&lt;string, number&gt;;map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var map2 = map1.set('b', 50);map1.get('b'); // 2map2.get('b'); // 50 The case for ImmutabilityMuch of what makes application development difficult is tracking mutation andmaintaining state. Developing with immutable data encourages you to thinkdifferently about how data flows through your application. Subscribing to data events throughout your application creates a huge overhead ofbook-keeping which can hurt performance, sometimes dramatically, and createsopportunities for areas of your application to get out of sync with each otherdue to easy to make programmer error. Since immutable data never changes,subscribing to changes throughout the model is a dead-end and new data can onlyever be passed from above. This model of data flow aligns well with the architecture of Reactand especially well with an application designed using the ideas of Flux. When data is passed from above rather than being subscribed to, and you’re onlyinterested in doing work when something has changed, you can use equality. Immutable collections should be treated as values rather than objects. Whileobjects represent some thing which could change over time, a value representsthe state of that thing at a particular instance of time. This principle is mostimportant to understanding the appropriate use of immutable data. In order totreat Immutable.js collections as values, it’s important to use theImmutable.is() function or .equals() method to determine value equalityinstead of the === operator which determines object reference identity. 12345var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var map2 = map1.set('b', 2);assert(map1.equals(map2) === true);var map3 = map1.set('b', 50);assert(map1.equals(map3) === false); Note: As a performance optimization Immutable attempts to return the existingcollection when an operation would result in an identical collection, allowingfor using === reference equality to determine if something definitely has notchanged. This can be extremely useful when used within a memoization functionwhich would prefer to re-run the function if a deeper equality check couldpotentially be more costly. The === equality check is also used internally byImmutable.is and .equals() as a performance optimization. If an object is immutable, it can be “copied” simply by making another referenceto it instead of copying the entire object. Because a reference is much smallerthan the object itself, this results in memory savings and a potential boost inexecution speed for programs which rely on copies (such as an undo-stack). 12var map1 = Immutable.Map(&#123;a:1, b:2, c:3&#125;);var clone = map1; JavaScript-first APIWhile immutable is inspired by Clojure, Scala, Haskell and other functionalprogramming environments, it’s designed to bring these powerful concepts toJavaScript, and therefore has an Object-Oriented API that closely mirrors thatof ES6 Array, Map, and Set. The difference for the immutable collections is that methods which would mutatethe collection, like push, set, unshift or splice instead return a newimmutable collection. Methods which return new arrays like slice or concatinstead return new immutable collections. 123456789var list1 = Immutable.List.of(1, 2);var list2 = list1.push(3, 4, 5);var list3 = list2.unshift(0);var list4 = list1.concat(list2, list3);assert(list1.size === 2);assert(list2.size === 5);assert(list3.size === 6);assert(list4.size === 13);assert(list4.get(0) === 1); Almost all of the methods on Array will be found in similar form onImmutable.List, those of Map found on Immutable.Map, and those of Setfound on Immutable.Set, including collection operations like forEach()and map(). 123var alpha = Immutable.Map(&#123;a:1, b:2, c:3, d:4&#125;);alpha.map((v, k) =&gt; k.toUpperCase()).join();// 'A,B,C,D' Accepts raw JavaScript objects.Designed to inter-operate with your existing JavaScript, immutableaccepts plain JavaScript Arrays and Objects anywhere a method expects anIterable with no performance penalty. 12345var map1 = Immutable.Map(&#123;a:1, b:2, c:3, d:4&#125;);var map2 = Immutable.Map(&#123;c:10, a:20, t:30&#125;);var obj = &#123;d:100, o:200, g:300&#125;;var map3 = map1.merge(map2, obj);// Map &#123; a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 &#125; This is possible because immutable can treat any JavaScript Array or Objectas an Iterable. You can take advantage of this in order to get sophisticatedcollection methods on JavaScript Objects, which otherwise have a very sparsenative API. Because Seq evaluates lazily and does not cache intermediateresults, these operations can be extremely efficient. 123var myObject = &#123;a:1,b:2,c:3&#125;;Immutable.Seq(myObject).map(x =&gt; x * x).toObject();// &#123; a: 1, b: 4, c: 9 &#125; Keep in mind, when using JS objects to construct Immutable Maps, thatJavaScript Object properties are always strings, even if written in a quote-lessshorthand, while Immutable Maps accept keys of any type. 12345678var obj = &#123; 1: "one" &#125;;Object.keys(obj); // [ "1" ]obj["1"]; // "one"obj[1]; // "one"var map = Immutable.fromJS(obj);map.get("1"); // "one"map.get(1); // undefined Property access for JavaScript Objects first converts the key to a string, butsince Immutable Map keys can be of any type the argument to get() isnot altered. Converts back to raw JavaScript objects.All immutable Iterables can be converted to plain JavaScript Arrays andObjects shallowly with toArray() and toObject() or deeply with toJS().All Immutable Iterables also implement toJSON() allowing them to be passed toJSON.stringify directly. 12345var deep = Immutable.Map(&#123; a: 1, b: 2, c: Immutable.List.of(3, 4, 5) &#125;);deep.toObject() // &#123; a: 1, b: 2, c: List [ 3, 4, 5 ] &#125;deep.toArray() // [ 1, 2, List [ 3, 4, 5 ] ]deep.toJS() // &#123; a: 1, b: 2, c: [ 3, 4, 5 ] &#125;JSON.stringify(deep) // '&#123;"a":1,"b":2,"c":[3,4,5]&#125;' Embraces ES6Immutable takes advantage of features added to JavaScript in ES6,the latest standard version of ECMAScript (JavaScript), including Iterators,Arrow Functions, Classes, and Modules. It’s also inspired by theMap and Set collections added to ES6. The library is “transpiled” to ES3in order to support all modern browsers. All examples are presented in ES6. To run in all browsers, they need to betranslated to ES3. 1234// ES6foo.map(x =&gt; x * x);// ES3foo.map(function (x) &#123; return x * x; &#125;); Nested StructuresThe collections in immutable are intended to be nested, allowing for deeptrees of data, similar to JSON. 12var nested = Immutable.fromJS(&#123;a:&#123;b:&#123;c:[3,4,5]&#125;&#125;&#125;);// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5 ] &#125; &#125; &#125; A few power-tools allow for reading and operating on nested data. Themost useful are mergeDeep, getIn, setIn, and updateIn, found on List,Map and OrderedMap. 12345678910var nested2 = nested.mergeDeep(&#123;a:&#123;b:&#123;d:6&#125;&#125;&#125;);// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5 ], d: 6 &#125; &#125; &#125;nested2.getIn(['a', 'b', 'd']); // 6var nested3 = nested2.updateIn(['a', 'b', 'd'], value =&gt; value + 1);// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5 ], d: 7 &#125; &#125; &#125;var nested4 = nested3.updateIn(['a', 'b', 'c'], list =&gt; list.push(6));// Map &#123; a: Map &#123; b: Map &#123; c: List [ 3, 4, 5, 6 ], d: 7 &#125; &#125; &#125; Lazy SeqSeq describes a lazy operation, allowing them to efficiently chainuse of all the Iterable methods (such as map and filter). Seq is immutable — Once a Seq is created, it cannot bechanged, appended to, rearranged or otherwise modified. Instead, any mutativemethod called on a Seq will return a new Seq. Seq is lazy — Seq does as little work as necessary to respond to anymethod call. For example, the following does not perform any work, because the resultingSeq is never used: var oddSquares = Immutable.Seq.of(1,2,3,4,5,6,7,8) .filter(x =&gt; x % 2).map(x =&gt; x * x); Once the Seq is used, it performs only the work necessary. In thisexample, no intermediate arrays are ever created, filter is called three times,and map is only called once: console.log(oddSquares.get(1)); // 9 Any collection can be converted to a lazy Seq with .toSeq(). var seq = Immutable.Map({a:1, b:1, c:1}).toSeq(); Seq allows for the efficient chaining of sequence operations, especially whenconverting to a different concrete type (such as to a JS object): seq.flip().map(key =&gt; key.toUpperCase()).flip().toObject(); // { A: 1, B: 1, C: 1 } As well as expressing logic that would otherwise seem memory-limited: Immutable.Range(1, Infinity) .skip(1000) .map(n =&gt; -n) .filter(n =&gt; n % 2 === 0) .take(2) .reduce((r, n) =&gt; r * n, 1); // 1006008 Note: An iterable is always iterated in the same order, however that order maynot always be well defined, as is the case for the Map. Equality treats Collections as DataImmutable provides equality which treats immutable data structures as puredata, performing a deep equality check if necessary. 12345var map1 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);var map2 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);assert(map1 !== map2); // two different instancesassert(Immutable.is(map1, map2)); // have equivalent valuesassert(map1.equals(map2)); // alternatively use the equals method Immutable.is() uses the same measure of equality as Object.isincluding if both are immutable and all keys and values are equalusing the same measure of equality. Batching Mutations If a tree falls in the woods, does it make a sound? If a pure function mutates some local data in order to produce an immutablereturn value, is that ok? — Rich Hickey, Clojure Applying a mutation to create a new immutable object results in some overhead,which can add up to a minor performance penalty. If you need to apply a seriesof mutations locally before returning, Immutable gives you the ability tocreate a temporary mutable (transient) copy of a collection and apply a batch ofmutations in a performant manner by using withMutations. In fact, this isexactly how Immutable applies complex mutations itself. As an example, building list2 results in the creation of 1, not 3, newimmutable Lists. 123456var list1 = Immutable.List.of(1,2,3);var list2 = list1.withMutations(function (list) &#123; list.push(4).push(5).push(6);&#125;);assert(list1.size === 3);assert(list2.size === 6); Note: immutable also provides asMutable and asImmutable, but onlyencourages their use when withMutations will not suffice. Use caution to notreturn a mutable copy, which could result in undesired behavior. Important!: Only a select few methods can be used in withMutations includingset, push and pop. These methods can be applied directly against apersistent data-structure where other methods like map, filter, sort,and splice will always return new immutable data-structures and never mutatea mutable collection. DocumentationRead the docs and eat your vegetables. Docs are automatically generated from Immutable.d.ts.Please contribute! Also, don’t miss the Wiki whichcontains articles on specific topics. Can’t find something? Open an issue. TestingIf you are using the Chai Assertion Library, Chai Immutable provides a set of assertions to use against Immutable collections. ContributionUse Github issues for requests. We actively welcome pull requests, learn how to contribute. ChangelogChanges are tracked as Github releases. ThanksPhil Bagwell, for his inspirationand research in persistent data structures. Hugh Jackson, for providing the npm packagename. If you’re looking for his unsupported package, see this repository. LicenseImmutable is BSD-licensed. We also provide an additional patent grant.]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux-awesome]]></title>
    <url>%2F2017%2F03%2F08%2FAwesome%20Redux%2F</url>
    <content type="text"><![CDATA[Awesome Redux List of repositories which use Redux ReduxDocumentation of ReduxDocumentation of Redux(Simple Chinese version)Documentation of Redux(Russian version) (Work in progress)Documentation of Redux(Traditional Chinese version)Documentation of Redux(Japanese version) (Work in progress)Documentation of Redux(Portuguese version) (Work in progress)Documentation of Redux(Spanish version) (Work in progress)Documentation of Redux(Korean version)Documentation of Redux(Sinhala|සිංහල version) (Work in progress) Predictable state container for JavaScript apps Marks Universal (Isomorphic) - :metal: Hot Reload - :fire: Presentations Let’s learn React and Redux with Javascript’s new ES6 syntax, from Beginner to Intermediate to Advanced. A introduction about Redux Real World Redux The power of higher-order reducers Reactive Architecture with Redux and Angular Redux Internals Replacing Angular 1 with React and Redux A tour on the React ecosystem Redux from Twitter hype to production Resources Many tools and middlewares Redux offline docs Flux challenge Sound Redux - a simple Soundcloud client Favesound Redux - SoundCloud Client for Artists Structor - a user interface builder for React generator-redux - CLI tools for Redux: next-gen functional Flux/React with devtools generator-reactapp - Yeoman generator for react app with redux Rekit - Toolkit for building scalable web apps with React, Redux and React-router Spectacle - ReactJS based Presentation Library Notes (and partial transcription) of Dan Abramov’s Redux course videos on http://egghead.io Comprehensive Notes for Learning (how to use) Redux to manage state in your Web/Mobile Apps React Redux [RU tutorial] Redux without profanity React and Redux Single Page Applications Resources A categorized list of Redux-related addons, libraries, and utilities Building the F8 2016 App (Redux, GraphQL, React Native) The Elm Architecture in JavaScript Articles And Tutorials Building Applications with React and Redux in ES6 on Pluralsight Writing a Basic App in Redux Learn how to use Redux step by step Tutorial: Handcrafting an Isomorphic Redux Application (With Love) 0 to 1 : Getting started with Redux Redux Chinese Document Redux Document (Traditional Chinese) Relay and Routing Understanding Redux Middleware Several videos about Redux + Falcor and Example code Redux Middleware: Behind the Scenes A proposal for bundling reducers, action types and actions when using Redux Full-Stack Redux Tutorial - A Comprehensive Guide to Test-First Development with Redux, React, and Immutable Source Server + Client Redux best practices The 3REE Stack: React + Redux + RethinkDB + Express.js React Tutorial - Converting Reflux to Redux Redux example using 500px API (with ES6) Building a boilerplate for a Koa, Redux, React application including Webpack, Mocha and SASS - This article explains in detail how this koa-redux-react-boilerplate was built and the technologies it uses. Typed React and Redux A cartoon intro to Redux Join The Dark Side Of The Flux: Responding to Actions with Actors Can I dispatch multiple actions from Redux action creators? Understanding Redux (or, How I Fell in Love with a JavaScript State Container) Your First Immutable React &amp; Redux App Getting Started with Redux - Egghead’s video lessons from Dan Abramov Redux Testing Video Lessons - a few short Egghead video lessons (some free, some require a subscription) Implementing a smart Login Modal with Redux, reselect and ReactJS How to Build a Todo App Using React, Redux, and Immutable.js Rethinking Redux Managing Side Effects In React + Redux Using Sagas Secure Your React and Redux App with JWT Authentication Getting started with Redux and GraphQL Data Flows with Angular 2 and Redux Simple Routing with Redux and React Redux nowadays : From actions creators to sagas Master Complex Redux Workflows with Sagas Angular 2 Application Architecture - Building Flux Apps with Redux and Immutable.js React, Redux and Immutable.js: Ingredients for Efficient Web Applications An Introduction to React Redux (Part 1) An Introduction to React Redux (Part 2) Rules For Structuring (Redux) Applications Redux for the very beginner Redux - Calling web service asynchronously Animating with React, Redux, and d3 Build an Image Gallery Using React, Redux and redux-saga Introducing redux-operations Solving Redux’s shortcoming in 150 LOCs The Anatomy Of A React Redux App Getting Started with React, Redux and Immutable: a Test-Driven Tutorial (Part 2) Leveling Up with React: Redux Complete intro to react Recreating Redux — Behind the magic curtain Let’s Build a Redux Powered React Application Deep Introduction to Redux - Seriese 1/3 Universal Rendering with Redux and React-Router - Seriese 2/3 Unit Testing Redux Apps - Seriese 3/3 Using Aurelia and Redux together for good times all around Comparing Redux and Relay Building React Applications with Idiomatic Redux The SoundCloud Client in React + Redux 深入浅出 Redux Building Angular 2 applications with Immutable.js and Redux Tutorial: Building Redux in TypeScript with Angular 2 Improving React and Redux performance with Reselect Recipes for Redux Getting Started with Redux &amp; Angular 2 Universal/Isomorphic React+Redux on a Swift Web Backend Creating Reusable React-Redux Components Through Scoping React+Redux系列教程 书籍：《React 与 Redux 开发实例精解》 Boilerplate redux-minimal - Minimalist react-redux starter kit which let’s you build rich real world apps Modern and Scalable React/Redux Boilerplate - Flexible starter kit using Webpack 2 (tree-shaking) / React Hot Loader v3 / Code Splitting for React Router / PostCSS / CSS Modules / custom Ducks pattern app architecture / best practices / Sentry error tracking / Enzyme test environment :rocket: react-production-starter - React boilerplate with isomorphic rendering, async react-router routes, async redux reducers, async data fetching, and code-splitting. :metal: :fire: mern.io - Simple full-stack boilerplate to get started with building isomorphic/universal apps, handles api part and also offers a cli to generate the boilerplate :metal: :fire: universal-react-redux - Opinionated Universal React/Redux/Webpack with HMR. Continually updated. :metal: :fire: react-slingshot - React Redux Starter Kit with hot reloading, tests and example app react-redux-boilerplate - React Redux Boilerplate react-boilerplate - React + Typescript + Sass boilerplate react-redux-scaffold - Combination of redux, react-router and ES6+ support simple-redux-boilerplate - Simple and guided React, Redux boilerplate w/ Transform HMR! :fire: reactv - React Redux example redux-boilerplate - Boilerplate for Redux react-redux-starter-kit - Get started with React, Redux, and React-Router. simplest-redux-example - Simplest Redux + React example for beginners redux-easy-boilerplate - React Redux easy boilerplate dicty-redux - Starter kit to bootstrap React and Redux (Flux) based web application 3ree - Boilerplate &amp; Demo for Universal Realtime Apps built with React + Redux + RethinkDB + Express react_scaffolding - React + React Router 1.0 + Redux + Webpack &amp; Hot Module Replacement express-redux-sample - Express-Redux-PassportJs-MySQL Boilerplate redux-blog-example - Redux-Webpack-Babel Blog Platform boilerplate redux-undo-boilerplate - a magical boilerplate with hot reloading and awesome error handling redux500 - The Redux version of isomorphic500 redux-demo - Redux port of SurviveJS - Webpack and React Kanban app react-redux-universal-hot-example - A starter boilerplate for a universal webapp using express, react, redux, webpack, and react-hot-loader :metal: rde - Reactive Live Programming Environment React Redux Starter Kit - Yet another React and Redux based web application starter kit skeleton - A simple project-stub to show the basic ideas. Also serves you as a quick start for your project (Mori + Redux) browser-redux - Building Chrome apps and cross-browser extensions with Redux and Webpack react-for-hipsters-boilerplate - Fresh boilerplate with brand new hot reloading confing and other hipster stuff Documented Koa Redux React Webpack boilerplate- The building process of this boilerplate is deeply documented from 0 for learning purposes. You can find the docs here. err - Electron, React, Redux-devtools boilerplate for building cross-platform apps. friends-app-redux - React Redux Universal Hot Example isomorphic-redux-app - Redux Isomorphic App (with async content) starter-kit - Project boilerplate using React, Redux and Uniloc http://unicornstandard.com/packages/boilerplate.html loopback-redux-react-boilerplate - A boilerplate for a Redux-React application using LoopBack breko-hub - Babel React Koa Hot Universal Boilerplate – A simple, clean and consistent boilerplate for creating universal webapps with universal data fetching and SocketIO integration React Redux Cordova Boilerplate react-boilerplate - Performance orientated, offline-first boilerplate feat. hot-reloading, PostCSS and the best developer experience. react-webpack-node - Boilerplate for an universal React + Redux/alt Flux application using Webpack running on a node express server [Hapi React Starter Kit - Universal, Redux, Redis, Socket.io, Intl] (https://github.com/Dindaleon/hapi-react-starter-kit) [Universal Redux Template - A clean, extensible react + redux boilerplate with universal rendering, testing and more] (https://github.com/mz026/universal-redux-template) universal-js - A universal Javascript starter kit inc. React, Redux, Redux Dev Tools, Universal Redux Router, CSS Modules, hot module reloading, Babel for ES2015+ and ESLint redux-react-material-boilerplate - Simple boilerplate inc. React, Redux, Hot reload and Material-ui react-redux-starter - React Redux Starter Reduxible - The Fast and Easy way to make a React + Redux apps react-workflow - A large SPA boilerplate for web development built on top of Facebook’s React library,use redux architecture ReacToGo - A simple ES6 boilerplate with Redux architecture and ImmutableJS: Hot Reload, React UI Comp, Firebase, Router React/Redux simple CRUD with persistent state and local async actions (add a manifest file and you get an offline webapp) StarHackIt - An React/Redux Node full-stack starter kit with authentication and authorization code React Seed - A barebones scalable directory structure and package.json for facilitating new React + Redux projects. No fat to trim here! [React/Redux with Auth boilerplate - Very simple boilerplate, good for fast creating admin panels / dashboard. Included: React, Redux, ReduxForm, React-Router, Simple Authenticate, Hot Reload and Webpack (with babel) :fire:] (https://github.com/WapGeaR/react-redux-boilerplate-auth) Docker + React/Redux + Node + PostgreSQL - full stack boilerplate with fully dockerized workflows for development, deployment, testing Redux universal boilerplate - boilerplate for react universal application building on flux architecture based on redux implementation. React Redux Universal Boilerplate - An Universal ReactJS/Redux Boilerplate. react-hot-redux-firebase-starter - Starter boilerplate for using React/Redux with Firebase 3.0 API, include the new React Hot Loader 3.0 :fire: React Redux Firebase Boilerplate - Designed for quickly spin up your apps with Firebase, using bunch of awesome new front-end technologies includes webpack build system, hot reloading, routing &amp; sass support. :fire: React Universal Saga - Universal React Starter Kit ft. Redux Saga React Redux SoundCloud Client - Seed Project for a SoundCloud Client with working Login + Extension Seed Projects vortigern - A universal boilerplate for building web applications w/ TypeScript, React, Redux and more. angular2-redux-contact-list - Simple contact list built with Angular 2, Immutable.js and Redux react-redux-seed - 使用 React 与 Redux 实现 Universal 渲染的种子工程 ARc - A progressive React starter kit based on Atomic Design with redux, redux-saga and redux-form edux - fast Redux without constants and switches. Actions and reducers are generated from single source. React Native - A framework for building native apps using React Examples CarteJaune - An open source Redux/ExponentJS (React Native) app leveraging redux-saga to keep track of your vaccinations noder-react-native - The mobile app of cnodejs.org written in React Native react-native-redux-counter react-native-counter-ios-android react-native-redux-groceries - An example app using React Native, Redux, Firebase, and AsyncStorage for offline data react-native-sound-cloud snowflake - mobile app starter: Login, Logout, Reset Password, Update Profile, Hot Reload uestc-bbs-react-native - An iOS client for http://bbs.uestc.edu.cn/ written in React Native with Redux movies-redux - redux implementation of react-native movies example that is included in react-native source react-native-redux-todo-list - A sample todo list app developed by using react-native and redux React - A JavaScript library for building user interfaces Containers reapop - A React &amp; Redux notifications system Middlewares redux-cheerio - Make HTTP requests and then parse the responses with jQuery selectors using Cheerio redux-reporter - Report actions &amp; metadata to 3rd party providers, extremely useful for analytics and error handling (New Relic, Sentry, Adobe DTM, Keen, etc.) redux-transduce - Transducer utilities for Redux redux-actions - Flux Standard Action utilities for Redux redux-promise - FSA-compliant promise middleware for Redux redux-sync-promise - Middleware for writing asynchronous actions in synchronous style redux-simple-promise - FSA-compliant promise middleware for Redux with simple behaviour with minimal boilerplate declarations redux-async - FSA-compliant promise property middleware for Redux redux-async-queue - Manage queues of thunk actions redux-async-initial-state - Set initial Redux state asynchronously redux-await - Manage async redux actions sanely redux-rx - RxJS utilities for Redux reselect - Selector library for Redux like in NuclearJS react-redux - React bindings for Redux redux-react-router - Redux bindings for React Router – keep your router state inside your Redux store redux-promise-middleware - Redux middleware for resolving and rejecting promises redux-thunk - Thunk middleware for Redux redux-batched-updates - Batch React updates that occur as a result of Redux dispatches, to prevent cascading renders. redux-combine-actions - Redux middleware that allows you to easy combine actions and dispatch them sequentially redux-catch-promise - Extended replacement of redux-thunk middleware to supporting async-await functions and implement server-side rendering for React components with async state redux-delegator - Compose redux reducers in a structured way routex - Simple router for Redux universal applications. Can be used with React too redux-persist-store - Persist and rehydrate a redux store adrenaline - React bindings for Redux with Relay in mind redux-localstorage - Store enhancer that syncs (a subset) of your Redux store state to localstorage. redux-storage - Persistence layer for redux with flexible backends redux-pouchdb - sync store state to pouchdb redux-vstack-router - Helpers to bind vstack-router to redux redux-create-store redux-batched-subscribe - Batch calls to subscribe handlers with a custom function, including debouncing or React batched updates. redux-logger - Logger middleware for Redux redux-node-logger - A Redux Logger for Node Environments redux-diff-logger - Diff logger between states for Redux redux-debug - debug(…) middleware for Redux redux-requests - Avoid issuing duplicate HTTP requests redux-owl - Redux One Way Linking redux-act - An opinionated lib to create actions and reducers for Redux redux-act-async - Reducing boilerplate when creating asynchronous actions in Redux redux-raven-middleware - Redux middleware for sending error reports to Sentry through raven-js redux-routing - Universal routing built on top of redux redux-undo - Simple undo/redo functionality for redux state containers rn-redux-mixpanel - Configurable Redux middleware that sends your actions &amp; user profile data to Mixpanel redux-falcor - Connect your redux front-end to your falcor back-end redux-analytics - Trigger analytics events based on your event metadata redux-ignore - Ignore redux actions by array or filter function redux-recycle - Reset the redux state on certain actions re-notif A notification center based on React &amp; Redux. redux-lunr - Make your redux store searchable with Lunr.js redux-ensure-fsa - Development middleware to check for FSA-compliant actions redux-pagan - internationalization via redux redux-debounce - Debounce your actions! redux-future - FSA-compliant future monad middleware for redux redux-io - FSA-compliant io monad middleware for redux redux-either - FSA-compliant either monad middleware for redux redux-timeout - Trigger actions based on timeouts redux-observable-middleware - Redux middleware for subscribing to observables redux-observable - RxJS 5-based middleware for Redux. Compose and cancel actions as epics. redux-deferred - Redux middleware for jQuery Deferred Object redux-task - A simple Side Effects manager for redux redux-gen - Generator based middleware for redux redux-authentication - Authentication component for Redux socket.io-redux - Redux middleware to emit action via socket.io redux-catch - Error catcher middleware for Redux reducers and middlewares redux-elm-middleware - Elm middleware for redux redux-api-middleware - Redux API middleware based on the real-world example redux-mediaquery - Redux ActionCreator to put responsive-design breakpoints in your store redux-amrc - Redux async middleware and reducer creator redux-fetch-middleware - Redux middleware that help user to treat simple request via fetch api Tools reactotron - Control, monitor, and instrument your React Native apps from the comfort of your TTY redux-test-recorder - Redux test recorder is a redux middleware + included component for automagically generating tests for your reducers based on the actions in your app redux-devtools - DevTools for Redux with hot reloading, action replay, and customizable UI react-router-redux - Ruthlessly simple bindings to keep react-router and redux in sync redux-tiny-router - A Router made for Redux, stop using the router as a controller it’s just state! redux-devtools-gentest-plugin - Generate mocha like tests from redux-devtools session generator-redux - CLI tools for Redux: next-gen functional Flux/React with devtools generator-reactapp - Yeoman generator for react app with redux generator-redux-app - Scaffold out a redux app with counter example and react-router redux-loader - A high order component for Redux. This components loads resources and passes them to the child components via props redux-rest - Automatically create Flux action constants, action creators and Redux reducers for your REST API react-reach - A library to communicate with Graphql through Redux redux-api - Flux REST API for redux infrastructure redux-store-validator - Add validation to your Redux reducers firedux - Firebase + Redux for ReactJS vstack-router - Universal router redux-ecommerce - E-commerce flux with redux redux-form - An ES7 decorator for forms using Redux and React redux-form-validation - Form validation for controlled &amp; uncontrolled inputs simple-redux-form - A tiny redux-form alternative Higher Order Component for forms. redux-slider-monitor - A custom monitor for Redux DevTools to replay recorded Redux actions updeep - Easily update nested frozen objects and arrays in a declarative and immutable manner redux-immutable - Streamlines use of Immutable.js with Redux reducers. redux-import-export-monitor - A monitor for copying your serialized action log to the clipboard, as well as pasting it in from somewhere else icedam - Just-in-time immutability: freezes data sent to views. react-inline-grid - Predictable flexbox based grid for React using Redux and Immutable-js. redux-easy-actions - Sugar library for creating Redux or Flux actions redux-mount - Mount state data and change its state values on the fly redux-multi - Dispatch multiple actions from one action creator immu - A tiny, fail-fast, lazy, immutable Javascript objects library Generate standard action creators and reducers for CRUD applications Redux &amp; ImmutableJs - Integration of Redux &amp; ImmutableJs that 100% conforms Redux standards redux-tcomb - Immutable and type-checked state and actions for Redux redux-react-router-transitions - Attach react-router transitions to arbitrary actions redux-optimist - Optimistically apply actions that can be later commited or reverted. redux-devtools-diff-monitor - Redux DevTools – Diff Monitor redux-store-visualizer - Visualize Redux store in real time generator-redux - CLI tools for Redux: next-gen functional Flux/React with devtools generator-reactapp - Yeoman generator for react app with redux redux-viewmodel - ViewModel wrapping for Redux &amp; React redux-utils - Utility functions for Redux multireducer - A utility to wrap many copies of a single Redux reducer into a single key-based reducer subdivide - User defined UI layout: Every pane can be subdivided and any widget assigned to any pane replux - Self contained components and enhancements for Redux redux-immutable-utils - Utilities for using Immutable with Redux recompose - A microcomponentization toolkit for React redux-lift - Lifting for Redux redux-router5 - router5 integration with Redux redux-devtools-extension - Redux DevTools Extension universal-redux-router - A very simple router for Redux and React that works on both server and client redux-watch - Watch/monitor for state changes on an object path redux-devtools-filterable-log-monitor - Filterable tree view monitor for Redux DevTools redux-flash-notification - A flash notification component for Redux redux-saga - An alternative side effect model for Redux apps remote-redux-devtools - Use Redux DevTools remotely for React Native, hybrid, desktop and server side Redux apps redux-devtools-dispatch - Dispatch your actions manually to test if your app reacts well redux-loop - Sequence your effects naturally and purely by returning them from your reducers redux-orm - A small, simple and immutable ORM to manage data in your Redux store redux-bacon - Utilities for attaching Bacon.js to Redux rereduce - Reducer library for Redux redux-decorators - A ridiculously good syntax for working with Redux and TypeScript. Currently limited to Angular 2 but could potentially be used elsewhere redux-test-reducer - Simple and clean testing mechanism for Redux reducers redux-devtools-inspector - Another Redux DevTools Monitor redux-ava - Helpers for writing Redux tests in AVA redux-cli - An opinionated CLI for building redux/react apps quicker redux-saga-rxjs - RxJS implementation of Saga pattern for redux redux-actions-assertions - Assertions for redux actions testing redux-duck - Helper function to create Redux modules using the ducks-modular-redux proposal redux-dispatch-cli - A CLI tool for Redux remote dispatch. Used in remote-redux-devtools redux-immutable-reducer - Immutable reducer states with Redux redux-bootstrap - configure React + React-Router + Redux + Immutable.js with one function! redux-director - Redux bindings to director router redux-q - Provides a way to queue callbacks until an action is dispatched redux-apist - Creator API actions for redux-thunk reswitch — Write reducers with less boilerplate redux-autoform - Create Redux-Forms dynamically out of metadata redux-ship - Composable, testable and typable side effects Frameworks Jumpsuit - A powerful &amp; efficient React framework. Jump in. Zip up. Build great apps. Jumpstate - Simple and powerful state management for Redux dva - Front-end framework based on react, redux, react-redux, react-router and redux-saga. Vdux - World’s smallest framework. Stateless Virtual DOM &lt;-&gt; Redux Esex - Full-stack Universal JavaScript Framework (Redux+RxJs) Ripster Este - The most complete minimal dev stack / boilerplate for React &amp; Redux universal web apps stardux - Functional DOM containers based on starplate, IncrementalDOM, and redux nux - A Push-Based Functional Reactive Web Application Framework Keo - Plain functions for a more functional Deku approach to creating React components, with functional goodies such as compose, memoize, etc… for free plait - A minimal JavaScript framework for building reactive web components reactuate — A React/Redux stack (not a boilerplate!) with a focus on Domain-Driven Design meatier - Like meteor, but meatier relax - New generation CMS on top of React, Redux and GraphQL lovli.js - A boilerplate for developing react+redux applications with rethinkdb/horizon as realtime database and express for the server kea - Well-readable, self-documenting and easily refactorable framework that brings your data to life! Comes with scaffolding tools :bird: Feeble - A framework built on top of React/Redux/redux-saga which aims to make building React/Redux applications easier and better. Conventional-Redux - A wrapper for react-redux which provides API based on convention over configuration pattern. redux-react-i18n - An i18n solution for redux/react✌🏿✊🏽🤘🏻 Examples Similar libraries flux-ts - A small flux implementation heavily inspired by redux chopped-redux - A very small Flux implementation based on Redux fluxette - Minimalist, functional, and concise Flux rx-redux - A reimplementation of redux using RxJS understate - A simple state manager refer - Redux-like library for handling global state on functional style bobflux - Bobflux is pure functional implementation of FLUX pattern and is fitted to Bobril mobx - Simple, scalable state management Deku - Functional view library for building UI components as an alternative to React Examples Deku + Express + Redux + Crossroads Router deku-redux - Bindings for redux in deku (Standalone plugin)) Incremental DOM - Incremental DOM is a library for building up DOM trees and updating them in-place when data changes Examples Incremental DOM + Redux Flux = Todo App WinJS - Windows Library for JavaScript Examples react-redux-winjs-example Angular - HTML enhanced for web apps Examples Angular + Typescript + Redux ng-redux - Standalone plugin redux-ui-router - ngRedux middleware for Angular UI Router Todo app with ng-redux • ES6 • Webpack https://github.com/InfomediaLtd/angular2-redux-example https://github.com/tomusdrw/angular2-redux-example Angular 2 - One framework. Mobile and desktop Examples angular2-redux-example - Example project for using pure Redux with Angular 2 and TypeScript @angular-redux/store - Angular 2 bindings for Redux angular2-redux - Wrapper components for using Redux in an Angular2 application ng2redux - Angular 2 bindings for Redux implemented with TypeScript and decorators Vue - A library for building modern web interfaces Examples Revue - Redux binding for Vue Vue + Redux Meteor + Vue + Redux Polymer - Build modern apps using web components Examples polymer-redux redux-store-element Ember - A framework for creating ambitious web applications Examples Meteor - Build apps that are a delight to use, faster than you ever thought possible Examples meteor-react-redux-example meteor-flux-leaderboard Mithril - A Javascript Framework for Building Brilliant Applications Examples mithril-redux-starter-hmr Backbone - Give your JS App some Backbone with Models, Views, Collections, and Events Tools backbone-redux — The easy way to keep your backbone collections and redux store in sync Aurelia - is a next gen JavaScript client framework for mobile, desktop and web that leverages simple conventions to empower your creativity Examples aurelia-redux-todo - An implementation of the Redux todo demo app using Aurelia Managing State in Aurelia: How to Use Aurelia with Redux Riot - A React-like user interface micro-library Examples riotredux-budget app-skeleton Electron - Build cross platform desktop apps with web technologies electron-react-boilerplate (Electron + Redux + Hot Reload) A-Frame - A web framework for building VR experiences aframe-redux-component Chrome Extensions Redux Chrome Extension React Chrome Extension Boilerplate (Webpack + Redux + Babel and etc Examples Pumgrana Plugin Ruby on Rails Resources React Webpack Rails Tutorial Using Redux react_on_rails gem Other languages .NET https://github.com/GuillaumeSalles/redux.NET https://github.com/pshomov/reducto Java https://github.com/glung/redux-java https://github.com/trikita/jedux https://github.com/izumin5210/Droidux Swift https://github.com/ReSwift/reduxSwift https://github.com/Swift-Flow/Swift-Flow https://github.com/ReSwift/ReSwift and docs Purescript https://github.com/brakmic/purescript-redux https://github.com/faber/purescript-purdux]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux-logic]]></title>
    <url>%2F2017%2F03%2F08%2Fredux-logic%2F</url>
    <content type="text"><![CDATA[redux-logic “One place for all your business logic and action side effects” Redux middleware that can: intercept (validate/transform/augment) actions AND perform async processing (fetching, I/O, side effects) tl;drWith redux-logic, you have the freedom to write your logic in your favorite JS style: plain callback code - dispatch(resultAction) promises - return axios.get(url).then(...) async/await - result = await fetch(url) observables - ob$.next(action1) Use the type of code you and your team are comfortable and experienced with. Leverage powerful declarative features by simply setting properties: filtering for action type(s) or with regular expression(s) cancellation on receiving action type(s) use only response for the latest request debouncing throttling dispatch actions - auto decoration of payloads Testing your logic is straight forward and simple. With simple code your logic can: intercept actions before they hit the reducer validate, verify, auth check actions and allow/reject or modify actions transform - augment/enhance/modify actions process - async processing and dispatching, orchestration, I/O (ajax, REST, subscriptions, GraphQL, web sockets, …) Redux-logic makes it easy to use code that is split into bundles, so you can dynamically load logic right along with your split UI. Server rendering is simplified with redux-logic since it lets you know when all your async fetching is complete without manual tracking. Inspired by redux-observable epics, redux-saga, and custom redux middleware, redux-logic combines ideas of each into a simple easy to use API. Quick ExampleThis is an example of logic which will listen for actions of type FETCH_POLLS and it will perform ajax request to fetch data for which it dispatches the results (or error) on completion. It supports cancellation by allowing anything to send an action of type CANCEL_FETCH_POLLS. It also uses take latest feature that if additional FETCH_POLLS actions come in before this completes, it will ignore the outdated requests. The developer can just declare the type filtering, cancellation, and take latest behavior, no code needs to be written for that. That leaves the developer to focus on the real business requirements which are invoked in the process hook. 12345678910111213141516171819202122const fetchPollsLogic = createLogic(&#123; // declarative built-in functionality wraps your code type: FETCH_POLLS, // only apply this logic to this type cancelType: CANCEL_FETCH_POLLS, // cancel on this type latest: true, // only take latest // your code here, hook into one or more of these execution // phases: validate, transform, and/or process process(&#123; getState, action &#125;, dispatch, done) &#123; axios.get('https://survey.codewinds.com/polls') .then(resp =&gt; resp.data.polls) .then(polls =&gt; dispatch(&#123; type: FETCH_POLLS_SUCCESS, payload: polls &#125;)) .catch(err =&gt; &#123; console.error(err); // log since could be render err dispatch(&#123; type: FETCH_POLLS_FAILED, payload: err, error: true &#125;) &#125;) .then(() =&gt; done()); // call done when finished dispatching &#125;&#125;); Since redux-logic gives you the freedom to use your favorite style of JS code (callbacks, promises, async/await, observables), it supports many features to make that easier, explained in more detail. Table of contents Goals Usage Full API Examples - JSFiddle and full examples Comparison summaries to fat action creators, thunks, redux-observable, redux-saga, custom middleware SAM/PAL pattern Other - todo, inspiration, license Goals organize business logic keeping action creators and reducers clean action creators are light and just post action objects reducers just focus on updating state intercept and perform validations, verifications, authentication intercept and transform actions perform async processing, orchestration, dispatch actions wrap your core business logic code with declarative behavior filtered - apply to one or many action types or even all actions cancellable - async work can be cancelled limiting (like taking only the latest, throttling, and debouncing) features to support business logic and large apps have access to full state to make decisions easily composable to support large applications inject dependencies into your logic, so you have everything needed in your logic code dynamic loading of logic for splitting bundles in your app your core logic code stays focussed and simple, don’t use generators or observables unless you want to. create subscriptions - streaming updates easy testing - since your code is just a function it’s easy to isolate and test Usage12npm install rxjs --savenpm install redux-logic --save 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// in configureStore.jsimport &#123; createLogic, createLogicMiddleware &#125; from 'redux-logic';import rootReducer from './rootReducer';import arrLogic from './logic';const deps = &#123; // optional injected dependencies for logic // anything you need to have available in your logic A_SECRET_KEY: 'dsfjsdkfjsdlfjls', firebase: firebaseInstance&#125;;const logicMiddleware = createLogicMiddleware(arrLogic, deps);const middleware = applyMiddleware( logicMiddleware);const enhancer = middleware; // could compose in dev tools tooexport default function configureStore() &#123; const store = createStore(rootReducer, enhancer); return store;&#125;// in logic.js - combines logic from across many files, just// a simple array of logic to be used for this appexport default [ ...todoLogic, ...pollsLogic];// in polls/logic.jsconst validationLogic = createLogic(&#123; type: ADD_USER, validate(&#123; getState, action &#125;, allow, reject) &#123; const user = action.payload; if (!getState().users[user.id]) &#123; // can also hit server to check allow(action); &#125; else &#123; reject(&#123; type: USER_EXISTS_ERROR, payload: user, error: true &#125;) &#125; &#125;&#125;);const addUniqueId = createLogic(&#123; type: '*', transform(&#123; getState, action &#125;, next) &#123; // add unique tid to action.meta of every action const existingMeta = action.meta || &#123;&#125;; const meta = &#123; ...existingMeta, tid: shortid.generate() &#125;, next(&#123; ...action, meta &#125;); &#125;&#125;);const fetchPollsLogic = createLogic(&#123; type: FETCH_POLLS, // only apply this logic to this type cancelType: CANCEL_FETCH_POLLS, // cancel on this type latest: true, // only take latest process(&#123; getState, action &#125;, dispatch, done) &#123; axios.get('https://survey.codewinds.com/polls') .then(resp =&gt; resp.data.polls) .then(polls =&gt; dispatch(&#123; type: FETCH_POLLS_SUCCESS, payload: polls &#125;)) .catch(err =&gt; &#123; console.error(err); // log since could be render err dispatch(&#123; type: FETCH_POLLS_FAILED, payload: err, error: true &#125;) &#125;) .then(() =&gt; done()); &#125;&#125;);// pollsLogicexport default [ validationLogic, addUniqueId, fetchPollsLogic]; processOptions introduced for redux-logic@0.8.2 allowing for even more streamlined codeprocessOptions has these new properties which affect the process hook behavior: dispatchReturn - the returned value of the process function will be dispatched or if it is a promise or observable then the resolve, reject, or observable values will be dispatched applying any successType or failType logic if defined. Default is determined by arity of process fn, true if dispatch not provided, false otherwise. Details successType - dispatch this action type using contents of dispatch as the payload (also would work with with promise or observable). You may alternatively provide an action creator function to use instead and it will receive the value as only parameter. Default: undefined. if successType is a string action type create action using successType and provide value as payload. ex: with successType:&#39;FOO&#39;, result would be { type: &#39;FOO&#39;, payload: value } if successType is an action creator fn receiving the value as only parameter use the return value from the action creator fn for dispatching ex: successType: x =&gt; ({ type: &#39;FOO&#39;, payload: x }) if the action creator fn returns a falsey value like undefined then nothing will be dispatched. This allows your action creator to control whether something is actually dispatched based on the value provided to it. failType - dispatch this action type using contents of error as the payload, sets error: true (would also work for rejects of promises or error from observable). You may alternatively provide an action creator function to use instead which will receive the error as the only parameter. Default: undefined. if failType is a string action type create action using failType, provide value as the payload, and set error to true. ex: with failType:&#39;BAR&#39;, result would be { type: &#39;BAR&#39;, payload: errorValue, error: true } if failType is an action creator function receiving the error value as its only parameter use the return value from the action creator fn for dispatching. ex: failType: x =&gt; ({ type: &#39;BAR&#39;, payload: x, error: true }) if the action creator fn returns a falsey value like undefined then nothing will be dispatched. This allows your action creator to control whether something is actually dispatched based on teh value provided to it. The successType and failType would enable clean code, where you can simply return a promise or observable that resolves to the payload and rejects on error. The resulting code doesn’t have to deal with dispatch and actions directly. 12345678910111213141516171819202122232425const fetchPollsLogic = createLogic(&#123; // declarative built-in functionality wraps your code type: FETCH_POLLS, // only apply this logic to this type cancelType: CANCEL_FETCH_POLLS, // cancel on this type latest: true, // only take latest processOptions: &#123; // optional since the default is true when dispatch is omitted from // the process fn signature dispatchReturn: true, // use returned/resolved value(s) for dispatching // provide action types or action creator functions to be used // with the resolved/rejected values from promise/observable returned successType: FETCH_POLLS_SUCCESS, // dispatch this success act type failType: FETCH_POLLS_FAILED, // dispatch this failed action type &#125;, // Omitting dispatch from the signature below makes the default for // dispatchReturn true allowing you to simply return obj, promise, obs // not needing to use dispatch directly process(&#123; getState, action &#125;) &#123; return axios.get('https://survey.codewinds.com/polls') .then(resp =&gt; resp.data.polls); &#125;&#125;); This is pretty nice leaving us with mainly our business logic code that could be easily extracted and called from here. Full APISee the docs for the full api ExamplesJSFiddle live examples search async axios fetch - live search using debounce and take latest functionality with axios fetch search rxjs ajax fetch - live search using debounce and take latest functionality with rxjs ajax fetch search rxjs ajax fetch - using processOptions - live search using debounce and take latest with rxjs ajax fetch using processOptions to streamline the code async axios fetch - single page - displayed using React async rxjs-ajax fetch - async fetching using RxJS ajax which supports XHR abort for cancels async axios fetch - single page redux only - just the redux and redux-logic code async axios fetch - using processOptions - using processOptions to streamline your code further with React async rxjs-ajax fetch - using processOptions - async fetch using RxJS ajax (supporting XHR abort on cancel) and processOptions for clean code. async await - react - using ES7 async functions (async/await) displaying with React async await - redux only - using ES7 async functions (async/await) - just redux and redux-logic code async await - react processOptions - using ES7 async functions (async/await) with processOptions, displayed with React Full examples search-async-fetch - search async fetch example using axios uses debouncing and take latest features async-fetch-vanilla - async fetch example using axios async-rxjs-ajax-fetch - async fetch example using RxJS ajax (supporting XHR abort on cancel) and redux-actions async-fetch-proc-options - async fetch example using axios and the new processOptions feature async-rxjs-ajax-proc-options - async RxJS ajax (with XHR abort on cancel) fetch example using axios and the new processOptions feature async-await - ES7 async functions - async fetch example using axios and ES7 async functions (async/await) async-await - ES7 async functions with processOptions - async fetch example using axios and ES7 async functions (async/await) and using the new processOptions feature countdown - a countdown timer implemented with setInterval countdown-obs - a countdown timer implemented with Rx.Observable.interval form-validation - form validation and async post to server using axios, displays updated user list notification - notification message example showing at most N messages for X amount of time, rotating queued messages in as others expire search-single-file - search async fetch example with all code in a single file and displayed with React single-file-redux - async fetch example with all code in a single file and appended to the container div. Only redux and redux-logic code. Comparison summariesFollowing are just short summaries to compare redux-logic to other approaches. For a more detailed comparison with examples, see by article in docs, Where do I put my business logic in a React-Redux application?. Compared to fat action creators no easy way to cancel or do limiting like take latest with fat action creators action creators would not have access to the full global state so you might have to pass down lots of extra data that isn’t needed for rendering. Every time business logic changes might require new data to be made available no global interception using just action creators - applying logic or transformations across all or many actions Testing components and fat action creators may require running the code (possibly mocked API calls). Compared to redux-thunk With thunks business logic is spread over action creators With thunks there is not an easy way to cancel async work nor to perform (take latest) limiting no global interception with thunks - applying logic or transformations across all or many actions Testing components and thunked action creators may require running the code (possibly mocked API calls). When you have a thunk (function or promise) you don’t know what it does unless you execute it. Compared to redux-observable redux-logic doesn’t require the developer to use rxjs observables. It uses observables under the covers to provide cancellation, throttling, etc. You simply configure these parameters to get this functionality. You can still use rxjs in your code if you want, but not a requirement. redux-logic hooks in before the reducer stack like middleware allowing validation, verification, auth, tranformations. Allow, reject, tranform actions before they hit your reducers to update your state as well as accessing state after reducers have run. redux-observable hooks in after the reducers have updated state so they have no opportuntity to prevent the updates. Compared to redux-saga redux-logic doesn’t require you to code with generators redux-saga relies on pulling data (usually in a never ending loop) while redux-logic and logic are reactive, responding to data as it is available redux-saga runs after reducers have been run, redux-logic can intercept and allow/reject/modify before reducers run also as well as after Compared to custom redux middleware Both are fully featured to do any type of business logic (validations, tranformations, processing) redux-logic already has built-in capabilities for some of the hard stuff like cancellation, limiting, dynamic loading of code. With custom middleware you have to implement all functionality. No safety net, if things break it could stop all of your future actions Testing requires some mocking or setup Implementing SAM/PAL PatternThe SAM (State-Action-Model) pattern is a pattern introduced by Jean-Jacques Dubray. Also known as the PAL (proposer, acceptor, learner) pattern based on Paxos terminology. A few of the challenging parts of implementing this with a React-Redux application are: where to perform the accept (interception) of the proposed action performing validation, verification, authentication against the current model state. Based on the current state, it might be appropriate to modify the action, dispatch a different action, or simply suppress the action. how to trigger actions based on the state after the model has finished updating, referred to as the NAP (next-action-predicate). Custom Redux middleware can be introduced to perform this logic, but you’ll be implementing most everything on your own. With redux-logic you can implement the SAM / PAL pattern easily in your React/Redux apps. Namely you can separate out your business logic from your action creators and reducers keeping them thin. redux-logic provides a nice place to accept, reject, and transform actions before your reducers are run. You have access to the full state to make decisions and you can trigger actions based on the updated state as well. Solving those SAM challenges previously identified using redux-logic: perform acceptance in redux-logic validate hooks, you have access to the full state (model) of the app to make decisions. You can perform synchronous or asynchronous logic to determine whether to accept the action and you may augment, modify, substitute actions, or suppress as desired. Perform NAP processing in redux-logic process hooks. The process hook runs after the actions have been sent down to the reducers so you have access to the full model (state) after the updates where you can make decisions and dispatch additional actions based on the updated state. Inspirationredux-logic was inspired from these projects: redux-observable epics redux-saga redux middleware Minimized/gzipped size with all deps(redux-logic only includes the modules of RxJS 5 that it uses)1redux-logic.min.js.gz 11KB Note: If you are already including RxJS 5 into your project then the resulting delta will be much smaller. TODO add typescript support more docs more examples evaulate additional features as outlined above Get involvedIf you have input or ideas or would like to get involved, you may: contact me via twitter @jeffbski - http://twitter.com/jeffbski open an issue on github to begin a discussion - https://github.com/jeffbski/redux-logic/issues fork the repo and send a pull request (ideally with tests) - https://github.com/jeffbski/redux-logic See the contributing guide SupportersThis project is supported by CodeWinds Training License - MIT MIT license]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
</search>